
STM32MP157C-DK2_DDR_UTILITIES_A7.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .RESET        0000eb00  2ffc2500  2ffc2500  00000500  2**7
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.extab    00000000  2ffd1000  2ffd1000  0000f8f8  2**0
                  CONTENTS
  2 .ARM          00000008  2ffd1000  2ffd1000  0000f000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .preinit_array 00000000  2ffd1008  2ffd18f8  0000f8f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .init_array   00000004  2ffd1008  2ffd1008  0000f008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  2ffd100c  2ffd100c  0000f00c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         000008e8  2ffd1010  2ffd1010  0000f010  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00001260  2ffd1900  2ffd1900  0000f8f8  2**5
                  ALLOC
  8 ._TTB         00005000  2ffd4000  2ffd4000  00010000  2**14
                  ALLOC
  9 ._user_heap_stack 00000600  2ffd9000  2ffd9000  00010000  2**0
                  ALLOC
 10 .ARM.attributes 00000037  00000000  00000000  0000f8f8  2**0
                  CONTENTS, READONLY
 11 .comment      00000043  00000000  00000000  0000f92f  2**0
                  CONTENTS, READONLY
 12 .debug_info   0002dcc5  00000000  00000000  0000f972  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000466c  00000000  00000000  0003d637  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loclists 0000fd6a  00000000  00000000  00041ca3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00001490  00000000  00000000  00051a0d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 00002513  00000000  00000000  00052e9d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00006962  00000000  00000000  000553b0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   000209c9  00000000  00000000  0005bd12  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    001c9249  00000000  00000000  0007c6db  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_frame  0000488c  00000000  00000000  00245924  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .RESET:

2ffc2500 <Reset_Handler>:

/*----------------------------------------------------------------------------
  Reset Handler called on controller reset
 *----------------------------------------------------------------------------*/
void Reset_Handler(void) {
  __asm__ volatile(
2ffc2500:	f10c00c0 	cpsid	if
2ffc2504:	ee100fb0 	mrc	15, 0, r0, cr0, cr0, {5}
2ffc2508:	e2100003 	ands	r0, r0, #3

2ffc250c <goToSleep>:
2ffc250c:	1320f003 	wfine
2ffc2510:	1afffffd 	bne	2ffc250c <goToSleep>
2ffc2514:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
2ffc2518:	e3c00a01 	bic	r0, r0, #4096	@ 0x1000
2ffc251c:	e3c00004 	bic	r0, r0, #4
2ffc2520:	e3c00001 	bic	r0, r0, #1
2ffc2524:	e3c00b02 	bic	r0, r0, #2048	@ 0x800
2ffc2528:	e3c00a02 	bic	r0, r0, #8192	@ 0x2000
2ffc252c:	e3c00202 	bic	r0, r0, #536870912	@ 0x20000000
2ffc2530:	e3800101 	orr	r0, r0, #1073741824	@ 0x40000000
2ffc2534:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
2ffc2538:	f57ff06f 	isb	sy
2ffc253c:	ee110f30 	mrc	15, 0, r0, cr1, cr0, {1}
2ffc2540:	e3800002 	orr	r0, r0, #2
2ffc2544:	ee010f30 	mcr	15, 0, r0, cr1, cr0, {1}
2ffc2548:	e59f0044 	ldr	r0, [pc, #68]	@ 2ffc2594 <goToSleep+0x88>
2ffc254c:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
2ffc2550:	f57ff06f 	isb	sy
2ffc2554:	f1020011 	cps	#17
2ffc2558:	e59fd038 	ldr	sp, [pc, #56]	@ 2ffc2598 <goToSleep+0x8c>
2ffc255c:	f1020012 	cps	#18
2ffc2560:	e59fd034 	ldr	sp, [pc, #52]	@ 2ffc259c <goToSleep+0x90>
2ffc2564:	f1020013 	cps	#19
2ffc2568:	e59fd030 	ldr	sp, [pc, #48]	@ 2ffc25a0 <goToSleep+0x94>
2ffc256c:	f1020017 	cps	#23
2ffc2570:	e59fd02c 	ldr	sp, [pc, #44]	@ 2ffc25a4 <goToSleep+0x98>
2ffc2574:	f102001b 	cps	#27
2ffc2578:	e59fd028 	ldr	sp, [pc, #40]	@ 2ffc25a8 <goToSleep+0x9c>
2ffc257c:	f102001f 	cps	#31
2ffc2580:	e59fd024 	ldr	sp, [pc, #36]	@ 2ffc25ac <goToSleep+0xa0>
2ffc2584:	fa00036a 	blx	2ffc3334 <SystemInit>
2ffc2588:	f10800c0 	cpsie	if
2ffc258c:	fa0025f6 	blx	2ffcbd6c <__libc_init_array>
2ffc2590:	fa002300 	blx	2ffcb198 <main>
    [irq_mode] "M" (IRQ_MODE),
    [svc_mode] "M" (SVC_MODE),
    [abt_mode] "M" (ABT_MODE),
    [und_mode] "M" (UND_MODE),
    [sys_mode] "M" (SYS_MODE));
}
2ffc2594:	2ffc2601 	.word	0x2ffc2601
2ffc2598:	30000000 	.word	0x30000000
2ffc259c:	2ffffc00 	.word	0x2ffffc00
2ffc25a0:	2ffff400 	.word	0x2ffff400
2ffc25a4:	2ffff800 	.word	0x2ffff800
2ffc25a8:	2ffff000 	.word	0x2ffff000
2ffc25ac:	2fffec00 	.word	0x2fffec00
	...

2ffc2600 <Vectors>:
  __asm__ volatile(
2ffc2600:	f8df f01c 	ldr.w	pc, [pc, #28]	@ 2ffc2620 <Vectors+0x20>
2ffc2604:	f8df f01c 	ldr.w	pc, [pc, #28]	@ 2ffc2624 <Vectors+0x24>
2ffc2608:	f8df f01c 	ldr.w	pc, [pc, #28]	@ 2ffc2628 <Vectors+0x28>
2ffc260c:	f8df f01c 	ldr.w	pc, [pc, #28]	@ 2ffc262c <Vectors+0x2c>
2ffc2610:	f8df f01c 	ldr.w	pc, [pc, #28]	@ 2ffc2630 <Vectors+0x30>
2ffc2614:	f8df f01c 	ldr.w	pc, [pc, #28]	@ 2ffc2634 <Vectors+0x34>
2ffc2618:	f8df f01c 	ldr.w	pc, [pc, #28]	@ 2ffc2638 <Vectors+0x38>
2ffc261c:	f8df f01c 	ldr.w	pc, [pc, #28]	@ 2ffc263c <Vectors+0x3c>
}
2ffc2620:	2ffc2501 	.word	0x2ffc2501
2ffc2624:	2ffc32a5 	.word	0x2ffc32a5
2ffc2628:	2ffcb375 	.word	0x2ffcb375
2ffc262c:	2ffc32a5 	.word	0x2ffc32a5
2ffc2630:	2ffc32a5 	.word	0x2ffc32a5
2ffc2634:	2ffc32a5 	.word	0x2ffc32a5
2ffc2638:	2ffc32c9 	.word	0x2ffc32c9
2ffc263c:	2ffc32a5 	.word	0x2ffc32a5

2ffc2640 <__do_global_dtors_aux>:
2ffc2640:	b510      	push	{r4, lr}
2ffc2642:	f642 04f4 	movw	r4, #10484	@ 0x28f4
2ffc2646:	f6c2 74fd 	movt	r4, #12285	@ 0x2ffd
2ffc264a:	7823      	ldrb	r3, [r4, #0]
2ffc264c:	b963      	cbnz	r3, 2ffc2668 <__do_global_dtors_aux+0x28>
2ffc264e:	f240 0300 	movw	r3, #0
2ffc2652:	f2c0 0300 	movt	r3, #0
2ffc2656:	b12b      	cbz	r3, 2ffc2664 <__do_global_dtors_aux+0x24>
2ffc2658:	f241 0000 	movw	r0, #4096	@ 0x1000
2ffc265c:	f6c2 70fd 	movt	r0, #12285	@ 0x2ffd
2ffc2660:	f3af 8000 	nop.w
2ffc2664:	2301      	movs	r3, #1
2ffc2666:	7023      	strb	r3, [r4, #0]
2ffc2668:	bd10      	pop	{r4, pc}
2ffc266a:	bf00      	nop

2ffc266c <frame_dummy>:
2ffc266c:	b508      	push	{r3, lr}
2ffc266e:	f240 0300 	movw	r3, #0
2ffc2672:	f2c0 0300 	movt	r3, #0
2ffc2676:	b14b      	cbz	r3, 2ffc268c <frame_dummy+0x20>
2ffc2678:	f642 01f8 	movw	r1, #10488	@ 0x28f8
2ffc267c:	f6c2 71fd 	movt	r1, #12285	@ 0x2ffd
2ffc2680:	f241 0000 	movw	r0, #4096	@ 0x1000
2ffc2684:	f6c2 70fd 	movt	r0, #12285	@ 0x2ffd
2ffc2688:	f3af 8000 	nop.w
2ffc268c:	bd08      	pop	{r3, pc}
2ffc268e:	bf00      	nop

2ffc2690 <_getpid>:
}

int _getpid(void)
{
    return 1;
}
2ffc2690:	2001      	movs	r0, #1
2ffc2692:	4770      	bx	lr

2ffc2694 <_kill>:

int _kill(__attribute__((unused))int pid, __attribute__((unused))int sig)
{
2ffc2694:	b508      	push	{r3, lr}
    errno = EINVAL;
2ffc2696:	f009 fb63 	bl	2ffcbd60 <__errno>
2ffc269a:	4603      	mov	r3, r0
2ffc269c:	2216      	movs	r2, #22
    return -1;
}
2ffc269e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    errno = EINVAL;
2ffc26a2:	601a      	str	r2, [r3, #0]
}
2ffc26a4:	bd08      	pop	{r3, pc}
2ffc26a6:	bf00      	nop

2ffc26a8 <_exit>:

void _exit (int status)
{
2ffc26a8:	b508      	push	{r3, lr}
    errno = EINVAL;
2ffc26aa:	f009 fb59 	bl	2ffcbd60 <__errno>
2ffc26ae:	2316      	movs	r3, #22
2ffc26b0:	6003      	str	r3, [r0, #0]
    _kill(status, -1);
    while (1) {}        /* Make sure we hang here */
2ffc26b2:	e7fe      	b.n	2ffc26b2 <_exit+0xa>

2ffc26b4 <_read>:
}

int _read (__attribute__((unused))int file, char *ptr, int len)
{
2ffc26b4:	b570      	push	{r4, r5, r6, lr}
    int DataIdx;

    for (DataIdx = 0; DataIdx < len; DataIdx++)
2ffc26b6:	1e16      	subs	r6, r2, #0
2ffc26b8:	dd07      	ble.n	2ffc26ca <_read+0x16>
2ffc26ba:	198d      	adds	r5, r1, r6
2ffc26bc:	460c      	mov	r4, r1
    {
        *ptr++ = __io_getchar();
2ffc26be:	f3af 8000 	nop.w
2ffc26c2:	f804 0b01 	strb.w	r0, [r4], #1
    for (DataIdx = 0; DataIdx < len; DataIdx++)
2ffc26c6:	42a5      	cmp	r5, r4
2ffc26c8:	d1f9      	bne.n	2ffc26be <_read+0xa>
    }

return len;
}
2ffc26ca:	4630      	mov	r0, r6
2ffc26cc:	bd70      	pop	{r4, r5, r6, pc}
2ffc26ce:	bf00      	nop

2ffc26d0 <_write>:

int _write(__attribute__((unused))int file, char *ptr, int len)
{
2ffc26d0:	b570      	push	{r4, r5, r6, lr}
    int DataIdx;

    for (DataIdx = 0; DataIdx < len; DataIdx++)
2ffc26d2:	1e16      	subs	r6, r2, #0
2ffc26d4:	dd07      	ble.n	2ffc26e6 <_write+0x16>
2ffc26d6:	198d      	adds	r5, r1, r6
2ffc26d8:	460c      	mov	r4, r1
    {
        __io_putchar(*ptr++);
2ffc26da:	f814 0b01 	ldrb.w	r0, [r4], #1
2ffc26de:	f008 fdb1 	bl	2ffcb244 <__io_putchar>
    for (DataIdx = 0; DataIdx < len; DataIdx++)
2ffc26e2:	42a5      	cmp	r5, r4
2ffc26e4:	d1f9      	bne.n	2ffc26da <_write+0xa>
    }
    return len;
}
2ffc26e6:	4630      	mov	r0, r6
2ffc26e8:	bd70      	pop	{r4, r5, r6, pc}
2ffc26ea:	bf00      	nop

2ffc26ec <_sbrk>:
    char *prev_heap_end;
#ifdef A7_DUAL_CORE_SMP
    static int mutex = unlocked;
    lock_mutex(&mutex);
#endif
    if (heap_end == 0)
2ffc26ec:	f642 1210 	movw	r2, #10512	@ 0x2910
2ffc26f0:	f6c2 72fd 	movt	r2, #12285	@ 0x2ffd
{
2ffc26f4:	b508      	push	{r3, lr}
2ffc26f6:	4603      	mov	r3, r0
    if (heap_end == 0)
2ffc26f8:	6810      	ldr	r0, [r2, #0]
2ffc26fa:	b170      	cbz	r0, 2ffc271a <_sbrk+0x2e>
        heap_end = &end;

    prev_heap_end = heap_end;
    if (heap_end + incr > stack_ptr)
2ffc26fc:	4403      	add	r3, r0
2ffc26fe:	4669      	mov	r1, sp
2ffc2700:	428b      	cmp	r3, r1
        unlock_mutex(&mutex);
#endif
        return (caddr_t) -1;
    }

    heap_end += incr;
2ffc2702:	bf98      	it	ls
2ffc2704:	6013      	strls	r3, [r2, #0]
    if (heap_end + incr > stack_ptr)
2ffc2706:	d800      	bhi.n	2ffc270a <_sbrk+0x1e>
#ifdef A7_DUAL_CORE_SMP
    unlock_mutex(&mutex);
#endif
    return (caddr_t) prev_heap_end;
}
2ffc2708:	bd08      	pop	{r3, pc}
        errno = ENOMEM;
2ffc270a:	f009 fb29 	bl	2ffcbd60 <__errno>
2ffc270e:	4603      	mov	r3, r0
2ffc2710:	220c      	movs	r2, #12
        return (caddr_t) -1;
2ffc2712:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
        errno = ENOMEM;
2ffc2716:	601a      	str	r2, [r3, #0]
}
2ffc2718:	bd08      	pop	{r3, pc}
        heap_end = &end;
2ffc271a:	f249 0000 	movw	r0, #36864	@ 0x9000
2ffc271e:	f6c2 70fd 	movt	r0, #12285	@ 0x2ffd
2ffc2722:	6010      	str	r0, [r2, #0]
2ffc2724:	e7ea      	b.n	2ffc26fc <_sbrk+0x10>
2ffc2726:	bf00      	nop

2ffc2728 <_close>:

int _close(__attribute__((unused))int file)
{
    return -1;
}
2ffc2728:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
2ffc272c:	4770      	bx	lr
2ffc272e:	bf00      	nop

2ffc2730 <_fstat>:


int _fstat(__attribute__((unused))int file, struct stat *st)
{
    st->st_mode = S_IFCHR;
2ffc2730:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
    return 0;
}
2ffc2734:	2000      	movs	r0, #0
    st->st_mode = S_IFCHR;
2ffc2736:	604b      	str	r3, [r1, #4]
}
2ffc2738:	4770      	bx	lr
2ffc273a:	bf00      	nop

2ffc273c <_isatty>:

int _isatty(__attribute__((unused))int file)
{
    return 1;
}
2ffc273c:	2001      	movs	r0, #1
2ffc273e:	4770      	bx	lr

2ffc2740 <_lseek>:

int _lseek(__attribute__((unused))int file, __attribute__((unused))int ptr,
           __attribute__((unused))int dir)
{
    return 0;
}
2ffc2740:	2000      	movs	r0, #0
2ffc2742:	4770      	bx	lr

2ffc2744 <BSP_LED_Off>:
  *            @arg  LED8
  */
int32_t BSP_LED_Off(Led_TypeDef Led)
{
  int32_t  status = BSP_ERROR_NONE;
  if((Led == LED5) || (Led == LED6))
2ffc2744:	2801      	cmp	r0, #1
{
2ffc2746:	b508      	push	{r3, lr}
  {
    HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET);
2ffc2748:	bf9c      	itt	ls
2ffc274a:	2201      	movls	r2, #1
2ffc274c:	f24e 0300 	movwls	r3, #57344	@ 0xe000
  if((Led == LED5) || (Led == LED6))
2ffc2750:	d907      	bls.n	2ffc2762 <BSP_LED_Off+0x1e>
  }
  else if ((Led == LED7) || (Led == LED8))
2ffc2752:	1e83      	subs	r3, r0, #2
2ffc2754:	2b01      	cmp	r3, #1
2ffc2756:	d901      	bls.n	2ffc275c <BSP_LED_Off+0x18>
  {
    HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
  }

  return status;
}
2ffc2758:	2000      	movs	r0, #0
2ffc275a:	bd08      	pop	{r3, pc}
    HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
2ffc275c:	f24e 0300 	movw	r3, #57344	@ 0xe000
2ffc2760:	2200      	movs	r2, #0
2ffc2762:	f6c2 73fc 	movt	r3, #12284	@ 0x2ffc
2ffc2766:	eb03 0180 	add.w	r1, r3, r0, lsl #2
2ffc276a:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
2ffc276e:	8a09      	ldrh	r1, [r1, #16]
2ffc2770:	f002 fd2c 	bl	2ffc51cc <HAL_GPIO_WritePin>
}
2ffc2774:	2000      	movs	r0, #0
2ffc2776:	bd08      	pop	{r3, pc}

2ffc2778 <BSP_LED_Init>:
{
2ffc2778:	b510      	push	{r4, lr}
2ffc277a:	4604      	mov	r4, r0
2ffc277c:	b086      	sub	sp, #24
2ffc277e:	2803      	cmp	r0, #3
2ffc2780:	d808      	bhi.n	2ffc2794 <BSP_LED_Init+0x1c>
2ffc2782:	e8df f000 	tbb	[pc, r0]
2ffc2786:	0202      	.short	0x0202
2ffc2788:	2026      	.short	0x2026
    LED5_GPIO_CLK_ENABLE();
2ffc278a:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc278e:	2201      	movs	r2, #1
2ffc2790:	f8c3 2a28 	str.w	r2, [r3, #2600]	@ 0xa28
  gpio_init_structure.Pin = LED_PIN[Led];
2ffc2794:	f24e 0300 	movw	r3, #57344	@ 0xe000
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
2ffc2798:	2201      	movs	r2, #1
  gpio_init_structure.Pin = LED_PIN[Led];
2ffc279a:	f6c2 73fc 	movt	r3, #12284	@ 0x2ffc
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
2ffc279e:	a901      	add	r1, sp, #4
  gpio_init_structure.Pin = LED_PIN[Led];
2ffc27a0:	eb03 0c84 	add.w	ip, r3, r4, lsl #2
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
2ffc27a4:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
  gpio_init_structure.Pin = LED_PIN[Led];
2ffc27a8:	f8dc 3010 	ldr.w	r3, [ip, #16]
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
2ffc27ac:	9202      	str	r2, [sp, #8]
  gpio_init_structure.Pull = GPIO_PULLUP;
2ffc27ae:	9203      	str	r2, [sp, #12]
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
2ffc27b0:	2203      	movs	r2, #3
2ffc27b2:	9204      	str	r2, [sp, #16]
  gpio_init_structure.Pin = LED_PIN[Led];
2ffc27b4:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
2ffc27b6:	f002 faa7 	bl	2ffc4d08 <HAL_GPIO_Init>
  BSP_LED_Off(Led);
2ffc27ba:	4620      	mov	r0, r4
2ffc27bc:	f7ff ffc2 	bl	2ffc2744 <BSP_LED_Off>
}
2ffc27c0:	2000      	movs	r0, #0
2ffc27c2:	b006      	add	sp, #24
2ffc27c4:	bd10      	pop	{r4, pc}
    LED8_GPIO_CLK_ENABLE();
2ffc27c6:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc27ca:	2208      	movs	r2, #8
2ffc27cc:	f8c3 2a28 	str.w	r2, [r3, #2600]	@ 0xa28
2ffc27d0:	e7e0      	b.n	2ffc2794 <BSP_LED_Init+0x1c>
    LED7_GPIO_CLK_ENABLE();
2ffc27d2:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc27d6:	2280      	movs	r2, #128	@ 0x80
2ffc27d8:	f8c3 2a28 	str.w	r2, [r3, #2600]	@ 0xa28
2ffc27dc:	e7da      	b.n	2ffc2794 <BSP_LED_Init+0x1c>
2ffc27de:	bf00      	nop

2ffc27e0 <BSP_LED_Toggle>:
  *            @arg  LED6
  *            @arg  LED7
  *            @arg  LED8
  */
int32_t BSP_LED_Toggle(Led_TypeDef Led)
{
2ffc27e0:	b508      	push	{r3, lr}
  int32_t  status = BSP_ERROR_NONE;
  /* Toggle GPIO Led Pin */
  HAL_GPIO_TogglePin(LED_PORT[Led], LED_PIN[Led]);
2ffc27e2:	f24e 0300 	movw	r3, #57344	@ 0xe000
2ffc27e6:	f6c2 73fc 	movt	r3, #12284	@ 0x2ffc
2ffc27ea:	eb03 0280 	add.w	r2, r3, r0, lsl #2
2ffc27ee:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
2ffc27f2:	8a11      	ldrh	r1, [r2, #16]
2ffc27f4:	f002 fcee 	bl	2ffc51d4 <HAL_GPIO_TogglePin>
  return status;
}
2ffc27f8:	2000      	movs	r0, #0
2ffc27fa:	bd08      	pop	{r3, pc}
2ffc27fc:	0000      	movs	r0, r0
	...

2ffc2800 <I2C_MspInit.constprop.0>:
  /* Enable GPIO clock */
  DISCO_I2C_SCL_GPIO_CLK_ENABLE();
  DISCO_I2C_SDA_GPIO_CLK_ENABLE();
  
  /* Configure I2C Tx as alternate function */
  gpio_init_structure.Pin = DISCO_I2C_SCL_PIN;
2ffc2800:	eddf 0b1f 	vldr	d16, [pc, #124]	@ 2ffc2880 <I2C_MspInit.constprop.0+0x80>
2ffc2804:	eddf 1b20 	vldr	d17, [pc, #128]	@ 2ffc2888 <I2C_MspInit.constprop.0+0x88>
static void I2C_MspInit(I2C_HandleTypeDef *hI2c)
2ffc2808:	b570      	push	{r4, r5, r6, lr}
  DISCO_I2C_SCL_GPIO_CLK_ENABLE();
2ffc280a:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
  gpio_init_structure.Mode = GPIO_MODE_AF_OD;
  gpio_init_structure.Pull = GPIO_NOPULL;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
  gpio_init_structure.Alternate = DISCO_I2C_SCL_AF;
  BSP_ENTER_CRITICAL_SECTION(DISCO_I2C_SCL_GPIO_PORT);
  HAL_GPIO_Init(DISCO_I2C_SCL_GPIO_PORT, &gpio_init_structure);
2ffc280e:	f44f 4580 	mov.w	r5, #16384	@ 0x4000
static void I2C_MspInit(I2C_HandleTypeDef *hI2c)
2ffc2812:	b0dc      	sub	sp, #368	@ 0x170
  HAL_GPIO_Init(DISCO_I2C_SCL_GPIO_PORT, &gpio_init_structure);
2ffc2814:	f2c5 4500 	movt	r5, #21504	@ 0x5400
  DISCO_I2C_SCL_GPIO_CLK_ENABLE();
2ffc2818:	2301      	movs	r3, #1
2ffc281a:	f8c4 3210 	str.w	r3, [r4, #528]	@ 0x210
  gpio_init_structure.Alternate = DISCO_I2C_SCL_AF;
2ffc281e:	2606      	movs	r6, #6
  DISCO_I2C_SDA_GPIO_CLK_ENABLE();
2ffc2820:	f8c4 3210 	str.w	r3, [r4, #528]	@ 0x210
  HAL_GPIO_Init(DISCO_I2C_SCL_GPIO_PORT, &gpio_init_structure);
2ffc2824:	4669      	mov	r1, sp
  gpio_init_structure.Alternate = DISCO_I2C_SCL_AF;
2ffc2826:	9604      	str	r6, [sp, #16]
  HAL_GPIO_Init(DISCO_I2C_SCL_GPIO_PORT, &gpio_init_structure);
2ffc2828:	4628      	mov	r0, r5
  gpio_init_structure.Pin = DISCO_I2C_SCL_PIN;
2ffc282a:	f94d 0adf 	vst1.64	{d16-d17}, [sp :64]
  HAL_GPIO_Init(DISCO_I2C_SCL_GPIO_PORT, &gpio_init_structure);
2ffc282e:	f002 fa6b 	bl	2ffc4d08 <HAL_GPIO_Init>
  BSP_EXIT_CRITICAL_SECTION(DISCO_I2C_SCL_GPIO_PORT);
  
  /* Configure I2C Rx as alternate function */
  gpio_init_structure.Pin = DISCO_I2C_SDA_PIN;
  gpio_init_structure.Alternate = DISCO_I2C_SDA_AF;
2ffc2832:	9604      	str	r6, [sp, #16]
  BSP_ENTER_CRITICAL_SECTION(DISCO_I2C_SDA_GPIO_PORT);
  HAL_GPIO_Init(DISCO_I2C_SDA_GPIO_PORT, &gpio_init_structure);
2ffc2834:	4669      	mov	r1, sp
2ffc2836:	4628      	mov	r0, r5
  gpio_init_structure.Pin = DISCO_I2C_SDA_PIN;
2ffc2838:	2320      	movs	r3, #32
2ffc283a:	9300      	str	r3, [sp, #0]
  HAL_GPIO_Init(DISCO_I2C_SDA_GPIO_PORT, &gpio_init_structure);
2ffc283c:	f002 fa64 	bl	2ffc4d08 <HAL_GPIO_Init>
  BSP_EXIT_CRITICAL_SECTION(DISCO_I2C_SDA_GPIO_PORT);
  
  /* Enable I2C clock */
  DISCO_I2C_CLK_ENABLE();
2ffc2840:	2304      	movs	r3, #4
  I2C_clock_source_config.PeriphClockSelection = RCC_PERIPHCLK_I2C12;
#elif (UTIL_PMIC_I2C_PORT == UTIL_I2C3) || (UTIL_PMIC_I2C_PORT == UTIL_I2C5)
  I2C_clock_source_config.I2c35ClockSelection = RCC_I2C35CLKSOURCE_HSI;
  I2C_clock_source_config.PeriphClockSelection = RCC_PERIPHCLK_I2C35;
#elif (UTIL_PMIC_I2C_PORT == UTIL_I2C4) || (UTIL_PMIC_I2C_PORT == UTIL_I2C6)
  I2C_clock_source_config.I2c46ClockSelection = RCC_I2C46CLKSOURCE_HSI;
2ffc2842:	2202      	movs	r2, #2
  DISCO_I2C_CLK_ENABLE();
2ffc2844:	f8c4 3208 	str.w	r3, [r4, #520]	@ 0x208
  I2C_clock_source_config.PeriphClockSelection = RCC_PERIPHCLK_I2C46;
#else
  #error "unknown UTIL_PMIC_I2C_PORT definition."
#endif
HAL_RCCEx_PeriphCLKConfig(&I2C_clock_source_config); 
2ffc2848:	a806      	add	r0, sp, #24
  DISCO_I2C_FORCE_RESET();
2ffc284a:	f8c4 3188 	str.w	r3, [r4, #392]	@ 0x188
  DISCO_I2C_RELEASE_RESET();
2ffc284e:	f8c4 318c 	str.w	r3, [r4, #396]	@ 0x18c
  I2C_clock_source_config.PeriphClockSelection = RCC_PERIPHCLK_I2C46;
2ffc2852:	2320      	movs	r3, #32
  I2C_clock_source_config.I2c46ClockSelection = RCC_I2C46CLKSOURCE_HSI;
2ffc2854:	9237      	str	r2, [sp, #220]	@ 0xdc
  I2C_clock_source_config.PeriphClockSelection = RCC_PERIPHCLK_I2C46;
2ffc2856:	2200      	movs	r2, #0
2ffc2858:	e9cd 2306 	strd	r2, r3, [sp, #24]
HAL_RCCEx_PeriphCLKConfig(&I2C_clock_source_config); 
2ffc285c:	f004 fee6 	bl	2ffc762c <HAL_RCCEx_PeriphCLKConfig>
  
#if defined(CORE_CA7)
  IRQ_SetPriority(DISCO_I2C_ER_IRQn, 0);
2ffc2860:	2100      	movs	r1, #0
2ffc2862:	2080      	movs	r0, #128	@ 0x80
2ffc2864:	f000 fba4 	bl	2ffc2fb0 <IRQ_SetPriority>
  IRQ_Enable(DISCO_I2C_ER_IRQn);
2ffc2868:	2080      	movs	r0, #128	@ 0x80
2ffc286a:	f000 fb13 	bl	2ffc2e94 <IRQ_Enable>
  IRQ_SetPriority(DISCO_I2C_EV_IRQn, 0);
2ffc286e:	2100      	movs	r1, #0
2ffc2870:	207f      	movs	r0, #127	@ 0x7f
2ffc2872:	f000 fb9d 	bl	2ffc2fb0 <IRQ_SetPriority>
  IRQ_Enable(DISCO_I2C_EV_IRQn);
2ffc2876:	207f      	movs	r0, #127	@ 0x7f
2ffc2878:	f000 fb0c 	bl	2ffc2e94 <IRQ_Enable>
  HAL_NVIC_SetPriority(DISCO_I2C_ER_IRQn, 0, 1);
  HAL_NVIC_EnableIRQ(DISCO_I2C_ER_IRQn);
  HAL_NVIC_SetPriority(DISCO_I2C_EV_IRQn, 0, 2);
  HAL_NVIC_EnableIRQ(DISCO_I2C_EV_IRQn);
#endif
}
2ffc287c:	b05c      	add	sp, #368	@ 0x170
2ffc287e:	bd70      	pop	{r4, r5, r6, pc}
2ffc2880:	00000010 	.word	0x00000010
2ffc2884:	00000012 	.word	0x00000012
2ffc2888:	00000000 	.word	0x00000000
2ffc288c:	00000002 	.word	0x00000002

2ffc2890 <MX_I2C_Init>:
  hI2c->Init.Timing           = DISCO_I2C_TIMING;
2ffc2890:	eddf 2b0b 	vldr	d18, [pc, #44]	@ 2ffc28c0 <MX_I2C_Init+0x30>
2ffc2894:	eddf 3b0c 	vldr	d19, [pc, #48]	@ 2ffc28c8 <MX_I2C_Init+0x38>
2ffc2898:	efc0 0050 	vmov.i32	q8, #0	@ 0x00000000
{
2ffc289c:	4603      	mov	r3, r0
  hI2c->Instance              = DISCO_I2C;
2ffc289e:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
2ffc28a2:	f6c5 4200 	movt	r2, #23552	@ 0x5c00
  hI2c->Init.Timing           = DISCO_I2C_TIMING;
2ffc28a6:	f100 0114 	add.w	r1, r0, #20
  hI2c->Instance              = DISCO_I2C;
2ffc28aa:	f843 2b04 	str.w	r2, [r3], #4
  hI2c->Init.Timing           = DISCO_I2C_TIMING;
2ffc28ae:	f943 2a8f 	vst1.32	{d18-d19}, [r3]
2ffc28b2:	f941 0a8f 	vst1.32	{d16-d17}, [r1]
  return HAL_I2C_Init(hI2c);
2ffc28b6:	f002 be47 	b.w	2ffc5548 <HAL_I2C_Init>
2ffc28ba:	bf00      	nop
2ffc28bc:	f3af 8000 	nop.w
2ffc28c0:	10805e89 	.word	0x10805e89
2ffc28c4:	00000066 	.word	0x00000066
2ffc28c8:	00000001 	.word	0x00000001
2ffc28cc:	00000000 	.word	0x00000000

2ffc28d0 <BSP_I2C_Init>:
  if(HAL_I2C_GetState(&hI2c) == HAL_I2C_STATE_RESET)
2ffc28d0:	f642 1018 	movw	r0, #10520	@ 0x2918
{
2ffc28d4:	b508      	push	{r3, lr}
  if(HAL_I2C_GetState(&hI2c) == HAL_I2C_STATE_RESET)
2ffc28d6:	f6c2 70fd 	movt	r0, #12285	@ 0x2ffd
2ffc28da:	f003 f971 	bl	2ffc5bc0 <HAL_I2C_GetState>
2ffc28de:	b108      	cbz	r0, 2ffc28e4 <BSP_I2C_Init+0x14>
  int32_t status = BSP_ERROR_NONE;
2ffc28e0:	2000      	movs	r0, #0
}
2ffc28e2:	bd08      	pop	{r3, pc}
    I2C_MspInit(&hI2c);
2ffc28e4:	f7ff ff8c 	bl	2ffc2800 <I2C_MspInit.constprop.0>
    if( MX_I2C_Init(&hI2c) != HAL_OK)
2ffc28e8:	f642 1018 	movw	r0, #10520	@ 0x2918
2ffc28ec:	f6c2 70fd 	movt	r0, #12285	@ 0x2ffd
2ffc28f0:	f7ff ffce 	bl	2ffc2890 <MX_I2C_Init>
2ffc28f4:	2800      	cmp	r0, #0
2ffc28f6:	d0f3      	beq.n	2ffc28e0 <BSP_I2C_Init+0x10>
        status = BSP_ERROR_BUS_FAILURE;
2ffc28f8:	f06f 0007 	mvn.w	r0, #7
}
2ffc28fc:	bd08      	pop	{r3, pc}
2ffc28fe:	bf00      	nop

2ffc2900 <BSP_I2C_WriteReg>:
{
2ffc2900:	b500      	push	{lr}
2ffc2902:	b085      	sub	sp, #20
2ffc2904:	4684      	mov	ip, r0
  */
static int32_t I2C_WriteReg(uint16_t DevAddr, uint16_t Reg, uint16_t MemAddSize, uint8_t *pData, uint16_t Length)
{  
  int32_t status = BSP_ERROR_BUS_FAILURE;

  if(HAL_I2C_Mem_Write(&hI2c, DevAddr, Reg, MemAddSize, pData, Length, 10000) == HAL_OK)
2ffc2906:	f642 1018 	movw	r0, #10520	@ 0x2918
2ffc290a:	9301      	str	r3, [sp, #4]
2ffc290c:	f242 7310 	movw	r3, #10000	@ 0x2710
2ffc2910:	9302      	str	r3, [sp, #8]
2ffc2912:	2301      	movs	r3, #1
2ffc2914:	9200      	str	r2, [sp, #0]
2ffc2916:	460a      	mov	r2, r1
2ffc2918:	f6c2 70fd 	movt	r0, #12285	@ 0x2ffd
2ffc291c:	4661      	mov	r1, ip
2ffc291e:	f002 fe69 	bl	2ffc55f4 <HAL_I2C_Mem_Write>
  int32_t status = BSP_ERROR_BUS_FAILURE;
2ffc2922:	2800      	cmp	r0, #0
}
2ffc2924:	bf14      	ite	ne
2ffc2926:	f06f 0007 	mvnne.w	r0, #7
2ffc292a:	2000      	moveq	r0, #0
2ffc292c:	b005      	add	sp, #20
2ffc292e:	f85d fb04 	ldr.w	pc, [sp], #4
2ffc2932:	bf00      	nop

2ffc2934 <BSP_I2C_ReadReg>:
{
2ffc2934:	b500      	push	{lr}
2ffc2936:	b085      	sub	sp, #20
2ffc2938:	4684      	mov	ip, r0
  */
static int32_t I2C_ReadReg(uint16_t DevAddr, uint16_t Reg, uint16_t MemAddSize, uint8_t *pData, uint16_t Length)
{  
  int32_t status = BSP_ERROR_BUS_FAILURE;

  if (HAL_I2C_Mem_Read(&hI2c, DevAddr, Reg, MemAddSize, pData, Length, 10000) == HAL_OK)
2ffc293a:	f642 1018 	movw	r0, #10520	@ 0x2918
2ffc293e:	9301      	str	r3, [sp, #4]
2ffc2940:	f242 7310 	movw	r3, #10000	@ 0x2710
2ffc2944:	9302      	str	r3, [sp, #8]
2ffc2946:	2301      	movs	r3, #1
2ffc2948:	9200      	str	r2, [sp, #0]
2ffc294a:	460a      	mov	r2, r1
2ffc294c:	f6c2 70fd 	movt	r0, #12285	@ 0x2ffd
2ffc2950:	4661      	mov	r1, ip
2ffc2952:	f002 ff57 	bl	2ffc5804 <HAL_I2C_Mem_Read>
  int32_t status = BSP_ERROR_BUS_FAILURE;
2ffc2956:	2800      	cmp	r0, #0
}
2ffc2958:	bf14      	ite	ne
2ffc295a:	f06f 0007 	mvnne.w	r0, #7
2ffc295e:	2000      	moveq	r0, #0
2ffc2960:	b005      	add	sp, #20
2ffc2962:	f85d fb04 	ldr.w	pc, [sp], #4
2ffc2966:	bf00      	nop

2ffc2968 <BSP_I2C_IsReady>:
{
2ffc2968:	4684      	mov	ip, r0
  if(HAL_I2C_IsDeviceReady(&hI2c, DevAddr, Trials, 1000) != HAL_OK)
2ffc296a:	f642 1018 	movw	r0, #10520	@ 0x2918
2ffc296e:	f6c2 70fd 	movt	r0, #12285	@ 0x2ffd
{
2ffc2972:	460a      	mov	r2, r1
2ffc2974:	b508      	push	{r3, lr}
  if(HAL_I2C_IsDeviceReady(&hI2c, DevAddr, Trials, 1000) != HAL_OK)
2ffc2976:	4661      	mov	r1, ip
2ffc2978:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
2ffc297c:	f003 f852 	bl	2ffc5a24 <HAL_I2C_IsDeviceReady>
  int32_t status = BSP_ERROR_NONE;
2ffc2980:	2800      	cmp	r0, #0
}
2ffc2982:	bf14      	ite	ne
2ffc2984:	f06f 0002 	mvnne.w	r0, #2
2ffc2988:	2000      	moveq	r0, #0
2ffc298a:	bd08      	pop	{r3, pc}

2ffc298c <BSP_Error_Handler>:
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void BSP_Error_Handler(void)
{
  BSP_LED_Init(LED_RED);
2ffc298c:	2000      	movs	r0, #0
{
2ffc298e:	b508      	push	{r3, lr}
  BSP_LED_Init(LED_RED);
2ffc2990:	f7ff fef2 	bl	2ffc2778 <BSP_LED_Init>

  /* Infinite loop */
  while (1)
  {
    /* Toggle LED_RED */
    BSP_LED_Toggle(LED_RED);
2ffc2994:	2000      	movs	r0, #0
2ffc2996:	f7ff ff23 	bl	2ffc27e0 <BSP_LED_Toggle>
    HAL_Delay(500);
2ffc299a:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
2ffc299e:	f000 fdef 	bl	2ffc3580 <HAL_Delay>
  while (1)
2ffc29a2:	e7f7      	b.n	2ffc2994 <BSP_Error_Handler+0x8>

2ffc29a4 <STPMU1_Register_Read>:
  STPMU1_Register_Update(regul->control_reg, voltage_index << 2, 0xFC);
}

/* register direct access */
uint8_t STPMU1_Register_Read(uint8_t register_id)
{
2ffc29a4:	b500      	push	{lr}
2ffc29a6:	b083      	sub	sp, #12
  uint32_t status = BSP_ERROR_NONE;
  uint8_t Value = 0;
2ffc29a8:	2300      	movs	r3, #0
{
2ffc29aa:	4601      	mov	r1, r0
  uint8_t Value = 0;
2ffc29ac:	f88d 3007 	strb.w	r3, [sp, #7]

  status = BSP_I2C_ReadReg(STPMU1_I2C_ADDRESS, (uint16_t)register_id, &Value, 1);
2ffc29b0:	f10d 0207 	add.w	r2, sp, #7
2ffc29b4:	2301      	movs	r3, #1
2ffc29b6:	2066      	movs	r0, #102	@ 0x66
2ffc29b8:	f7ff ffbc 	bl	2ffc2934 <BSP_I2C_ReadReg>

  /* Check the communication status */
  if (status != BSP_ERROR_NONE)
2ffc29bc:	b920      	cbnz	r0, 2ffc29c8 <STPMU1_Register_Read+0x24>
  {
    BSP_Error_Handler();
  }
  return Value;
}
2ffc29be:	f89d 0007 	ldrb.w	r0, [sp, #7]
2ffc29c2:	b003      	add	sp, #12
2ffc29c4:	f85d fb04 	ldr.w	pc, [sp], #4
    BSP_Error_Handler();
2ffc29c8:	f7ff ffe0 	bl	2ffc298c <BSP_Error_Handler>

2ffc29cc <STPMU1_Register_Write>:

void STPMU1_Register_Write(uint8_t register_id, uint8_t value)
{
2ffc29cc:	b510      	push	{r4, lr}
2ffc29ce:	b084      	sub	sp, #16
2ffc29d0:	4604      	mov	r4, r0
  uint32_t status = BSP_ERROR_NONE;

  status = BSP_I2C_WriteReg(STPMU1_I2C_ADDRESS, (uint16_t)register_id, &value, 1);
2ffc29d2:	2301      	movs	r3, #1
{
2ffc29d4:	f88d 1007 	strb.w	r1, [sp, #7]
  status = BSP_I2C_WriteReg(STPMU1_I2C_ADDRESS, (uint16_t)register_id, &value, 1);
2ffc29d8:	f10d 0207 	add.w	r2, sp, #7
2ffc29dc:	4601      	mov	r1, r0
2ffc29de:	2066      	movs	r0, #102	@ 0x66
2ffc29e0:	f7ff ff8e 	bl	2ffc2900 <BSP_I2C_WriteReg>

  /* Check the communication status */
  if (status != BSP_ERROR_NONE)
2ffc29e4:	b9c8      	cbnz	r0, 2ffc2a1a <STPMU1_Register_Write+0x4e>
  {
    BSP_Error_Handler();
  }

  /* verify register content */
  if ((register_id != WATCHDOG_CONTROL_REG) && (register_id <= 0x40))
2ffc29e6:	f1b4 031b 	subs.w	r3, r4, #27
2ffc29ea:	bf18      	it	ne
2ffc29ec:	2301      	movne	r3, #1
2ffc29ee:	2c40      	cmp	r4, #64	@ 0x40
2ffc29f0:	bf88      	it	hi
2ffc29f2:	2300      	movhi	r3, #0
2ffc29f4:	b90b      	cbnz	r3, 2ffc29fa <STPMU1_Register_Write+0x2e>
    {
      BSP_Error_Handler();
    }
  }
  return;
}
2ffc29f6:	b004      	add	sp, #16
2ffc29f8:	bd10      	pop	{r4, pc}
  uint8_t Value = 0;
2ffc29fa:	f88d 000f 	strb.w	r0, [sp, #15]
  status = BSP_I2C_ReadReg(STPMU1_I2C_ADDRESS, (uint16_t)register_id, &Value, 1);
2ffc29fe:	2301      	movs	r3, #1
2ffc2a00:	f10d 020f 	add.w	r2, sp, #15
2ffc2a04:	4621      	mov	r1, r4
2ffc2a06:	2066      	movs	r0, #102	@ 0x66
2ffc2a08:	f7ff ff94 	bl	2ffc2934 <BSP_I2C_ReadReg>
  if (status != BSP_ERROR_NONE)
2ffc2a0c:	b928      	cbnz	r0, 2ffc2a1a <STPMU1_Register_Write+0x4e>
  return Value;
2ffc2a0e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    if (readval != value)
2ffc2a12:	f89d 2007 	ldrb.w	r2, [sp, #7]
2ffc2a16:	429a      	cmp	r2, r3
2ffc2a18:	d0ed      	beq.n	2ffc29f6 <STPMU1_Register_Write+0x2a>
    BSP_Error_Handler();
2ffc2a1a:	f7ff ffb7 	bl	2ffc298c <BSP_Error_Handler>
2ffc2a1e:	bf00      	nop

2ffc2a20 <STPMU1_Regulator_Enable>:
  regul_struct *regul = STPMU1_Get_Regulator_Data(id);
2ffc2a20:	f241 0c10 	movw	ip, #4112	@ 0x1010
{
2ffc2a24:	2300      	movs	r3, #0
2ffc2a26:	b510      	push	{r4, lr}
2ffc2a28:	b082      	sub	sp, #8
2ffc2a2a:	f6c2 7cfd 	movt	ip, #12285	@ 0x2ffd
    if (id == regulators_table[i].id)
2ffc2a2e:	011a      	lsls	r2, r3, #4
2ffc2a30:	f81c 1002 	ldrb.w	r1, [ip, r2]
2ffc2a34:	4281      	cmp	r1, r0
2ffc2a36:	d004      	beq.n	2ffc2a42 <STPMU1_Regulator_Enable+0x22>
  for (i = 0; i < MAX_REGUL; i++)
2ffc2a38:	3301      	adds	r3, #1
2ffc2a3a:	2b0b      	cmp	r3, #11
2ffc2a3c:	d1f7      	bne.n	2ffc2a2e <STPMU1_Regulator_Enable+0xe>
  BSP_Error_Handler();
2ffc2a3e:	f7ff ffa5 	bl	2ffc298c <BSP_Error_Handler>
  STPMU1_Register_Update(regul->control_reg, BIT(0), BIT(0));
2ffc2a42:	4494      	add	ip, r2
  uint8_t Value = 0;
2ffc2a44:	2300      	movs	r3, #0
2ffc2a46:	f88d 3007 	strb.w	r3, [sp, #7]
  status = BSP_I2C_ReadReg(STPMU1_I2C_ADDRESS, (uint16_t)register_id, &Value, 1);
2ffc2a4a:	f10d 0207 	add.w	r2, sp, #7
  STPMU1_Register_Update(regul->control_reg, BIT(0), BIT(0));
2ffc2a4e:	f89c 4009 	ldrb.w	r4, [ip, #9]
  status = BSP_I2C_ReadReg(STPMU1_I2C_ADDRESS, (uint16_t)register_id, &Value, 1);
2ffc2a52:	2301      	movs	r3, #1
2ffc2a54:	2066      	movs	r0, #102	@ 0x66
2ffc2a56:	4621      	mov	r1, r4
2ffc2a58:	f7ff ff6c 	bl	2ffc2934 <BSP_I2C_ReadReg>
  if (status != BSP_ERROR_NONE)
2ffc2a5c:	2800      	cmp	r0, #0
2ffc2a5e:	d1ee      	bne.n	2ffc2a3e <STPMU1_Regulator_Enable+0x1e>
  return Value;
2ffc2a60:	f89d 3007 	ldrb.w	r3, [sp, #7]

  /* Update appropriate bits*/
  initial_value |= (value & mask);

  /* Send new value on I2C Bus */
  STPMU1_Register_Write(register_id, initial_value);
2ffc2a64:	4620      	mov	r0, r4
  initial_value &= ~mask;
2ffc2a66:	f003 01fe 	and.w	r1, r3, #254	@ 0xfe
  STPMU1_Register_Write(register_id, initial_value);
2ffc2a6a:	f041 0101 	orr.w	r1, r1, #1
}
2ffc2a6e:	b002      	add	sp, #8
2ffc2a70:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  STPMU1_Register_Write(register_id, initial_value);
2ffc2a74:	f7ff bfaa 	b.w	2ffc29cc <STPMU1_Register_Write>

2ffc2a78 <STPMU1_Regulator_Voltage_Set>:
  uint8_t voltage_index = STPMU1_Voltage_Find_Index(id, milivolts);
2ffc2a78:	f241 0c10 	movw	ip, #4112	@ 0x1010
{
2ffc2a7c:	2300      	movs	r3, #0
2ffc2a7e:	b530      	push	{r4, r5, lr}
2ffc2a80:	b083      	sub	sp, #12
2ffc2a82:	f6c2 7cfd 	movt	ip, #12285	@ 0x2ffd
    if (id == regulators_table[i].id)
2ffc2a86:	011a      	lsls	r2, r3, #4
2ffc2a88:	f81c 4002 	ldrb.w	r4, [ip, r2]
2ffc2a8c:	4284      	cmp	r4, r0
2ffc2a8e:	d004      	beq.n	2ffc2a9a <STPMU1_Regulator_Voltage_Set+0x22>
  for (i = 0; i < MAX_REGUL; i++)
2ffc2a90:	3301      	adds	r3, #1
2ffc2a92:	2b0b      	cmp	r3, #11
2ffc2a94:	d1f7      	bne.n	2ffc2a86 <STPMU1_Regulator_Voltage_Set+0xe>
  BSP_Error_Handler();
2ffc2a96:	f7ff ff79 	bl	2ffc298c <BSP_Error_Handler>
  for (i = 0; i < regul->voltage_table_size; i++)
2ffc2a9a:	4462      	add	r2, ip
2ffc2a9c:	7a15      	ldrb	r5, [r2, #8]
2ffc2a9e:	2d00      	cmp	r5, #0
2ffc2aa0:	d0f9      	beq.n	2ffc2a96 <STPMU1_Regulator_Voltage_Set+0x1e>
2ffc2aa2:	6852      	ldr	r2, [r2, #4]
    if (regul->voltage_table[i] == milivolts)
2ffc2aa4:	2300      	movs	r3, #0
2ffc2aa6:	3a02      	subs	r2, #2
2ffc2aa8:	e002      	b.n	2ffc2ab0 <STPMU1_Regulator_Voltage_Set+0x38>
  for (i = 0; i < regul->voltage_table_size; i++)
2ffc2aaa:	3301      	adds	r3, #1
2ffc2aac:	42ab      	cmp	r3, r5
2ffc2aae:	d0f2      	beq.n	2ffc2a96 <STPMU1_Regulator_Voltage_Set+0x1e>
    if (regul->voltage_table[i] == milivolts)
2ffc2ab0:	f832 4f02 	ldrh.w	r4, [r2, #2]!
2ffc2ab4:	428c      	cmp	r4, r1
2ffc2ab6:	d1f8      	bne.n	2ffc2aaa <STPMU1_Regulator_Voltage_Set+0x32>
2ffc2ab8:	2200      	movs	r2, #0
    if (id == regulators_table[i].id)
2ffc2aba:	0111      	lsls	r1, r2, #4
2ffc2abc:	f81c 4001 	ldrb.w	r4, [ip, r1]
2ffc2ac0:	4284      	cmp	r4, r0
2ffc2ac2:	d007      	beq.n	2ffc2ad4 <STPMU1_Regulator_Voltage_Set+0x5c>
  for (i = 0; i < MAX_REGUL; i++)
2ffc2ac4:	3201      	adds	r2, #1
2ffc2ac6:	2a0b      	cmp	r2, #11
2ffc2ac8:	d0e5      	beq.n	2ffc2a96 <STPMU1_Regulator_Voltage_Set+0x1e>
    if (id == regulators_table[i].id)
2ffc2aca:	0111      	lsls	r1, r2, #4
2ffc2acc:	f81c 4001 	ldrb.w	r4, [ip, r1]
2ffc2ad0:	4284      	cmp	r4, r0
2ffc2ad2:	d1f7      	bne.n	2ffc2ac4 <STPMU1_Regulator_Voltage_Set+0x4c>
  STPMU1_Register_Update(regul->control_reg, voltage_index << 2, 0xFC);
2ffc2ad4:	448c      	add	ip, r1
  status = BSP_I2C_ReadReg(STPMU1_I2C_ADDRESS, (uint16_t)register_id, &Value, 1);
2ffc2ad6:	f10d 0207 	add.w	r2, sp, #7
  STPMU1_Register_Update(regul->control_reg, voltage_index << 2, 0xFC);
2ffc2ada:	009c      	lsls	r4, r3, #2
  uint8_t Value = 0;
2ffc2adc:	2300      	movs	r3, #0
  STPMU1_Register_Update(regul->control_reg, voltage_index << 2, 0xFC);
2ffc2ade:	f89c 5009 	ldrb.w	r5, [ip, #9]
  status = BSP_I2C_ReadReg(STPMU1_I2C_ADDRESS, (uint16_t)register_id, &Value, 1);
2ffc2ae2:	2066      	movs	r0, #102	@ 0x66
  uint8_t Value = 0;
2ffc2ae4:	f88d 3007 	strb.w	r3, [sp, #7]
  status = BSP_I2C_ReadReg(STPMU1_I2C_ADDRESS, (uint16_t)register_id, &Value, 1);
2ffc2ae8:	2301      	movs	r3, #1
2ffc2aea:	4629      	mov	r1, r5
  STPMU1_Register_Update(regul->control_reg, voltage_index << 2, 0xFC);
2ffc2aec:	b2e4      	uxtb	r4, r4
  status = BSP_I2C_ReadReg(STPMU1_I2C_ADDRESS, (uint16_t)register_id, &Value, 1);
2ffc2aee:	f7ff ff21 	bl	2ffc2934 <BSP_I2C_ReadReg>
  if (status != BSP_ERROR_NONE)
2ffc2af2:	2800      	cmp	r0, #0
2ffc2af4:	d1cf      	bne.n	2ffc2a96 <STPMU1_Regulator_Voltage_Set+0x1e>
  return Value;
2ffc2af6:	f89d 3007 	ldrb.w	r3, [sp, #7]
  STPMU1_Register_Write(register_id, initial_value);
2ffc2afa:	4628      	mov	r0, r5
  initial_value &= ~mask;
2ffc2afc:	f003 0103 	and.w	r1, r3, #3
  STPMU1_Register_Write(register_id, initial_value);
2ffc2b00:	4321      	orrs	r1, r4
}
2ffc2b02:	b003      	add	sp, #12
2ffc2b04:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  STPMU1_Register_Write(register_id, initial_value);
2ffc2b08:	f7ff bf60 	b.w	2ffc29cc <STPMU1_Register_Write>
2ffc2b0c:	0000      	movs	r0, r0
	...

2ffc2b10 <BSP_PMIC_Init>:

/* Use Xls I2C COnfiguration Tools with I2C Clock config + output clocks requirement */
#define I2C_TIMING 0x10805E89

uint32_t BSP_PMIC_Init(void)
{
2ffc2b10:	b5f0      	push	{r4, r5, r6, r7, lr}
2ffc2b12:	b087      	sub	sp, #28
  PMIC_INTn_CLK_ENABLE();
2ffc2b14:	2701      	movs	r7, #1
  BSP_I2C_Init();
2ffc2b16:	f7ff fedb 	bl	2ffc28d0 <BSP_I2C_Init>
  GPIO_InitStruct.Pin = PMIC_INTn_PIN;
2ffc2b1a:	eddf 0b2f 	vldr	d16, [pc, #188]	@ 2ffc2bd8 <BSP_PMIC_Init+0xc8>
2ffc2b1e:	eddf 1b30 	vldr	d17, [pc, #192]	@ 2ffc2be0 <BSP_PMIC_Init+0xd0>
  PMIC_INTn_CLK_ENABLE();
2ffc2b22:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
  HAL_GPIO_Init(PMIC_INTn_PORT, &GPIO_InitStruct);
2ffc2b26:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
2ffc2b2a:	f2c5 0000 	movt	r0, #20480	@ 0x5000
  GPIO_InitStruct.Alternate = 0;
2ffc2b2e:	2400      	movs	r4, #0
  PMIC_INTn_CLK_ENABLE();
2ffc2b30:	f8c3 7a28 	str.w	r7, [r3, #2600]	@ 0xa28
  HAL_GPIO_Init(PMIC_INTn_PORT, &GPIO_InitStruct);
2ffc2b34:	4669      	mov	r1, sp
  GPIO_InitStruct.Pin = PMIC_INTn_PIN;
2ffc2b36:	f94d 0adf 	vst1.64	{d16-d17}, [sp :64]
  GPIO_InitStruct.Alternate = 0;
2ffc2b3a:	9404      	str	r4, [sp, #16]
  HAL_GPIO_Init(PMIC_INTn_PORT, &GPIO_InitStruct);
2ffc2b3c:	f002 f8e4 	bl	2ffc4d08 <HAL_GPIO_Init>
  IRQ_SetPriority(EXTI0_IRQn, 0);
2ffc2b40:	4621      	mov	r1, r4
2ffc2b42:	2026      	movs	r0, #38	@ 0x26
2ffc2b44:	f000 fa34 	bl	2ffc2fb0 <IRQ_SetPriority>
  IRQ_Enable(EXTI0_IRQn);
2ffc2b48:	2026      	movs	r0, #38	@ 0x26
2ffc2b4a:	f000 f9a3 	bl	2ffc2e94 <IRQ_Enable>
  if (BSP_I2C_IsReady(STPMU1_I2C_ADDRESS, 1) != BSP_ERROR_NONE)
2ffc2b4e:	4639      	mov	r1, r7
2ffc2b50:	2066      	movs	r0, #102	@ 0x66
2ffc2b52:	f7ff ff09 	bl	2ffc2968 <BSP_I2C_IsReady>
2ffc2b56:	bbb0      	cbnz	r0, 2ffc2bc6 <BSP_PMIC_Init+0xb6>
  uint8_t Value = 0;
2ffc2b58:	f88d 0000 	strb.w	r0, [sp]
  status = BSP_I2C_ReadReg(STPMU1_I2C_ADDRESS, (uint16_t)register_id, &Value, 1);
2ffc2b5c:	463b      	mov	r3, r7
2ffc2b5e:	466a      	mov	r2, sp
2ffc2b60:	2106      	movs	r1, #6
2ffc2b62:	2066      	movs	r0, #102	@ 0x66
2ffc2b64:	f7ff fee6 	bl	2ffc2934 <BSP_I2C_ReadReg>
  if (status != BSP_ERROR_NONE)
2ffc2b68:	bb88      	cbnz	r0, 2ffc2bce <BSP_PMIC_Init+0xbe>
  return Value;
2ffc2b6a:	f89d 5000 	ldrb.w	r5, [sp]
  }

  if (STPMU1_Register_Read(VERSION_STATUS_REG) != 0x00)
  {
    status = BSP_ERROR_BUS_FAILURE;
    return status;
2ffc2b6e:	f06f 0007 	mvn.w	r0, #7
  if (STPMU1_Register_Read(VERSION_STATUS_REG) != 0x00)
2ffc2b72:	bb55      	cbnz	r5, 2ffc2bca <BSP_PMIC_Init+0xba>
  STPMU1_Register_Write(ITCLEARLATCH1_REG + irq_reg, irq_reg_value);
2ffc2b74:	2102      	movs	r1, #2
2ffc2b76:	2070      	movs	r0, #112	@ 0x70
2ffc2b78:	f7ff ff28 	bl	2ffc29cc <STPMU1_Register_Write>
  STPMU1_Register_Write(ITCLEARMASK1_REG + irq_reg, irq_reg_value);
2ffc2b7c:	20a0      	movs	r0, #160	@ 0xa0
2ffc2b7e:	2102      	movs	r1, #2
2ffc2b80:	f7ff ff24 	bl	2ffc29cc <STPMU1_Register_Write>
  STPMU1_Register_Write(ITCLEARLATCH1_REG + irq_reg, irq_reg_value);
2ffc2b84:	4639      	mov	r1, r7
2ffc2b86:	2070      	movs	r0, #112	@ 0x70
2ffc2b88:	f7ff ff20 	bl	2ffc29cc <STPMU1_Register_Write>
  STPMU1_Register_Write(ITCLEARMASK1_REG + irq_reg, irq_reg_value);
2ffc2b8c:	4639      	mov	r1, r7
2ffc2b8e:	20a0      	movs	r0, #160	@ 0xa0
2ffc2b90:	f7ff ff1c 	bl	2ffc29cc <STPMU1_Register_Write>
  irq_reg_value = 1 << (7 - (IRQn % 8));
2ffc2b94:	43ec      	mvns	r4, r5
  irq_reg = IRQn >> 3;
2ffc2b96:	f3c5 06c4 	ubfx	r6, r5, #3, #5
  irq_reg_value = 1 << (7 - (IRQn % 8));
2ffc2b9a:	f004 0407 	and.w	r4, r4, #7
  STPMU1_Register_Write(ITCLEARLATCH1_REG + irq_reg, irq_reg_value);
2ffc2b9e:	f106 0070 	add.w	r0, r6, #112	@ 0x70
  }

  STPMU1_Enable_Interrupt(IT_PONKEY_R);
  STPMU1_Enable_Interrupt(IT_PONKEY_F);
  /* enable all irqs  */
  for (irq = IT_SWOUT_R; irq < IRQ_NR; irq++)
2ffc2ba2:	3501      	adds	r5, #1
  irq_reg_value = 1 << (7 - (IRQn % 8));
2ffc2ba4:	fa07 f404 	lsl.w	r4, r7, r4
2ffc2ba8:	b2e4      	uxtb	r4, r4
  STPMU1_Register_Write(ITCLEARLATCH1_REG + irq_reg, irq_reg_value);
2ffc2baa:	4621      	mov	r1, r4
2ffc2bac:	f7ff ff0e 	bl	2ffc29cc <STPMU1_Register_Write>
  STPMU1_Register_Write(ITCLEARMASK1_REG + irq_reg, irq_reg_value);
2ffc2bb0:	f1a6 0060 	sub.w	r0, r6, #96	@ 0x60
2ffc2bb4:	4621      	mov	r1, r4
2ffc2bb6:	b2c0      	uxtb	r0, r0
2ffc2bb8:	f7ff ff08 	bl	2ffc29cc <STPMU1_Register_Write>
  for (irq = IT_SWOUT_R; irq < IRQ_NR; irq++)
2ffc2bbc:	2d20      	cmp	r5, #32
2ffc2bbe:	d1e9      	bne.n	2ffc2b94 <BSP_PMIC_Init+0x84>
  {
    STPMU1_Enable_Interrupt(irq);
  }

  return BSP_ERROR_NONE;
2ffc2bc0:	2000      	movs	r0, #0
}
2ffc2bc2:	b007      	add	sp, #28
2ffc2bc4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return status;
2ffc2bc6:	f06f 0002 	mvn.w	r0, #2
}
2ffc2bca:	b007      	add	sp, #28
2ffc2bcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    BSP_Error_Handler();
2ffc2bce:	f7ff fedd 	bl	2ffc298c <BSP_Error_Handler>
2ffc2bd2:	bf00      	nop
2ffc2bd4:	f3af 8000 	nop.w
2ffc2bd8:	00000001 	.word	0x00000001
2ffc2bdc:	10210000 	.word	0x10210000
2ffc2be0:	00000001 	.word	0x00000001
2ffc2be4:	00000002 	.word	0x00000002

2ffc2be8 <SystemPower_Config>:
 * @brief  This function handles System Power configuration.
 * @param  None
 * @retval None
 */
void SystemPower_Config(void)
{
2ffc2be8:	b508      	push	{r3, lr}
  /* Nothing to do */
#else
  /* PMIC initialization */
  /***********************/
  log_dbg("PMIC initialization \n\r");
  BSP_PMIC_Init();
2ffc2bea:	f7ff ff91 	bl	2ffc2b10 <BSP_PMIC_Init>

  STPMU1_Register_Write(MAIN_CONTROL_REG, 0x04);
2ffc2bee:	2104      	movs	r1, #4
2ffc2bf0:	2010      	movs	r0, #16
2ffc2bf2:	f7ff feeb 	bl	2ffc29cc <STPMU1_Register_Write>
  STPMU1_Register_Write(VIN_CONTROL_REG, 0xc0);
2ffc2bf6:	21c0      	movs	r1, #192	@ 0xc0
2ffc2bf8:	2015      	movs	r0, #21
2ffc2bfa:	f7ff fee7 	bl	2ffc29cc <STPMU1_Register_Write>
  STPMU1_Register_Write(USB_CONTROL_REG, 0x30);
2ffc2bfe:	2130      	movs	r1, #48	@ 0x30
2ffc2c00:	2040      	movs	r0, #64	@ 0x40
2ffc2c02:	f7ff fee3 	bl	2ffc29cc <STPMU1_Register_Write>

  STPMU1_Register_Write(MASK_RESET_BUCK_REG, 0x04);
2ffc2c06:	2104      	movs	r1, #4
2ffc2c08:	2018      	movs	r0, #24
2ffc2c0a:	f7ff fedf 	bl	2ffc29cc <STPMU1_Register_Write>
  STPMU1_Register_Write(MASK_RESET_LDO_REG, 0x00);
2ffc2c0e:	2100      	movs	r1, #0
2ffc2c10:	201a      	movs	r0, #26
2ffc2c12:	f7ff fedb 	bl	2ffc29cc <STPMU1_Register_Write>
  STPMU1_Register_Write(MASK_RANK_BUCK_REG, 0x00);
2ffc2c16:	2100      	movs	r1, #0
2ffc2c18:	2017      	movs	r0, #23
2ffc2c1a:	f7ff fed7 	bl	2ffc29cc <STPMU1_Register_Write>
  STPMU1_Register_Write(MASK_RANK_LDO_REG, 0x00);
2ffc2c1e:	2100      	movs	r1, #0
2ffc2c20:	2019      	movs	r0, #25
2ffc2c22:	f7ff fed3 	bl	2ffc29cc <STPMU1_Register_Write>
  STPMU1_Register_Write(BUCK_PULL_DOWN_REG, 0x00);
2ffc2c26:	2100      	movs	r1, #0
2ffc2c28:	2012      	movs	r0, #18
2ffc2c2a:	f7ff fecf 	bl	2ffc29cc <STPMU1_Register_Write>
  STPMU1_Register_Write(LDO14_PULL_DOWN_REG, 0x00);
2ffc2c2e:	2100      	movs	r1, #0
2ffc2c30:	2013      	movs	r0, #19
2ffc2c32:	f7ff fecb 	bl	2ffc29cc <STPMU1_Register_Write>
  STPMU1_Register_Write(LDO56_PULL_DOWN_REG, 0x00);
2ffc2c36:	2100      	movs	r1, #0
2ffc2c38:	2014      	movs	r0, #20
2ffc2c3a:	f7ff fec7 	bl	2ffc29cc <STPMU1_Register_Write>
  STPMU1_Register_Write(BUCK_ICC_TURNOFF_REG, 0x30);
2ffc2c3e:	2130      	movs	r1, #48	@ 0x30
2ffc2c40:	201d      	movs	r0, #29
2ffc2c42:	f7ff fec3 	bl	2ffc29cc <STPMU1_Register_Write>
  STPMU1_Register_Write(LDO_ICC_TURNOFF_REG, 0x3b);
2ffc2c46:	213b      	movs	r1, #59	@ 0x3b
2ffc2c48:	201e      	movs	r0, #30
2ffc2c4a:	f7ff febf 	bl	2ffc29cc <STPMU1_Register_Write>

  /* vddcore */
  STPMU1_Regulator_Voltage_Set(STPMU1_BUCK1, 1200);
2ffc2c4e:	f44f 6196 	mov.w	r1, #1200	@ 0x4b0
2ffc2c52:	2001      	movs	r0, #1
2ffc2c54:	f7ff ff10 	bl	2ffc2a78 <STPMU1_Regulator_Voltage_Set>
  STPMU1_Regulator_Enable(STPMU1_BUCK1);
2ffc2c58:	2001      	movs	r0, #1
2ffc2c5a:	f7ff fee1 	bl	2ffc2a20 <STPMU1_Regulator_Enable>
  /* vddddr */
  //  STPMU1_Regulator_Voltage_Set(STPMU1_BUCK2, 1200);
  //  STPMU1_Regulator_Enable(STPMU1_BUCK2);

  /* vdd */
  STPMU1_Regulator_Voltage_Set(STPMU1_BUCK3, 1800);
2ffc2c5e:	f44f 61e1 	mov.w	r1, #1800	@ 0x708
2ffc2c62:	2003      	movs	r0, #3
2ffc2c64:	f7ff ff08 	bl	2ffc2a78 <STPMU1_Regulator_Voltage_Set>
  STPMU1_Regulator_Enable(STPMU1_BUCK3);
2ffc2c68:	2003      	movs	r0, #3
2ffc2c6a:	f7ff fed9 	bl	2ffc2a20 <STPMU1_Regulator_Enable>

  /* 3v3 */
  STPMU1_Regulator_Voltage_Set(STPMU1_BUCK4, 3300);
2ffc2c6e:	f640 41e4 	movw	r1, #3300	@ 0xce4
2ffc2c72:	2004      	movs	r0, #4
2ffc2c74:	f7ff ff00 	bl	2ffc2a78 <STPMU1_Regulator_Voltage_Set>
  STPMU1_Regulator_Enable(STPMU1_BUCK4);
2ffc2c78:	2004      	movs	r0, #4
2ffc2c7a:	f7ff fed1 	bl	2ffc2a20 <STPMU1_Regulator_Enable>

  /* vdda */
  STPMU1_Regulator_Voltage_Set(STPMU1_LDO1, 1800);
2ffc2c7e:	f44f 61e1 	mov.w	r1, #1800	@ 0x708
2ffc2c82:	2005      	movs	r0, #5
2ffc2c84:	f7ff fef8 	bl	2ffc2a78 <STPMU1_Regulator_Voltage_Set>
  STPMU1_Regulator_Enable(STPMU1_LDO1);
2ffc2c88:	2005      	movs	r0, #5
2ffc2c8a:	f7ff fec9 	bl	2ffc2a20 <STPMU1_Regulator_Enable>

  /* 2v8 */
  STPMU1_Regulator_Voltage_Set(STPMU1_LDO2, 2900);
2ffc2c8e:	f640 3154 	movw	r1, #2900	@ 0xb54
2ffc2c92:	2006      	movs	r0, #6
2ffc2c94:	f7ff fef0 	bl	2ffc2a78 <STPMU1_Regulator_Voltage_Set>
  STPMU1_Regulator_Enable(STPMU1_LDO2);
2ffc2c98:	2006      	movs	r0, #6
2ffc2c9a:	f7ff fec1 	bl	2ffc2a20 <STPMU1_Regulator_Enable>
  /* vtt_ddr  lod3 mode buck2/2 */
  //  STPMU1_Regulator_Voltage_Set(STPMU1_LDO3, 0xFFFF);
  //  STPMU1_Regulator_Enable(STPMU1_LDO3);

  /* vdd_usb */
  STPMU1_Regulator_Voltage_Set(STPMU1_LDO4, 3300);
2ffc2c9e:	f640 41e4 	movw	r1, #3300	@ 0xce4
2ffc2ca2:	2008      	movs	r0, #8
2ffc2ca4:	f7ff fee8 	bl	2ffc2a78 <STPMU1_Regulator_Voltage_Set>
  STPMU1_Regulator_Enable(STPMU1_LDO4);
2ffc2ca8:	2008      	movs	r0, #8
2ffc2caa:	f7ff feb9 	bl	2ffc2a20 <STPMU1_Regulator_Enable>

  /* vdd_sd */
  STPMU1_Regulator_Voltage_Set(STPMU1_LDO5, 2900);
2ffc2cae:	f640 3154 	movw	r1, #2900	@ 0xb54
2ffc2cb2:	2009      	movs	r0, #9
2ffc2cb4:	f7ff fee0 	bl	2ffc2a78 <STPMU1_Regulator_Voltage_Set>
  STPMU1_Regulator_Enable(STPMU1_LDO5);
2ffc2cb8:	2009      	movs	r0, #9
2ffc2cba:	f7ff feb1 	bl	2ffc2a20 <STPMU1_Regulator_Enable>

  /* 1v8 */
  STPMU1_Regulator_Voltage_Set(STPMU1_LDO6, 1200);
2ffc2cbe:	200a      	movs	r0, #10
2ffc2cc0:	f44f 6196 	mov.w	r1, #1200	@ 0x4b0
2ffc2cc4:	f7ff fed8 	bl	2ffc2a78 <STPMU1_Regulator_Voltage_Set>
  STPMU1_Regulator_Enable(STPMU1_LDO6);

//  STPMU1_Regulator_Enable(STPMU1_VREFDDR);
#endif
}
2ffc2cc8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  STPMU1_Regulator_Enable(STPMU1_LDO6);
2ffc2ccc:	200a      	movs	r0, #10
2ffc2cce:	f7ff bea7 	b.w	2ffc2a20 <STPMU1_Regulator_Enable>
2ffc2cd2:	bf00      	nop

2ffc2cd4 <IRQ_Initialize>:

static IRQHandler_t IRQTable[IRQ_GIC_LINE_COUNT] = { 0U };
static uint32_t     IRQ_ID0;

/// Initialize interrupt controller.
__WEAK int32_t IRQ_Initialize (void) {
2ffc2cd4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

/** \brief Disable the interrupt distributor using the GIC's CTLR register.
*/
__STATIC_INLINE void GIC_DisableDistributor(void)
{
  GICDistributor->CTLR &=~1U;
2ffc2cd8:	f44f 5580 	mov.w	r5, #4096	@ 0x1000
2ffc2cdc:	f2ca 0502 	movt	r5, #40962	@ 0xa002
  uint32_t i;

  for (i = 0U; i < IRQ_GIC_LINE_COUNT; i++) {
    IRQTable[i] = (IRQHandler_t)NULL;
2ffc2ce0:	f641 1000 	movw	r0, #6400	@ 0x1900
2ffc2ce4:	f6c2 70fd 	movt	r0, #12285	@ 0x2ffd
2ffc2ce8:	f44f 627f 	mov.w	r2, #4080	@ 0xff0
2ffc2cec:	2100      	movs	r1, #0
2ffc2cee:	f008 ffb3 	bl	2ffcbc58 <memset>
2ffc2cf2:	682b      	ldr	r3, [r5, #0]
2ffc2cf4:	f023 0301 	bic.w	r3, r3, #1
2ffc2cf8:	602b      	str	r3, [r5, #0]
/** \brief Read the GIC's TYPER register.
* \return GICDistributor_Type::TYPER
*/
__STATIC_INLINE uint32_t GIC_DistributorInfo(void)
{
  return (GICDistributor->TYPER);
2ffc2cfa:	686b      	ldr	r3, [r5, #4]
* \param [in] IRQn The interrupt to be configured.
* \param [in] priority The priority for the interrupt, lower values denote higher priorities.
*/
__STATIC_INLINE void GIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  uint32_t mask = GICDistributor->IPRIORITYR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2cfc:	f8d5 2400 	ldr.w	r2, [r5, #1024]	@ 0x400
  //configuring all of the interrupts as Secure.

  //Disable interrupt forwarding
  GIC_DisableDistributor();
  //Get the maximum number of interrupts that the GIC supports
  num_irq = 32U * ((GIC_DistributorInfo() & 0x1FU) + 1U);
2ffc2d00:	f003 031f 	and.w	r3, r3, #31
2ffc2d04:	3301      	adds	r3, #1
  GICDistributor->IPRIORITYR[IRQn / 4U] = mask | ((priority & 0xFFUL) << ((IRQn % 4U) * 8U));
2ffc2d06:	f042 02ff 	orr.w	r2, r2, #255	@ 0xff
2ffc2d0a:	f8c5 2400 	str.w	r2, [r5, #1024]	@ 0x400
   To determine the number of priority bits implemented write 0xFF to an IPRIORITYR
   priority field and read back the value stored.*/
  GIC_SetPriority((IRQn_Type)0U, 0xFFU);
  priority_field = GIC_GetPriority((IRQn_Type)0U);

  for (i = 32U; i < num_irq; i++)
2ffc2d0e:	2b01      	cmp	r3, #1
  return (GICDistributor->IPRIORITYR[IRQn / 4U] >> ((IRQn % 4U) * 8U)) & 0xFFUL;
2ffc2d10:	f8d5 6400 	ldr.w	r6, [r5, #1024]	@ 0x400
  for (i = 32U; i < num_irq; i++)
2ffc2d14:	d04a      	beq.n	2ffc2dac <IRQ_Initialize+0xd8>
2ffc2d16:	015f      	lsls	r7, r3, #5
2ffc2d18:	2020      	movs	r0, #32
      //Disable the SPI interrupt
      GIC_DisableIRQ((IRQn_Type)i);
      //Set level-sensitive (and N-N model)
      GIC_SetConfiguration((IRQn_Type)i, 0U);
      //Set priority
      GIC_SetPriority((IRQn_Type)i, priority_field/2U);
2ffc2d1a:	f3c6 0646 	ubfx	r6, r6, #1, #7
  GICDistributor->ICENABLER[IRQn / 32U] = 1U << (IRQn % 32U);
2ffc2d1e:	2401      	movs	r4, #1
  icfgr &= (~(3U         << shift));
2ffc2d20:	f04f 0e03 	mov.w	lr, #3
  uint32_t mask = GICDistributor->IPRIORITYR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2d24:	f04f 0cff 	mov.w	ip, #255	@ 0xff
  uint32_t shift = (IRQn % 16U) << 1U;
2ffc2d28:	ea4f 0840 	mov.w	r8, r0, lsl #1
2ffc2d2c:	b283      	uxth	r3, r0
  GICDistributor->ICENABLER[IRQn / 32U] = 1U << (IRQn % 32U);
2ffc2d2e:	f003 091f 	and.w	r9, r3, #31
  uint32_t shift = (IRQn % 16U) << 1U;
2ffc2d32:	f008 081e 	and.w	r8, r8, #30
  uint32_t icfgr = GICDistributor->ICFGR[IRQn / 16U];
2ffc2d36:	0919      	lsrs	r1, r3, #4
  for (i = 32U; i < num_irq; i++)
2ffc2d38:	3001      	adds	r0, #1
  GICDistributor->ICENABLER[IRQn / 32U] = 1U << (IRQn % 32U);
2ffc2d3a:	095a      	lsrs	r2, r3, #5
  for (i = 32U; i < num_irq; i++)
2ffc2d3c:	4287      	cmp	r7, r0
  GICDistributor->ICENABLER[IRQn / 32U] = 1U << (IRQn % 32U);
2ffc2d3e:	f102 0260 	add.w	r2, r2, #96	@ 0x60
2ffc2d42:	ea4f 0181 	mov.w	r1, r1, lsl #2
2ffc2d46:	fa04 f909 	lsl.w	r9, r4, r9
2ffc2d4a:	f101 4120 	add.w	r1, r1, #2684354560	@ 0xa0000000
2ffc2d4e:	f845 9022 	str.w	r9, [r5, r2, lsl #2]
  uint32_t icfgr = GICDistributor->ICFGR[IRQn / 16U];
2ffc2d52:	f501 3104 	add.w	r1, r1, #135168	@ 0x21000
  uint32_t mask = GICDistributor->IPRIORITYR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2d56:	ea4f 0293 	mov.w	r2, r3, lsr #2
2ffc2d5a:	f003 0303 	and.w	r3, r3, #3
  icfgr &= (~(3U         << shift));
2ffc2d5e:	fa0e f808 	lsl.w	r8, lr, r8
2ffc2d62:	ea4f 0982 	mov.w	r9, r2, lsl #2
  uint32_t icfgr = GICDistributor->ICFGR[IRQn / 16U];
2ffc2d66:	f8d1 2c00 	ldr.w	r2, [r1, #3072]	@ 0xc00
  uint32_t mask = GICDistributor->IPRIORITYR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2d6a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
  icfgr &= (~(3U         << shift));
2ffc2d6e:	ea22 0808 	bic.w	r8, r2, r8
  GICDistributor->ICFGR[IRQn / 16U] = icfgr;
2ffc2d72:	f109 4220 	add.w	r2, r9, #2684354560	@ 0xa0000000
2ffc2d76:	f8c1 8c00 	str.w	r8, [r1, #3072]	@ 0xc00
  uint32_t mask = GICDistributor->IPRIORITYR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2d7a:	f502 3204 	add.w	r2, r2, #135168	@ 0x21000
2ffc2d7e:	fa0c f803 	lsl.w	r8, ip, r3
2ffc2d82:	f8d2 1400 	ldr.w	r1, [r2, #1024]	@ 0x400
  GICDistributor->IPRIORITYR[IRQn / 4U] = mask | ((priority & 0xFFUL) << ((IRQn % 4U) * 8U));
2ffc2d86:	fa06 f903 	lsl.w	r9, r6, r3
  uint32_t mask = GICDistributor->IPRIORITYR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2d8a:	ea21 0108 	bic.w	r1, r1, r8
  GICDistributor->IPRIORITYR[IRQn / 4U] = mask | ((priority & 0xFFUL) << ((IRQn % 4U) * 8U));
2ffc2d8e:	ea41 0109 	orr.w	r1, r1, r9
2ffc2d92:	f8c2 1400 	str.w	r1, [r2, #1024]	@ 0x400
  uint32_t mask = GICDistributor->ITARGETSR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2d96:	f8d2 1800 	ldr.w	r1, [r2, #2048]	@ 0x800
  GICDistributor->ITARGETSR[IRQn / 4U] = mask | ((cpu_target & 0xFFUL) << ((IRQn % 4U) * 8U));
2ffc2d9a:	fa04 f303 	lsl.w	r3, r4, r3
  uint32_t mask = GICDistributor->ITARGETSR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2d9e:	ea21 0108 	bic.w	r1, r1, r8
  GICDistributor->ITARGETSR[IRQn / 4U] = mask | ((cpu_target & 0xFFUL) << ((IRQn % 4U) * 8U));
2ffc2da2:	ea43 0301 	orr.w	r3, r3, r1
2ffc2da6:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800
  for (i = 32U; i < num_irq; i++)
2ffc2daa:	d1bd      	bne.n	2ffc2d28 <IRQ_Initialize+0x54>
  GICDistributor->CTLR |= 1U;
2ffc2dac:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
  GICInterface->CTLR &=~1U; //disable distributor
2ffc2db0:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
  GICDistributor->CTLR |= 1U;
2ffc2db4:	f2ca 0002 	movt	r0, #40962	@ 0xa002
  GICDistributor->ICENABLER[IRQn / 32U] = 1U << (IRQn % 32U);
2ffc2db8:	2501      	movs	r5, #1
  GICInterface->CTLR &=~1U; //disable distributor
2ffc2dba:	f2ca 0302 	movt	r3, #40962	@ 0xa002
  uint32_t mask = GICDistributor->IPRIORITYR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2dbe:	24ff      	movs	r4, #255	@ 0xff
  GICDistributor->CTLR |= 1U;
2ffc2dc0:	6802      	ldr	r2, [r0, #0]
   priority field and read back the value stored.*/
  GIC_SetPriority((IRQn_Type)0U, 0xFFU);
  priority_field = GIC_GetPriority((IRQn_Type)0U);

  //SGI and PPI
  for (i = 0U; i < 32U; i++)
2ffc2dc2:	2100      	movs	r1, #0
  icfgr &= (~(3U         << shift));
2ffc2dc4:	f04f 0e03 	mov.w	lr, #3
  GICDistributor->CTLR |= 1U;
2ffc2dc8:	432a      	orrs	r2, r5
2ffc2dca:	6002      	str	r2, [r0, #0]
  GICInterface->CTLR &=~1U; //disable distributor
2ffc2dcc:	681a      	ldr	r2, [r3, #0]
2ffc2dce:	f022 0201 	bic.w	r2, r2, #1
2ffc2dd2:	601a      	str	r2, [r3, #0]
  uint32_t mask = GICDistributor->IPRIORITYR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2dd4:	f8d0 3400 	ldr.w	r3, [r0, #1024]	@ 0x400
  GICDistributor->IPRIORITYR[IRQn / 4U] = mask | ((priority & 0xFFUL) << ((IRQn % 4U) * 8U));
2ffc2dd8:	4323      	orrs	r3, r4
2ffc2dda:	f8c0 3400 	str.w	r3, [r0, #1024]	@ 0x400
  return (GICDistributor->IPRIORITYR[IRQn / 4U] >> ((IRQn % 4U) * 8U)) & 0xFFUL;
2ffc2dde:	f8d0 3400 	ldr.w	r3, [r0, #1024]	@ 0x400
      GIC_SetConfiguration((IRQn_Type)i, 0U);
    }
    //Disable SGI and PPI interrupts
    GIC_DisableIRQ((IRQn_Type)i);
    //Set priority
    GIC_SetPriority((IRQn_Type)i, priority_field/2U);
2ffc2de2:	f3c3 0c46 	ubfx	ip, r3, #1, #7
    if(i > 15U) {
2ffc2de6:	e006      	b.n	2ffc2df6 <IRQ_Initialize+0x122>
2ffc2de8:	290f      	cmp	r1, #15
  uint32_t icfgr = GICDistributor->ICFGR[IRQn / 16U];
2ffc2dea:	bf82      	ittt	hi
2ffc2dec:	f8d0 3c04 	ldrhi.w	r3, [r0, #3076]	@ 0xc04
  icfgr &= (~(3U         << shift));
2ffc2df0:	43bb      	bichi	r3, r7
  GICDistributor->ICFGR[IRQn / 16U] = icfgr;
2ffc2df2:	f8c0 3c04 	strhi.w	r3, [r0, #3076]	@ 0xc04
  GICDistributor->ICENABLER[IRQn / 32U] = 1U << (IRQn % 32U);
2ffc2df6:	fa05 f201 	lsl.w	r2, r5, r1
2ffc2dfa:	b28b      	uxth	r3, r1
2ffc2dfc:	f8c0 2180 	str.w	r2, [r0, #384]	@ 0x180
  uint32_t mask = GICDistributor->IPRIORITYR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2e00:	f003 0203 	and.w	r2, r3, #3
2ffc2e04:	089b      	lsrs	r3, r3, #2
  for (i = 0U; i < 32U; i++)
2ffc2e06:	3101      	adds	r1, #1
  uint32_t mask = GICDistributor->IPRIORITYR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2e08:	00d2      	lsls	r2, r2, #3
  for (i = 0U; i < 32U; i++)
2ffc2e0a:	2920      	cmp	r1, #32
2ffc2e0c:	ea4f 0383 	mov.w	r3, r3, lsl #2
  uint32_t mask = GICDistributor->IPRIORITYR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2e10:	fa04 f802 	lsl.w	r8, r4, r2
2ffc2e14:	f103 4320 	add.w	r3, r3, #2684354560	@ 0xa0000000
  uint32_t shift = (IRQn % 16U) << 1U;
2ffc2e18:	ea4f 0741 	mov.w	r7, r1, lsl #1
2ffc2e1c:	f503 3304 	add.w	r3, r3, #135168	@ 0x21000
  GICDistributor->IPRIORITYR[IRQn / 4U] = mask | ((priority & 0xFFUL) << ((IRQn % 4U) * 8U));
2ffc2e20:	fa0c f202 	lsl.w	r2, ip, r2
  uint32_t shift = (IRQn % 16U) << 1U;
2ffc2e24:	f007 071e 	and.w	r7, r7, #30
  uint32_t mask = GICDistributor->IPRIORITYR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2e28:	f8d3 6400 	ldr.w	r6, [r3, #1024]	@ 0x400
  icfgr &= (~(3U         << shift));
2ffc2e2c:	fa0e f707 	lsl.w	r7, lr, r7
  uint32_t mask = GICDistributor->IPRIORITYR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2e30:	ea26 0608 	bic.w	r6, r6, r8
  GICDistributor->IPRIORITYR[IRQn / 4U] = mask | ((priority & 0xFFUL) << ((IRQn % 4U) * 8U));
2ffc2e34:	ea42 0206 	orr.w	r2, r2, r6
2ffc2e38:	f8c3 2400 	str.w	r2, [r3, #1024]	@ 0x400
  for (i = 0U; i < 32U; i++)
2ffc2e3c:	d1d4      	bne.n	2ffc2de8 <IRQ_Initialize+0x114>
  GICInterface->CTLR |= 1U; //enable interface
2ffc2e3e:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
  GICInterface->BPR = binary_point & 7U; //set binary point
2ffc2e42:	2000      	movs	r0, #0
  GICInterface->CTLR |= 1U; //enable interface
2ffc2e44:	f2ca 0302 	movt	r3, #40962	@ 0xa002
2ffc2e48:	681a      	ldr	r2, [r3, #0]
2ffc2e4a:	f042 0201 	orr.w	r2, r2, #1
2ffc2e4e:	601a      	str	r2, [r3, #0]
  GICInterface->BPR = binary_point & 7U; //set binary point
2ffc2e50:	6098      	str	r0, [r3, #8]
  GICInterface->PMR = priority & 0xFFUL; //set priority mask
2ffc2e52:	605c      	str	r4, [r3, #4]
  }
  GIC_Enable();
  return (0);
}
2ffc2e54:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

2ffc2e58 <IRQ_SetHandler>:

/// Register interrupt handler.
__WEAK int32_t IRQ_SetHandler (IRQn_ID_t irqn, IRQHandler_t handler) {
  int32_t status;

  if ((irqn >= 0) && (irqn < (IRQn_ID_t)IRQ_GIC_LINE_COUNT)) {
2ffc2e58:	f5b0 7f7f 	cmp.w	r0, #1020	@ 0x3fc
__WEAK int32_t IRQ_SetHandler (IRQn_ID_t irqn, IRQHandler_t handler) {
2ffc2e5c:	4603      	mov	r3, r0
    IRQTable[irqn] = handler;
2ffc2e5e:	bf3d      	ittte	cc
2ffc2e60:	f641 1200 	movwcc	r2, #6400	@ 0x1900
    status =  0;
2ffc2e64:	2000      	movcc	r0, #0
    IRQTable[irqn] = handler;
2ffc2e66:	f6c2 72fd 	movtcc	r2, #12285	@ 0x2ffd
  } else {
    status = -1;
2ffc2e6a:	f04f 30ff 	movcs.w	r0, #4294967295	@ 0xffffffff
    IRQTable[irqn] = handler;
2ffc2e6e:	bf38      	it	cc
2ffc2e70:	f842 1023 	strcc.w	r1, [r2, r3, lsl #2]
  }

  return (status);
}
2ffc2e74:	4770      	bx	lr
2ffc2e76:	bf00      	nop

2ffc2e78 <IRQ_GetHandler>:
/// Get the registered interrupt handler.
__WEAK IRQHandler_t IRQ_GetHandler (IRQn_ID_t irqn) {
  IRQHandler_t h;

  // Ignore CPUID field (software generated interrupts)
  irqn &= 0x3FFU;
2ffc2e78:	f3c0 0009 	ubfx	r0, r0, #0, #10

  if ((irqn >= 0) && (irqn < (IRQn_ID_t)IRQ_GIC_LINE_COUNT)) {
2ffc2e7c:	f5b0 7f7f 	cmp.w	r0, #1020	@ 0x3fc
    h = IRQTable[irqn];
2ffc2e80:	bfbd      	ittte	lt
2ffc2e82:	f641 1300 	movwlt	r3, #6400	@ 0x1900
2ffc2e86:	f6c2 73fd 	movtlt	r3, #12285	@ 0x2ffd
2ffc2e8a:	f853 0020 	ldrlt.w	r0, [r3, r0, lsl #2]
  } else {
    h = (IRQHandler_t)0;
2ffc2e8e:	2000      	movge	r0, #0
  }

  return (h);
}
2ffc2e90:	4770      	bx	lr
2ffc2e92:	bf00      	nop

2ffc2e94 <IRQ_Enable>:

/// Enable interrupt.
__WEAK int32_t IRQ_Enable (IRQn_ID_t irqn) {
  int32_t status;

  if ((irqn >= 0) && (irqn < (IRQn_ID_t)IRQ_GIC_LINE_COUNT)) {
2ffc2e94:	f5b0 7f7f 	cmp.w	r0, #1020	@ 0x3fc
2ffc2e98:	d20e      	bcs.n	2ffc2eb8 <IRQ_Enable+0x24>
    GIC_EnableIRQ ((IRQn_Type)irqn);
2ffc2e9a:	b280      	uxth	r0, r0
  GICDistributor->ISENABLER[IRQn / 32U] = 1U << (IRQn % 32U);
2ffc2e9c:	2301      	movs	r3, #1
2ffc2e9e:	f000 011f 	and.w	r1, r0, #31
2ffc2ea2:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
2ffc2ea6:	0940      	lsrs	r0, r0, #5
2ffc2ea8:	f2ca 0202 	movt	r2, #40962	@ 0xa002
2ffc2eac:	3040      	adds	r0, #64	@ 0x40
2ffc2eae:	408b      	lsls	r3, r1
2ffc2eb0:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
    status = 0;
2ffc2eb4:	2000      	movs	r0, #0
2ffc2eb6:	4770      	bx	lr
  } else {
    status = -1;
2ffc2eb8:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  }

  return (status);
}
2ffc2ebc:	4770      	bx	lr
2ffc2ebe:	bf00      	nop

2ffc2ec0 <IRQ_GetActiveIRQ>:
  return GICInterface->HPPIR; 
2ffc2ec0:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
2ffc2ec4:	f2ca 0302 	movt	r3, #40962	@ 0xa002
2ffc2ec8:	699a      	ldr	r2, [r3, #24]
  return (IRQn_Type)(GICInterface->IAR);
2ffc2eca:	68da      	ldr	r2, [r3, #12]
2ffc2ecc:	b290      	uxth	r0, r2
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE  void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
2ffc2ece:	f3bf 8f4f 	dsb	sy
  /* If the ID is 0 or 0x3FE or 0x3FF, then the GIC CPU interface may be locked-up */
  /* so unlock it, otherwise service the interrupt as normal.                      */
  /* Special IDs 1020=0x3FC and 1021=0x3FD are reserved values in GICv1 and GICv2  */
  /* so will not occur here.                                                       */

  if ((irqn == 0) || (irqn >= 0x3FE)) {
2ffc2ed2:	f240 33fd 	movw	r3, #1021	@ 0x3fd
2ffc2ed6:	4298      	cmp	r0, r3
2ffc2ed8:	bfd4      	ite	le
2ffc2eda:	2300      	movle	r3, #0
2ffc2edc:	2301      	movgt	r3, #1
2ffc2ede:	2800      	cmp	r0, #0
2ffc2ee0:	bf08      	it	eq
2ffc2ee2:	f043 0301 	orreq.w	r3, r3, #1
2ffc2ee6:	b1b3      	cbz	r3, 2ffc2f16 <IRQ_GetActiveIRQ+0x56>
  return (GICDistributor->IPRIORITYR[IRQn / 4U] >> ((IRQn % 4U) * 8U)) & 0xFFUL;
2ffc2ee8:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
2ffc2eec:	f2ca 0102 	movt	r1, #40962	@ 0xa002
__WEAK IRQn_ID_t IRQ_GetActiveIRQ (void) {
2ffc2ef0:	b410      	push	{r4}
2ffc2ef2:	f8d1 4400 	ldr.w	r4, [r1, #1024]	@ 0x400
  uint32_t mask = GICDistributor->IPRIORITYR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2ef6:	f8d1 3400 	ldr.w	r3, [r1, #1024]	@ 0x400
  return (GICDistributor->IPRIORITYR[IRQn / 4U] >> ((IRQn % 4U) * 8U)) & 0xFFUL;
2ffc2efa:	fa5f fc84 	uxtb.w	ip, r4
  uint32_t mask = GICDistributor->IPRIORITYR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2efe:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
  GICDistributor->IPRIORITYR[IRQn / 4U] = mask | ((priority & 0xFFUL) << ((IRQn % 4U) * 8U));
2ffc2f02:	ea43 030c 	orr.w	r3, r3, ip
2ffc2f06:	f8c1 3400 	str.w	r3, [r1, #1024]	@ 0x400
2ffc2f0a:	f3bf 8f4f 	dsb	sy
    prio = GIC_GetPriority((IRQn_Type)0);
    GIC_SetPriority ((IRQn_Type)0, prio);

    __DSB();

    if ((irqn == 0U) && ((GIC_GetIRQStatus ((IRQn_Type)irqn) & 1U) != 0U) && (IRQ_ID0 == 0U)) {
2ffc2f0e:	b118      	cbz	r0, 2ffc2f18 <IRQ_GetActiveIRQ+0x58>
    }
    /* End of Workaround GIC 390 errata 733075 */
  }

  return (irqn);
}
2ffc2f10:	f85d 4b04 	ldr.w	r4, [sp], #4
2ffc2f14:	4770      	bx	lr
2ffc2f16:	4770      	bx	lr
  active = ((GICDistributor->ISACTIVER[IRQn / 32U])  >> (IRQn % 32U)) & 1UL;
2ffc2f18:	0942      	lsrs	r2, r0, #5
2ffc2f1a:	f000 011f 	and.w	r1, r0, #31
2ffc2f1e:	0093      	lsls	r3, r2, #2
2ffc2f20:	f103 4320 	add.w	r3, r3, #2684354560	@ 0xa0000000
2ffc2f24:	f503 3304 	add.w	r3, r3, #135168	@ 0x21000
2ffc2f28:	f8d3 2300 	ldr.w	r2, [r3, #768]	@ 0x300
  pending = ((GICDistributor->ISPENDR[IRQn / 32U]) >> (IRQn % 32U)) & 1UL;
2ffc2f2c:	f8d3 3200 	ldr.w	r3, [r3, #512]	@ 0x200
2ffc2f30:	40cb      	lsrs	r3, r1
    if ((irqn == 0U) && ((GIC_GetIRQStatus ((IRQn_Type)irqn) & 1U) != 0U) && (IRQ_ID0 == 0U)) {
2ffc2f32:	07db      	lsls	r3, r3, #31
2ffc2f34:	d5ec      	bpl.n	2ffc2f10 <IRQ_GetActiveIRQ+0x50>
2ffc2f36:	f641 1300 	movw	r3, #6400	@ 0x1900
2ffc2f3a:	f6c2 73fd 	movt	r3, #12285	@ 0x2ffd
2ffc2f3e:	f8d3 2ff0 	ldr.w	r2, [r3, #4080]	@ 0xff0
2ffc2f42:	2a00      	cmp	r2, #0
2ffc2f44:	d1e4      	bne.n	2ffc2f10 <IRQ_GetActiveIRQ+0x50>
      IRQ_ID0 = 1U;
2ffc2f46:	2201      	movs	r2, #1
2ffc2f48:	f8c3 2ff0 	str.w	r2, [r3, #4080]	@ 0xff0
  return (irqn);
2ffc2f4c:	e7e0      	b.n	2ffc2f10 <IRQ_GetActiveIRQ+0x50>
2ffc2f4e:	bf00      	nop

2ffc2f50 <IRQ_EndOfInterrupt>:
/// Signal end of interrupt processing.
__WEAK int32_t IRQ_EndOfInterrupt (IRQn_ID_t irqn) {
  int32_t status;
  IRQn_Type irq = (IRQn_Type)irqn;

  irqn &= 0x3FFU;
2ffc2f50:	f3c0 0309 	ubfx	r3, r0, #0, #10

  if ((irqn >= 0) && (irqn < (IRQn_ID_t)IRQ_GIC_LINE_COUNT)) {
2ffc2f54:	f5b3 7f7f 	cmp.w	r3, #1020	@ 0x3fc
2ffc2f58:	da0e      	bge.n	2ffc2f78 <IRQ_EndOfInterrupt+0x28>
  GICInterface->EOIR = IRQn;
2ffc2f5a:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
2ffc2f5e:	b280      	uxth	r0, r0
2ffc2f60:	f2ca 0202 	movt	r2, #40962	@ 0xa002
2ffc2f64:	6110      	str	r0, [r2, #16]
    GIC_EndInterrupt (irq);

    if (irqn == 0) {
2ffc2f66:	b92b      	cbnz	r3, 2ffc2f74 <IRQ_EndOfInterrupt+0x24>
      IRQ_ID0 = 0U;
2ffc2f68:	f641 1200 	movw	r2, #6400	@ 0x1900
2ffc2f6c:	f6c2 72fd 	movt	r2, #12285	@ 0x2ffd
2ffc2f70:	f8c2 3ff0 	str.w	r3, [r2, #4080]	@ 0xff0
    }

    status = 0;
2ffc2f74:	2000      	movs	r0, #0
2ffc2f76:	4770      	bx	lr
  } else {
    status = -1;
2ffc2f78:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  }

  return (status);
}
2ffc2f7c:	4770      	bx	lr
2ffc2f7e:	bf00      	nop

2ffc2f80 <IRQ_ClearPending>:

/// Clear interrupt pending flag.
__WEAK int32_t IRQ_ClearPending (IRQn_ID_t irqn) {
  int32_t status;

  if ((irqn >= 16) && (irqn < (IRQn_ID_t)IRQ_GIC_LINE_COUNT)) {
2ffc2f80:	f1a0 0310 	sub.w	r3, r0, #16
2ffc2f84:	f5b3 7f7b 	cmp.w	r3, #1004	@ 0x3ec
2ffc2f88:	d20e      	bcs.n	2ffc2fa8 <IRQ_ClearPending+0x28>
    GIC_ClearPendingIRQ ((IRQn_Type)irqn);
2ffc2f8a:	b280      	uxth	r0, r0
    GICDistributor->ICPENDR[IRQn / 32U] = 1U << (IRQn % 32U);
2ffc2f8c:	2301      	movs	r3, #1
2ffc2f8e:	f000 011f 	and.w	r1, r0, #31
2ffc2f92:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
2ffc2f96:	0940      	lsrs	r0, r0, #5
2ffc2f98:	f2ca 0202 	movt	r2, #40962	@ 0xa002
2ffc2f9c:	30a0      	adds	r0, #160	@ 0xa0
2ffc2f9e:	408b      	lsls	r3, r1
2ffc2fa0:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
    status = 0;
2ffc2fa4:	2000      	movs	r0, #0
2ffc2fa6:	4770      	bx	lr
  } else {
    status = -1;
2ffc2fa8:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  }

  return (status);
}
2ffc2fac:	4770      	bx	lr
2ffc2fae:	bf00      	nop

2ffc2fb0 <IRQ_SetPriority>:

/// Set interrupt priority value.
__WEAK int32_t IRQ_SetPriority (IRQn_ID_t irqn, uint32_t priority) {
  int32_t status;

  if ((irqn >= 0) && (irqn < (IRQn_ID_t)IRQ_GIC_LINE_COUNT)) {
2ffc2fb0:	f5b0 7f7f 	cmp.w	r0, #1020	@ 0x3fc
2ffc2fb4:	d218      	bcs.n	2ffc2fe8 <IRQ_SetPriority+0x38>
    GIC_SetPriority ((IRQn_Type)irqn, priority);
2ffc2fb6:	b280      	uxth	r0, r0
  GICDistributor->IPRIORITYR[IRQn / 4U] = mask | ((priority & 0xFFUL) << ((IRQn % 4U) * 8U));
2ffc2fb8:	b2c9      	uxtb	r1, r1
  uint32_t mask = GICDistributor->IPRIORITYR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2fba:	f000 0203 	and.w	r2, r0, #3
2ffc2fbe:	f04f 0cff 	mov.w	ip, #255	@ 0xff
2ffc2fc2:	0883      	lsrs	r3, r0, #2
    status = 0;
2ffc2fc4:	2000      	movs	r0, #0
2ffc2fc6:	00d2      	lsls	r2, r2, #3
2ffc2fc8:	009b      	lsls	r3, r3, #2
2ffc2fca:	fa0c fc02 	lsl.w	ip, ip, r2
2ffc2fce:	f103 4320 	add.w	r3, r3, #2684354560	@ 0xa0000000
  GICDistributor->IPRIORITYR[IRQn / 4U] = mask | ((priority & 0xFFUL) << ((IRQn % 4U) * 8U));
2ffc2fd2:	4091      	lsls	r1, r2
2ffc2fd4:	f503 3304 	add.w	r3, r3, #135168	@ 0x21000
  uint32_t mask = GICDistributor->IPRIORITYR[IRQn / 4U] & ~(0xFFUL << ((IRQn % 4U) * 8U));
2ffc2fd8:	f8d3 2400 	ldr.w	r2, [r3, #1024]	@ 0x400
2ffc2fdc:	ea22 020c 	bic.w	r2, r2, ip
  GICDistributor->IPRIORITYR[IRQn / 4U] = mask | ((priority & 0xFFUL) << ((IRQn % 4U) * 8U));
2ffc2fe0:	430a      	orrs	r2, r1
2ffc2fe2:	f8c3 2400 	str.w	r2, [r3, #1024]	@ 0x400
}
2ffc2fe6:	4770      	bx	lr
  } else {
    status = -1;
2ffc2fe8:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  }

  return (status);
}
2ffc2fec:	4770      	bx	lr
2ffc2fee:	bf00      	nop

2ffc2ff0 <RESERVED_IRQHandler>:
void __attribute__ ((weak)) RESERVED_IRQHandler(void) {}
2ffc2ff0:	4770      	bx	lr
2ffc2ff2:	bf00      	nop

2ffc2ff4 <WWDG1_RST_IRQHandler>:
void __attribute__ ((weak)) WWDG1_RST_IRQHandler(void) {}
2ffc2ff4:	4770      	bx	lr
2ffc2ff6:	bf00      	nop

2ffc2ff8 <SGI0_IRQHandler>:
void __attribute__ ((weak)) SGI0_IRQHandler(void) {}
2ffc2ff8:	4770      	bx	lr
2ffc2ffa:	bf00      	nop

2ffc2ffc <SGI1_IRQHandler>:
void __attribute__ ((weak)) SGI1_IRQHandler(void) {}
2ffc2ffc:	4770      	bx	lr
2ffc2ffe:	bf00      	nop

2ffc3000 <SGI2_IRQHandler>:
void __attribute__ ((weak)) SGI2_IRQHandler(void) {}
2ffc3000:	4770      	bx	lr
2ffc3002:	bf00      	nop

2ffc3004 <SGI3_IRQHandler>:
void __attribute__ ((weak)) SGI3_IRQHandler(void) {}
2ffc3004:	4770      	bx	lr
2ffc3006:	bf00      	nop

2ffc3008 <SGI4_IRQHandler>:
void __attribute__ ((weak)) SGI4_IRQHandler(void) {}
2ffc3008:	4770      	bx	lr
2ffc300a:	bf00      	nop

2ffc300c <SGI5_IRQHandler>:
void __attribute__ ((weak)) SGI5_IRQHandler(void) {}
2ffc300c:	4770      	bx	lr
2ffc300e:	bf00      	nop

2ffc3010 <SGI6_IRQHandler>:
void __attribute__ ((weak)) SGI6_IRQHandler(void) {}
2ffc3010:	4770      	bx	lr
2ffc3012:	bf00      	nop

2ffc3014 <SGI7_IRQHandler>:
void __attribute__ ((weak)) SGI7_IRQHandler(void) {}
2ffc3014:	4770      	bx	lr
2ffc3016:	bf00      	nop

2ffc3018 <SGI8_IRQHandler>:
void __attribute__ ((weak)) SGI8_IRQHandler(void) {}
2ffc3018:	4770      	bx	lr
2ffc301a:	bf00      	nop

2ffc301c <SGI9_IRQHandler>:
void __attribute__ ((weak)) SGI9_IRQHandler(void) {}
2ffc301c:	4770      	bx	lr
2ffc301e:	bf00      	nop

2ffc3020 <SGI10_IRQHandler>:
void __attribute__ ((weak)) SGI10_IRQHandler(void) {}
2ffc3020:	4770      	bx	lr
2ffc3022:	bf00      	nop

2ffc3024 <SGI11_IRQHandler>:
void __attribute__ ((weak)) SGI11_IRQHandler(void) {}
2ffc3024:	4770      	bx	lr
2ffc3026:	bf00      	nop

2ffc3028 <SGI12_IRQHandler>:
void __attribute__ ((weak)) SGI12_IRQHandler(void) {}
2ffc3028:	4770      	bx	lr
2ffc302a:	bf00      	nop

2ffc302c <SGI13_IRQHandler>:
void __attribute__ ((weak)) SGI13_IRQHandler(void) {}
2ffc302c:	4770      	bx	lr
2ffc302e:	bf00      	nop

2ffc3030 <SGI14_IRQHandler>:
void __attribute__ ((weak)) SGI14_IRQHandler(void) {}
2ffc3030:	4770      	bx	lr
2ffc3032:	bf00      	nop

2ffc3034 <SGI15_IRQHandler>:
void __attribute__ ((weak)) SGI15_IRQHandler(void) {}
2ffc3034:	4770      	bx	lr
2ffc3036:	bf00      	nop

2ffc3038 <VirtualMaintenanceInterrupt_IRQHandler>:
void __attribute__ ((weak)) VirtualMaintenanceInterrupt_IRQHandler(void) {}
2ffc3038:	4770      	bx	lr
2ffc303a:	bf00      	nop

2ffc303c <HypervisorTimer_IRQHandler>:
void __attribute__ ((weak)) HypervisorTimer_IRQHandler(void) {}
2ffc303c:	4770      	bx	lr
2ffc303e:	bf00      	nop

2ffc3040 <VirtualTimer_IRQHandler>:
void __attribute__ ((weak)) VirtualTimer_IRQHandler(void) {}
2ffc3040:	4770      	bx	lr
2ffc3042:	bf00      	nop

2ffc3044 <Legacy_nFIQ_IRQHandler>:
void __attribute__ ((weak)) Legacy_nFIQ_IRQHandler(void) {}
2ffc3044:	4770      	bx	lr
2ffc3046:	bf00      	nop

2ffc3048 <NonSecurePhysicalTimer_IRQHandler>:
void __attribute__ ((weak)) NonSecurePhysicalTimer_IRQHandler(void) {}
2ffc3048:	4770      	bx	lr
2ffc304a:	bf00      	nop

2ffc304c <Legacy_nIRQ_IRQHandler>:
void __attribute__ ((weak)) Legacy_nIRQ_IRQHandler(void) {}
2ffc304c:	4770      	bx	lr
2ffc304e:	bf00      	nop

2ffc3050 <WWDG1_IRQHandler>:
void __attribute__ ((weak)) WWDG1_IRQHandler(void) {}
2ffc3050:	4770      	bx	lr
2ffc3052:	bf00      	nop

2ffc3054 <PVD_AVD_IRQHandler>:
void __attribute__ ((weak)) PVD_AVD_IRQHandler(void) {}
2ffc3054:	4770      	bx	lr
2ffc3056:	bf00      	nop

2ffc3058 <TAMP_IRQHandler>:
void __attribute__ ((weak)) TAMP_IRQHandler (void) {}
2ffc3058:	4770      	bx	lr
2ffc305a:	bf00      	nop

2ffc305c <RTC_WKUP_ALARM_IRQHandler>:
void __attribute__ ((weak)) RTC_WKUP_ALARM_IRQHandler (void) {}
2ffc305c:	4770      	bx	lr
2ffc305e:	bf00      	nop

2ffc3060 <RCC_IRQHandler>:
void __attribute__ ((weak)) RCC_IRQHandler(void) {}
2ffc3060:	4770      	bx	lr
2ffc3062:	bf00      	nop

2ffc3064 <EXTI0_IRQHandler>:
void __attribute__ ((weak)) EXTI0_IRQHandler(void) {}
2ffc3064:	4770      	bx	lr
2ffc3066:	bf00      	nop

2ffc3068 <EXTI1_IRQHandler>:
void __attribute__ ((weak)) EXTI1_IRQHandler(void) {}
2ffc3068:	4770      	bx	lr
2ffc306a:	bf00      	nop

2ffc306c <EXTI2_IRQHandler>:
void __attribute__ ((weak)) EXTI2_IRQHandler(void) {}
2ffc306c:	4770      	bx	lr
2ffc306e:	bf00      	nop

2ffc3070 <EXTI3_IRQHandler>:
void __attribute__ ((weak)) EXTI3_IRQHandler(void) {}
2ffc3070:	4770      	bx	lr
2ffc3072:	bf00      	nop

2ffc3074 <EXTI4_IRQHandler>:
void __attribute__ ((weak)) EXTI4_IRQHandler(void) {}
2ffc3074:	4770      	bx	lr
2ffc3076:	bf00      	nop

2ffc3078 <DMA1_Stream0_IRQHandler>:
void __attribute__ ((weak)) DMA1_Stream0_IRQHandler(void) {}
2ffc3078:	4770      	bx	lr
2ffc307a:	bf00      	nop

2ffc307c <DMA1_Stream1_IRQHandler>:
void __attribute__ ((weak)) DMA1_Stream1_IRQHandler (void) {}
2ffc307c:	4770      	bx	lr
2ffc307e:	bf00      	nop

2ffc3080 <DMA1_Stream2_IRQHandler>:
void __attribute__ ((weak)) DMA1_Stream2_IRQHandler (void) {}
2ffc3080:	4770      	bx	lr
2ffc3082:	bf00      	nop

2ffc3084 <DMA1_Stream3_IRQHandler>:
void __attribute__ ((weak)) DMA1_Stream3_IRQHandler (void) {}
2ffc3084:	4770      	bx	lr
2ffc3086:	bf00      	nop

2ffc3088 <DMA1_Stream4_IRQHandler>:
void __attribute__ ((weak)) DMA1_Stream4_IRQHandler (void) {}
2ffc3088:	4770      	bx	lr
2ffc308a:	bf00      	nop

2ffc308c <DMA1_Stream5_IRQHandler>:
void __attribute__ ((weak)) DMA1_Stream5_IRQHandler (void) {}
2ffc308c:	4770      	bx	lr
2ffc308e:	bf00      	nop

2ffc3090 <DMA1_Stream6_IRQHandler>:
void __attribute__ ((weak)) DMA1_Stream6_IRQHandler (void) {}
2ffc3090:	4770      	bx	lr
2ffc3092:	bf00      	nop

2ffc3094 <ADC1_IRQHandler>:
void __attribute__ ((weak)) ADC1_IRQHandler(void) {}
2ffc3094:	4770      	bx	lr
2ffc3096:	bf00      	nop

2ffc3098 <ADC2_IRQHandler>:
void __attribute__ ((weak)) ADC2_IRQHandler(void) {}
2ffc3098:	4770      	bx	lr
2ffc309a:	bf00      	nop

2ffc309c <FDCAN1_IT0_IRQHandler>:
void __attribute__ ((weak)) FDCAN1_IT0_IRQHandler(void) {}
2ffc309c:	4770      	bx	lr
2ffc309e:	bf00      	nop

2ffc30a0 <FDCAN2_IT0_IRQHandler>:
void __attribute__ ((weak)) FDCAN2_IT0_IRQHandler(void) {}
2ffc30a0:	4770      	bx	lr
2ffc30a2:	bf00      	nop

2ffc30a4 <FDCAN1_IT1_IRQHandler>:
void __attribute__ ((weak)) FDCAN1_IT1_IRQHandler(void) {}
2ffc30a4:	4770      	bx	lr
2ffc30a6:	bf00      	nop

2ffc30a8 <FDCAN2_IT1_IRQHandler>:
void __attribute__ ((weak)) FDCAN2_IT1_IRQHandler(void) {}
2ffc30a8:	4770      	bx	lr
2ffc30aa:	bf00      	nop

2ffc30ac <FDCAN_CAL_IRQHandler>:
void __attribute__ ((weak)) FDCAN_CAL_IRQHandler(void) {}
2ffc30ac:	4770      	bx	lr
2ffc30ae:	bf00      	nop

2ffc30b0 <EXTI5_IRQHandler>:
void __attribute__ ((weak)) EXTI5_IRQHandler(void) {}
2ffc30b0:	4770      	bx	lr
2ffc30b2:	bf00      	nop

2ffc30b4 <TIM1_BRK_TIM9_IRQHandler>:
void __attribute__ ((weak)) TIM1_BRK_TIM9_IRQHandler(void) {}
2ffc30b4:	4770      	bx	lr
2ffc30b6:	bf00      	nop

2ffc30b8 <TIM1_UP_TIM10_IRQHandler>:
void __attribute__ ((weak)) TIM1_UP_TIM10_IRQHandler(void) {}
2ffc30b8:	4770      	bx	lr
2ffc30ba:	bf00      	nop

2ffc30bc <TIM1_TRG_COM_TIM11_IRQHandler>:
void __attribute__ ((weak)) TIM1_TRG_COM_TIM11_IRQHandler (void) {}
2ffc30bc:	4770      	bx	lr
2ffc30be:	bf00      	nop

2ffc30c0 <TIM1_CC_IRQHandler>:
void __attribute__ ((weak)) TIM1_CC_IRQHandler(void) {}
2ffc30c0:	4770      	bx	lr
2ffc30c2:	bf00      	nop

2ffc30c4 <TIM2_IRQHandler>:
void __attribute__ ((weak)) TIM2_IRQHandler (void) {}
2ffc30c4:	4770      	bx	lr
2ffc30c6:	bf00      	nop

2ffc30c8 <TIM3_IRQHandler>:
void __attribute__ ((weak)) TIM3_IRQHandler (void) {}
2ffc30c8:	4770      	bx	lr
2ffc30ca:	bf00      	nop

2ffc30cc <TIM4_IRQHandler>:
void __attribute__ ((weak)) TIM4_IRQHandler (void) {}
2ffc30cc:	4770      	bx	lr
2ffc30ce:	bf00      	nop

2ffc30d0 <I2C1_EV_IRQHandler>:
void __attribute__ ((weak)) I2C1_EV_IRQHandler(void) {}
2ffc30d0:	4770      	bx	lr
2ffc30d2:	bf00      	nop

2ffc30d4 <I2C1_ER_IRQHandler>:
void __attribute__ ((weak)) I2C1_ER_IRQHandler(void) {}
2ffc30d4:	4770      	bx	lr
2ffc30d6:	bf00      	nop

2ffc30d8 <I2C2_EV_IRQHandler>:
void __attribute__ ((weak)) I2C2_EV_IRQHandler(void) {}
2ffc30d8:	4770      	bx	lr
2ffc30da:	bf00      	nop

2ffc30dc <I2C2_ER_IRQHandler>:
void __attribute__ ((weak)) I2C2_ER_IRQHandler(void) {}
2ffc30dc:	4770      	bx	lr
2ffc30de:	bf00      	nop

2ffc30e0 <SPI1_IRQHandler>:
void __attribute__ ((weak)) SPI1_IRQHandler (void) {}
2ffc30e0:	4770      	bx	lr
2ffc30e2:	bf00      	nop

2ffc30e4 <SPI2_IRQHandler>:
void __attribute__ ((weak)) SPI2_IRQHandler (void) {}
2ffc30e4:	4770      	bx	lr
2ffc30e6:	bf00      	nop

2ffc30e8 <USART1_IRQHandler>:
void __attribute__ ((weak)) USART1_IRQHandler (void) {}
2ffc30e8:	4770      	bx	lr
2ffc30ea:	bf00      	nop

2ffc30ec <USART2_IRQHandler>:
void __attribute__ ((weak)) USART2_IRQHandler (void) {}
2ffc30ec:	4770      	bx	lr
2ffc30ee:	bf00      	nop

2ffc30f0 <USART3_IRQHandler>:
void __attribute__ ((weak)) USART3_IRQHandler (void) {}
2ffc30f0:	4770      	bx	lr
2ffc30f2:	bf00      	nop

2ffc30f4 <EXTI10_IRQHandler>:
void __attribute__ ((weak)) EXTI10_IRQHandler(void) {}
2ffc30f4:	4770      	bx	lr
2ffc30f6:	bf00      	nop

2ffc30f8 <RTC_Alarm_IRQHandler>:
void __attribute__ ((weak)) RTC_Alarm_IRQHandler(void) {}
2ffc30f8:	4770      	bx	lr
2ffc30fa:	bf00      	nop

2ffc30fc <EXTI11_IRQHandler>:
void __attribute__ ((weak)) EXTI11_IRQHandler(void) {}
2ffc30fc:	4770      	bx	lr
2ffc30fe:	bf00      	nop

2ffc3100 <TIM8_BRK_IRQHandler>:
void __attribute__ ((weak)) TIM8_BRK_IRQHandler(void) {}
2ffc3100:	4770      	bx	lr
2ffc3102:	bf00      	nop

2ffc3104 <TIM8_UP_IRQHandler>:
void __attribute__ ((weak)) TIM8_UP_IRQHandler(void) {}
2ffc3104:	4770      	bx	lr
2ffc3106:	bf00      	nop

2ffc3108 <TIM8_TRG_COM_IRQHandler>:
void __attribute__ ((weak)) TIM8_TRG_COM_IRQHandler(void) {}
2ffc3108:	4770      	bx	lr
2ffc310a:	bf00      	nop

2ffc310c <TIM8_CC_IRQHandler>:
void __attribute__ ((weak)) TIM8_CC_IRQHandler(void) {}
2ffc310c:	4770      	bx	lr
2ffc310e:	bf00      	nop

2ffc3110 <DMA1_Stream7_IRQHandler>:
void __attribute__ ((weak)) DMA1_Stream7_IRQHandler (void) {}
2ffc3110:	4770      	bx	lr
2ffc3112:	bf00      	nop

2ffc3114 <FMC_IRQHandler>:
void __attribute__ ((weak)) FMC_IRQHandler(void) {}
2ffc3114:	4770      	bx	lr
2ffc3116:	bf00      	nop

2ffc3118 <SDMMC1_IRQHandler>:
void __attribute__ ((weak)) SDMMC1_IRQHandler(void) {}
2ffc3118:	4770      	bx	lr
2ffc311a:	bf00      	nop

2ffc311c <TIM5_IRQHandler>:
void __attribute__ ((weak)) TIM5_IRQHandler (void) {}
2ffc311c:	4770      	bx	lr
2ffc311e:	bf00      	nop

2ffc3120 <SPI3_IRQHandler>:
void __attribute__ ((weak)) SPI3_IRQHandler (void) {}
2ffc3120:	4770      	bx	lr
2ffc3122:	bf00      	nop

2ffc3124 <UART4_IRQHandler>:
void __attribute__ ((weak)) UART4_IRQHandler(void) {}
2ffc3124:	4770      	bx	lr
2ffc3126:	bf00      	nop

2ffc3128 <UART5_IRQHandler>:
void __attribute__ ((weak)) UART5_IRQHandler(void) {}
2ffc3128:	4770      	bx	lr
2ffc312a:	bf00      	nop

2ffc312c <TIM6_IRQHandler>:
void __attribute__ ((weak)) TIM6_IRQHandler(void) {}
2ffc312c:	4770      	bx	lr
2ffc312e:	bf00      	nop

2ffc3130 <TIM7_IRQHandler>:
void __attribute__ ((weak)) TIM7_IRQHandler (void) {}
2ffc3130:	4770      	bx	lr
2ffc3132:	bf00      	nop

2ffc3134 <DMA2_Stream0_IRQHandler>:
void __attribute__ ((weak)) DMA2_Stream0_IRQHandler (void) {}
2ffc3134:	4770      	bx	lr
2ffc3136:	bf00      	nop

2ffc3138 <DMA2_Stream1_IRQHandler>:
void __attribute__ ((weak)) DMA2_Stream1_IRQHandler (void) {}
2ffc3138:	4770      	bx	lr
2ffc313a:	bf00      	nop

2ffc313c <DMA2_Stream2_IRQHandler>:
void __attribute__ ((weak)) DMA2_Stream2_IRQHandler (void) {}
2ffc313c:	4770      	bx	lr
2ffc313e:	bf00      	nop

2ffc3140 <DMA2_Stream3_IRQHandler>:
void __attribute__ ((weak)) DMA2_Stream3_IRQHandler (void) {}
2ffc3140:	4770      	bx	lr
2ffc3142:	bf00      	nop

2ffc3144 <DMA2_Stream4_IRQHandler>:
void __attribute__ ((weak)) DMA2_Stream4_IRQHandler (void) {}
2ffc3144:	4770      	bx	lr
2ffc3146:	bf00      	nop

2ffc3148 <ETH1_IRQHandler>:
void __attribute__ ((weak)) ETH1_IRQHandler(void) {}
2ffc3148:	4770      	bx	lr
2ffc314a:	bf00      	nop

2ffc314c <ETH1_WKUP_IRQHandler>:
void __attribute__ ((weak)) ETH1_WKUP_IRQHandler (void) {}
2ffc314c:	4770      	bx	lr
2ffc314e:	bf00      	nop

2ffc3150 <ETH1_LPI_IRQHandler>:
void __attribute__ ((weak)) ETH1_LPI_IRQHandler (void) {}
2ffc3150:	4770      	bx	lr
2ffc3152:	bf00      	nop

2ffc3154 <EXTI6_IRQHandler>:
void __attribute__ ((weak)) EXTI6_IRQHandler(void) {}
2ffc3154:	4770      	bx	lr
2ffc3156:	bf00      	nop

2ffc3158 <EXTI7_IRQHandler>:
void __attribute__ ((weak)) EXTI7_IRQHandler(void) {}
2ffc3158:	4770      	bx	lr
2ffc315a:	bf00      	nop

2ffc315c <EXTI8_IRQHandler>:
void __attribute__ ((weak)) EXTI8_IRQHandler(void) {}
2ffc315c:	4770      	bx	lr
2ffc315e:	bf00      	nop

2ffc3160 <EXTI9_IRQHandler>:
void __attribute__ ((weak)) EXTI9_IRQHandler(void) {}
2ffc3160:	4770      	bx	lr
2ffc3162:	bf00      	nop

2ffc3164 <DMA2_Stream5_IRQHandler>:
void __attribute__ ((weak)) DMA2_Stream5_IRQHandler (void) {}
2ffc3164:	4770      	bx	lr
2ffc3166:	bf00      	nop

2ffc3168 <DMA2_Stream6_IRQHandler>:
void __attribute__ ((weak)) DMA2_Stream6_IRQHandler (void) {}
2ffc3168:	4770      	bx	lr
2ffc316a:	bf00      	nop

2ffc316c <DMA2_Stream7_IRQHandler>:
void __attribute__ ((weak)) DMA2_Stream7_IRQHandler (void) {}
2ffc316c:	4770      	bx	lr
2ffc316e:	bf00      	nop

2ffc3170 <USART6_IRQHandler>:
void __attribute__ ((weak)) USART6_IRQHandler (void) {}
2ffc3170:	4770      	bx	lr
2ffc3172:	bf00      	nop

2ffc3174 <I2C3_EV_IRQHandler>:
void __attribute__ ((weak)) I2C3_EV_IRQHandler(void) {}
2ffc3174:	4770      	bx	lr
2ffc3176:	bf00      	nop

2ffc3178 <I2C3_ER_IRQHandler>:
void __attribute__ ((weak)) I2C3_ER_IRQHandler(void) {}
2ffc3178:	4770      	bx	lr
2ffc317a:	bf00      	nop

2ffc317c <USBH_OHCI_IRQHandler>:
void __attribute__ ((weak)) USBH_OHCI_IRQHandler(void) {}
2ffc317c:	4770      	bx	lr
2ffc317e:	bf00      	nop

2ffc3180 <USBH_EHCI_IRQHandler>:
void __attribute__ ((weak)) USBH_EHCI_IRQHandler(void) {}
2ffc3180:	4770      	bx	lr
2ffc3182:	bf00      	nop

2ffc3184 <EXTI12_IRQHandler>:
void __attribute__ ((weak)) EXTI12_IRQHandler(void) {}
2ffc3184:	4770      	bx	lr
2ffc3186:	bf00      	nop

2ffc3188 <EXTI13_IRQHandler>:
void __attribute__ ((weak)) EXTI13_IRQHandler(void) {}
2ffc3188:	4770      	bx	lr
2ffc318a:	bf00      	nop

2ffc318c <DCMI_IRQHandler>:
void __attribute__ ((weak)) DCMI_IRQHandler (void) {}
2ffc318c:	4770      	bx	lr
2ffc318e:	bf00      	nop

2ffc3190 <CRYP1_IRQHandler>:
void __attribute__ ((weak)) CRYP1_IRQHandler(void) {}
2ffc3190:	4770      	bx	lr
2ffc3192:	bf00      	nop

2ffc3194 <HASH1_IRQHandler>:
void __attribute__ ((weak)) HASH1_IRQHandler(void) {}
2ffc3194:	4770      	bx	lr
2ffc3196:	bf00      	nop

2ffc3198 <UART7_IRQHandler>:
void __attribute__ ((weak)) UART7_IRQHandler(void) {}
2ffc3198:	4770      	bx	lr
2ffc319a:	bf00      	nop

2ffc319c <UART8_IRQHandler>:
void __attribute__ ((weak)) UART8_IRQHandler(void) {}
2ffc319c:	4770      	bx	lr
2ffc319e:	bf00      	nop

2ffc31a0 <SPI4_IRQHandler>:
void __attribute__ ((weak)) SPI4_IRQHandler (void) {}
2ffc31a0:	4770      	bx	lr
2ffc31a2:	bf00      	nop

2ffc31a4 <SPI5_IRQHandler>:
void __attribute__ ((weak)) SPI5_IRQHandler (void) {}
2ffc31a4:	4770      	bx	lr
2ffc31a6:	bf00      	nop

2ffc31a8 <SPI6_IRQHandler>:
void __attribute__ ((weak)) SPI6_IRQHandler (void) {}
2ffc31a8:	4770      	bx	lr
2ffc31aa:	bf00      	nop

2ffc31ac <SAI1_IRQHandler>:
void __attribute__ ((weak)) SAI1_IRQHandler (void) {}
2ffc31ac:	4770      	bx	lr
2ffc31ae:	bf00      	nop

2ffc31b0 <LTDC_IRQHandler>:
void __attribute__ ((weak)) LTDC_IRQHandler (void) {}
2ffc31b0:	4770      	bx	lr
2ffc31b2:	bf00      	nop

2ffc31b4 <LTDC_ER_IRQHandler>:
void __attribute__ ((weak)) LTDC_ER_IRQHandler(void) {}
2ffc31b4:	4770      	bx	lr
2ffc31b6:	bf00      	nop

2ffc31b8 <SAI2_IRQHandler>:
void __attribute__ ((weak)) SAI2_IRQHandler (void) {}
2ffc31b8:	4770      	bx	lr
2ffc31ba:	bf00      	nop

2ffc31bc <QUADSPI_IRQHandler>:
void __attribute__ ((weak)) QUADSPI_IRQHandler(void) {}
2ffc31bc:	4770      	bx	lr
2ffc31be:	bf00      	nop

2ffc31c0 <LPTIM1_IRQHandler>:
void __attribute__ ((weak)) LPTIM1_IRQHandler(void) {}
2ffc31c0:	4770      	bx	lr
2ffc31c2:	bf00      	nop

2ffc31c4 <CEC_IRQHandler>:
void __attribute__ ((weak)) CEC_IRQHandler(void) {}
2ffc31c4:	4770      	bx	lr
2ffc31c6:	bf00      	nop

2ffc31c8 <I2C4_EV_IRQHandler>:
void __attribute__ ((weak)) I2C4_EV_IRQHandler(void) {}
2ffc31c8:	4770      	bx	lr
2ffc31ca:	bf00      	nop

2ffc31cc <I2C4_ER_IRQHandler>:
void __attribute__ ((weak)) I2C4_ER_IRQHandler(void) {}
2ffc31cc:	4770      	bx	lr
2ffc31ce:	bf00      	nop

2ffc31d0 <SPDIF_RX_IRQHandler>:
void __attribute__ ((weak)) SPDIF_RX_IRQHandler (void) {}
2ffc31d0:	4770      	bx	lr
2ffc31d2:	bf00      	nop

2ffc31d4 <OTG_IRQHandler>:
void __attribute__ ((weak)) OTG_IRQHandler(void) {}
2ffc31d4:	4770      	bx	lr
2ffc31d6:	bf00      	nop

2ffc31d8 <IPCC_RX0_IRQHandler>:
void __attribute__ ((weak)) IPCC_RX0_IRQHandler(void) {}
2ffc31d8:	4770      	bx	lr
2ffc31da:	bf00      	nop

2ffc31dc <IPCC_TX0_IRQHandler>:
void __attribute__ ((weak)) IPCC_TX0_IRQHandler(void) {}
2ffc31dc:	4770      	bx	lr
2ffc31de:	bf00      	nop

2ffc31e0 <DMAMUX1_OVR_IRQHandler>:
void __attribute__ ((weak)) DMAMUX1_OVR_IRQHandler(void) {}
2ffc31e0:	4770      	bx	lr
2ffc31e2:	bf00      	nop

2ffc31e4 <IPCC_RX1_IRQHandler>:
void __attribute__ ((weak)) IPCC_RX1_IRQHandler(void) {}
2ffc31e4:	4770      	bx	lr
2ffc31e6:	bf00      	nop

2ffc31e8 <IPCC_TX1_IRQHandler>:
void __attribute__ ((weak)) IPCC_TX1_IRQHandler(void) {}
2ffc31e8:	4770      	bx	lr
2ffc31ea:	bf00      	nop

2ffc31ec <CRYP2_IRQHandler>:
void __attribute__ ((weak)) CRYP2_IRQHandler(void) {}
2ffc31ec:	4770      	bx	lr
2ffc31ee:	bf00      	nop

2ffc31f0 <HASH2_IRQHandler>:
void __attribute__ ((weak)) HASH2_IRQHandler(void) {}
2ffc31f0:	4770      	bx	lr
2ffc31f2:	bf00      	nop

2ffc31f4 <I2C5_EV_IRQHandler>:
void __attribute__ ((weak)) I2C5_EV_IRQHandler(void) {}
2ffc31f4:	4770      	bx	lr
2ffc31f6:	bf00      	nop

2ffc31f8 <I2C5_ER_IRQHandler>:
void __attribute__ ((weak)) I2C5_ER_IRQHandler(void) {}
2ffc31f8:	4770      	bx	lr
2ffc31fa:	bf00      	nop

2ffc31fc <GPU_IRQHandler>:
void __attribute__ ((weak)) GPU_IRQHandler(void) {}
2ffc31fc:	4770      	bx	lr
2ffc31fe:	bf00      	nop

2ffc3200 <DFSDM1_FLT0_IRQHandler>:
void __attribute__ ((weak)) DFSDM1_FLT0_IRQHandler(void) {}
2ffc3200:	4770      	bx	lr
2ffc3202:	bf00      	nop

2ffc3204 <DFSDM1_FLT1_IRQHandler>:
void __attribute__ ((weak)) DFSDM1_FLT1_IRQHandler(void) {}
2ffc3204:	4770      	bx	lr
2ffc3206:	bf00      	nop

2ffc3208 <DFSDM1_FLT2_IRQHandler>:
void __attribute__ ((weak)) DFSDM1_FLT2_IRQHandler(void) {}
2ffc3208:	4770      	bx	lr
2ffc320a:	bf00      	nop

2ffc320c <DFSDM1_FLT3_IRQHandler>:
void __attribute__ ((weak)) DFSDM1_FLT3_IRQHandler(void) {}
2ffc320c:	4770      	bx	lr
2ffc320e:	bf00      	nop

2ffc3210 <SAI3_IRQHandler>:
void __attribute__ ((weak)) SAI3_IRQHandler(void) {}
2ffc3210:	4770      	bx	lr
2ffc3212:	bf00      	nop

2ffc3214 <TIM15_IRQHandler>:
void __attribute__ ((weak)) TIM15_IRQHandler (void) {}
2ffc3214:	4770      	bx	lr
2ffc3216:	bf00      	nop

2ffc3218 <TIM16_IRQHandler>:
void __attribute__ ((weak)) TIM16_IRQHandler (void) {}
2ffc3218:	4770      	bx	lr
2ffc321a:	bf00      	nop

2ffc321c <TIM17_IRQHandler>:
void __attribute__ ((weak)) TIM17_IRQHandler (void) {}
2ffc321c:	4770      	bx	lr
2ffc321e:	bf00      	nop

2ffc3220 <TIM12_IRQHandler>:
void __attribute__ ((weak)) TIM12_IRQHandler (void) {}
2ffc3220:	4770      	bx	lr
2ffc3222:	bf00      	nop

2ffc3224 <MDIOS_IRQHandler>:
void __attribute__ ((weak)) MDIOS_IRQHandler (void) {}
2ffc3224:	4770      	bx	lr
2ffc3226:	bf00      	nop

2ffc3228 <EXTI14_IRQHandler>:
void __attribute__ ((weak)) EXTI14_IRQHandler(void) {}
2ffc3228:	4770      	bx	lr
2ffc322a:	bf00      	nop

2ffc322c <MDMA_IRQHandler>:
void __attribute__ ((weak)) MDMA_IRQHandler(void) {}
2ffc322c:	4770      	bx	lr
2ffc322e:	bf00      	nop

2ffc3230 <DSI_IRQHandler>:
void __attribute__ ((weak)) DSI_IRQHandler (void) {}
2ffc3230:	4770      	bx	lr
2ffc3232:	bf00      	nop

2ffc3234 <SDMMC2_IRQHandler>:
void __attribute__ ((weak)) SDMMC2_IRQHandler(void) {}
2ffc3234:	4770      	bx	lr
2ffc3236:	bf00      	nop

2ffc3238 <HSEM_IT1_IRQHandler>:
void __attribute__ ((weak)) HSEM_IT1_IRQHandler(void) {}
2ffc3238:	4770      	bx	lr
2ffc323a:	bf00      	nop

2ffc323c <EXTI15_IRQHandler>:
void __attribute__ ((weak)) EXTI15_IRQHandler(void) {}
2ffc323c:	4770      	bx	lr
2ffc323e:	bf00      	nop

2ffc3240 <TIM13_IRQHandler>:
void __attribute__ ((weak)) TIM13_IRQHandler(void) {}
2ffc3240:	4770      	bx	lr
2ffc3242:	bf00      	nop

2ffc3244 <TIM14_IRQHandler>:
void __attribute__ ((weak)) TIM14_IRQHandler(void) {}
2ffc3244:	4770      	bx	lr
2ffc3246:	bf00      	nop

2ffc3248 <DAC_IRQHandler>:
void __attribute__ ((weak)) DAC_IRQHandler(void) {}
2ffc3248:	4770      	bx	lr
2ffc324a:	bf00      	nop

2ffc324c <RNG1_IRQHandler>:
void __attribute__ ((weak)) RNG1_IRQHandler(void) {}
2ffc324c:	4770      	bx	lr
2ffc324e:	bf00      	nop

2ffc3250 <RNG2_IRQHandler>:
void __attribute__ ((weak)) RNG2_IRQHandler(void) {}
2ffc3250:	4770      	bx	lr
2ffc3252:	bf00      	nop

2ffc3254 <I2C6_EV_IRQHandler>:
void __attribute__ ((weak)) I2C6_EV_IRQHandler(void) {}
2ffc3254:	4770      	bx	lr
2ffc3256:	bf00      	nop

2ffc3258 <I2C6_ER_IRQHandler>:
void __attribute__ ((weak)) I2C6_ER_IRQHandler(void) {}
2ffc3258:	4770      	bx	lr
2ffc325a:	bf00      	nop

2ffc325c <SDMMC3_IRQHandler>:
void __attribute__ ((weak)) SDMMC3_IRQHandler(void) {}
2ffc325c:	4770      	bx	lr
2ffc325e:	bf00      	nop

2ffc3260 <LPTIM2_IRQHandler>:
void __attribute__ ((weak)) LPTIM2_IRQHandler(void) {}
2ffc3260:	4770      	bx	lr
2ffc3262:	bf00      	nop

2ffc3264 <LPTIM3_IRQHandler>:
void __attribute__ ((weak)) LPTIM3_IRQHandler(void) {}
2ffc3264:	4770      	bx	lr
2ffc3266:	bf00      	nop

2ffc3268 <LPTIM4_IRQHandler>:
void __attribute__ ((weak)) LPTIM4_IRQHandler(void) {}
2ffc3268:	4770      	bx	lr
2ffc326a:	bf00      	nop

2ffc326c <LPTIM5_IRQHandler>:
void __attribute__ ((weak)) LPTIM5_IRQHandler(void) {}
2ffc326c:	4770      	bx	lr
2ffc326e:	bf00      	nop

2ffc3270 <MCU_SEV_IRQHandler>:
void __attribute__ ((weak)) MCU_SEV_IRQHandler(void) {}
2ffc3270:	4770      	bx	lr
2ffc3272:	bf00      	nop

2ffc3274 <SAI4_IRQHandler>:
void __attribute__ ((weak)) SAI4_IRQHandler(void) {}
2ffc3274:	4770      	bx	lr
2ffc3276:	bf00      	nop

2ffc3278 <DTS_IRQHandler>:
void __attribute__ ((weak)) DTS_IRQHandler(void) {}
2ffc3278:	4770      	bx	lr
2ffc327a:	bf00      	nop

2ffc327c <WAKEUP_PIN_IRQHandler>:
void __attribute__ ((weak)) WAKEUP_PIN_IRQHandler(void) {}
2ffc327c:	4770      	bx	lr
2ffc327e:	bf00      	nop

2ffc3280 <DFSDM1_FLT4_IRQHandler>:
void __attribute__ ((weak)) DFSDM1_FLT4_IRQHandler(void) {}
2ffc3280:	4770      	bx	lr
2ffc3282:	bf00      	nop

2ffc3284 <DFSDM1_FLT5_IRQHandler>:
void __attribute__ ((weak)) DFSDM1_FLT5_IRQHandler(void) {}
2ffc3284:	4770      	bx	lr
2ffc3286:	bf00      	nop

2ffc3288 <MDMA_SEC_IT_IRQHandler>:
void __attribute__ ((weak)) MDMA_SEC_IT_IRQHandler(void) {}
2ffc3288:	4770      	bx	lr
2ffc328a:	bf00      	nop

2ffc328c <SYSRESETQ_IRQHandler>:
void __attribute__ ((weak)) SYSRESETQ_IRQHandler(void) {}
2ffc328c:	4770      	bx	lr
2ffc328e:	bf00      	nop

2ffc3290 <TAMP_SERR_S_IRQHandler>:
void __attribute__ ((weak)) TAMP_SERR_S_IRQHandler(void) {}
2ffc3290:	4770      	bx	lr
2ffc3292:	bf00      	nop

2ffc3294 <IWDG1_IRQHandler>:
void __attribute__ ((weak)) IWDG1_IRQHandler(void) {}
2ffc3294:	4770      	bx	lr
2ffc3296:	bf00      	nop

2ffc3298 <IWDG2_IRQHandler>:
void __attribute__ ((weak)) IWDG2_IRQHandler(void) {}
2ffc3298:	4770      	bx	lr
2ffc329a:	bf00      	nop

2ffc329c <RTC_WKUP_ALARM_S_IRQHandler>:
void __attribute__ ((weak)) RTC_WKUP_ALARM_S_IRQHandler(void) {}
2ffc329c:	4770      	bx	lr
2ffc329e:	bf00      	nop

2ffc32a0 <RTC_TS_SERR_S_IRQHandler>:
void __attribute__ ((weak)) RTC_TS_SERR_S_IRQHandler(void) {}
2ffc32a0:	4770      	bx	lr
2ffc32a2:	bf00      	nop

2ffc32a4 <Default_Handler>:
#endif
/*----------------------------------------------------------------------------
  Default Handler for Exceptions / Interrupts
 *----------------------------------------------------------------------------*/
void Default_Handler(void) {
  while(1);
2ffc32a4:	e7fe      	b.n	2ffc32a4 <Default_Handler>
2ffc32a6:	bf00      	nop

2ffc32a8 <SecurePhysicalTimer_IRQHandler>:
  UNUSED(Software_Interrupt_Id);
  UNUSED(cpu_id_request);
}

void SecurePhysicalTimer_IRQHandler(void)
{
2ffc32a8:	b508      	push	{r3, lr}
  IRQ_ClearPending(SecurePhysicalTimer_IRQn);
2ffc32aa:	201d      	movs	r0, #29
2ffc32ac:	f7ff fe68 	bl	2ffc2f80 <IRQ_ClearPending>
    \return               CNTP_TVAL Register value
 */
__STATIC_FORCEINLINE uint32_t __get_CNTP_TVAL(void)
{
  uint32_t result;
  __get_CP(15, 0, result, 14, 2, 0);
2ffc32b0:	ee1e 3f12 	mrc	15, 0, r3, cr14, cr2, {0}
     34 CLK/tick = 34/48000 = 0.07 % = 0.7ms/s
   Measured error with optimized compilation (-O2) is
     6 CLK/tick = 6/48000 = 0.01 % = 0.1ms/s
*/

  PL1_SetLoadValue(HSI_VALUE/1000 + PL1_GetCurrentValue());
2ffc32b4:	f503 437a 	add.w	r3, r3, #64000	@ 0xfa00
  __set_CP(15, 0, value, 14, 2, 0);
2ffc32b8:	ee0e 3f12 	mcr	15, 0, r3, cr14, cr2, {0}
  __ASM volatile ("isb 0xF":::"memory");
2ffc32bc:	f3bf 8f6f 	isb	sy

  HAL_IncTick();
}
2ffc32c0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_IncTick();
2ffc32c4:	f000 b934 	b.w	2ffc3530 <HAL_IncTick>

2ffc32c8 <IRQ_Handler>:
/**
  * @brief  Generic IRQ Handler (Software IRQs, PPIs & IRQs)
  * @param  None
  * @retval None
  */
void __attribute__ ((interrupt ("IRQ")))IRQ_Handler(void) {
2ffc32c8:	e92d 503f 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, ip, lr}
      IRQ_EndOfInterrupt(ItId);
    }
    else
    {
      /* Normal case: whenever there is no more pending IRQ , IAR returns ACKNOWLEDGE special IRQ value */
      if (ItId == GIC_ACKNOWLEDGE_RESPONSE)
2ffc32cc:	f240 35ff 	movw	r5, #1023	@ 0x3ff
    ItId = IRQ_GetActiveIRQ();
2ffc32d0:	f7ff fdf6 	bl	2ffc2ec0 <IRQ_GetActiveIRQ>
    if (ItId <= GIC_HIGHEST_INTERRUPT_VALUE) /* Highest value of GIC Valid Interrupt */
2ffc32d4:	f5b0 7f7f 	cmp.w	r0, #1020	@ 0x3fc
    ItId = IRQ_GetActiveIRQ();
2ffc32d8:	4604      	mov	r4, r0
    if (ItId <= GIC_HIGHEST_INTERRUPT_VALUE) /* Highest value of GIC Valid Interrupt */
2ffc32da:	d80a      	bhi.n	2ffc32f2 <IRQ_Handler+0x2a>
      if (ItId >= MAX_IRQ_n)
2ffc32dc:	28e7      	cmp	r0, #231	@ 0xe7
2ffc32de:	d90e      	bls.n	2ffc32fe <IRQ_Handler+0x36>
      IRQ_EndOfInterrupt(ItId);
2ffc32e0:	4620      	mov	r0, r4
2ffc32e2:	f7ff fe35 	bl	2ffc2f50 <IRQ_EndOfInterrupt>
    ItId = IRQ_GetActiveIRQ();
2ffc32e6:	f7ff fdeb 	bl	2ffc2ec0 <IRQ_GetActiveIRQ>
    if (ItId <= GIC_HIGHEST_INTERRUPT_VALUE) /* Highest value of GIC Valid Interrupt */
2ffc32ea:	f5b0 7f7f 	cmp.w	r0, #1020	@ 0x3fc
    ItId = IRQ_GetActiveIRQ();
2ffc32ee:	4604      	mov	r4, r0
    if (ItId <= GIC_HIGHEST_INTERRUPT_VALUE) /* Highest value of GIC Valid Interrupt */
2ffc32f0:	d9f4      	bls.n	2ffc32dc <IRQ_Handler+0x14>
      if (ItId == GIC_ACKNOWLEDGE_RESPONSE)
2ffc32f2:	42a8      	cmp	r0, r5
2ffc32f4:	d1ec      	bne.n	2ffc32d0 <IRQ_Handler+0x8>
      {
        SystemInit_IRQ_ErrorHandler();
      }
    }
  }
}
2ffc32f6:	e8bd 503f 	ldmia.w	sp!, {r0, r1, r2, r3, r4, r5, ip, lr}
2ffc32fa:	f3de 8f04 	subs	pc, lr, #4
        handler = IRQ_GetHandler(ItId);
2ffc32fe:	f7ff fdbb 	bl	2ffc2e78 <IRQ_GetHandler>
        if (handler!=NULL)
2ffc3302:	2800      	cmp	r0, #0
2ffc3304:	d0ec      	beq.n	2ffc32e0 <IRQ_Handler+0x18>
          handler();
2ffc3306:	4780      	blx	r0
2ffc3308:	e7ea      	b.n	2ffc32e0 <IRQ_Handler+0x18>
2ffc330a:	bf00      	nop

2ffc330c <ZeroBss>:
  * @param  None
  * @retval None
  */
void __attribute__((noinline)) ZeroBss(void)
{
  __asm volatile(
2ffc330c:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
2ffc3310:	4a06      	ldr	r2, [pc, #24]	@ (2ffc332c <LoopFillZerobss+0x12>)
2ffc3312:	e002      	b.n	2ffc331a <LoopFillZerobss>

2ffc3314 <FillZerobss>:
2ffc3314:	2300      	movs	r3, #0
2ffc3316:	6013      	str	r3, [r2, #0]
2ffc3318:	3204      	adds	r2, #4

2ffc331a <LoopFillZerobss>:
2ffc331a:	4b05      	ldr	r3, [pc, #20]	@ (2ffc3330 <LoopFillZerobss+0x16>)
2ffc331c:	429a      	cmp	r2, r3
2ffc331e:	d3f9      	bcc.n	2ffc3314 <FillZerobss>
2ffc3320:	f3bf 8f4f 	dsb	sy
2ffc3324:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    "BCC FillZerobss        \n"

    "DSB                    \n"
    "POP    {R4-R11}        "
  );
}
2ffc3328:	4770      	bx	lr
2ffc332a:	0000      	.short	0x0000
2ffc332c:	2ffd1900 	.word	0x2ffd1900
2ffc3330:	2ffd2b60 	.word	0x2ffd2b60

2ffc3334 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
2ffc3334:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* Fill BSS Section with '0' */
  ZeroBss();
2ffc3338:	f7ff ffe8 	bl	2ffc330c <ZeroBss>

  TLB Invalidate All
 */
__STATIC_FORCEINLINE void __set_TLBIALL(uint32_t value)
{
  __set_CP(15, 0, value, 8, 7, 0);
2ffc333c:	2300      	movs	r3, #0
2ffc333e:	ee08 3f17 	mcr	15, 0, r3, cr8, cr7, {0}

  /* Invalidate entire Unified TLB */
  __set_TLBIALL(0);

  /* Disable all interrupts and events */
  CLEAR_REG(EXTI_C1->IMR1);
2ffc3342:	f44f 4250 	mov.w	r2, #53248	@ 0xd000
2ffc3346:	f2c5 0200 	movt	r2, #20480	@ 0x5000
2ffc334a:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
  CLEAR_REG(EXTI_C1->IMR2);
2ffc334e:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
  CLEAR_REG(EXTI_C1->IMR3);
2ffc3352:	f8c2 30a0 	str.w	r3, [r2, #160]	@ 0xa0
  CLEAR_REG(EXTI_C1->EMR1);
2ffc3356:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
  CLEAR_REG(EXTI_C1->EMR2);
2ffc335a:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
  CLEAR_REG(EXTI_C1->EMR3);
2ffc335e:	f8c2 30a4 	str.w	r3, [r2, #164]	@ 0xa4

  Branch Predictor Invalidate All
 */
__STATIC_FORCEINLINE void __set_BPIALL(uint32_t value)
{
  __set_CP(15, 0, value, 7, 5, 6);
2ffc3362:	ee07 3fd5 	mcr	15, 0, r3, cr7, cr5, {6}
  __ASM volatile ("dsb 0xF":::"memory");
2ffc3366:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
2ffc336a:	f3bf 8f6f 	isb	sy

  Instruction Cache Invalidate All
 */
__STATIC_FORCEINLINE void __set_ICIALLU(uint32_t value)
{
  __set_CP(15, 0, value, 7, 5, 0);
2ffc336e:	ee07 3f15 	mcr	15, 0, r3, cr7, cr5, {0}
  __ASM volatile ("dsb 0xF":::"memory");
2ffc3372:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
2ffc3376:	f3bf 8f6f 	isb	sy
 */
__STATIC_FORCEINLINE uint32_t __get_CLIDR(void)
{
  uint32_t result;
//  __ASM volatile("MRC p15, 1, %0, c0, c0, 1" : "=r"(result) : : "memory");
  __get_CP(15, 1, result, 0, 0, 1);
2ffc337a:	ee30 8f30 	mrc	15, 1, r8, cr0, cr0, {1}
    cache_type = (clidr >> i*3U) & 0x7UL;
2ffc337e:	2703      	movs	r7, #3
  for(uint32_t i = 0U; i<7U; i++)
2ffc3380:	469c      	mov	ip, r3
    cache_type = (clidr >> i*3U) & 0x7UL;
2ffc3382:	fb07 f30c 	mul.w	r3, r7, ip
2ffc3386:	fa28 f303 	lsr.w	r3, r8, r3
2ffc338a:	f003 0307 	and.w	r3, r3, #7
    if ((cache_type >= 2U) && (cache_type <= 4U))
2ffc338e:	3b02      	subs	r3, #2
2ffc3390:	2b02      	cmp	r3, #2
2ffc3392:	d831      	bhi.n	2ffc33f8 <SystemInit+0xc4>
  Dummy = level << 1U;
2ffc3394:	ea4f 0e4c 	mov.w	lr, ip, lsl #1
  __set_CP(15, 2, value, 0, 0, 0);
2ffc3398:	ee40 ef10 	mcr	15, 2, lr, cr0, cr0, {0}
  __get_CP(15, 1, result, 0, 0, 0);
2ffc339c:	ee30 0f10 	mrc	15, 1, r0, cr0, cr0, {0}
  num_ways = ((ccsidr & 0x00001FF8U) >> 3U) + 1U;
2ffc33a0:	f3c0 04c9 	ubfx	r4, r0, #3, #10
2ffc33a4:	1c66      	adds	r6, r4, #1
  if (n < 2U) {
2ffc33a6:	2c00      	cmp	r4, #0
2ffc33a8:	f000 8098 	beq.w	2ffc34dc <SystemInit+0x1a8>
2ffc33ac:	4633      	mov	r3, r6
  uint8_t log = 0U;
2ffc33ae:	2500      	movs	r5, #0
    t >>= 1U;
2ffc33b0:	085b      	lsrs	r3, r3, #1
    log++;
2ffc33b2:	1c6a      	adds	r2, r5, #1
  while(t > 1U)
2ffc33b4:	2b01      	cmp	r3, #1
2ffc33b6:	4629      	mov	r1, r5
    log++;
2ffc33b8:	b2d5      	uxtb	r5, r2
  while(t > 1U)
2ffc33ba:	d1f9      	bne.n	2ffc33b0 <SystemInit+0x7c>
  if (n & 1U) { log++; }
2ffc33bc:	07f3      	lsls	r3, r6, #31
2ffc33be:	bf44      	itt	mi
2ffc33c0:	3102      	addmi	r1, #2
2ffc33c2:	b2cd      	uxtbmi	r5, r1
  if ((log2_num_ways < 0) || (log2_num_ways > 32)) {
2ffc33c4:	2d20      	cmp	r5, #32
  shift_way = 32U - (uint32_t)log2_num_ways;
2ffc33c6:	bf98      	it	ls
2ffc33c8:	f1c5 0520 	rsbls	r5, r5, #32
  if ((log2_num_ways < 0) || (log2_num_ways > 32)) {
2ffc33cc:	d814      	bhi.n	2ffc33f8 <SystemInit+0xc4>
  num_sets = ((ccsidr & 0x0FFFE000U) >> 13U) + 1U;
2ffc33ce:	f3c0 364e 	ubfx	r6, r0, #13, #15
  log2_linesize = (ccsidr & 0x00000007U) + 2U + 2U;
2ffc33d2:	f000 0007 	and.w	r0, r0, #7
2ffc33d6:	3004      	adds	r0, #4
      Dummy = (level << 1U) | (((uint32_t)set) << log2_linesize) | (((uint32_t)way) << shift_way);
2ffc33d8:	fa04 f105 	lsl.w	r1, r4, r5
    for(int32_t set = num_sets-1; set >= 0; set--)
2ffc33dc:	4633      	mov	r3, r6
2ffc33de:	ea41 010e 	orr.w	r1, r1, lr
      Dummy = (level << 1U) | (((uint32_t)set) << log2_linesize) | (((uint32_t)way) << shift_way);
2ffc33e2:	fa03 f200 	lsl.w	r2, r3, r0
2ffc33e6:	430a      	orrs	r2, r1
/** \brief  Set DCISW
 */
__STATIC_FORCEINLINE void __set_DCISW(uint32_t value)
{
//  __ASM volatile("MCR p15, 0, %0, c7, c6, 2" : : "r"(value) : "memory")
  __set_CP(15, 0, value, 7, 6, 2);
2ffc33e8:	ee07 2f56 	mcr	15, 0, r2, cr7, cr6, {2}
    for(int32_t set = num_sets-1; set >= 0; set--)
2ffc33ec:	3b01      	subs	r3, #1
2ffc33ee:	d2f8      	bcs.n	2ffc33e2 <SystemInit+0xae>
  for(int32_t way = num_ways-1; way >= 0; way--)
2ffc33f0:	3c01      	subs	r4, #1
2ffc33f2:	d2f1      	bcs.n	2ffc33d8 <SystemInit+0xa4>
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE  void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
2ffc33f4:	f3bf 8f5f 	dmb	sy
  for(uint32_t i = 0U; i<7U; i++)
2ffc33f8:	f10c 0c01 	add.w	ip, ip, #1
2ffc33fc:	f1bc 0f07 	cmp.w	ip, #7
2ffc3400:	d1bf      	bne.n	2ffc3382 <SystemInit+0x4e>

  Critical section, called from undef handler, so systick is disabled
 */
__STATIC_INLINE void __FPU_Enable(void)
{
  __ASM volatile(
2ffc3402:	ee11 1f50 	mrc	15, 0, r1, cr1, cr0, {2}
2ffc3406:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
2ffc340a:	ee01 1f50 	mcr	15, 0, r1, cr1, cr0, {2}
2ffc340e:	f3bf 8f6f 	isb	sy
2ffc3412:	eef8 1a10 	vmrs	r1, fpexc
2ffc3416:	f041 4180 	orr.w	r1, r1, #1073741824	@ 0x40000000
2ffc341a:	eee8 1a10 	vmsr	fpexc, r1
2ffc341e:	f04f 0200 	mov.w	r2, #0
2ffc3422:	ec42 2b10 	vmov	d0, r2, r2
2ffc3426:	ec42 2b11 	vmov	d1, r2, r2
2ffc342a:	ec42 2b12 	vmov	d2, r2, r2
2ffc342e:	ec42 2b13 	vmov	d3, r2, r2
2ffc3432:	ec42 2b14 	vmov	d4, r2, r2
2ffc3436:	ec42 2b15 	vmov	d5, r2, r2
2ffc343a:	ec42 2b16 	vmov	d6, r2, r2
2ffc343e:	ec42 2b17 	vmov	d7, r2, r2
2ffc3442:	ec42 2b18 	vmov	d8, r2, r2
2ffc3446:	ec42 2b19 	vmov	d9, r2, r2
2ffc344a:	ec42 2b1a 	vmov	d10, r2, r2
2ffc344e:	ec42 2b1b 	vmov	d11, r2, r2
2ffc3452:	ec42 2b1c 	vmov	d12, r2, r2
2ffc3456:	ec42 2b1d 	vmov	d13, r2, r2
2ffc345a:	ec42 2b1e 	vmov	d14, r2, r2
2ffc345e:	ec42 2b1f 	vmov	d15, r2, r2
2ffc3462:	ec42 2b30 	vmov	d16, r2, r2
2ffc3466:	ec42 2b31 	vmov	d17, r2, r2
2ffc346a:	ec42 2b32 	vmov	d18, r2, r2
2ffc346e:	ec42 2b33 	vmov	d19, r2, r2
2ffc3472:	ec42 2b34 	vmov	d20, r2, r2
2ffc3476:	ec42 2b35 	vmov	d21, r2, r2
2ffc347a:	ec42 2b36 	vmov	d22, r2, r2
2ffc347e:	ec42 2b37 	vmov	d23, r2, r2
2ffc3482:	ec42 2b38 	vmov	d24, r2, r2
2ffc3486:	ec42 2b39 	vmov	d25, r2, r2
2ffc348a:	ec42 2b3a 	vmov	d26, r2, r2
2ffc348e:	ec42 2b3b 	vmov	d27, r2, r2
2ffc3492:	ec42 2b3c 	vmov	d28, r2, r2
2ffc3496:	ec42 2b3d 	vmov	d29, r2, r2
2ffc349a:	ec42 2b3e 	vmov	d30, r2, r2
2ffc349e:	ec42 2b3f 	vmov	d31, r2, r2
2ffc34a2:	eef1 1a10 	vmrs	r1, fpscr
2ffc34a6:	4a0f      	ldr	r2, [pc, #60]	@ (2ffc34e4 <SystemInit+0x1b0>)
2ffc34a8:	ea01 0102 	and.w	r1, r1, r2
2ffc34ac:	eee1 1a10 	vmsr	fpscr, r1
  __get_CP(15, 0, result, 1, 0, 0);
2ffc34b0:	ee11 3f10 	mrc	15, 0, r3, cr1, cr0, {0}
  __set_SCTLR( __get_SCTLR() | SCTLR_Z_Msk);
2ffc34b4:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
  __set_CP(15, 0, sctlr, 1, 0, 0);
2ffc34b8:	ee01 3f10 	mcr	15, 0, r3, cr1, cr0, {0}
  __ASM volatile ("isb 0xF":::"memory");
2ffc34bc:	f3bf 8f6f 	isb	sy

#if (__GIC_PRESENT == 1)
  uint32_t i;

  /* Enable GIC */
  IRQ_Initialize();
2ffc34c0:	4d07      	ldr	r5, [pc, #28]	@ (2ffc34e0 <SystemInit+0x1ac>)

  /* Set Interrupt vectors */
  for (i = 0U; i < MAX_IRQ_n ; i++) {
2ffc34c2:	2400      	movs	r4, #0
  IRQ_Initialize();
2ffc34c4:	f7ff fc06 	bl	2ffc2cd4 <IRQ_Initialize>
    IRQ_SetHandler(i, IRQ_Vector_Table[i]);
2ffc34c8:	f855 1f04 	ldr.w	r1, [r5, #4]!
2ffc34cc:	4620      	mov	r0, r4
  for (i = 0U; i < MAX_IRQ_n ; i++) {
2ffc34ce:	3401      	adds	r4, #1
    IRQ_SetHandler(i, IRQ_Vector_Table[i]);
2ffc34d0:	f7ff fcc2 	bl	2ffc2e58 <IRQ_SetHandler>
  for (i = 0U; i < MAX_IRQ_n ; i++) {
2ffc34d4:	2ce8      	cmp	r4, #232	@ 0xe8
2ffc34d6:	d1f7      	bne.n	2ffc34c8 <SystemInit+0x194>
  }
#endif
}
2ffc34d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
2ffc34dc:	2520      	movs	r5, #32
2ffc34de:	e776      	b.n	2ffc33ce <SystemInit+0x9a>
2ffc34e0:	2ffd136c 	.word	0x2ffd136c
2ffc34e4:	00086060 	.word	0x00086060

2ffc34e8 <HAL_InitTick>:
  __set_CP(15, 0, value, 14, 0, 0);
2ffc34e8:	f44f 4310 	mov.w	r3, #36864	@ 0x9000
2ffc34ec:	f2c0 33d0 	movt	r3, #976	@ 0x3d0
2ffc34f0:	ee0e 3f10 	mcr	15, 0, r3, cr14, cr0, {0}
2ffc34f4:	f3bf 8f6f 	isb	sy
  __set_CP(15, 0, value, 14, 2, 0);
2ffc34f8:	2301      	movs	r3, #1
2ffc34fa:	ee0e 3f12 	mcr	15, 0, r3, cr14, cr2, {0}
2ffc34fe:	f3bf 8f6f 	isb	sy



  /* Return function status */
  return HAL_OK;
}
2ffc3502:	2000      	movs	r0, #0
2ffc3504:	4770      	bx	lr
2ffc3506:	bf00      	nop

2ffc3508 <HAL_Init>:
{
2ffc3508:	b510      	push	{r4, lr}
  SystemCoreClock = HAL_RCC_GetSystemCoreClockFreq();
2ffc350a:	f003 fa33 	bl	2ffc6974 <HAL_RCC_GetSystemCoreClockFreq>
2ffc350e:	f241 7310 	movw	r3, #5904	@ 0x1710
2ffc3512:	4602      	mov	r2, r0
2ffc3514:	f6c2 73fd 	movt	r3, #12285	@ 0x2ffd
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
2ffc3518:	200f      	movs	r0, #15
    return HAL_ERROR;
2ffc351a:	2401      	movs	r4, #1
  SystemCoreClock = HAL_RCC_GetSystemCoreClockFreq();
2ffc351c:	601a      	str	r2, [r3, #0]
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
2ffc351e:	f7ff ffe3 	bl	2ffc34e8 <HAL_InitTick>
2ffc3522:	b910      	cbnz	r0, 2ffc352a <HAL_Init+0x22>
2ffc3524:	4604      	mov	r4, r0
  HAL_MspInit();
2ffc3526:	f007 fe9f 	bl	2ffcb268 <HAL_MspInit>
}
2ffc352a:	4620      	mov	r0, r4
2ffc352c:	bd10      	pop	{r4, pc}
2ffc352e:	bf00      	nop

2ffc3530 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
2ffc3530:	f642 1364 	movw	r3, #10596	@ 0x2964
2ffc3534:	f241 7214 	movw	r2, #5908	@ 0x1714
2ffc3538:	f6c2 73fd 	movt	r3, #12285	@ 0x2ffd
2ffc353c:	f6c2 72fd 	movt	r2, #12285	@ 0x2ffd
2ffc3540:	6819      	ldr	r1, [r3, #0]
2ffc3542:	7812      	ldrb	r2, [r2, #0]
2ffc3544:	440a      	add	r2, r1
2ffc3546:	601a      	str	r2, [r3, #0]
}
2ffc3548:	4770      	bx	lr
2ffc354a:	bf00      	nop

2ffc354c <HAL_GetTick>:
#elif defined (USE_PL1_SecurePhysicalTimer_IRQ)
  /* tick is incremented in SecurePhysicalTimer_IRQ handler */
  return uwTick;
#else
  /* tick value directly got from 64bits CA7 register*/
  if ((RCC->STGENCKSELR & RCC_STGENCKSELR_STGENSRC) == RCC_STGENCLKSOURCE_HSE)
2ffc354c:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc3550:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
2ffc3554:	f003 0303 	and.w	r3, r3, #3
2ffc3558:	2b01      	cmp	r3, #1
  __get_CP64(15, 0, result, 14);
2ffc355a:	ec51 0f0e 	mrrc	15, 0, r0, r1, cr14
    {
      return ((uint32_t)PL1_GetCurrentPhysicalValue() / (HSE_VALUE / 1000UL));
2ffc355e:	bf09      	itett	eq
2ffc3560:	f641 13f1 	movweq	r3, #6641	@ 0x19f1
    }
  else
    {
      return ((uint32_t)PL1_GetCurrentPhysicalValue() / (HSI_VALUE / 1000UL));
2ffc3564:	f644 53d3 	movwne	r3, #19923	@ 0x4dd3
      return ((uint32_t)PL1_GetCurrentPhysicalValue() / (HSE_VALUE / 1000UL));
2ffc3568:	f2c0 5376 	movteq	r3, #1398	@ 0x576
2ffc356c:	fba3 3000 	umulleq	r3, r0, r3, r0
      return ((uint32_t)PL1_GetCurrentPhysicalValue() / (HSI_VALUE / 1000UL));
2ffc3570:	bf17      	itett	ne
2ffc3572:	f2c1 0362 	movtne	r3, #4194	@ 0x1062
      return ((uint32_t)PL1_GetCurrentPhysicalValue() / (HSE_VALUE / 1000UL));
2ffc3576:	0a40      	lsreq	r0, r0, #9
      return ((uint32_t)PL1_GetCurrentPhysicalValue() / (HSI_VALUE / 1000UL));
2ffc3578:	fba3 3000 	umullne	r3, r0, r3, r0
2ffc357c:	0b00      	lsrne	r0, r0, #12
#if defined (CORE_CM4)
  /* tick is incremented in systick handler */
  return uwTick;
#endif /* CORE_CM4 */

}
2ffc357e:	4770      	bx	lr

2ffc3580 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
2ffc3580:	b538      	push	{r3, r4, r5, lr}
2ffc3582:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
2ffc3584:	f7ff ffe2 	bl	2ffc354c <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
2ffc3588:	1c63      	adds	r3, r4, #1
  uint32_t tickstart = HAL_GetTick();
2ffc358a:	4605      	mov	r5, r0
  {
    wait += (uint32_t)(uwTickFreq);
2ffc358c:	bf1f      	itttt	ne
2ffc358e:	f241 7314 	movwne	r3, #5908	@ 0x1714
2ffc3592:	f6c2 73fd 	movtne	r3, #12285	@ 0x2ffd
2ffc3596:	781b      	ldrbne	r3, [r3, #0]
2ffc3598:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
2ffc359a:	f7ff ffd7 	bl	2ffc354c <HAL_GetTick>
2ffc359e:	1b40      	subs	r0, r0, r5
2ffc35a0:	42a0      	cmp	r0, r4
2ffc35a2:	d3fa      	bcc.n	2ffc359a <HAL_Delay+0x1a>
  {
  }
}
2ffc35a4:	bd38      	pop	{r3, r4, r5, pc}
2ffc35a6:	bf00      	nop

2ffc35a8 <ddrphy_idone_wait>:
  */
static __IO uint32_t ddr_timeout_init_us(uint32_t timeout_us)
{
  __IO uint32_t wait_loop_index = 0U;

  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc35a8:	f241 7310 	movw	r3, #5904	@ 0x1710
2ffc35ac:	f64d 6183 	movw	r1, #56963	@ 0xde83
2ffc35b0:	f6c2 73fd 	movt	r3, #12285	@ 0x2ffd
2ffc35b4:	2032      	movs	r0, #50	@ 0x32
2ffc35b6:	f2c4 311b 	movt	r1, #17179	@ 0x431b
                       | DDRPHYC_PGSR_RVEIRR;
  __IO uint32_t timeout = ddr_timeout_init_us(DDR_TIMEOUT_50_US);

  do
  {
    pgsr = READ_REG(DDRPHYC->PGSR);
2ffc35ba:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc35be:	681b      	ldr	r3, [r3, #0]
{
2ffc35c0:	b410      	push	{r4}
2ffc35c2:	b083      	sub	sp, #12
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc35c4:	fba1 1303 	umull	r1, r3, r1, r3
    pgsr = READ_REG(DDRPHYC->PGSR);
2ffc35c8:	f6c5 2200 	movt	r2, #23040	@ 0x5a00
  __IO uint32_t wait_loop_index = 0U;
2ffc35cc:	2400      	movs	r4, #0
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc35ce:	0cdb      	lsrs	r3, r3, #19
2ffc35d0:	fb00 f303 	mul.w	r3, r0, r3
  __IO uint32_t wait_loop_index = 0U;
2ffc35d4:	9401      	str	r4, [sp, #4]

    if ((pgsr & errormask) != 0U)
    {
      error++;
    }
  } while (((pgsr & DDRPHYC_PGSR_IDONE) == 0U) && (error == 0U));
2ffc35d6:	f240 30e1 	movw	r0, #993	@ 0x3e1
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc35da:	9301      	str	r3, [sp, #4]
  return wait_loop_index;
2ffc35dc:	9b01      	ldr	r3, [sp, #4]
  __IO uint32_t timeout = ddr_timeout_init_us(DDR_TIMEOUT_50_US);
2ffc35de:	9300      	str	r3, [sp, #0]
    pgsr = READ_REG(DDRPHYC->PGSR);
2ffc35e0:	68d1      	ldr	r1, [r2, #12]
    timeout--;
2ffc35e2:	9b00      	ldr	r3, [sp, #0]
2ffc35e4:	3b01      	subs	r3, #1
2ffc35e6:	9300      	str	r3, [sp, #0]
    if (ddr_timeout_elapsed(timeout))
2ffc35e8:	9b00      	ldr	r3, [sp, #0]
  if (timeout == 0U)
2ffc35ea:	b133      	cbz	r3, 2ffc35fa <ddrphy_idone_wait+0x52>
  } while (((pgsr & DDRPHYC_PGSR_IDONE) == 0U) && (error == 0U));
2ffc35ec:	4201      	tst	r1, r0
2ffc35ee:	d0f7      	beq.n	2ffc35e0 <ddrphy_idone_wait+0x38>

  return HAL_OK;
2ffc35f0:	2000      	movs	r0, #0
}
2ffc35f2:	b003      	add	sp, #12
2ffc35f4:	f85d 4b04 	ldr.w	r4, [sp], #4
2ffc35f8:	4770      	bx	lr
      return HAL_TIMEOUT; /* Timeout initialising DRAM */
2ffc35fa:	2003      	movs	r0, #3
}
2ffc35fc:	b003      	add	sp, #12
2ffc35fe:	f85d 4b04 	ldr.w	r4, [sp], #4
2ffc3602:	4770      	bx	lr

2ffc3604 <wait_sw_done_ack>:
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3604:	f241 7310 	movw	r3, #5904	@ 0x1710
2ffc3608:	f64d 6183 	movw	r1, #56963	@ 0xde83
2ffc360c:	f6c2 73fd 	movt	r3, #12285	@ 0x2ffd
  CLEAR_BIT(DDRCTRL->SWCTL, DDRCTRL_SWCTL_SW_DONE);
}

/* Wait quasi dynamic register update */
static HAL_StatusTypeDef wait_sw_done_ack(void)
{
2ffc3610:	b082      	sub	sp, #8
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3612:	f2c4 311b 	movt	r1, #17179	@ 0x431b
  __IO uint32_t wait_loop_index = 0U;
2ffc3616:	2200      	movs	r2, #0
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3618:	681b      	ldr	r3, [r3, #0]
  __IO uint32_t wait_loop_index = 0U;
2ffc361a:	9201      	str	r2, [sp, #4]
  uint32_t swstat;
  __IO uint32_t timeout = ddr_timeout_init_us(DDR_TIMEOUT_1_US);

  SET_BIT(DDRCTRL->SWCTL, DDRCTRL_SWCTL_SW_DONE);
2ffc361c:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3620:	fba1 1303 	umull	r1, r3, r1, r3
  SET_BIT(DDRCTRL->SWCTL, DDRCTRL_SWCTL_SW_DONE);
2ffc3624:	f6c5 2200 	movt	r2, #23040	@ 0x5a00
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3628:	0cdb      	lsrs	r3, r3, #19
2ffc362a:	9301      	str	r3, [sp, #4]
  return wait_loop_index;
2ffc362c:	9b01      	ldr	r3, [sp, #4]
  __IO uint32_t timeout = ddr_timeout_init_us(DDR_TIMEOUT_1_US);
2ffc362e:	9300      	str	r3, [sp, #0]
  SET_BIT(DDRCTRL->SWCTL, DDRCTRL_SWCTL_SW_DONE);
2ffc3630:	f8d2 3320 	ldr.w	r3, [r2, #800]	@ 0x320
2ffc3634:	f043 0301 	orr.w	r3, r3, #1
2ffc3638:	f8c2 3320 	str.w	r3, [r2, #800]	@ 0x320

  do
  {
    swstat = READ_REG(DDRCTRL->SWSTAT);
2ffc363c:	f8d2 1324 	ldr.w	r1, [r2, #804]	@ 0x324

    timeout--;
2ffc3640:	9b00      	ldr	r3, [sp, #0]
2ffc3642:	3b01      	subs	r3, #1
2ffc3644:	9300      	str	r3, [sp, #0]
    if (ddr_timeout_elapsed(timeout))
2ffc3646:	9b00      	ldr	r3, [sp, #0]
  if (timeout == 0U)
2ffc3648:	b11b      	cbz	r3, 2ffc3652 <wait_sw_done_ack+0x4e>
    {
      return HAL_TIMEOUT; /* Timeout initialising DRAM */
    }
  } while ((swstat & DDRCTRL_SWSTAT_SW_DONE_ACK) == 0U);
2ffc364a:	07cb      	lsls	r3, r1, #31
2ffc364c:	d5f6      	bpl.n	2ffc363c <wait_sw_done_ack+0x38>

  return HAL_OK;
2ffc364e:	2000      	movs	r0, #0
2ffc3650:	e000      	b.n	2ffc3654 <wait_sw_done_ack+0x50>
      return HAL_TIMEOUT; /* Timeout initialising DRAM */
2ffc3652:	2003      	movs	r0, #3
}
2ffc3654:	b002      	add	sp, #8
2ffc3656:	4770      	bx	lr

2ffc3658 <wait_operating_mode>:
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3658:	f241 7310 	movw	r3, #5904	@ 0x1710
2ffc365c:	f64d 6283 	movw	r2, #56963	@ 0xde83
2ffc3660:	f6c2 73fd 	movt	r3, #12285	@ 0x2ffd

/* Wait quasi dynamic register update */
static HAL_StatusTypeDef wait_operating_mode(uint32_t mode)
{
2ffc3664:	b082      	sub	sp, #8
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3666:	f2c4 321b 	movt	r2, #17179	@ 0x431b
  __IO uint32_t wait_loop_index = 0U;
2ffc366a:	2100      	movs	r1, #0
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc366c:	681b      	ldr	r3, [r3, #0]
  for (; ;)
  {
    uint32_t operating_mode;
    uint32_t selref_type;

    stat = READ_REG(DDRCTRL->STAT);
2ffc366e:	f44f 5c40 	mov.w	ip, #12288	@ 0x3000
  __IO uint32_t wait_loop_index = 0U;
2ffc3672:	9101      	str	r1, [sp, #4]
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3674:	fba2 2303 	umull	r2, r3, r2, r3
    stat = READ_REG(DDRCTRL->STAT);
2ffc3678:	f6c5 2c00 	movt	ip, #23040	@ 0x5a00
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc367c:	0cdb      	lsrs	r3, r3, #19
2ffc367e:	9301      	str	r3, [sp, #4]
  return wait_loop_index;
2ffc3680:	9b01      	ldr	r3, [sp, #4]
  __IO uint32_t timeout = ddr_timeout_init_us(DDR_TIMEOUT_1_US);
2ffc3682:	9300      	str	r3, [sp, #0]
    stat = READ_REG(DDRCTRL->STAT);
2ffc3684:	f8dc 3004 	ldr.w	r3, [ip, #4]
    operating_mode = stat & DDRCTRL_STAT_OPERATING_MODE_Msk;
    selref_type = stat & DDRCTRL_STAT_SELFREF_TYPE_Msk;

    timeout--;
2ffc3688:	9a00      	ldr	r2, [sp, #0]
2ffc368a:	3a01      	subs	r2, #1
2ffc368c:	9200      	str	r2, [sp, #0]
    if (ddr_timeout_elapsed(timeout))
2ffc368e:	9a00      	ldr	r2, [sp, #0]
  if (timeout == 0U)
2ffc3690:	b1fa      	cbz	r2, 2ffc36d2 <wait_operating_mode+0x7a>
    operating_mode = stat & DDRCTRL_STAT_OPERATING_MODE_Msk;
2ffc3692:	f003 0207 	and.w	r2, r3, #7
    selref_type = stat & DDRCTRL_STAT_SELFREF_TYPE_Msk;
2ffc3696:	f003 0330 	and.w	r3, r3, #48	@ 0x30
    {
      return HAL_TIMEOUT; /* Timeout initialising DRAM */
    }

    if (mode == DDRCTRL_STAT_OPERATING_MODE_SR)
2ffc369a:	2803      	cmp	r0, #3
2ffc369c:	d01c      	beq.n	2ffc36d8 <wait_operating_mode+0x80>
          && (selref_type == DDRCTRL_STAT_SELFREF_TYPE_SR))
      {
        break_loop = 1U;
      }
    }
    else if (operating_mode == mode)
2ffc369e:	4290      	cmp	r0, r2
2ffc36a0:	d01e      	beq.n	2ffc36e0 <wait_operating_mode+0x88>
    {
      break_loop = 1U;
    }
    else if ((mode == DDRCTRL_STAT_OPERATING_MODE_NORMAL)
             && (operating_mode == DDRCTRL_STAT_OPERATING_MODE_SR)
             && (selref_type == DDRCTRL_STAT_SELFREF_TYPE_ASR))
2ffc36a2:	2a03      	cmp	r2, #3
2ffc36a4:	bf08      	it	eq
2ffc36a6:	2b30      	cmpeq	r3, #48	@ 0x30
2ffc36a8:	bf0c      	ite	eq
2ffc36aa:	2201      	moveq	r2, #1
2ffc36ac:	2200      	movne	r2, #0
2ffc36ae:	2801      	cmp	r0, #1
2ffc36b0:	bf14      	ite	ne
2ffc36b2:	2200      	movne	r2, #0
2ffc36b4:	f002 0201 	andeq.w	r2, r2, #1
2ffc36b8:	b992      	cbnz	r2, 2ffc36e0 <wait_operating_mode+0x88>
    stat = READ_REG(DDRCTRL->STAT);
2ffc36ba:	f8dc 3004 	ldr.w	r3, [ip, #4]
    timeout--;
2ffc36be:	9900      	ldr	r1, [sp, #0]
    operating_mode = stat & DDRCTRL_STAT_OPERATING_MODE_Msk;
2ffc36c0:	f003 0207 	and.w	r2, r3, #7
    selref_type = stat & DDRCTRL_STAT_SELFREF_TYPE_Msk;
2ffc36c4:	f003 0330 	and.w	r3, r3, #48	@ 0x30
    timeout--;
2ffc36c8:	3901      	subs	r1, #1
2ffc36ca:	9100      	str	r1, [sp, #0]
    if (ddr_timeout_elapsed(timeout))
2ffc36cc:	9900      	ldr	r1, [sp, #0]
  if (timeout == 0U)
2ffc36ce:	2900      	cmp	r1, #0
2ffc36d0:	d1e3      	bne.n	2ffc369a <wait_operating_mode+0x42>
      return HAL_TIMEOUT; /* Timeout initialising DRAM */
2ffc36d2:	2003      	movs	r0, #3
      break;
    }
  }

  return HAL_OK;
}
2ffc36d4:	b002      	add	sp, #8
2ffc36d6:	4770      	bx	lr
      if ((operating_mode == DDRCTRL_STAT_OPERATING_MODE_SR)
2ffc36d8:	2a03      	cmp	r2, #3
2ffc36da:	bf08      	it	eq
2ffc36dc:	2b20      	cmpeq	r3, #32
2ffc36de:	d1ec      	bne.n	2ffc36ba <wait_operating_mode+0x62>
  return HAL_OK;
2ffc36e0:	2000      	movs	r0, #0
}
2ffc36e2:	b002      	add	sp, #8
2ffc36e4:	4770      	bx	lr
2ffc36e6:	bf00      	nop

2ffc36e8 <disable_axi_port>:
static int32_t disable_axi_port(void)
{
  __IO uint32_t timeout;

  /* Disable uMCTL2 AXI port 0 */
  CLEAR_BIT(DDRCTRL->PCTRL_0, DDRCTRL_PCTRL_0_PORT_EN);
2ffc36e8:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc36ec:	f241 7310 	movw	r3, #5904	@ 0x1710
  CLEAR_BIT(DDRCTRL->PCTRL_0, DDRCTRL_PCTRL_0_PORT_EN);
2ffc36f0:	f6c5 2200 	movt	r2, #23040	@ 0x5a00
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc36f4:	f64d 6183 	movw	r1, #56963	@ 0xde83
2ffc36f8:	f6c2 73fd 	movt	r3, #12285	@ 0x2ffd
2ffc36fc:	f244 2c40 	movw	ip, #16960	@ 0x4240
  CLEAR_BIT(DDRCTRL->PCTRL_0, DDRCTRL_PCTRL_0_PORT_EN);
2ffc3700:	f8d2 0490 	ldr.w	r0, [r2, #1168]	@ 0x490
{
2ffc3704:	b082      	sub	sp, #8
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3706:	f2c4 311b 	movt	r1, #17179	@ 0x431b
  CLEAR_BIT(DDRCTRL->PCTRL_0, DDRCTRL_PCTRL_0_PORT_EN);
2ffc370a:	f020 0001 	bic.w	r0, r0, #1
2ffc370e:	f8c2 0490 	str.w	r0, [r2, #1168]	@ 0x490
#ifdef DDR_DUAL_AXI_PORT
  CLEAR_BIT(DDRCTRL->PCTRL_1, DDRCTRL_PCTRL_0_PORT_EN);
2ffc3712:	f8d2 0540 	ldr.w	r0, [r2, #1344]	@ 0x540
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3716:	f2c0 0c0f 	movt	ip, #15
  CLEAR_BIT(DDRCTRL->PCTRL_1, DDRCTRL_PCTRL_0_PORT_EN);
2ffc371a:	f020 0001 	bic.w	r0, r0, #1
2ffc371e:	f8c2 0540 	str.w	r0, [r2, #1344]	@ 0x540
  __IO uint32_t wait_loop_index = 0U;
2ffc3722:	2000      	movs	r0, #0
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3724:	681b      	ldr	r3, [r3, #0]
  __IO uint32_t wait_loop_index = 0U;
2ffc3726:	9001      	str	r0, [sp, #4]
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3728:	fba1 1303 	umull	r1, r3, r1, r3
2ffc372c:	0cdb      	lsrs	r3, r3, #19
2ffc372e:	fb0c f303 	mul.w	r3, ip, r3
2ffc3732:	9301      	str	r3, [sp, #4]
  return wait_loop_index;
2ffc3734:	9b01      	ldr	r3, [sp, #4]

  /* Waits unit all AXI ports are idle
   * Poll PSTAT.rd_port_busy_n = 0
   * Poll PSTAT.wr_port_busy_n = 0
   */
  timeout = ddr_timeout_init_us(DDR_TIMEOUT_1S);
2ffc3736:	9300      	str	r3, [sp, #0]
  while (READ_REG(DDRCTRL->PSTAT) != 0U)
2ffc3738:	f8d2 03fc 	ldr.w	r0, [r2, #1020]	@ 0x3fc
2ffc373c:	b138      	cbz	r0, 2ffc374e <disable_axi_port+0x66>
  {
    timeout--;
2ffc373e:	9b00      	ldr	r3, [sp, #0]
2ffc3740:	3b01      	subs	r3, #1
2ffc3742:	9300      	str	r3, [sp, #0]
    if (ddr_timeout_elapsed(timeout))
2ffc3744:	9b00      	ldr	r3, [sp, #0]
  if (timeout == 0U)
2ffc3746:	2b00      	cmp	r3, #0
2ffc3748:	d1f6      	bne.n	2ffc3738 <disable_axi_port+0x50>
    {
      return -1;
2ffc374a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    }
  }

  return 0;
}
2ffc374e:	b002      	add	sp, #8
2ffc3750:	4770      	bx	lr
2ffc3752:	bf00      	nop

2ffc3754 <disable_host_interface>:
{
  __IO uint32_t timeout;
  uint32_t dbgcam;
  uint32_t count = 0;

  SET_BIT(DDRCTRL->DBG1, DDRCTRL_DBG1_DIS_HIF);
2ffc3754:	f44f 5c40 	mov.w	ip, #12288	@ 0x3000
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3758:	f241 7310 	movw	r3, #5904	@ 0x1710
  SET_BIT(DDRCTRL->DBG1, DDRCTRL_DBG1_DIS_HIF);
2ffc375c:	f6c5 2c00 	movt	ip, #23040	@ 0x5a00
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3760:	f64d 6183 	movw	r1, #56963	@ 0xde83
2ffc3764:	f6c2 73fd 	movt	r3, #12285	@ 0x2ffd
2ffc3768:	f244 2040 	movw	r0, #16960	@ 0x4240
  SET_BIT(DDRCTRL->DBG1, DDRCTRL_DBG1_DIS_HIF);
2ffc376c:	f8dc 2304 	ldr.w	r2, [ip, #772]	@ 0x304
{
2ffc3770:	b082      	sub	sp, #8
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3772:	f2c4 311b 	movt	r1, #17179	@ 0x431b
2ffc3776:	f2c0 000f 	movt	r0, #15
  SET_BIT(DDRCTRL->DBG1, DDRCTRL_DBG1_DIS_HIF);
2ffc377a:	f042 0202 	orr.w	r2, r2, #2
2ffc377e:	f8cc 2304 	str.w	r2, [ip, #772]	@ 0x304
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3782:	681a      	ldr	r2, [r3, #0]
  __IO uint32_t wait_loop_index = 0U;
2ffc3784:	2300      	movs	r3, #0
2ffc3786:	9301      	str	r3, [sp, #4]
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3788:	fba1 1202 	umull	r1, r2, r1, r2
2ffc378c:	0cd2      	lsrs	r2, r2, #19
2ffc378e:	fb00 f202 	mul.w	r2, r0, r2
2ffc3792:	9201      	str	r2, [sp, #4]
  return wait_loop_index;
2ffc3794:	9a01      	ldr	r2, [sp, #4]
   * Poll DBGCAM.dbg_rd_data_pipeline_empty = 1
   *
   * data_pipeline fields must be polled twice to ensure
   * value propoagation, so count is added to loop condition.
   */
  timeout = ddr_timeout_init_us(DDR_TIMEOUT_1S);
2ffc3796:	9200      	str	r2, [sp, #0]
  do
  {
    dbgcam = READ_REG(DDRCTRL->DBGCAM);
2ffc3798:	f8dc 2308 	ldr.w	r2, [ip, #776]	@ 0x308
    timeout--;
    if (ddr_timeout_elapsed(timeout))
    {
      return -1;
    }
    count++;
2ffc379c:	3301      	adds	r3, #1
    timeout--;
2ffc379e:	9900      	ldr	r1, [sp, #0]
  } while (((dbgcam & DDRCTRL_DBG_Q_AND_DATA_PIPELINE_EMPTY) !=
            DDRCTRL_DBG_Q_AND_DATA_PIPELINE_EMPTY) || (count < 2U));
2ffc37a0:	2b01      	cmp	r3, #1
  } while (((dbgcam & DDRCTRL_DBG_Q_AND_DATA_PIPELINE_EMPTY) !=
2ffc37a2:	f002 5258 	and.w	r2, r2, #905969664	@ 0x36000000
            DDRCTRL_DBG_Q_AND_DATA_PIPELINE_EMPTY) || (count < 2U));
2ffc37a6:	bf88      	it	hi
2ffc37a8:	2000      	movhi	r0, #0
    timeout--;
2ffc37aa:	f101 31ff 	add.w	r1, r1, #4294967295	@ 0xffffffff
            DDRCTRL_DBG_Q_AND_DATA_PIPELINE_EMPTY) || (count < 2U));
2ffc37ae:	bf98      	it	ls
2ffc37b0:	2001      	movls	r0, #1
    timeout--;
2ffc37b2:	9100      	str	r1, [sp, #0]
    if (ddr_timeout_elapsed(timeout))
2ffc37b4:	9900      	ldr	r1, [sp, #0]
            DDRCTRL_DBG_Q_AND_DATA_PIPELINE_EMPTY) || (count < 2U));
2ffc37b6:	f1b2 5f58 	cmp.w	r2, #905969664	@ 0x36000000
2ffc37ba:	bf18      	it	ne
2ffc37bc:	f040 0001 	orrne.w	r0, r0, #1
  if (timeout == 0U)
2ffc37c0:	b119      	cbz	r1, 2ffc37ca <disable_host_interface+0x76>
            DDRCTRL_DBG_Q_AND_DATA_PIPELINE_EMPTY) || (count < 2U));
2ffc37c2:	2800      	cmp	r0, #0
2ffc37c4:	d1e8      	bne.n	2ffc3798 <disable_host_interface+0x44>

  return 0;
}
2ffc37c6:	b002      	add	sp, #8
2ffc37c8:	4770      	bx	lr
      return -1;
2ffc37ca:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
2ffc37ce:	b002      	add	sp, #8
2ffc37d0:	4770      	bx	lr
2ffc37d2:	bf00      	nop

2ffc37d4 <wait_refresh_update_done_ack>:
  __IO uint32_t timeout;
  uint32_t rfshctl3;
  uint32_t refresh_update_level  = DDRCTRL_RFSHCTL3_REFRESH_UPDATE_LEVEL;

  /* Toggle rfshctl3.refresh_update_level */
  rfshctl3 = READ_REG(DDRCTRL->RFSHCTL3);
2ffc37d4:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc37d8:	f244 2c40 	movw	ip, #16960	@ 0x4240
  rfshctl3 = READ_REG(DDRCTRL->RFSHCTL3);
2ffc37dc:	f6c5 2300 	movt	r3, #23040	@ 0x5a00
{
2ffc37e0:	b082      	sub	sp, #8
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc37e2:	f2c0 0c0f 	movt	ip, #15
  __IO uint32_t wait_loop_index = 0U;
2ffc37e6:	2000      	movs	r0, #0
  rfshctl3 = READ_REG(DDRCTRL->RFSHCTL3);
2ffc37e8:	6e19      	ldr	r1, [r3, #96]	@ 0x60
  if ((rfshctl3 & refresh_update_level) == refresh_update_level)
  {
    SET_BIT(DDRCTRL->RFSHCTL3, refresh_update_level);
2ffc37ea:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
  if ((rfshctl3 & refresh_update_level) == refresh_update_level)
2ffc37ec:	f011 0102 	ands.w	r1, r1, #2
  }
  else
  {
    CLEAR_BIT(DDRCTRL->RFSHCTL3, refresh_update_level);
2ffc37f0:	bf0e      	itee	eq
2ffc37f2:	f022 0202 	biceq.w	r2, r2, #2
  uint32_t refresh_update_level  = DDRCTRL_RFSHCTL3_REFRESH_UPDATE_LEVEL;
2ffc37f6:	2102      	movne	r1, #2
    SET_BIT(DDRCTRL->RFSHCTL3, refresh_update_level);
2ffc37f8:	430a      	orrne	r2, r1
    CLEAR_BIT(DDRCTRL->RFSHCTL3, refresh_update_level);
2ffc37fa:	661a      	str	r2, [r3, #96]	@ 0x60
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc37fc:	f241 7310 	movw	r3, #5904	@ 0x1710
2ffc3800:	f6c2 73fd 	movt	r3, #12285	@ 0x2ffd
2ffc3804:	f64d 6283 	movw	r2, #56963	@ 0xde83
2ffc3808:	f2c4 321b 	movt	r2, #17179	@ 0x431b
2ffc380c:	681b      	ldr	r3, [r3, #0]
  __IO uint32_t wait_loop_index = 0U;
2ffc380e:	9001      	str	r0, [sp, #4]
  }

  timeout = ddr_timeout_init_us(DDR_TIMEOUT_1S);
  do
  {
    rfshctl3 = READ_REG(DDRCTRL->RFSHCTL3);
2ffc3810:	f44f 5040 	mov.w	r0, #12288	@ 0x3000
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3814:	fba2 2303 	umull	r2, r3, r2, r3
    rfshctl3 = READ_REG(DDRCTRL->RFSHCTL3);
2ffc3818:	f6c5 2000 	movt	r0, #23040	@ 0x5a00
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc381c:	0cdb      	lsrs	r3, r3, #19
2ffc381e:	fb0c f303 	mul.w	r3, ip, r3
2ffc3822:	9301      	str	r3, [sp, #4]
  return wait_loop_index;
2ffc3824:	9b01      	ldr	r3, [sp, #4]
  timeout = ddr_timeout_init_us(DDR_TIMEOUT_1S);
2ffc3826:	9300      	str	r3, [sp, #0]
    rfshctl3 = READ_REG(DDRCTRL->RFSHCTL3);
2ffc3828:	6e02      	ldr	r2, [r0, #96]	@ 0x60
    timeout--;
2ffc382a:	9b00      	ldr	r3, [sp, #0]

    if (ddr_timeout_elapsed(timeout))
    {
      return -1;
    }
  } while ((rfshctl3 & DDRCTRL_RFSHCTL3_REFRESH_UPDATE_LEVEL) !=
2ffc382c:	f002 0202 	and.w	r2, r2, #2
    timeout--;
2ffc3830:	3b01      	subs	r3, #1
2ffc3832:	9300      	str	r3, [sp, #0]
    if (ddr_timeout_elapsed(timeout))
2ffc3834:	9b00      	ldr	r3, [sp, #0]
  if (timeout == 0U)
2ffc3836:	b11b      	cbz	r3, 2ffc3840 <wait_refresh_update_done_ack+0x6c>
  } while ((rfshctl3 & DDRCTRL_RFSHCTL3_REFRESH_UPDATE_LEVEL) !=
2ffc3838:	428a      	cmp	r2, r1
2ffc383a:	d1f5      	bne.n	2ffc3828 <wait_refresh_update_done_ack+0x54>
           refresh_update_level);

  return 0;
2ffc383c:	2000      	movs	r0, #0
2ffc383e:	e001      	b.n	2ffc3844 <wait_refresh_update_done_ack+0x70>
      return -1;
2ffc3840:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
2ffc3844:	b002      	add	sp, #8
2ffc3846:	4770      	bx	lr

2ffc3848 <mode_register_write>:
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3848:	f241 7210 	movw	r2, #5904	@ 0x1710
2ffc384c:	f64d 6383 	movw	r3, #56963	@ 0xde83
2ffc3850:	f6c2 72fd 	movt	r2, #12285	@ 0x2ffd

/* Mode Register Writes (MRW or MRS) */
static HAL_StatusTypeDef mode_register_write(uint32_t addr, uint32_t data)
{
2ffc3854:	b430      	push	{r4, r5}
2ffc3856:	b084      	sub	sp, #16
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3858:	6814      	ldr	r4, [r2, #0]
2ffc385a:	f44f 6254 	mov.w	r2, #3392	@ 0xd40
2ffc385e:	f2c4 331b 	movt	r3, #17179	@ 0x431b
  __IO uint32_t wait_loop_index = 0U;
2ffc3862:	2500      	movs	r5, #0
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3864:	fba3 3404 	umull	r3, r4, r3, r4
2ffc3868:	f2c0 0203 	movt	r2, #3
2ffc386c:	0ce4      	lsrs	r4, r4, #19
2ffc386e:	fb02 f404 	mul.w	r4, r2, r4
  __IO uint32_t wait_loop_index = 0U;
2ffc3872:	9502      	str	r5, [sp, #8]
   * 1. Poll MRSTAT.mr_wr_busy until it is '0'.
   *    This checks that there is no outstanding MR transaction.
   *    No write should be performed to MRCTRL0 and MRCTRL1
   *    if MRSTAT.mr_wr_busy = 1.
   */
  while ((READ_REG(DDRCTRL->MRSTAT) & DDRCTRL_MRSTAT_MR_WR_BUSY) != 0U)
2ffc3874:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3878:	9402      	str	r4, [sp, #8]
  return wait_loop_index;
2ffc387a:	9b02      	ldr	r3, [sp, #8]
  while ((READ_REG(DDRCTRL->MRSTAT) & DDRCTRL_MRSTAT_MR_WR_BUSY) != 0U)
2ffc387c:	f6c5 2200 	movt	r2, #23040	@ 0x5a00
  __IO uint32_t timeout = ddr_timeout_init_us(DDR_TIMEOUT_200_MS);
2ffc3880:	9301      	str	r3, [sp, #4]
  while ((READ_REG(DDRCTRL->MRSTAT) & DDRCTRL_MRSTAT_MR_WR_BUSY) != 0U)
2ffc3882:	6993      	ldr	r3, [r2, #24]
2ffc3884:	f013 0301 	ands.w	r3, r3, #1
2ffc3888:	d009      	beq.n	2ffc389e <mode_register_write+0x56>
  {
    timeout--;
2ffc388a:	9b01      	ldr	r3, [sp, #4]
2ffc388c:	3b01      	subs	r3, #1
2ffc388e:	9301      	str	r3, [sp, #4]
    if (ddr_timeout_elapsed(timeout))
2ffc3890:	9b01      	ldr	r3, [sp, #4]
  if (timeout == 0U)
2ffc3892:	2b00      	cmp	r3, #0
2ffc3894:	d1f5      	bne.n	2ffc3882 <mode_register_write+0x3a>
    {
      return HAL_TIMEOUT;
2ffc3896:	2003      	movs	r0, #3
      return HAL_TIMEOUT;
    }
  }

  return HAL_OK;
}
2ffc3898:	b004      	add	sp, #16
2ffc389a:	bc30      	pop	{r4, r5}
2ffc389c:	4770      	bx	lr
            | ((addr << DDRCTRL_MRCTRL0_MR_ADDR_Pos)
2ffc389e:	0300      	lsls	r0, r0, #12
  while ((READ_REG(DDRCTRL->MRSTAT) & DDRCTRL_MRSTAT_MR_WR_BUSY) != 0U)
2ffc38a0:	f44f 5c40 	mov.w	ip, #12288	@ 0x3000
2ffc38a4:	f6c5 2c00 	movt	ip, #23040	@ 0x5a00
  mrctrl0 |= DDRCTRL_MRCTRL0_MR_WR;
2ffc38a8:	f040 4500 	orr.w	r5, r0, #2147483648	@ 0x80000000
2ffc38ac:	f045 0510 	orr.w	r5, r5, #16
  mrctrl0 = DDRCTRL_MRCTRL0_MR_TYPE_WRITE
2ffc38b0:	f040 0010 	orr.w	r0, r0, #16
  WRITE_REG(DDRCTRL->MRCTRL0, mrctrl0);
2ffc38b4:	6110      	str	r0, [r2, #16]
  WRITE_REG(DDRCTRL->MRCTRL1, data);
2ffc38b6:	6151      	str	r1, [r2, #20]
  WRITE_REG(DDRCTRL->MRCTRL0, mrctrl0);
2ffc38b8:	6115      	str	r5, [r2, #16]
  __IO uint32_t wait_loop_index = 0U;
2ffc38ba:	9303      	str	r3, [sp, #12]
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc38bc:	9403      	str	r4, [sp, #12]
  return wait_loop_index;
2ffc38be:	9b03      	ldr	r3, [sp, #12]
  timeout = ddr_timeout_init_us(DDR_TIMEOUT_200_MS);
2ffc38c0:	9301      	str	r3, [sp, #4]
  while ((READ_REG(DDRCTRL->MRSTAT) & DDRCTRL_MRSTAT_MR_WR_BUSY) != 0U)
2ffc38c2:	f8dc 0018 	ldr.w	r0, [ip, #24]
2ffc38c6:	f010 0001 	ands.w	r0, r0, #1
2ffc38ca:	d0e5      	beq.n	2ffc3898 <mode_register_write+0x50>
    timeout--;
2ffc38cc:	9b01      	ldr	r3, [sp, #4]
2ffc38ce:	3b01      	subs	r3, #1
2ffc38d0:	9301      	str	r3, [sp, #4]
    if (ddr_timeout_elapsed(timeout))
2ffc38d2:	9b01      	ldr	r3, [sp, #4]
  if (timeout == 0U)
2ffc38d4:	2b00      	cmp	r3, #0
2ffc38d6:	d1f4      	bne.n	2ffc38c2 <mode_register_write+0x7a>
2ffc38d8:	e7dd      	b.n	2ffc3896 <mode_register_write+0x4e>
2ffc38da:	bf00      	nop

2ffc38dc <found_reg>:
{
2ffc38dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
2ffc38e0:	f24e 6a14 	movw	sl, #58900	@ 0xe614
2ffc38e4:	f6c2 7afc 	movt	sl, #12284	@ 0x2ffc
2ffc38e8:	4606      	mov	r6, r0
2ffc38ea:	4689      	mov	r9, r1
  for (i = 0; i < ARRAY_SIZE(ddr_registers); i++)
2ffc38ec:	f04f 0800 	mov.w	r8, #0
    for (j = 0; j < ddr_registers[i].size; j++)
2ffc38f0:	f89a 7008 	ldrb.w	r7, [sl, #8]
    desc = ddr_registers[i].desc;
2ffc38f4:	f8da 5004 	ldr.w	r5, [sl, #4]
    for (j = 0; j < ddr_registers[i].size; j++)
2ffc38f8:	b19f      	cbz	r7, 2ffc3922 <found_reg+0x46>
2ffc38fa:	2400      	movs	r4, #0
2ffc38fc:	e002      	b.n	2ffc3904 <found_reg+0x28>
2ffc38fe:	3401      	adds	r4, #1
2ffc3900:	42bc      	cmp	r4, r7
2ffc3902:	d00e      	beq.n	2ffc3922 <found_reg+0x46>
      if (strcmp(name, desc[j].name) == 0)
2ffc3904:	f855 1034 	ldr.w	r1, [r5, r4, lsl #3]
2ffc3908:	4630      	mov	r0, r6
2ffc390a:	f008 ea58 	blx	2ffcbdbc <strcmp>
2ffc390e:	2800      	cmp	r0, #0
2ffc3910:	d1f5      	bne.n	2ffc38fe <found_reg+0x22>
2ffc3912:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
        *type = i;
2ffc3916:	fa5f f888 	uxtb.w	r8, r8
2ffc391a:	f889 8000 	strb.w	r8, [r9]
}
2ffc391e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  for (i = 0; i < ARRAY_SIZE(ddr_registers); i++)
2ffc3922:	f108 0801 	add.w	r8, r8, #1
2ffc3926:	f10a 0a0c 	add.w	sl, sl, #12
2ffc392a:	f1b8 0f08 	cmp.w	r8, #8
2ffc392e:	d1df      	bne.n	2ffc38f0 <found_reg+0x14>
  return NULL;
2ffc3930:	2000      	movs	r0, #0
2ffc3932:	e7f2      	b.n	2ffc391a <found_reg+0x3e>

2ffc3934 <dump_reg_desc>:
{
2ffc3934:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
2ffc3938:	b08e      	sub	sp, #56	@ 0x38
  char reg_name[strlen(desc->name)];
2ffc393a:	680e      	ldr	r6, [r1, #0]
{
2ffc393c:	af00      	add	r7, sp, #0
2ffc393e:	4605      	mov	r5, r0
2ffc3940:	460c      	mov	r4, r1
  char reg_name[strlen(desc->name)];
2ffc3942:	4630      	mov	r0, r6
{
2ffc3944:	4690      	mov	r8, r2
  char reg_name[strlen(desc->name)];
2ffc3946:	f008 fa5c 	bl	2ffcbe02 <strlen>
  char output_dest[50] = "";
2ffc394a:	efc0 0050 	vmov.i32	q8, #0	@ 0x00000000
2ffc394e:	2300      	movs	r3, #0
  char reg_name[strlen(desc->name)];
2ffc3950:	3007      	adds	r0, #7
  char output_dest[50] = "";
2ffc3952:	607b      	str	r3, [r7, #4]
2ffc3954:	f107 0308 	add.w	r3, r7, #8
  char reg_name[strlen(desc->name)];
2ffc3958:	f020 0007 	bic.w	r0, r0, #7
  char output_dest[50] = "";
2ffc395c:	f943 0a0f 	vst1.8	{d16-d17}, [r3]
  char reg_name[strlen(desc->name)];
2ffc3960:	ebad 0d00 	sub.w	sp, sp, r0
  char output_dest[50] = "";
2ffc3964:	f107 032e 	add.w	r3, r7, #46	@ 0x2e
2ffc3968:	edc7 0b0a 	vstr	d16, [r7, #40]	@ 0x28
2ffc396c:	edc7 0b06 	vstr	d16, [r7, #24]
2ffc3970:	edc7 0b08 	vstr	d16, [r7, #32]
2ffc3974:	f943 070f 	vst1.8	{d16}, [r3]
  if (save)
2ffc3978:	f1b8 0f00 	cmp.w	r8, #0
2ffc397c:	d129      	bne.n	2ffc39d2 <dump_reg_desc+0x9e>
2ffc397e:	491a      	ldr	r1, [pc, #104]	@ (2ffc39e8 <dump_reg_desc+0xb4>)
2ffc3980:	466a      	mov	r2, sp
2ffc3982:	1e70      	subs	r0, r6, #1
2ffc3984:	f10d 3eff 	add.w	lr, sp, #4294967295	@ 0xffffffff
  while((*out_str = ToUpper? toupper(*in_str) : tolower(*in_str)))
2ffc3988:	f810 3f01 	ldrb.w	r3, [r0, #1]!
2ffc398c:	f811 c003 	ldrb.w	ip, [r1, r3]
2ffc3990:	f00c 0c03 	and.w	ip, ip, #3
2ffc3994:	f1bc 0f01 	cmp.w	ip, #1
2ffc3998:	bf04      	itt	eq
2ffc399a:	3320      	addeq	r3, #32
2ffc399c:	b2db      	uxtbeq	r3, r3
2ffc399e:	f80e 3f01 	strb.w	r3, [lr, #1]!
2ffc39a2:	2b00      	cmp	r3, #0
2ffc39a4:	d1f0      	bne.n	2ffc3988 <dump_reg_desc+0x54>
    sprintf(output_dest, "%s=", reg_name);
2ffc39a6:	f107 0804 	add.w	r8, r7, #4
2ffc39aa:	f24e 014c 	movw	r1, #57420	@ 0xe04c
2ffc39ae:	f6c2 71fc 	movt	r1, #12284	@ 0x2ffc
2ffc39b2:	4640      	mov	r0, r8
2ffc39b4:	f008 f858 	bl	2ffcba68 <siprintf>
  ptr = (uint32_t)(base_addr + desc->offset);
2ffc39b8:	88a3      	ldrh	r3, [r4, #4]
  printf("%s 0x%08lx\n\r", output_dest, READ_REG(*(volatile uint32_t*)ptr));
2ffc39ba:	f24e 0050 	movw	r0, #57424	@ 0xe050
2ffc39be:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc39c2:	4641      	mov	r1, r8
2ffc39c4:	595a      	ldr	r2, [r3, r5]
2ffc39c6:	f007 ffdf 	bl	2ffcb988 <iprintf>
}
2ffc39ca:	3738      	adds	r7, #56	@ 0x38
2ffc39cc:	46bd      	mov	sp, r7
2ffc39ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    sprintf(output_dest, "#define DDR_%s", desc->name);
2ffc39d2:	f107 0804 	add.w	r8, r7, #4
2ffc39d6:	f24e 013c 	movw	r1, #57404	@ 0xe03c
2ffc39da:	f6c2 71fc 	movt	r1, #12284	@ 0x2ffc
2ffc39de:	4632      	mov	r2, r6
2ffc39e0:	4640      	mov	r0, r8
2ffc39e2:	f008 f841 	bl	2ffcba68 <siprintf>
2ffc39e6:	e7e7      	b.n	2ffc39b8 <dump_reg_desc+0x84>
2ffc39e8:	2ffcff40 	.word	0x2ffcff40

2ffc39ec <HAL_DDR_ASS_Set_Clksrc>:
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc39ec:	f241 7310 	movw	r3, #5904	@ 0x1710
2ffc39f0:	f64d 6283 	movw	r2, #56963	@ 0xde83
2ffc39f4:	f6c2 73fd 	movt	r3, #12285	@ 0x2ffd
2ffc39f8:	f44f 6154 	mov.w	r1, #3392	@ 0xd40
2ffc39fc:	f2c4 321b 	movt	r2, #17179	@ 0x431b
2ffc3a00:	681b      	ldr	r3, [r3, #0]
2ffc3a02:	f2c0 0103 	movt	r1, #3
2ffc3a06:	fba2 2303 	umull	r2, r3, r2, r3
{
2ffc3a0a:	b410      	push	{r4}
2ffc3a0c:	b083      	sub	sp, #12
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3a0e:	0cdb      	lsrs	r3, r3, #19
  __IO uint32_t wait_loop_index = 0U;
2ffc3a10:	2400      	movs	r4, #0
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3a12:	fb01 f303 	mul.w	r3, r1, r3
  __IO uint32_t wait_loop_index = 0U;
2ffc3a16:	9401      	str	r4, [sp, #4]
  MODIFY_REG(RCC->ASSCKSELR, (RCC_ASSCKSELR_AXISSRC), clksrc);
2ffc3a18:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc3a1c:	9301      	str	r3, [sp, #4]
  return wait_loop_index;
2ffc3a1e:	9b01      	ldr	r3, [sp, #4]
  __IO uint32_t timeout = ddr_timeout_init_us(DDR_TIMEOUT_200_MS);
2ffc3a20:	9300      	str	r3, [sp, #0]
  MODIFY_REG(RCC->ASSCKSELR, (RCC_ASSCKSELR_AXISSRC), clksrc);
2ffc3a22:	6a53      	ldr	r3, [r2, #36]	@ 0x24
2ffc3a24:	f023 0307 	bic.w	r3, r3, #7
2ffc3a28:	4303      	orrs	r3, r0
2ffc3a2a:	6253      	str	r3, [r2, #36]	@ 0x24
  while ((RCC->ASSCKSELR & RCC_ASSCKSELR_AXISSRCRDY_Msk) != RCC_ASSCKSELR_AXISSRCRDY )
2ffc3a2c:	6a53      	ldr	r3, [r2, #36]	@ 0x24
2ffc3a2e:	2b00      	cmp	r3, #0
2ffc3a30:	db0a      	blt.n	2ffc3a48 <HAL_DDR_ASS_Set_Clksrc+0x5c>
    timeout--;
2ffc3a32:	9b00      	ldr	r3, [sp, #0]
2ffc3a34:	3b01      	subs	r3, #1
2ffc3a36:	9300      	str	r3, [sp, #0]
    if (ddr_timeout_elapsed(timeout))
2ffc3a38:	9b00      	ldr	r3, [sp, #0]
  if (timeout == 0U)
2ffc3a3a:	2b00      	cmp	r3, #0
2ffc3a3c:	d1f6      	bne.n	2ffc3a2c <HAL_DDR_ASS_Set_Clksrc+0x40>
      return HAL_TIMEOUT; /* Timeout setting clock source */
2ffc3a3e:	2003      	movs	r0, #3
}
2ffc3a40:	b003      	add	sp, #12
2ffc3a42:	f85d 4b04 	ldr.w	r4, [sp], #4
2ffc3a46:	4770      	bx	lr
  return HAL_OK;
2ffc3a48:	2000      	movs	r0, #0
}
2ffc3a4a:	b003      	add	sp, #12
2ffc3a4c:	f85d 4b04 	ldr.w	r4, [sp], #4
2ffc3a50:	4770      	bx	lr
2ffc3a52:	bf00      	nop

2ffc3a54 <HAL_DDR_Convert_Case>:
{
2ffc3a54:	b410      	push	{r4}
2ffc3a56:	3801      	subs	r0, #1
2ffc3a58:	4c0f      	ldr	r4, [pc, #60]	@ (2ffc3a98 <HAL_DDR_Convert_Case+0x44>)
2ffc3a5a:	3901      	subs	r1, #1
  while((*out_str = ToUpper? toupper(*in_str) : tolower(*in_str)))
2ffc3a5c:	e007      	b.n	2ffc3a6e <HAL_DDR_Convert_Case+0x1a>
2ffc3a5e:	f1bc 0f02 	cmp.w	ip, #2
2ffc3a62:	bf04      	itt	eq
2ffc3a64:	3b20      	subeq	r3, #32
2ffc3a66:	b2db      	uxtbeq	r3, r3
2ffc3a68:	f801 3f01 	strb.w	r3, [r1, #1]!
2ffc3a6c:	b183      	cbz	r3, 2ffc3a90 <HAL_DDR_Convert_Case+0x3c>
2ffc3a6e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
2ffc3a72:	f814 c003 	ldrb.w	ip, [r4, r3]
2ffc3a76:	f00c 0c03 	and.w	ip, ip, #3
2ffc3a7a:	2a00      	cmp	r2, #0
2ffc3a7c:	d1ef      	bne.n	2ffc3a5e <HAL_DDR_Convert_Case+0xa>
2ffc3a7e:	f1bc 0f01 	cmp.w	ip, #1
2ffc3a82:	bf04      	itt	eq
2ffc3a84:	3320      	addeq	r3, #32
2ffc3a86:	b2db      	uxtbeq	r3, r3
2ffc3a88:	f801 3f01 	strb.w	r3, [r1, #1]!
2ffc3a8c:	2b00      	cmp	r3, #0
2ffc3a8e:	d1ee      	bne.n	2ffc3a6e <HAL_DDR_Convert_Case+0x1a>
}
2ffc3a90:	f85d 4b04 	ldr.w	r4, [sp], #4
2ffc3a94:	4770      	bx	lr
2ffc3a96:	bf00      	nop
2ffc3a98:	2ffcff40 	.word	0x2ffcff40

2ffc3a9c <HAL_DDR_Dump_Reg>:
{
2ffc3a9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
2ffc3aa0:	b089      	sub	sp, #36	@ 0x24
    if (!name || (filter == p_base || !strcmp(name, p_name)) || save)
2ffc3aa2:	fab0 fa80 	clz	sl, r0
  if (save) {
2ffc3aa6:	460f      	mov	r7, r1
    if (!name || (filter == p_base || !strcmp(name, p_name)) || save)
2ffc3aa8:	9001      	str	r0, [sp, #4]
2ffc3aaa:	ea4f 1a5a 	mov.w	sl, sl, lsr #5
  if (save) {
2ffc3aae:	2900      	cmp	r1, #0
2ffc3ab0:	f040 80c0 	bne.w	2ffc3c34 <HAL_DDR_Dump_Reg+0x198>
    if (name) {
2ffc3ab4:	9b01      	ldr	r3, [sp, #4]
2ffc3ab6:	b193      	cbz	r3, 2ffc3ade <HAL_DDR_Dump_Reg+0x42>
      if (strcmp(name, base_name[BASE_DDRCTRL]) == 0)
2ffc3ab8:	f241 741c 	movw	r4, #5916	@ 0x171c
2ffc3abc:	f6c2 74fd 	movt	r4, #12285	@ 0x2ffd
2ffc3ac0:	f8d4 115c 	ldr.w	r1, [r4, #348]	@ 0x15c
2ffc3ac4:	f008 e97a 	blx	2ffcbdbc <strcmp>
2ffc3ac8:	2800      	cmp	r0, #0
2ffc3aca:	f000 80d3 	beq.w	2ffc3c74 <HAL_DDR_Dump_Reg+0x1d8>
      else if (strcmp(name, base_name[BASE_DDRPHYC]) == 0)
2ffc3ace:	f8d4 1160 	ldr.w	r1, [r4, #352]	@ 0x160
2ffc3ad2:	9801      	ldr	r0, [sp, #4]
2ffc3ad4:	f008 e972 	blx	2ffcbdbc <strcmp>
2ffc3ad8:	2800      	cmp	r0, #0
2ffc3ada:	f000 80cd 	beq.w	2ffc3c78 <HAL_DDR_Dump_Reg+0x1dc>
  base_type filter = BASE_NONE;
2ffc3ade:	2302      	movs	r3, #2
2ffc3ae0:	9300      	str	r3, [sp, #0]
  for (i = 0; i < ARRAY_SIZE(ddr_registers); i++)
2ffc3ae2:	f24e 6614 	movw	r6, #58900	@ 0xe614
        printf("\n/* %s.%s */\n\r", base_name[p_base], p_name);
2ffc3ae6:	f241 711c 	movw	r1, #5916	@ 0x171c
2ffc3aea:	f6c2 76fc 	movt	r6, #12284	@ 0x2ffc
2ffc3aee:	f24e 1e24 	movw	lr, #57636	@ 0xe124
2ffc3af2:	f6c2 71fd 	movt	r1, #12285	@ 0x2ffd
    return (uint32_t)DDRCTRL_BASE;
2ffc3af6:	f44f 4c80 	mov.w	ip, #16384	@ 0x4000
        printf("\n/* %s.%s */\n\r", base_name[p_base], p_name);
2ffc3afa:	f6c2 7efc 	movt	lr, #12284	@ 0x2ffc
        filter = BASE_DDRCTRL;
2ffc3afe:	2400      	movs	r4, #0
    return (uint32_t)DDRCTRL_BASE;
2ffc3b00:	f6c5 2c00 	movt	ip, #23040	@ 0x5a00
2ffc3b04:	46b1      	mov	r9, r6
  for (i = 0; i < ARRAY_SIZE(ddr_registers); i++)
2ffc3b06:	9605      	str	r6, [sp, #20]
  HAL_StatusTypeDef result = HAL_ERROR;
2ffc3b08:	2501      	movs	r5, #1
  for (i = 0; i < ARRAY_SIZE(ddr_registers); i++)
2ffc3b0a:	9102      	str	r1, [sp, #8]
2ffc3b0c:	46a0      	mov	r8, r4
2ffc3b0e:	46a3      	mov	fp, r4
2ffc3b10:	e9cd ce03 	strd	ip, lr, [sp, #12]
2ffc3b14:	e00f      	b.n	2ffc3b36 <HAL_DDR_Dump_Reg+0x9a>
    if (!name || (filter == p_base || !strcmp(name, p_name)) || save)
2ffc3b16:	9801      	ldr	r0, [sp, #4]
2ffc3b18:	4631      	mov	r1, r6
2ffc3b1a:	f008 e950 	blx	2ffcbdbc <strcmp>
2ffc3b1e:	b1a0      	cbz	r0, 2ffc3b4a <HAL_DDR_Dump_Reg+0xae>
2ffc3b20:	2f00      	cmp	r7, #0
2ffc3b22:	d155      	bne.n	2ffc3bd0 <HAL_DDR_Dump_Reg+0x134>
  for (i = 0; i < ARRAY_SIZE(ddr_registers); i++)
2ffc3b24:	f108 0801 	add.w	r8, r8, #1
2ffc3b28:	f109 090c 	add.w	r9, r9, #12
2ffc3b2c:	f1b8 0f08 	cmp.w	r8, #8
2ffc3b30:	d03a      	beq.n	2ffc3ba8 <HAL_DDR_Dump_Reg+0x10c>
    p_base = ddr_registers[i].base;
2ffc3b32:	f899 b009 	ldrb.w	fp, [r9, #9]
    if (!name || (filter == p_base || !strcmp(name, p_name)) || save)
2ffc3b36:	9b00      	ldr	r3, [sp, #0]
    p_name = ddr_registers[i].name;
2ffc3b38:	f8d9 6000 	ldr.w	r6, [r9]
    if (!name || (filter == p_base || !strcmp(name, p_name)) || save)
2ffc3b3c:	455b      	cmp	r3, fp
2ffc3b3e:	bf14      	ite	ne
2ffc3b40:	4651      	movne	r1, sl
2ffc3b42:	f04a 0101 	orreq.w	r1, sl, #1
2ffc3b46:	2900      	cmp	r1, #0
2ffc3b48:	d0e5      	beq.n	2ffc3b16 <HAL_DDR_Dump_Reg+0x7a>
    return (uint32_t)DDRCTRL_BASE;
2ffc3b4a:	9b03      	ldr	r3, [sp, #12]
2ffc3b4c:	f44f 5540 	mov.w	r5, #12288	@ 0x3000
2ffc3b50:	f6c5 2500 	movt	r5, #23040	@ 0x5a00
      desc = ddr_registers[i].desc;
2ffc3b54:	f8d9 4004 	ldr.w	r4, [r9, #4]
    return (uint32_t)DDRCTRL_BASE;
2ffc3b58:	f1bb 0f01 	cmp.w	fp, #1
2ffc3b5c:	bf08      	it	eq
2ffc3b5e:	461d      	moveq	r5, r3
      if (save)
2ffc3b60:	b34f      	cbz	r7, 2ffc3bb6 <HAL_DDR_Dump_Reg+0x11a>
        if (i == REG_DYN)
2ffc3b62:	f1b8 0f06 	cmp.w	r8, #6
2ffc3b66:	d041      	beq.n	2ffc3bec <HAL_DDR_Dump_Reg+0x150>
        printf("\n/* %s.%s */\n\r", base_name[p_base], p_name);
2ffc3b68:	9b02      	ldr	r3, [sp, #8]
2ffc3b6a:	4632      	mov	r2, r6
2ffc3b6c:	9804      	ldr	r0, [sp, #16]
2ffc3b6e:	eb03 038b 	add.w	r3, r3, fp, lsl #2
2ffc3b72:	f8d3 115c 	ldr.w	r1, [r3, #348]	@ 0x15c
2ffc3b76:	f007 ff07 	bl	2ffcb988 <iprintf>
      for (j = 0; j < ddr_registers[i].size; j++)
2ffc3b7a:	f899 6008 	ldrb.w	r6, [r9, #8]
2ffc3b7e:	f04f 0b00 	mov.w	fp, #0
2ffc3b82:	b14e      	cbz	r6, 2ffc3b98 <HAL_DDR_Dump_Reg+0xfc>
        dump_reg_desc(base_addr, &desc[j], save);
2ffc3b84:	4621      	mov	r1, r4
      for (j = 0; j < ddr_registers[i].size; j++)
2ffc3b86:	f10b 0b01 	add.w	fp, fp, #1
        dump_reg_desc(base_addr, &desc[j], save);
2ffc3b8a:	463a      	mov	r2, r7
2ffc3b8c:	4628      	mov	r0, r5
      for (j = 0; j < ddr_registers[i].size; j++)
2ffc3b8e:	3408      	adds	r4, #8
        dump_reg_desc(base_addr, &desc[j], save);
2ffc3b90:	f7ff fed0 	bl	2ffc3934 <dump_reg_desc>
      for (j = 0; j < ddr_registers[i].size; j++)
2ffc3b94:	45b3      	cmp	fp, r6
2ffc3b96:	d1f5      	bne.n	2ffc3b84 <HAL_DDR_Dump_Reg+0xe8>
  for (i = 0; i < ARRAY_SIZE(ddr_registers); i++)
2ffc3b98:	f108 0801 	add.w	r8, r8, #1
      result = HAL_OK;
2ffc3b9c:	2500      	movs	r5, #0
  for (i = 0; i < ARRAY_SIZE(ddr_registers); i++)
2ffc3b9e:	f1b8 0f08 	cmp.w	r8, #8
2ffc3ba2:	f109 090c 	add.w	r9, r9, #12
2ffc3ba6:	d1c4      	bne.n	2ffc3b32 <HAL_DDR_Dump_Reg+0x96>
  if (result != HAL_OK)
2ffc3ba8:	9e05      	ldr	r6, [sp, #20]
2ffc3baa:	bb35      	cbnz	r5, 2ffc3bfa <HAL_DDR_Dump_Reg+0x15e>
    return (uint32_t)DDRCTRL_BASE;
2ffc3bac:	2500      	movs	r5, #0
}
2ffc3bae:	4628      	mov	r0, r5
2ffc3bb0:	b009      	add	sp, #36	@ 0x24
2ffc3bb2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        printf("==%s.%s==\n\r", base_name[p_base], p_name);
2ffc3bb6:	9b02      	ldr	r3, [sp, #8]
2ffc3bb8:	f24e 1034 	movw	r0, #57652	@ 0xe134
2ffc3bbc:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc3bc0:	4632      	mov	r2, r6
2ffc3bc2:	eb03 038b 	add.w	r3, r3, fp, lsl #2
2ffc3bc6:	f8d3 115c 	ldr.w	r1, [r3, #348]	@ 0x15c
2ffc3bca:	f007 fedd 	bl	2ffcb988 <iprintf>
2ffc3bce:	e7d4      	b.n	2ffc3b7a <HAL_DDR_Dump_Reg+0xde>
    return (uint32_t)DDRPHYC_BASE;
2ffc3bd0:	9b03      	ldr	r3, [sp, #12]
2ffc3bd2:	f44f 5540 	mov.w	r5, #12288	@ 0x3000
2ffc3bd6:	f6c5 2500 	movt	r5, #23040	@ 0x5a00
      desc = ddr_registers[i].desc;
2ffc3bda:	f8d9 4004 	ldr.w	r4, [r9, #4]
    return (uint32_t)DDRPHYC_BASE;
2ffc3bde:	f1bb 0f01 	cmp.w	fp, #1
2ffc3be2:	bf08      	it	eq
2ffc3be4:	461d      	moveq	r5, r3
        if (i == REG_DYN)
2ffc3be6:	f1b8 0f06 	cmp.w	r8, #6
2ffc3bea:	d1bd      	bne.n	2ffc3b68 <HAL_DDR_Dump_Reg+0xcc>
          printf("\n/* /!\\ No need to copy DDR dynamic registers to conf file */\n\r");
2ffc3bec:	f24e 00e4 	movw	r0, #57572	@ 0xe0e4
2ffc3bf0:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc3bf4:	f007 fec8 	bl	2ffcb988 <iprintf>
2ffc3bf8:	e7b6      	b.n	2ffc3b68 <HAL_DDR_Dump_Reg+0xcc>
    desc = found_reg(name, &type);
2ffc3bfa:	9801      	ldr	r0, [sp, #4]
2ffc3bfc:	f10d 011f 	add.w	r1, sp, #31
2ffc3c00:	f7ff fe6c 	bl	2ffc38dc <found_reg>
    if (desc)
2ffc3c04:	4601      	mov	r1, r0
2ffc3c06:	2800      	cmp	r0, #0
2ffc3c08:	d0d1      	beq.n	2ffc3bae <HAL_DDR_Dump_Reg+0x112>
      p_base = ddr_registers[type].base;
2ffc3c0a:	f89d 201f 	ldrb.w	r2, [sp, #31]
2ffc3c0e:	200c      	movs	r0, #12
    return (uint32_t)DDRPHYC_BASE;
2ffc3c10:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
      p_base = ddr_registers[type].base;
2ffc3c14:	fb00 6602 	mla	r6, r0, r2, r6
    return (uint32_t)DDRPHYC_BASE;
2ffc3c18:	f6c5 2300 	movt	r3, #23040	@ 0x5a00
2ffc3c1c:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
  if (base == BASE_DDRPHYC)
2ffc3c20:	7a74      	ldrb	r4, [r6, #9]
      dump_reg_desc(base_addr, desc, false);
2ffc3c22:	2200      	movs	r2, #0
    return (uint32_t)DDRPHYC_BASE;
2ffc3c24:	f6c5 2000 	movt	r0, #23040	@ 0x5a00
      dump_reg_desc(base_addr, desc, false);
2ffc3c28:	2c01      	cmp	r4, #1
2ffc3c2a:	bf18      	it	ne
2ffc3c2c:	4618      	movne	r0, r3
2ffc3c2e:	f7ff fe81 	bl	2ffc3934 <dump_reg_desc>
      result = HAL_OK;
2ffc3c32:	e7bb      	b.n	2ffc3bac <HAL_DDR_Dump_Reg+0x110>
    printf("\n/* DDR REG VALUES TO BE SAVED */\n\r");
2ffc3c34:	f24e 0060 	movw	r0, #57440	@ 0xe060
    printf("#define DDR_MEM_NAME  \"%s\"\n\r", static_ddr_config.info.name);
2ffc3c38:	f241 741c 	movw	r4, #5916	@ 0x171c
2ffc3c3c:	f6c2 74fd 	movt	r4, #12285	@ 0x2ffd
    printf("\n/* DDR REG VALUES TO BE SAVED */\n\r");
2ffc3c40:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc3c44:	f007 fea0 	bl	2ffcb988 <iprintf>
    printf("#define DDR_MEM_NAME  \"%s\"\n\r", static_ddr_config.info.name);
2ffc3c48:	6821      	ldr	r1, [r4, #0]
2ffc3c4a:	f24e 0084 	movw	r0, #57476	@ 0xe084
2ffc3c4e:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc3c52:	f007 fe99 	bl	2ffcb988 <iprintf>
    printf("#define DDR_MEM_SPEED %d\n\r", (int)static_ddr_config.info.speed);
2ffc3c56:	6861      	ldr	r1, [r4, #4]
2ffc3c58:	f24e 00a4 	movw	r0, #57508	@ 0xe0a4
2ffc3c5c:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc3c60:	f007 fe92 	bl	2ffcb988 <iprintf>
    printf("#define DDR_MEM_SIZE  0x%08lx\n\n\r", static_ddr_config.info.size);
2ffc3c64:	68a1      	ldr	r1, [r4, #8]
2ffc3c66:	f24e 00c0 	movw	r0, #57536	@ 0xe0c0
2ffc3c6a:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc3c6e:	f007 fe8b 	bl	2ffcb988 <iprintf>
2ffc3c72:	e734      	b.n	2ffc3ade <HAL_DDR_Dump_Reg+0x42>
        filter = BASE_DDRCTRL;
2ffc3c74:	9700      	str	r7, [sp, #0]
2ffc3c76:	e734      	b.n	2ffc3ae2 <HAL_DDR_Dump_Reg+0x46>
        filter = BASE_DDRPHYC;
2ffc3c78:	2301      	movs	r3, #1
2ffc3c7a:	9300      	str	r3, [sp, #0]
2ffc3c7c:	e731      	b.n	2ffc3ae2 <HAL_DDR_Dump_Reg+0x46>
2ffc3c7e:	bf00      	nop

2ffc3c80 <HAL_DDR_Edit_Reg>:
{
2ffc3c80:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
2ffc3c84:	b083      	sub	sp, #12
2ffc3c86:	af00      	add	r7, sp, #0
2ffc3c88:	4606      	mov	r6, r0
2ffc3c8a:	460d      	mov	r5, r1
  char reg_name[strlen(name)];
2ffc3c8c:	f008 f8b9 	bl	2ffcbe02 <strlen>
2ffc3c90:	f8df c0c0 	ldr.w	ip, [pc, #192]	@ 2ffc3d54 <HAL_DDR_Edit_Reg+0xd4>
2ffc3c94:	3007      	adds	r0, #7
2ffc3c96:	f020 0007 	bic.w	r0, r0, #7
{
2ffc3c9a:	46e8      	mov	r8, sp
  char reg_name[strlen(name)];
2ffc3c9c:	ebad 0d00 	sub.w	sp, sp, r0
2ffc3ca0:	1e71      	subs	r1, r6, #1
2ffc3ca2:	4668      	mov	r0, sp
void HAL_DDR_Convert_Case(const char *in_str, char *out_str, bool ToUpper)
2ffc3ca4:	f10d 32ff 	add.w	r2, sp, #4294967295	@ 0xffffffff
  while((*out_str = ToUpper? toupper(*in_str) : tolower(*in_str)))
2ffc3ca8:	f811 4f01 	ldrb.w	r4, [r1, #1]!
2ffc3cac:	f81c 3004 	ldrb.w	r3, [ip, r4]
2ffc3cb0:	f003 0303 	and.w	r3, r3, #3
2ffc3cb4:	2b02      	cmp	r3, #2
2ffc3cb6:	bf04      	itt	eq
2ffc3cb8:	3c20      	subeq	r4, #32
2ffc3cba:	b2e4      	uxtbeq	r4, r4
2ffc3cbc:	f802 4f01 	strb.w	r4, [r2, #1]!
2ffc3cc0:	2c00      	cmp	r4, #0
2ffc3cc2:	d1f1      	bne.n	2ffc3ca8 <HAL_DDR_Edit_Reg+0x28>
  desc = found_reg(reg_name, &type);
2ffc3cc4:	1cf9      	adds	r1, r7, #3
2ffc3cc6:	f7ff fe09 	bl	2ffc38dc <found_reg>
  if (!desc)
2ffc3cca:	4681      	mov	r9, r0
2ffc3ccc:	b360      	cbz	r0, 2ffc3d28 <HAL_DDR_Edit_Reg+0xa8>
  value = (uint32_t)strtoll(string, &end_ptr, 0);
2ffc3cce:	4622      	mov	r2, r4
2ffc3cd0:	1d39      	adds	r1, r7, #4
2ffc3cd2:	4628      	mov	r0, r5
2ffc3cd4:	f007 fd7e 	bl	2ffcb7d4 <strtoll>
  if (end_ptr == string)
2ffc3cd8:	687b      	ldr	r3, [r7, #4]
2ffc3cda:	42ab      	cmp	r3, r5
2ffc3cdc:	d030      	beq.n	2ffc3d40 <HAL_DDR_Edit_Reg+0xc0>
  base_addr = get_base_addr(ddr_registers[type].base);
2ffc3cde:	78fa      	ldrb	r2, [r7, #3]
2ffc3ce0:	f24e 6314 	movw	r3, #58900	@ 0xe614
2ffc3ce4:	f6c2 73fc 	movt	r3, #12284	@ 0x2ffc
2ffc3ce8:	210c      	movs	r1, #12
2ffc3cea:	fb01 3202 	mla	r2, r1, r2, r3
    return (uint32_t)DDRPHYC_BASE;
2ffc3cee:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
2ffc3cf2:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
  if (base == BASE_DDRPHYC)
2ffc3cf6:	7a52      	ldrb	r2, [r2, #9]
    return (uint32_t)DDRPHYC_BASE;
2ffc3cf8:	f6c5 2100 	movt	r1, #23040	@ 0x5a00
2ffc3cfc:	f6c5 2300 	movt	r3, #23040	@ 0x5a00
2ffc3d00:	2a01      	cmp	r2, #1
2ffc3d02:	bf08      	it	eq
2ffc3d04:	460b      	moveq	r3, r1
  ptr = (uint32_t)(base_addr + desc->offset);
2ffc3d06:	f8b9 2004 	ldrh.w	r2, [r9, #4]
  printf("%s= 0x%08lx\n\r", desc->name, READ_REG(*(volatile uint32_t*)ptr));
2ffc3d0a:	f8d9 1000 	ldr.w	r1, [r9]
  WRITE_REG(*(volatile uint32_t*)ptr, value);
2ffc3d0e:	50d0      	str	r0, [r2, r3]
  printf("%s= 0x%08lx\n\r", desc->name, READ_REG(*(volatile uint32_t*)ptr));
2ffc3d10:	f24e 1064 	movw	r0, #57700	@ 0xe164
2ffc3d14:	58d2      	ldr	r2, [r2, r3]
2ffc3d16:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc3d1a:	f007 fe35 	bl	2ffcb988 <iprintf>
}
2ffc3d1e:	370c      	adds	r7, #12
2ffc3d20:	46c5      	mov	sp, r8
2ffc3d22:	46bd      	mov	sp, r7
2ffc3d24:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    printf("%s not found\n\r", name);
2ffc3d28:	f24e 1040 	movw	r0, #57664	@ 0xe140
2ffc3d2c:	4631      	mov	r1, r6
2ffc3d2e:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc3d32:	f007 fe29 	bl	2ffcb988 <iprintf>
    return;
2ffc3d36:	46c5      	mov	sp, r8
}
2ffc3d38:	370c      	adds	r7, #12
2ffc3d3a:	46bd      	mov	sp, r7
2ffc3d3c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    printf("invalid value %s\n\r", string);
2ffc3d40:	f24e 1050 	movw	r0, #57680	@ 0xe150
2ffc3d44:	4629      	mov	r1, r5
2ffc3d46:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc3d4a:	f007 fe1d 	bl	2ffcb988 <iprintf>
    return;
2ffc3d4e:	46c5      	mov	sp, r8
2ffc3d50:	e7f2      	b.n	2ffc3d38 <HAL_DDR_Edit_Reg+0xb8>
2ffc3d52:	bf00      	nop
2ffc3d54:	2ffcff40 	.word	0x2ffcff40

2ffc3d58 <HAL_DDR_Dump_Param>:
{
2ffc3d58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
2ffc3d5c:	b08d      	sub	sp, #52	@ 0x34
2ffc3d5e:	af00      	add	r7, sp, #0
2ffc3d60:	6238      	str	r0, [r7, #32]
  if (name) {
2ffc3d62:	6079      	str	r1, [r7, #4]
2ffc3d64:	2900      	cmp	r1, #0
2ffc3d66:	f000 80c7 	beq.w	2ffc3ef8 <HAL_DDR_Dump_Param+0x1a0>
    if (strcmp(name, base_name[BASE_DDRCTRL]) == 0)
2ffc3d6a:	f241 741c 	movw	r4, #5916	@ 0x171c
2ffc3d6e:	460d      	mov	r5, r1
2ffc3d70:	f6c2 74fd 	movt	r4, #12285	@ 0x2ffd
2ffc3d74:	4608      	mov	r0, r1
2ffc3d76:	f8d4 115c 	ldr.w	r1, [r4, #348]	@ 0x15c
2ffc3d7a:	f008 e820 	blx	2ffcbdbc <strcmp>
2ffc3d7e:	2800      	cmp	r0, #0
2ffc3d80:	d05d      	beq.n	2ffc3e3e <HAL_DDR_Dump_Param+0xe6>
    else if (strcmp(name, base_name[BASE_DDRPHYC]) == 0)
2ffc3d82:	f8d4 1160 	ldr.w	r1, [r4, #352]	@ 0x160
2ffc3d86:	4628      	mov	r0, r5
2ffc3d88:	f008 e818 	blx	2ffcbdbc <strcmp>
      filter = BASE_DDRPHYC;
2ffc3d8c:	2800      	cmp	r0, #0
2ffc3d8e:	bf14      	ite	ne
2ffc3d90:	2302      	movne	r3, #2
2ffc3d92:	2301      	moveq	r3, #1
2ffc3d94:	61fb      	str	r3, [r7, #28]
  for (i = 0; i < ARRAY_SIZE(ddr_registers); i++)
2ffc3d96:	4c78      	ldr	r4, [pc, #480]	@ (2ffc3f78 <HAL_DDR_Dump_Param+0x220>)
2ffc3d98:	f24e 6a14 	movw	sl, #58900	@ 0xe614
2ffc3d9c:	f6c2 7afc 	movt	sl, #12284	@ 0x2ffc
      printf("==%s.%s==\n\r\n\r", base_name[p_base], p_name);
2ffc3da0:	f241 731c 	movw	r3, #5916	@ 0x171c
  for (i = 0; i < ARRAY_SIZE(ddr_registers); i++)
2ffc3da4:	f8d7 9004 	ldr.w	r9, [r7, #4]
      printf("==%s.%s==\n\r\n\r", base_name[p_base], p_name);
2ffc3da8:	f24e 1274 	movw	r2, #57716	@ 0xe174
2ffc3dac:	f6c2 73fd 	movt	r3, #12285	@ 0x2ffd
  for (i = 0; i < ARRAY_SIZE(ddr_registers); i++)
2ffc3db0:	f04f 0800 	mov.w	r8, #0
      printf("==%s.%s==\n\r\n\r", base_name[p_base], p_name);
2ffc3db4:	f6c2 72fc 	movt	r2, #12284	@ 0x2ffc
  HAL_StatusTypeDef result = HAL_ERROR;
2ffc3db8:	2601      	movs	r6, #1
  for (i = 0; i < ARRAY_SIZE(ddr_registers); i++)
2ffc3dba:	627e      	str	r6, [r7, #36]	@ 0x24
2ffc3dbc:	e9c7 2302 	strd	r2, r3, [r7, #8]
  switch (type)
2ffc3dc0:	fa5f f388 	uxtb.w	r3, r8
2ffc3dc4:	2b05      	cmp	r3, #5
2ffc3dc6:	d816      	bhi.n	2ffc3df6 <HAL_DDR_Dump_Param+0x9e>
2ffc3dc8:	e8df f003 	tbb	[pc, r3]
2ffc3dcc:	352d3129 	.word	0x352d3129
2ffc3dd0:	0325      	.short	0x0325
    par_addr = (uint32_t)&config->p_timing;
2ffc3dd2:	6a3b      	ldr	r3, [r7, #32]
2ffc3dd4:	f503 7b9a 	add.w	fp, r3, #308	@ 0x134
    p_base = ddr_registers[i].base;
2ffc3dd8:	f89a 5009 	ldrb.w	r5, [sl, #9]
    if (!name || (filter == p_base || !strcmp(name, p_name)))
2ffc3ddc:	69fb      	ldr	r3, [r7, #28]
    p_name = ddr_registers[i].name;
2ffc3dde:	f8da 6000 	ldr.w	r6, [sl]
    if (!name || (filter == p_base || !strcmp(name, p_name)))
2ffc3de2:	42ab      	cmp	r3, r5
2ffc3de4:	bf18      	it	ne
2ffc3de6:	f1b9 0f00 	cmpne.w	r9, #0
2ffc3dea:	d02a      	beq.n	2ffc3e42 <HAL_DDR_Dump_Param+0xea>
2ffc3dec:	4631      	mov	r1, r6
2ffc3dee:	4648      	mov	r0, r9
2ffc3df0:	f007 efe4 	blx	2ffcbdbc <strcmp>
2ffc3df4:	b328      	cbz	r0, 2ffc3e42 <HAL_DDR_Dump_Param+0xea>
  for (i = 0; i < ARRAY_SIZE(ddr_registers); i++)
2ffc3df6:	f108 0801 	add.w	r8, r8, #1
2ffc3dfa:	f10a 0a0c 	add.w	sl, sl, #12
2ffc3dfe:	f1b8 0f08 	cmp.w	r8, #8
2ffc3e02:	d1dd      	bne.n	2ffc3dc0 <HAL_DDR_Dump_Param+0x68>
  if (result != HAL_OK)
2ffc3e04:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
2ffc3e06:	2e00      	cmp	r6, #0
2ffc3e08:	d165      	bne.n	2ffc3ed6 <HAL_DDR_Dump_Param+0x17e>
      result = HAL_OK;
2ffc3e0a:	2600      	movs	r6, #0
}
2ffc3e0c:	4630      	mov	r0, r6
2ffc3e0e:	3734      	adds	r7, #52	@ 0x34
2ffc3e10:	46bd      	mov	sp, r7
2ffc3e12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    par_addr = (uint32_t)&config->p_reg;
2ffc3e16:	6a3b      	ldr	r3, [r7, #32]
2ffc3e18:	f503 7b84 	add.w	fp, r3, #264	@ 0x108
    if (!par_addr)
2ffc3e1c:	e7dc      	b.n	2ffc3dd8 <HAL_DDR_Dump_Param+0x80>
    par_addr = (uint32_t)&config->c_reg;
2ffc3e1e:	6a3b      	ldr	r3, [r7, #32]
2ffc3e20:	f103 0b0c 	add.w	fp, r3, #12
    if (!par_addr)
2ffc3e24:	e7d8      	b.n	2ffc3dd8 <HAL_DDR_Dump_Param+0x80>
    par_addr = (uint32_t)&config->c_perf;
2ffc3e26:	6a3b      	ldr	r3, [r7, #32]
2ffc3e28:	f103 0bc4 	add.w	fp, r3, #196	@ 0xc4
    if (!par_addr)
2ffc3e2c:	e7d4      	b.n	2ffc3dd8 <HAL_DDR_Dump_Param+0x80>
    par_addr = (uint32_t)&config->c_timing;
2ffc3e2e:	6a3b      	ldr	r3, [r7, #32]
2ffc3e30:	f103 0b70 	add.w	fp, r3, #112	@ 0x70
    if (!par_addr)
2ffc3e34:	e7d0      	b.n	2ffc3dd8 <HAL_DDR_Dump_Param+0x80>
    par_addr = (uint32_t)&config->c_map;
2ffc3e36:	6a3b      	ldr	r3, [r7, #32]
2ffc3e38:	f103 0ba0 	add.w	fp, r3, #160	@ 0xa0
    if (!par_addr)
2ffc3e3c:	e7cc      	b.n	2ffc3dd8 <HAL_DDR_Dump_Param+0x80>
      filter = BASE_DDRCTRL;
2ffc3e3e:	61f8      	str	r0, [r7, #28]
2ffc3e40:	e7a9      	b.n	2ffc3d96 <HAL_DDR_Dump_Param+0x3e>
      printf("==%s.%s==\n\r\n\r", base_name[p_base], p_name);
2ffc3e42:	68fb      	ldr	r3, [r7, #12]
2ffc3e44:	4632      	mov	r2, r6
2ffc3e46:	68b8      	ldr	r0, [r7, #8]
2ffc3e48:	eb03 0585 	add.w	r5, r3, r5, lsl #2
2ffc3e4c:	f8d5 115c 	ldr.w	r1, [r5, #348]	@ 0x15c
      desc = ddr_registers[i].desc;
2ffc3e50:	f8da 5004 	ldr.w	r5, [sl, #4]
      printf("==%s.%s==\n\r\n\r", base_name[p_base], p_name);
2ffc3e54:	f007 fd98 	bl	2ffcb988 <iprintf>
      for (j = 0; j < ddr_registers[i].size; j++)
2ffc3e58:	f89a 3008 	ldrb.w	r3, [sl, #8]
2ffc3e5c:	627b      	str	r3, [r7, #36]	@ 0x24
2ffc3e5e:	b3bb      	cbz	r3, 2ffc3ed0 <HAL_DDR_Dump_Param+0x178>
2ffc3e60:	f8c7 9010 	str.w	r9, [r7, #16]
  printf("%s= 0x%08lx\n\r", reg_name, READ_REG(*(volatile uint32_t*)ptr));
2ffc3e64:	f24e 1364 	movw	r3, #57700	@ 0xe164
2ffc3e68:	f6c2 73fc 	movt	r3, #12284	@ 0x2ffc
2ffc3e6c:	3506      	adds	r5, #6
      for (j = 0; j < ddr_registers[i].size; j++)
2ffc3e6e:	e9c7 8a05 	strd	r8, sl, [r7, #20]
2ffc3e72:	2600      	movs	r6, #0
2ffc3e74:	469a      	mov	sl, r3
  char reg_name[strlen(desc->name)];
2ffc3e76:	f855 9c06 	ldr.w	r9, [r5, #-6]
{
2ffc3e7a:	46e8      	mov	r8, sp
  char reg_name[strlen(desc->name)];
2ffc3e7c:	4648      	mov	r0, r9
2ffc3e7e:	f007 ffc0 	bl	2ffcbe02 <strlen>
2ffc3e82:	3007      	adds	r0, #7
2ffc3e84:	f109 3cff 	add.w	ip, r9, #4294967295	@ 0xffffffff
2ffc3e88:	f020 0007 	bic.w	r0, r0, #7
2ffc3e8c:	ebad 0d00 	sub.w	sp, sp, r0
2ffc3e90:	4669      	mov	r1, sp
void HAL_DDR_Convert_Case(const char *in_str, char *out_str, bool ToUpper)
2ffc3e92:	f10d 30ff 	add.w	r0, sp, #4294967295	@ 0xffffffff
  while((*out_str = ToUpper? toupper(*in_str) : tolower(*in_str)))
2ffc3e96:	f81c 3f01 	ldrb.w	r3, [ip, #1]!
2ffc3e9a:	5ce2      	ldrb	r2, [r4, r3]
2ffc3e9c:	f002 0203 	and.w	r2, r2, #3
2ffc3ea0:	2a01      	cmp	r2, #1
2ffc3ea2:	bf04      	itt	eq
2ffc3ea4:	3320      	addeq	r3, #32
2ffc3ea6:	b2db      	uxtbeq	r3, r3
2ffc3ea8:	f800 3f01 	strb.w	r3, [r0, #1]!
2ffc3eac:	2b00      	cmp	r3, #0
2ffc3eae:	d1f2      	bne.n	2ffc3e96 <HAL_DDR_Dump_Param+0x13e>
  ptr = (uint32_t)(par_addr + desc->par_offset);
2ffc3eb0:	f815 3b08 	ldrb.w	r3, [r5], #8
  printf("%s= 0x%08lx\n\r", reg_name, READ_REG(*(volatile uint32_t*)ptr));
2ffc3eb4:	4650      	mov	r0, sl
      for (j = 0; j < ddr_registers[i].size; j++)
2ffc3eb6:	3601      	adds	r6, #1
  printf("%s= 0x%08lx\n\r", reg_name, READ_REG(*(volatile uint32_t*)ptr));
2ffc3eb8:	f853 200b 	ldr.w	r2, [r3, fp]
2ffc3ebc:	f007 fd64 	bl	2ffcb988 <iprintf>
      for (j = 0; j < ddr_registers[i].size; j++)
2ffc3ec0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2ffc3ec2:	46c5      	mov	sp, r8
2ffc3ec4:	429e      	cmp	r6, r3
2ffc3ec6:	d1d6      	bne.n	2ffc3e76 <HAL_DDR_Dump_Param+0x11e>
2ffc3ec8:	e9d7 8a05 	ldrd	r8, sl, [r7, #20]
2ffc3ecc:	f8d7 9010 	ldr.w	r9, [r7, #16]
      result = HAL_OK;
2ffc3ed0:	2300      	movs	r3, #0
2ffc3ed2:	627b      	str	r3, [r7, #36]	@ 0x24
2ffc3ed4:	e78f      	b.n	2ffc3df6 <HAL_DDR_Dump_Param+0x9e>
    desc = found_reg(name, &type);
2ffc3ed6:	6878      	ldr	r0, [r7, #4]
2ffc3ed8:	f107 012f 	add.w	r1, r7, #47	@ 0x2f
2ffc3edc:	f7ff fcfe 	bl	2ffc38dc <found_reg>
    if (desc)
2ffc3ee0:	4680      	mov	r8, r0
2ffc3ee2:	2800      	cmp	r0, #0
2ffc3ee4:	d092      	beq.n	2ffc3e0c <HAL_DDR_Dump_Param+0xb4>
  switch (type)
2ffc3ee6:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
2ffc3eea:	2b05      	cmp	r3, #5
2ffc3eec:	d88e      	bhi.n	2ffc3e0c <HAL_DDR_Dump_Param+0xb4>
2ffc3eee:	e8df f003 	tbb	[pc, r3]
2ffc3ef2:	3633      	.short	0x3633
2ffc3ef4:	063f3c39 	.word	0x063f3c39
  base_type filter = BASE_NONE;
2ffc3ef8:	2302      	movs	r3, #2
2ffc3efa:	61fb      	str	r3, [r7, #28]
2ffc3efc:	e74b      	b.n	2ffc3d96 <HAL_DDR_Dump_Param+0x3e>
    par_addr = (uint32_t)&config->p_timing;
2ffc3efe:	6a3b      	ldr	r3, [r7, #32]
2ffc3f00:	f503 769a 	add.w	r6, r3, #308	@ 0x134
  char reg_name[strlen(desc->name)];
2ffc3f04:	f8d8 4000 	ldr.w	r4, [r8]
{
2ffc3f08:	466d      	mov	r5, sp
  char reg_name[strlen(desc->name)];
2ffc3f0a:	4620      	mov	r0, r4
2ffc3f0c:	3c01      	subs	r4, #1
2ffc3f0e:	f007 ff78 	bl	2ffcbe02 <strlen>
2ffc3f12:	f8df c064 	ldr.w	ip, [pc, #100]	@ 2ffc3f78 <HAL_DDR_Dump_Param+0x220>
2ffc3f16:	1dc3      	adds	r3, r0, #7
2ffc3f18:	f023 0307 	bic.w	r3, r3, #7
2ffc3f1c:	ebad 0d03 	sub.w	sp, sp, r3
2ffc3f20:	4669      	mov	r1, sp
void HAL_DDR_Convert_Case(const char *in_str, char *out_str, bool ToUpper)
2ffc3f22:	f10d 30ff 	add.w	r0, sp, #4294967295	@ 0xffffffff
  while((*out_str = ToUpper? toupper(*in_str) : tolower(*in_str)))
2ffc3f26:	f814 3f01 	ldrb.w	r3, [r4, #1]!
2ffc3f2a:	f81c 2003 	ldrb.w	r2, [ip, r3]
2ffc3f2e:	f002 0203 	and.w	r2, r2, #3
2ffc3f32:	2a01      	cmp	r2, #1
2ffc3f34:	bf04      	itt	eq
2ffc3f36:	3320      	addeq	r3, #32
2ffc3f38:	b2db      	uxtbeq	r3, r3
2ffc3f3a:	f800 3f01 	strb.w	r3, [r0, #1]!
2ffc3f3e:	2b00      	cmp	r3, #0
2ffc3f40:	d1f1      	bne.n	2ffc3f26 <HAL_DDR_Dump_Param+0x1ce>
  ptr = (uint32_t)(par_addr + desc->par_offset);
2ffc3f42:	f898 3006 	ldrb.w	r3, [r8, #6]
  printf("%s= 0x%08lx\n\r", reg_name, READ_REG(*(volatile uint32_t*)ptr));
2ffc3f46:	f24e 1064 	movw	r0, #57700	@ 0xe164
2ffc3f4a:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc3f4e:	599a      	ldr	r2, [r3, r6]
2ffc3f50:	f007 fd1a 	bl	2ffcb988 <iprintf>
2ffc3f54:	46ad      	mov	sp, r5
}
2ffc3f56:	e758      	b.n	2ffc3e0a <HAL_DDR_Dump_Param+0xb2>
    par_addr = (uint32_t)&config->c_reg;
2ffc3f58:	6a3e      	ldr	r6, [r7, #32]
2ffc3f5a:	360c      	adds	r6, #12
      if (par_addr)
2ffc3f5c:	e7d2      	b.n	2ffc3f04 <HAL_DDR_Dump_Param+0x1ac>
    par_addr = (uint32_t)&config->c_timing;
2ffc3f5e:	6a3e      	ldr	r6, [r7, #32]
2ffc3f60:	3670      	adds	r6, #112	@ 0x70
      if (par_addr)
2ffc3f62:	e7cf      	b.n	2ffc3f04 <HAL_DDR_Dump_Param+0x1ac>
    par_addr = (uint32_t)&config->c_perf;
2ffc3f64:	6a3e      	ldr	r6, [r7, #32]
2ffc3f66:	36c4      	adds	r6, #196	@ 0xc4
      if (par_addr)
2ffc3f68:	e7cc      	b.n	2ffc3f04 <HAL_DDR_Dump_Param+0x1ac>
    par_addr = (uint32_t)&config->c_map;
2ffc3f6a:	6a3e      	ldr	r6, [r7, #32]
2ffc3f6c:	36a0      	adds	r6, #160	@ 0xa0
      if (par_addr)
2ffc3f6e:	e7c9      	b.n	2ffc3f04 <HAL_DDR_Dump_Param+0x1ac>
    par_addr = (uint32_t)&config->p_reg;
2ffc3f70:	6a3b      	ldr	r3, [r7, #32]
2ffc3f72:	f503 7684 	add.w	r6, r3, #264	@ 0x108
      if (par_addr)
2ffc3f76:	e7c5      	b.n	2ffc3f04 <HAL_DDR_Dump_Param+0x1ac>
2ffc3f78:	2ffcff40 	.word	0x2ffcff40

2ffc3f7c <HAL_DDR_Edit_Param>:
{
2ffc3f7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
2ffc3f80:	b082      	sub	sp, #8
2ffc3f82:	460e      	mov	r6, r1
2ffc3f84:	af00      	add	r7, sp, #0
2ffc3f86:	4604      	mov	r4, r0
  desc = found_reg(name, &type);
2ffc3f88:	1cf9      	adds	r1, r7, #3
2ffc3f8a:	4630      	mov	r0, r6
{
2ffc3f8c:	4690      	mov	r8, r2
  desc = found_reg(name, &type);
2ffc3f8e:	f7ff fca5 	bl	2ffc38dc <found_reg>
  if (!desc)
2ffc3f92:	2800      	cmp	r0, #0
2ffc3f94:	d050      	beq.n	2ffc4038 <HAL_DDR_Edit_Param+0xbc>
  value = (uint32_t)strtoll(string, &end_ptr, 0);
2ffc3f96:	4605      	mov	r5, r0
2ffc3f98:	2200      	movs	r2, #0
2ffc3f9a:	1d39      	adds	r1, r7, #4
2ffc3f9c:	4640      	mov	r0, r8
2ffc3f9e:	f007 fc19 	bl	2ffcb7d4 <strtoll>
  if (end_ptr == string)
2ffc3fa2:	6879      	ldr	r1, [r7, #4]
2ffc3fa4:	4541      	cmp	r1, r8
2ffc3fa6:	d052      	beq.n	2ffc404e <HAL_DDR_Edit_Param+0xd2>
  switch (type)
2ffc3fa8:	78fb      	ldrb	r3, [r7, #3]
2ffc3faa:	2b05      	cmp	r3, #5
2ffc3fac:	d856      	bhi.n	2ffc405c <HAL_DDR_Edit_Param+0xe0>
2ffc3fae:	e8df f003 	tbb	[pc, r3]
2ffc3fb2:	3734      	.short	0x3734
2ffc3fb4:	03403d3a 	.word	0x03403d3a
    par_addr = (uint32_t)&config->p_timing;
2ffc3fb8:	f504 739a 	add.w	r3, r4, #308	@ 0x134
    char reg_name[strlen(desc->name)];
2ffc3fbc:	682c      	ldr	r4, [r5, #0]
  ptr = (uint32_t)(par_addr + desc->par_offset);
2ffc3fbe:	f895 8006 	ldrb.w	r8, [r5, #6]
  {
2ffc3fc2:	466d      	mov	r5, sp
2ffc3fc4:	4e29      	ldr	r6, [pc, #164]	@ (2ffc406c <HAL_DDR_Edit_Param+0xf0>)
  WRITE_REG(*(volatile uint32_t*)ptr, value);
2ffc3fc6:	f848 0003 	str.w	r0, [r8, r3]
    char reg_name[strlen(desc->name)];
2ffc3fca:	4620      	mov	r0, r4
  ptr = (uint32_t)(par_addr + desc->par_offset);
2ffc3fcc:	4498      	add	r8, r3
    char reg_name[strlen(desc->name)];
2ffc3fce:	f007 ff18 	bl	2ffcbe02 <strlen>
2ffc3fd2:	3007      	adds	r0, #7
2ffc3fd4:	f104 3cff 	add.w	ip, r4, #4294967295	@ 0xffffffff
2ffc3fd8:	f020 0007 	bic.w	r0, r0, #7
2ffc3fdc:	ebad 0d00 	sub.w	sp, sp, r0
2ffc3fe0:	4669      	mov	r1, sp
void HAL_DDR_Convert_Case(const char *in_str, char *out_str, bool ToUpper)
2ffc3fe2:	f10d 34ff 	add.w	r4, sp, #4294967295	@ 0xffffffff
  while((*out_str = ToUpper? toupper(*in_str) : tolower(*in_str)))
2ffc3fe6:	f81c 3f01 	ldrb.w	r3, [ip, #1]!
2ffc3fea:	5cf2      	ldrb	r2, [r6, r3]
2ffc3fec:	f002 0203 	and.w	r2, r2, #3
2ffc3ff0:	2a01      	cmp	r2, #1
2ffc3ff2:	bf04      	itt	eq
2ffc3ff4:	3320      	addeq	r3, #32
2ffc3ff6:	b2db      	uxtbeq	r3, r3
2ffc3ff8:	f804 3f01 	strb.w	r3, [r4, #1]!
2ffc3ffc:	2b00      	cmp	r3, #0
2ffc3ffe:	d1f2      	bne.n	2ffc3fe6 <HAL_DDR_Edit_Param+0x6a>
    printf("%s= 0x%08lx\n\r", reg_name, READ_REG(*(volatile uint32_t*)ptr));
2ffc4000:	f8d8 2000 	ldr.w	r2, [r8]
2ffc4004:	f24e 1064 	movw	r0, #57700	@ 0xe164
2ffc4008:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc400c:	f007 fcbc 	bl	2ffcb988 <iprintf>
2ffc4010:	46ad      	mov	sp, r5
}
2ffc4012:	3708      	adds	r7, #8
2ffc4014:	46bd      	mov	sp, r7
2ffc4016:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    par_addr = (uint32_t)&config->c_reg;
2ffc401a:	f104 030c 	add.w	r3, r4, #12
  if (!par_addr) {
2ffc401e:	e7cd      	b.n	2ffc3fbc <HAL_DDR_Edit_Param+0x40>
    par_addr = (uint32_t)&config->c_timing;
2ffc4020:	f104 0370 	add.w	r3, r4, #112	@ 0x70
  if (!par_addr) {
2ffc4024:	e7ca      	b.n	2ffc3fbc <HAL_DDR_Edit_Param+0x40>
    par_addr = (uint32_t)&config->c_perf;
2ffc4026:	f104 03c4 	add.w	r3, r4, #196	@ 0xc4
  if (!par_addr) {
2ffc402a:	e7c7      	b.n	2ffc3fbc <HAL_DDR_Edit_Param+0x40>
    par_addr = (uint32_t)&config->c_map;
2ffc402c:	f104 03a0 	add.w	r3, r4, #160	@ 0xa0
  if (!par_addr) {
2ffc4030:	e7c4      	b.n	2ffc3fbc <HAL_DDR_Edit_Param+0x40>
    par_addr = (uint32_t)&config->p_reg;
2ffc4032:	f504 7384 	add.w	r3, r4, #264	@ 0x108
  if (!par_addr) {
2ffc4036:	e7c1      	b.n	2ffc3fbc <HAL_DDR_Edit_Param+0x40>
    printf("%s not found\n\r", name);
2ffc4038:	f24e 1040 	movw	r0, #57664	@ 0xe140
2ffc403c:	4631      	mov	r1, r6
2ffc403e:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc4042:	f007 fca1 	bl	2ffcb988 <iprintf>
}
2ffc4046:	3708      	adds	r7, #8
2ffc4048:	46bd      	mov	sp, r7
2ffc404a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    printf("invalid value %s\n\r", string);
2ffc404e:	f24e 1050 	movw	r0, #57680	@ 0xe150
2ffc4052:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc4056:	f007 fc97 	bl	2ffcb988 <iprintf>
    return;
2ffc405a:	e7da      	b.n	2ffc4012 <HAL_DDR_Edit_Param+0x96>
    printf("no parameter %s\n\r", name);
2ffc405c:	f24e 1084 	movw	r0, #57732	@ 0xe184
2ffc4060:	4631      	mov	r1, r6
2ffc4062:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc4066:	f007 fc8f 	bl	2ffcb988 <iprintf>
    return;
2ffc406a:	e7d2      	b.n	2ffc4012 <HAL_DDR_Edit_Param+0x96>
2ffc406c:	2ffcff40 	.word	0x2ffcff40

2ffc4070 <HAL_DDR_SR_SetMode>:
  */
HAL_StatusTypeDef HAL_DDR_SR_SetMode(HAL_DDR_SelfRefreshModeTypeDef mode)
{
  HAL_StatusTypeDef ret;

  switch (mode)
2ffc4070:	2801      	cmp	r0, #1
{
2ffc4072:	b510      	push	{r4, lr}
  switch (mode)
2ffc4074:	d006      	beq.n	2ffc4084 <HAL_DDR_SR_SetMode+0x14>
2ffc4076:	2802      	cmp	r0, #2
2ffc4078:	f000 80eb 	beq.w	2ffc4252 <HAL_DDR_SR_SetMode+0x1e2>
2ffc407c:	2800      	cmp	r0, #0
2ffc407e:	d062      	beq.n	2ffc4146 <HAL_DDR_SR_SetMode+0xd6>
    return HAL_ERROR;
2ffc4080:	2001      	movs	r0, #1
      ret = HAL_ERROR;
      break;
  }

  return ret;
}
2ffc4082:	bd10      	pop	{r4, pc}
  uint32_t mstr = READ_REG(DDRCTRL->MSTR);
2ffc4084:	f44f 5440 	mov.w	r4, #12288	@ 0x3000
2ffc4088:	f6c5 2400 	movt	r4, #23040	@ 0x5a00
2ffc408c:	6823      	ldr	r3, [r4, #0]
  if (!ddr_supports_ssr_asr())
2ffc408e:	075b      	lsls	r3, r3, #29
2ffc4090:	f140 813a 	bpl.w	2ffc4308 <HAL_DDR_SR_SetMode+0x298>
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_AXIDCGEN);
2ffc4094:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc4098:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc409c:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
2ffc40a0:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRC1LPEN);
2ffc40a4:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc40a8:	f042 0202 	orr.w	r2, r2, #2
2ffc40ac:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRC2LPEN);
2ffc40b0:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc40b4:	f042 0208 	orr.w	r2, r2, #8
2ffc40b8:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRPHYCLPEN);
2ffc40bc:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc40c0:	f042 0220 	orr.w	r2, r2, #32
2ffc40c4:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  MODIFY_REG(RCC->DDRITFCR, RCC_DDRITFCR_DDRCKMOD_Msk,
2ffc40c8:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc40cc:	f422 02e0 	bic.w	r2, r2, #7340032	@ 0x700000
2ffc40d0:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
2ffc40d4:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  if (disable_axi_port() != 0)
2ffc40d8:	f7ff fb06 	bl	2ffc36e8 <disable_axi_port>
2ffc40dc:	2800      	cmp	r0, #0
2ffc40de:	d1cf      	bne.n	2ffc4080 <HAL_DDR_SR_SetMode+0x10>
  if (disable_host_interface() != 0)
2ffc40e0:	f7ff fb38 	bl	2ffc3754 <disable_host_interface>
2ffc40e4:	2800      	cmp	r0, #0
2ffc40e6:	d1cb      	bne.n	2ffc4080 <HAL_DDR_SR_SetMode+0x10>
  CLEAR_BIT(DDRCTRL->SWCTL, DDRCTRL_SWCTL_SW_DONE);
2ffc40e8:	f8d4 3320 	ldr.w	r3, [r4, #800]	@ 0x320
2ffc40ec:	f023 0301 	bic.w	r3, r3, #1
2ffc40f0:	f8c4 3320 	str.w	r3, [r4, #800]	@ 0x320
  SET_BIT(DDRCTRL->HWLPCTL, DDRCTRL_HWLPCTL_HW_LP_EN);
2ffc40f4:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
2ffc40f6:	f043 0301 	orr.w	r3, r3, #1
2ffc40fa:	63a3      	str	r3, [r4, #56]	@ 0x38
  MODIFY_REG(DDRCTRL->PWRTMG, DDRCTRL_PWRTMG_SELFREF_TO_X32_Msk,
2ffc40fc:	6b63      	ldr	r3, [r4, #52]	@ 0x34
2ffc40fe:	f423 037f 	bic.w	r3, r3, #16711680	@ 0xff0000
2ffc4102:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
2ffc4106:	6363      	str	r3, [r4, #52]	@ 0x34
  ret = wait_sw_done_ack();
2ffc4108:	f7ff fa7c 	bl	2ffc3604 <wait_sw_done_ack>
  if (ret != HAL_OK)
2ffc410c:	2800      	cmp	r0, #0
2ffc410e:	d1b8      	bne.n	2ffc4082 <HAL_DDR_SR_SetMode+0x12>
  CLEAR_BIT(DDRCTRL->DBG1, DDRCTRL_DBG1_DIS_HIF);
2ffc4110:	f8d4 3304 	ldr.w	r3, [r4, #772]	@ 0x304
2ffc4114:	f023 0302 	bic.w	r3, r3, #2
2ffc4118:	f8c4 3304 	str.w	r3, [r4, #772]	@ 0x304
  SET_BIT(DDRCTRL->PCTRL_0, DDRCTRL_PCTRL_0_PORT_EN);
2ffc411c:	f8d4 3490 	ldr.w	r3, [r4, #1168]	@ 0x490
2ffc4120:	f043 0301 	orr.w	r3, r3, #1
2ffc4124:	f8c4 3490 	str.w	r3, [r4, #1168]	@ 0x490
  SET_BIT(DDRCTRL->PCTRL_1, DDRCTRL_PCTRL_0_PORT_EN);
2ffc4128:	f8d4 3540 	ldr.w	r3, [r4, #1344]	@ 0x540
2ffc412c:	f043 0301 	orr.w	r3, r3, #1
2ffc4130:	f8c4 3540 	str.w	r3, [r4, #1344]	@ 0x540
  SET_BIT(DDRCTRL->PWRCTL, DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE);
2ffc4134:	6b23      	ldr	r3, [r4, #48]	@ 0x30
2ffc4136:	f043 0308 	orr.w	r3, r3, #8
2ffc413a:	6323      	str	r3, [r4, #48]	@ 0x30
  SET_BIT(DDRCTRL->PWRCTL, DDRCTRL_PWRCTL_SELFREF_EN);
2ffc413c:	6b23      	ldr	r3, [r4, #48]	@ 0x30
2ffc413e:	f043 0301 	orr.w	r3, r3, #1
2ffc4142:	6323      	str	r3, [r4, #48]	@ 0x30
  return ret;
2ffc4144:	e0e0      	b.n	2ffc4308 <HAL_DDR_SR_SetMode+0x298>
  uint32_t mstr = READ_REG(DDRCTRL->MSTR);
2ffc4146:	f44f 5440 	mov.w	r4, #12288	@ 0x3000
2ffc414a:	f6c5 2400 	movt	r4, #23040	@ 0x5a00
2ffc414e:	6823      	ldr	r3, [r4, #0]
  if (!ddr_supports_ssr_asr())
2ffc4150:	075a      	lsls	r2, r3, #29
2ffc4152:	f140 80d9 	bpl.w	2ffc4308 <HAL_DDR_SR_SetMode+0x298>
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRC1LPEN);
2ffc4156:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc415a:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc415e:	f042 0202 	orr.w	r2, r2, #2
2ffc4162:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRC1EN);
2ffc4166:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc416a:	f042 0201 	orr.w	r2, r2, #1
2ffc416e:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRC2LPEN);
2ffc4172:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc4176:	f042 0208 	orr.w	r2, r2, #8
2ffc417a:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRC2EN);
2ffc417e:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc4182:	f042 0204 	orr.w	r2, r2, #4
2ffc4186:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRCAPBLPEN);
2ffc418a:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc418e:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
2ffc4192:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRPHYCAPBLPEN);
2ffc4196:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc419a:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
2ffc419e:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRCAPBEN);
2ffc41a2:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc41a6:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
2ffc41aa:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRPHYCAPBEN);
2ffc41ae:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc41b2:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
2ffc41b6:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRPHYCEN);
2ffc41ba:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc41be:	f042 0210 	orr.w	r2, r2, #16
2ffc41c2:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  CLEAR_BIT(RCC->DDRITFCR, RCC_DDRITFCR_AXIDCGEN);
2ffc41c6:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc41ca:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
2ffc41ce:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  CLEAR_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRCKMOD_Msk);
2ffc41d2:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc41d6:	f422 02e0 	bic.w	r2, r2, #7340032	@ 0x700000
2ffc41da:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  if (disable_axi_port() != 0)
2ffc41de:	f7ff fa83 	bl	2ffc36e8 <disable_axi_port>
2ffc41e2:	2800      	cmp	r0, #0
2ffc41e4:	f47f af4c 	bne.w	2ffc4080 <HAL_DDR_SR_SetMode+0x10>
  if (disable_host_interface() != 0)
2ffc41e8:	f7ff fab4 	bl	2ffc3754 <disable_host_interface>
2ffc41ec:	2800      	cmp	r0, #0
2ffc41ee:	f47f af47 	bne.w	2ffc4080 <HAL_DDR_SR_SetMode+0x10>
  CLEAR_BIT(DDRCTRL->SWCTL, DDRCTRL_SWCTL_SW_DONE);
2ffc41f2:	f8d4 3320 	ldr.w	r3, [r4, #800]	@ 0x320
2ffc41f6:	f023 0301 	bic.w	r3, r3, #1
2ffc41fa:	f8c4 3320 	str.w	r3, [r4, #800]	@ 0x320
  CLEAR_BIT(DDRCTRL->HWLPCTL, DDRCTRL_HWLPCTL_HW_LP_EN);
2ffc41fe:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
2ffc4200:	f023 0301 	bic.w	r3, r3, #1
2ffc4204:	63a3      	str	r3, [r4, #56]	@ 0x38
  MODIFY_REG(DDRCTRL->PWRTMG, DDRCTRL_PWRTMG_SELFREF_TO_X32_Msk,
2ffc4206:	6b63      	ldr	r3, [r4, #52]	@ 0x34
2ffc4208:	f423 037f 	bic.w	r3, r3, #16711680	@ 0xff0000
2ffc420c:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
2ffc4210:	6363      	str	r3, [r4, #52]	@ 0x34
  ret = wait_sw_done_ack();
2ffc4212:	f7ff f9f7 	bl	2ffc3604 <wait_sw_done_ack>
  if (ret != HAL_OK)
2ffc4216:	2800      	cmp	r0, #0
2ffc4218:	f47f af33 	bne.w	2ffc4082 <HAL_DDR_SR_SetMode+0x12>
  CLEAR_BIT(DDRCTRL->DBG1, DDRCTRL_DBG1_DIS_HIF);
2ffc421c:	f8d4 3304 	ldr.w	r3, [r4, #772]	@ 0x304
2ffc4220:	f023 0302 	bic.w	r3, r3, #2
2ffc4224:	f8c4 3304 	str.w	r3, [r4, #772]	@ 0x304
  SET_BIT(DDRCTRL->PCTRL_0, DDRCTRL_PCTRL_0_PORT_EN);
2ffc4228:	f8d4 3490 	ldr.w	r3, [r4, #1168]	@ 0x490
2ffc422c:	f043 0301 	orr.w	r3, r3, #1
2ffc4230:	f8c4 3490 	str.w	r3, [r4, #1168]	@ 0x490
  SET_BIT(DDRCTRL->PCTRL_1, DDRCTRL_PCTRL_0_PORT_EN);
2ffc4234:	f8d4 3540 	ldr.w	r3, [r4, #1344]	@ 0x540
2ffc4238:	f043 0301 	orr.w	r3, r3, #1
2ffc423c:	f8c4 3540 	str.w	r3, [r4, #1344]	@ 0x540
  CLEAR_BIT(DDRCTRL->PWRCTL, DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE);
2ffc4240:	6b23      	ldr	r3, [r4, #48]	@ 0x30
2ffc4242:	f023 0308 	bic.w	r3, r3, #8
2ffc4246:	6323      	str	r3, [r4, #48]	@ 0x30
  CLEAR_BIT(DDRCTRL->PWRCTL, DDRCTRL_PWRCTL_SELFREF_EN);
2ffc4248:	6b23      	ldr	r3, [r4, #48]	@ 0x30
2ffc424a:	f023 0301 	bic.w	r3, r3, #1
2ffc424e:	6323      	str	r3, [r4, #48]	@ 0x30
  return ret;
2ffc4250:	e05a      	b.n	2ffc4308 <HAL_DDR_SR_SetMode+0x298>
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_AXIDCGEN);
2ffc4252:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc4256:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc425a:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
2ffc425e:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  CLEAR_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRC1LPEN);
2ffc4262:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc4266:	f022 0202 	bic.w	r2, r2, #2
2ffc426a:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  CLEAR_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRC2LPEN);
2ffc426e:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc4272:	f022 0208 	bic.w	r2, r2, #8
2ffc4276:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRPHYCLPEN);
2ffc427a:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc427e:	f042 0220 	orr.w	r2, r2, #32
2ffc4282:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  MODIFY_REG(RCC->DDRITFCR, RCC_DDRITFCR_DDRCKMOD_Msk,
2ffc4286:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc428a:	f422 02e0 	bic.w	r2, r2, #7340032	@ 0x700000
2ffc428e:	f442 1200 	orr.w	r2, r2, #2097152	@ 0x200000
2ffc4292:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  if (disable_axi_port() != 0)
2ffc4296:	f7ff fa27 	bl	2ffc36e8 <disable_axi_port>
2ffc429a:	2800      	cmp	r0, #0
2ffc429c:	f47f aef0 	bne.w	2ffc4080 <HAL_DDR_SR_SetMode+0x10>
  if (disable_host_interface() != 0)
2ffc42a0:	f7ff fa58 	bl	2ffc3754 <disable_host_interface>
2ffc42a4:	2800      	cmp	r0, #0
2ffc42a6:	f47f aeeb 	bne.w	2ffc4080 <HAL_DDR_SR_SetMode+0x10>
  CLEAR_BIT(DDRCTRL->SWCTL, DDRCTRL_SWCTL_SW_DONE);
2ffc42aa:	f44f 5440 	mov.w	r4, #12288	@ 0x3000
2ffc42ae:	f6c5 2400 	movt	r4, #23040	@ 0x5a00
2ffc42b2:	f8d4 3320 	ldr.w	r3, [r4, #800]	@ 0x320
2ffc42b6:	f023 0301 	bic.w	r3, r3, #1
2ffc42ba:	f8c4 3320 	str.w	r3, [r4, #800]	@ 0x320
  SET_BIT(DDRCTRL->HWLPCTL, DDRCTRL_HWLPCTL_HW_LP_EN);
2ffc42be:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
2ffc42c0:	f043 0301 	orr.w	r3, r3, #1
2ffc42c4:	63a3      	str	r3, [r4, #56]	@ 0x38
  MODIFY_REG(DDRCTRL->PWRTMG, DDRCTRL_PWRTMG_SELFREF_TO_X32_Msk,
2ffc42c6:	6b63      	ldr	r3, [r4, #52]	@ 0x34
2ffc42c8:	f423 037f 	bic.w	r3, r3, #16711680	@ 0xff0000
2ffc42cc:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
2ffc42d0:	6363      	str	r3, [r4, #52]	@ 0x34
  ret = wait_sw_done_ack();
2ffc42d2:	f7ff f997 	bl	2ffc3604 <wait_sw_done_ack>
  if (ret != HAL_OK)
2ffc42d6:	2800      	cmp	r0, #0
2ffc42d8:	f47f aed3 	bne.w	2ffc4082 <HAL_DDR_SR_SetMode+0x12>
  CLEAR_BIT(DDRCTRL->DBG1, DDRCTRL_DBG1_DIS_HIF);
2ffc42dc:	f8d4 3304 	ldr.w	r3, [r4, #772]	@ 0x304
2ffc42e0:	f023 0302 	bic.w	r3, r3, #2
2ffc42e4:	f8c4 3304 	str.w	r3, [r4, #772]	@ 0x304
  SET_BIT(DDRCTRL->PCTRL_0, DDRCTRL_PCTRL_0_PORT_EN);
2ffc42e8:	f8d4 3490 	ldr.w	r3, [r4, #1168]	@ 0x490
2ffc42ec:	f043 0301 	orr.w	r3, r3, #1
2ffc42f0:	f8c4 3490 	str.w	r3, [r4, #1168]	@ 0x490
  SET_BIT(DDRCTRL->PCTRL_1, DDRCTRL_PCTRL_0_PORT_EN);
2ffc42f4:	f8d4 3540 	ldr.w	r3, [r4, #1344]	@ 0x540
2ffc42f8:	f043 0301 	orr.w	r3, r3, #1
2ffc42fc:	f8c4 3540 	str.w	r3, [r4, #1344]	@ 0x540
  SET_BIT(DDRCTRL->PWRCTL, DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE);
2ffc4300:	6b23      	ldr	r3, [r4, #48]	@ 0x30
2ffc4302:	f043 0308 	orr.w	r3, r3, #8
2ffc4306:	6323      	str	r3, [r4, #48]	@ 0x30
    return HAL_OK;
2ffc4308:	2000      	movs	r0, #0
}
2ffc430a:	bd10      	pop	{r4, pc}

2ffc430c <HAL_DDR_Init>:
  if (iddr->wakeup_from_standby)
2ffc430c:	7803      	ldrb	r3, [r0, #0]
  CLEAR_BIT(RCC->DDRITFCR, RCC_DDRITFCR_AXIDCGEN);
2ffc430e:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
{
2ffc4312:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  switch (static_ddr_config.c_reg.MSTR & DDRCTRL_MSTR_DATA_BUS_WIDTH)
2ffc4316:	f241 751c 	movw	r5, #5916	@ 0x171c
2ffc431a:	7043      	strb	r3, [r0, #1]
{
2ffc431c:	b08f      	sub	sp, #60	@ 0x3c
  CLEAR_BIT(RCC->DDRITFCR, RCC_DDRITFCR_AXIDCGEN);
2ffc431e:	f8d2 30d8 	ldr.w	r3, [r2, #216]	@ 0xd8
{
2ffc4322:	4680      	mov	r8, r0
  switch (static_ddr_config.c_reg.MSTR & DDRCTRL_MSTR_DATA_BUS_WIDTH)
2ffc4324:	f6c2 75fd 	movt	r5, #12285	@ 0x2ffd
  CLEAR_BIT(RCC->DDRITFCR, RCC_DDRITFCR_AXIDCGEN);
2ffc4328:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
2ffc432c:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
  switch (static_ddr_config.c_reg.MSTR & DDRCTRL_MSTR_DATA_BUS_WIDTH)
2ffc4330:	68eb      	ldr	r3, [r5, #12]
2ffc4332:	f403 5240 	and.w	r2, r3, #12288	@ 0x3000
2ffc4336:	f5b2 5f80 	cmp.w	r2, #4096	@ 0x1000
2ffc433a:	f000 80b8 	beq.w	2ffc44ae <HAL_DDR_Init+0x1a2>
2ffc433e:	f5b2 5f00 	cmp.w	r2, #8192	@ 0x2000
2ffc4342:	f000 80b4 	beq.w	2ffc44ae <HAL_DDR_Init+0x1a2>
  if ((static_ddr_config.c_reg.MSTR & DDRCTRL_MSTR_DDR3) != 0U)
2ffc4346:	07d9      	lsls	r1, r3, #31
2ffc4348:	f100 80ba 	bmi.w	2ffc44c0 <HAL_DDR_Init+0x1b4>
  else if ((static_ddr_config.c_reg.MSTR & DDRCTRL_MSTR_LPDDR2) != 0U)
2ffc434c:	075a      	lsls	r2, r3, #29
2ffc434e:	f100 8452 	bmi.w	2ffc4bf6 <HAL_DDR_Init+0x8ea>
  else if ((static_ddr_config.c_reg.MSTR & DDRCTRL_MSTR_LPDDR3) != 0U)
2ffc4352:	0718      	lsls	r0, r3, #28
2ffc4354:	f140 80a7 	bpl.w	2ffc44a6 <HAL_DDR_Init+0x19a>
      iret = HAL_DDR_MspInit(STM32MP_LPDDR3_32);
2ffc4358:	2004      	movs	r0, #4
2ffc435a:	f006 ffdf 	bl	2ffcb31c <HAL_DDR_MspInit>
  if (iret != 0)
2ffc435e:	2800      	cmp	r0, #0
2ffc4360:	f040 80a1 	bne.w	2ffc44a6 <HAL_DDR_Init+0x19a>
  if (iddr->self_refresh)
2ffc4364:	f898 1001 	ldrb.w	r1, [r8, #1]
  ddr_reten = READ_REG(PWR->CR3) & PWR_CR3_DDRRETEN;
2ffc4368:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
2ffc436c:	f2c5 0300 	movt	r3, #20480	@ 0x5000
2ffc4370:	68da      	ldr	r2, [r3, #12]
2ffc4372:	f402 5280 	and.w	r2, r2, #4096	@ 0x1000
  if (iddr->self_refresh)
2ffc4376:	2900      	cmp	r1, #0
2ffc4378:	f000 8420 	beq.w	2ffc4bbc <HAL_DDR_Init+0x8b0>
    if (ddr_reten == 0U)
2ffc437c:	2a00      	cmp	r2, #0
2ffc437e:	f000 8436 	beq.w	2ffc4bee <HAL_DDR_Init+0x8e2>
  wait_loop_index = (delay_us * (SystemCoreClock / (1000000UL * 2UL)));
2ffc4382:	f241 7910 	movw	r9, #5904	@ 0x1710
2ffc4386:	f64d 6a83 	movw	sl, #56963	@ 0xde83
2ffc438a:	f6c2 79fd 	movt	r9, #12285	@ 0x2ffd
  CLEAR_BIT(DDRCTRL->DFIMISC, DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
2ffc438e:	f44f 5440 	mov.w	r4, #12288	@ 0x3000
  wait_loop_index = (delay_us * (SystemCoreClock / (1000000UL * 2UL)));
2ffc4392:	f2c4 3a1b 	movt	sl, #17179	@ 0x431b
  CLEAR_BIT(DDRCTRL->DFIMISC, DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
2ffc4396:	f6c5 2400 	movt	r4, #23040	@ 0x5a00
  if (ddr_clk > (mem_speed_hz / (uint32_t)10))
2ffc439a:	f64c 46cd 	movw	r6, #52429	@ 0xcccd
2ffc439e:	f6cc 46cc 	movt	r6, #52428	@ 0xcccc
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRCAPBRST);
2ffc43a2:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
  uint32_t mem_speed_hz = mem_speed * 1000U;
2ffc43a6:	f44f 717a 	mov.w	r1, #1000	@ 0x3e8
  HAL_RCC_GetPLL2ClockFreq(&PLL2);
2ffc43aa:	a80b      	add	r0, sp, #44	@ 0x2c
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRCAPBRST);
2ffc43ac:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc43b0:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
2ffc43b4:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRCAXIRST);
2ffc43b8:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc43bc:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
2ffc43c0:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRCORERST);
2ffc43c4:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc43c8:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
2ffc43cc:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DPHYAPBRST);
2ffc43d0:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc43d4:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
2ffc43d8:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DPHYRST);
2ffc43dc:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc43e0:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
2ffc43e4:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DPHYCTLRST);
2ffc43e8:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc43ec:	f442 2200 	orr.w	r2, r2, #524288	@ 0x80000
2ffc43f0:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRC1EN
2ffc43f4:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
  uint32_t mem_speed_hz = mem_speed * 1000U;
2ffc43f8:	686f      	ldr	r7, [r5, #4]
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRC1EN
2ffc43fa:	f442 7215 	orr.w	r2, r2, #596	@ 0x254
2ffc43fe:	f042 0201 	orr.w	r2, r2, #1
2ffc4402:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  uint32_t mem_speed_hz = mem_speed * 1000U;
2ffc4406:	fb01 f707 	mul.w	r7, r1, r7
  HAL_RCC_GetPLL2ClockFreq(&PLL2);
2ffc440a:	f002 f829 	bl	2ffc6460 <HAL_RCC_GetPLL2ClockFreq>
  ddrphy_clk = PLL2.PLL2_R_Frequency;
2ffc440e:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
  if (ddrphy_clk > mem_speed_hz)
2ffc4410:	429f      	cmp	r7, r3
    ddr_clk = ddrphy_clk - mem_speed_hz;
2ffc4412:	bf34      	ite	cc
2ffc4414:	1bdb      	subcc	r3, r3, r7
    ddr_clk = mem_speed_hz - ddrphy_clk;
2ffc4416:	1afb      	subcs	r3, r7, r3
  if (ddr_clk > (mem_speed_hz / (uint32_t)10))
2ffc4418:	fba6 2707 	umull	r2, r7, r6, r7
2ffc441c:	ebb3 0fd7 	cmp.w	r3, r7, lsr #3
2ffc4420:	d841      	bhi.n	2ffc44a6 <HAL_DDR_Init+0x19a>
  CLEAR_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DPHYRST);
2ffc4422:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
  __IO uint32_t wait_loop_index = 0U;
2ffc4426:	2100      	movs	r1, #0
  CLEAR_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DPHYRST);
2ffc4428:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc442c:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
2ffc4430:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  CLEAR_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DPHYCTLRST);
2ffc4434:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc4438:	f422 2200 	bic.w	r2, r2, #524288	@ 0x80000
2ffc443c:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  CLEAR_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRCAPBRST);
2ffc4440:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
2ffc4444:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
2ffc4448:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  wait_loop_index = (delay_us * (SystemCoreClock / (1000000UL * 2UL)));
2ffc444c:	f8d9 3000 	ldr.w	r3, [r9]
  __IO uint32_t wait_loop_index = 0U;
2ffc4450:	9103      	str	r1, [sp, #12]
  wait_loop_index = (delay_us * (SystemCoreClock / (1000000UL * 2UL)));
2ffc4452:	fbaa 2303 	umull	r2, r3, sl, r3
2ffc4456:	0cdb      	lsrs	r3, r3, #19
2ffc4458:	005b      	lsls	r3, r3, #1
2ffc445a:	9303      	str	r3, [sp, #12]
  while (wait_loop_index != 0UL)
2ffc445c:	9b03      	ldr	r3, [sp, #12]
2ffc445e:	b12b      	cbz	r3, 2ffc446c <HAL_DDR_Init+0x160>
    wait_loop_index--;
2ffc4460:	9b03      	ldr	r3, [sp, #12]
2ffc4462:	3b01      	subs	r3, #1
2ffc4464:	9303      	str	r3, [sp, #12]
  while (wait_loop_index != 0UL)
2ffc4466:	9b03      	ldr	r3, [sp, #12]
2ffc4468:	2b00      	cmp	r3, #0
2ffc446a:	d1f9      	bne.n	2ffc4460 <HAL_DDR_Init+0x154>
  if (INTERACTIVE(STEP_DDR_RESET))
2ffc446c:	2000      	movs	r0, #0
2ffc446e:	f005 fe77 	bl	2ffca160 <HAL_DDR_Interactive>
2ffc4472:	2800      	cmp	r0, #0
2ffc4474:	d195      	bne.n	2ffc43a2 <HAL_DDR_Init+0x96>
  CLEAR_BIT(DDRCTRL->DFIMISC, DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
2ffc4476:	f8d4 31b0 	ldr.w	r3, [r4, #432]	@ 0x1b0
2ffc447a:	4a5c      	ldr	r2, [pc, #368]	@ (2ffc45ec <HAL_DDR_Init+0x2e0>)
2ffc447c:	f023 0301 	bic.w	r3, r3, #1
  ret = set_reg(REG_REG, (uint32_t)&static_ddr_config.c_reg);
2ffc4480:	4f5b      	ldr	r7, [pc, #364]	@ (2ffc45f0 <HAL_DDR_Init+0x2e4>)
2ffc4482:	f102 00c8 	add.w	r0, r2, #200	@ 0xc8
  CLEAR_BIT(DDRCTRL->DFIMISC, DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
2ffc4486:	f8c4 31b0 	str.w	r3, [r4, #432]	@ 0x1b0
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc448a:	e009      	b.n	2ffc44a0 <HAL_DDR_Init+0x194>
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc448c:	8893      	ldrh	r3, [r2, #4]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc448e:	3208      	adds	r2, #8
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc4490:	59c9      	ldr	r1, [r1, r7]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc4492:	4290      	cmp	r0, r2
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc4494:	f103 43b4 	add.w	r3, r3, #1509949440	@ 0x5a000000
2ffc4498:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
2ffc449c:	6019      	str	r1, [r3, #0]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc449e:	d013      	beq.n	2ffc44c8 <HAL_DDR_Init+0x1bc>
    if (desc[i].par_offset == INVALID_OFFSET)
2ffc44a0:	7991      	ldrb	r1, [r2, #6]
2ffc44a2:	29ff      	cmp	r1, #255	@ 0xff
2ffc44a4:	d1f2      	bne.n	2ffc448c <HAL_DDR_Init+0x180>
    return HAL_ERROR;
2ffc44a6:	2001      	movs	r0, #1
}
2ffc44a8:	b00f      	add	sp, #60	@ 0x3c
2ffc44aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((static_ddr_config.c_reg.MSTR & DDRCTRL_MSTR_DDR3) != 0U)
2ffc44ae:	07df      	lsls	r7, r3, #31
2ffc44b0:	d406      	bmi.n	2ffc44c0 <HAL_DDR_Init+0x1b4>
  else if ((static_ddr_config.c_reg.MSTR & DDRCTRL_MSTR_LPDDR2) != 0U)
2ffc44b2:	075e      	lsls	r6, r3, #29
2ffc44b4:	f140 8393 	bpl.w	2ffc4bde <HAL_DDR_Init+0x8d2>
      iret = HAL_DDR_MspInit(STM32MP_LPDDR2_16);
2ffc44b8:	2001      	movs	r0, #1
2ffc44ba:	f006 ff2f 	bl	2ffcb31c <HAL_DDR_MspInit>
2ffc44be:	e74e      	b.n	2ffc435e <HAL_DDR_Init+0x52>
    iret = HAL_DDR_MspInit(STM32MP_DDR3);
2ffc44c0:	2000      	movs	r0, #0
2ffc44c2:	f006 ff2b 	bl	2ffcb31c <HAL_DDR_MspInit>
2ffc44c6:	e74a      	b.n	2ffc435e <HAL_DDR_Init+0x52>
       & (DDRCTRL_MSTR_DDR3 | DDRCTRL_MSTR_DLL_OFF_MODE))
2ffc44c8:	68ea      	ldr	r2, [r5, #12]
2ffc44ca:	f248 0301 	movw	r3, #32769	@ 0x8001
  ret = set_reg(REG_TIMING, (uint32_t)&static_ddr_config.c_timing);
2ffc44ce:	4f49      	ldr	r7, [pc, #292]	@ (2ffc45f4 <HAL_DDR_Init+0x2e8>)
  if ((static_ddr_config.c_reg.MSTR
2ffc44d0:	4393      	bics	r3, r2
    CLEAR_BIT(DDRCTRL->MSTR, DDRCTRL_MSTR_DLL_OFF_MODE);
2ffc44d2:	4a49      	ldr	r2, [pc, #292]	@ (2ffc45f8 <HAL_DDR_Init+0x2ec>)
2ffc44d4:	bf08      	it	eq
2ffc44d6:	6823      	ldreq	r3, [r4, #0]
2ffc44d8:	f102 0060 	add.w	r0, r2, #96	@ 0x60
2ffc44dc:	bf04      	itt	eq
2ffc44de:	f423 4300 	biceq.w	r3, r3, #32768	@ 0x8000
2ffc44e2:	6023      	streq	r3, [r4, #0]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc44e4:	e009      	b.n	2ffc44fa <HAL_DDR_Init+0x1ee>
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc44e6:	8893      	ldrh	r3, [r2, #4]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc44e8:	3208      	adds	r2, #8
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc44ea:	59c9      	ldr	r1, [r1, r7]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc44ec:	4282      	cmp	r2, r0
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc44ee:	f103 43b4 	add.w	r3, r3, #1509949440	@ 0x5a000000
2ffc44f2:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
2ffc44f6:	6019      	str	r1, [r3, #0]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc44f8:	d003      	beq.n	2ffc4502 <HAL_DDR_Init+0x1f6>
    if (desc[i].par_offset == INVALID_OFFSET)
2ffc44fa:	7991      	ldrb	r1, [r2, #6]
2ffc44fc:	29ff      	cmp	r1, #255	@ 0xff
2ffc44fe:	d1f2      	bne.n	2ffc44e6 <HAL_DDR_Init+0x1da>
2ffc4500:	e7d1      	b.n	2ffc44a6 <HAL_DDR_Init+0x19a>
  ret = set_reg(REG_MAP, (uint32_t)&static_ddr_config.c_map);
2ffc4502:	4a3e      	ldr	r2, [pc, #248]	@ (2ffc45fc <HAL_DDR_Init+0x2f0>)
2ffc4504:	4f3e      	ldr	r7, [pc, #248]	@ (2ffc4600 <HAL_DDR_Init+0x2f4>)
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc4506:	f102 0048 	add.w	r0, r2, #72	@ 0x48
2ffc450a:	e009      	b.n	2ffc4520 <HAL_DDR_Init+0x214>
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc450c:	8893      	ldrh	r3, [r2, #4]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc450e:	3208      	adds	r2, #8
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc4510:	59c9      	ldr	r1, [r1, r7]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc4512:	4290      	cmp	r0, r2
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc4514:	f103 43b4 	add.w	r3, r3, #1509949440	@ 0x5a000000
2ffc4518:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
2ffc451c:	6019      	str	r1, [r3, #0]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc451e:	d003      	beq.n	2ffc4528 <HAL_DDR_Init+0x21c>
    if (desc[i].par_offset == INVALID_OFFSET)
2ffc4520:	7991      	ldrb	r1, [r2, #6]
2ffc4522:	29ff      	cmp	r1, #255	@ 0xff
2ffc4524:	d1f2      	bne.n	2ffc450c <HAL_DDR_Init+0x200>
2ffc4526:	e7be      	b.n	2ffc44a6 <HAL_DDR_Init+0x19a>
  if (iddr->self_refresh)
2ffc4528:	f898 3001 	ldrb.w	r3, [r8, #1]
2ffc452c:	b11b      	cbz	r3, 2ffc4536 <HAL_DDR_Init+0x22a>
    SET_BIT(DDRCTRL->PWRCTL, DDRCTRL_PWRCTL_SELFREF_SW);
2ffc452e:	6b23      	ldr	r3, [r4, #48]	@ 0x30
2ffc4530:	f043 0320 	orr.w	r3, r3, #32
2ffc4534:	6323      	str	r3, [r4, #48]	@ 0x30
  MODIFY_REG(DDRCTRL->INIT0, DDRCTRL_INIT0_SKIP_DRAM_INIT_Msk,
2ffc4536:	f8d4 30d0 	ldr.w	r3, [r4, #208]	@ 0xd0
2ffc453a:	4a32      	ldr	r2, [pc, #200]	@ (2ffc4604 <HAL_DDR_Init+0x2f8>)
2ffc453c:	f023 4340 	bic.w	r3, r3, #3221225472	@ 0xc0000000
  ret = set_reg(REG_PERF, (uint32_t)&static_ddr_config.c_perf);
2ffc4540:	4f31      	ldr	r7, [pc, #196]	@ (2ffc4608 <HAL_DDR_Init+0x2fc>)
  MODIFY_REG(DDRCTRL->INIT0, DDRCTRL_INIT0_SKIP_DRAM_INIT_Msk,
2ffc4542:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
2ffc4546:	f8c4 30d0 	str.w	r3, [r4, #208]	@ 0xd0
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc454a:	f102 0088 	add.w	r0, r2, #136	@ 0x88
2ffc454e:	e009      	b.n	2ffc4564 <HAL_DDR_Init+0x258>
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc4550:	8893      	ldrh	r3, [r2, #4]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc4552:	3208      	adds	r2, #8
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc4554:	59c9      	ldr	r1, [r1, r7]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc4556:	4282      	cmp	r2, r0
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc4558:	f103 43b4 	add.w	r3, r3, #1509949440	@ 0x5a000000
2ffc455c:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
2ffc4560:	6019      	str	r1, [r3, #0]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc4562:	d003      	beq.n	2ffc456c <HAL_DDR_Init+0x260>
    if (desc[i].par_offset == INVALID_OFFSET)
2ffc4564:	7991      	ldrb	r1, [r2, #6]
2ffc4566:	29ff      	cmp	r1, #255	@ 0xff
2ffc4568:	d1f2      	bne.n	2ffc4550 <HAL_DDR_Init+0x244>
2ffc456a:	e79c      	b.n	2ffc44a6 <HAL_DDR_Init+0x19a>
  if (INTERACTIVE(STEP_CTL_INIT))
2ffc456c:	2001      	movs	r0, #1
2ffc456e:	f005 fdf7 	bl	2ffca160 <HAL_DDR_Interactive>
2ffc4572:	2800      	cmp	r0, #0
2ffc4574:	f47f af15 	bne.w	2ffc43a2 <HAL_DDR_Init+0x96>
  CLEAR_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRCORERST);
2ffc4578:	4a24      	ldr	r2, [pc, #144]	@ (2ffc460c <HAL_DDR_Init+0x300>)
2ffc457a:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
  ret = set_reg(REGPHY_REG, (uint32_t)&static_ddr_config.p_reg);
2ffc457e:	4f24      	ldr	r7, [pc, #144]	@ (2ffc4610 <HAL_DDR_Init+0x304>)
  CLEAR_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRCORERST);
2ffc4580:	f8d3 10d8 	ldr.w	r1, [r3, #216]	@ 0xd8
2ffc4584:	f102 0058 	add.w	r0, r2, #88	@ 0x58
2ffc4588:	f421 3180 	bic.w	r1, r1, #65536	@ 0x10000
2ffc458c:	f8c3 10d8 	str.w	r1, [r3, #216]	@ 0xd8
  CLEAR_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DDRCAXIRST);
2ffc4590:	f8d3 10d8 	ldr.w	r1, [r3, #216]	@ 0xd8
2ffc4594:	f421 4100 	bic.w	r1, r1, #32768	@ 0x8000
2ffc4598:	f8c3 10d8 	str.w	r1, [r3, #216]	@ 0xd8
  CLEAR_BIT(RCC->DDRITFCR, RCC_DDRITFCR_DPHYAPBRST);
2ffc459c:	f8d3 10d8 	ldr.w	r1, [r3, #216]	@ 0xd8
2ffc45a0:	f421 3100 	bic.w	r1, r1, #131072	@ 0x20000
2ffc45a4:	f8c3 10d8 	str.w	r1, [r3, #216]	@ 0xd8
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc45a8:	e009      	b.n	2ffc45be <HAL_DDR_Init+0x2b2>
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc45aa:	8893      	ldrh	r3, [r2, #4]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc45ac:	3208      	adds	r2, #8
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc45ae:	59c9      	ldr	r1, [r1, r7]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc45b0:	4282      	cmp	r2, r0
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc45b2:	f103 43b4 	add.w	r3, r3, #1509949440	@ 0x5a000000
2ffc45b6:	f503 4380 	add.w	r3, r3, #16384	@ 0x4000
2ffc45ba:	6019      	str	r1, [r3, #0]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc45bc:	d003      	beq.n	2ffc45c6 <HAL_DDR_Init+0x2ba>
    if (desc[i].par_offset == INVALID_OFFSET)
2ffc45be:	7991      	ldrb	r1, [r2, #6]
2ffc45c0:	29ff      	cmp	r1, #255	@ 0xff
2ffc45c2:	d1f2      	bne.n	2ffc45aa <HAL_DDR_Init+0x29e>
2ffc45c4:	e76f      	b.n	2ffc44a6 <HAL_DDR_Init+0x19a>
  ret = set_reg(REGPHY_TIMING, (uint32_t)&static_ddr_config.p_timing);
2ffc45c6:	4a13      	ldr	r2, [pc, #76]	@ (2ffc4614 <HAL_DDR_Init+0x308>)
2ffc45c8:	4f13      	ldr	r7, [pc, #76]	@ (2ffc4618 <HAL_DDR_Init+0x30c>)
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc45ca:	f102 0050 	add.w	r0, r2, #80	@ 0x50
2ffc45ce:	e009      	b.n	2ffc45e4 <HAL_DDR_Init+0x2d8>
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc45d0:	8893      	ldrh	r3, [r2, #4]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc45d2:	3208      	adds	r2, #8
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc45d4:	59c9      	ldr	r1, [r1, r7]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc45d6:	4290      	cmp	r0, r2
      WRITE_REG(*(volatile uint32_t *)(base_addr + (uint32_t)desc[i].offset),
2ffc45d8:	f103 43b4 	add.w	r3, r3, #1509949440	@ 0x5a000000
2ffc45dc:	f503 4380 	add.w	r3, r3, #16384	@ 0x4000
2ffc45e0:	6019      	str	r1, [r3, #0]
  for (i = 0; i < ddr_registers[type].size; i++)
2ffc45e2:	d01b      	beq.n	2ffc461c <HAL_DDR_Init+0x310>
    if (desc[i].par_offset == INVALID_OFFSET)
2ffc45e4:	7991      	ldrb	r1, [r2, #6]
2ffc45e6:	29ff      	cmp	r1, #255	@ 0xff
2ffc45e8:	d1f2      	bne.n	2ffc45d0 <HAL_DDR_Init+0x2c4>
2ffc45ea:	e75c      	b.n	2ffc44a6 <HAL_DDR_Init+0x19a>
2ffc45ec:	2ffce674 	.word	0x2ffce674
2ffc45f0:	2ffd1728 	.word	0x2ffd1728
2ffc45f4:	2ffd178c 	.word	0x2ffd178c
2ffc45f8:	2ffce73c 	.word	0x2ffce73c
2ffc45fc:	2ffce79c 	.word	0x2ffce79c
2ffc4600:	2ffd17bc 	.word	0x2ffd17bc
2ffc4604:	2ffce7e4 	.word	0x2ffce7e4
2ffc4608:	2ffd17e0 	.word	0x2ffd17e0
2ffc460c:	2ffce86c 	.word	0x2ffce86c
2ffc4610:	2ffd1824 	.word	0x2ffd1824
2ffc4614:	2ffce8c4 	.word	0x2ffce8c4
2ffc4618:	2ffd1850 	.word	0x2ffd1850
       & (DDRCTRL_MSTR_DDR3 | DDRCTRL_MSTR_DLL_OFF_MODE))
2ffc461c:	68ea      	ldr	r2, [r5, #12]
2ffc461e:	f248 0301 	movw	r3, #32769	@ 0x8001
  if ((static_ddr_config.c_reg.MSTR
2ffc4622:	4393      	bics	r3, r2
2ffc4624:	d107      	bne.n	2ffc4636 <HAL_DDR_Init+0x32a>
    CLEAR_BIT(DDRPHYC->MR1, DDRPHYC_MR1_DE);
2ffc4626:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
2ffc462a:	f6c5 2300 	movt	r3, #23040	@ 0x5a00
2ffc462e:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
2ffc4630:	f022 0201 	bic.w	r2, r2, #1
2ffc4634:	645a      	str	r2, [r3, #68]	@ 0x44
  if (INTERACTIVE(STEP_PHY_INIT))
2ffc4636:	2002      	movs	r0, #2
2ffc4638:	f005 fd92 	bl	2ffca160 <HAL_DDR_Interactive>
2ffc463c:	2800      	cmp	r0, #0
2ffc463e:	f47f aeb0 	bne.w	2ffc43a2 <HAL_DDR_Init+0x96>
  ret = ddrphy_idone_wait();
2ffc4642:	f7fe ffb1 	bl	2ffc35a8 <ddrphy_idone_wait>
  if (ret != HAL_OK)
2ffc4646:	2800      	cmp	r0, #0
2ffc4648:	f47f af2e 	bne.w	2ffc44a8 <HAL_DDR_Init+0x19c>
  if ((static_ddr_config.c_reg.MSTR & DDRCTRL_MSTR_DDR3) != 0U)
2ffc464c:	68ee      	ldr	r6, [r5, #12]
    pir |= DDRPHYC_PIR_DRAMRST; /* Only for DDR3 */
2ffc464e:	227e      	movs	r2, #126	@ 0x7e
  if (iddr->self_refresh)
2ffc4650:	f898 b001 	ldrb.w	fp, [r8, #1]
    pir |= DDRPHYC_PIR_DRAMRST; /* Only for DDR3 */
2ffc4654:	235e      	movs	r3, #94	@ 0x5e
2ffc4656:	f2c0 0201 	movt	r2, #1
2ffc465a:	f016 0f01 	tst.w	r6, #1
2ffc465e:	f2c0 0301 	movt	r3, #1
2ffc4662:	bf18      	it	ne
2ffc4664:	4613      	movne	r3, r2
  if (iddr->self_refresh)
2ffc4666:	f1bb 0f00 	cmp.w	fp, #0
2ffc466a:	d001      	beq.n	2ffc4670 <HAL_DDR_Init+0x364>
    pir |= DDRPHYC_PIR_ZCALBYP;
2ffc466c:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
  WRITE_REG(DDRPHYC->PIR, pir_init);
2ffc4670:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
  uint32_t pir_init = pir | DDRPHYC_PIR_INIT;
2ffc4674:	f043 0301 	orr.w	r3, r3, #1
  WRITE_REG(DDRPHYC->PIR, pir_init);
2ffc4678:	f6c5 2200 	movt	r2, #23040	@ 0x5a00
2ffc467c:	6053      	str	r3, [r2, #4]
  wait_loop_index = (delay_us * (SystemCoreClock / (1000000UL * 2UL)));
2ffc467e:	f8d9 3000 	ldr.w	r3, [r9]
2ffc4682:	fbaa 3703 	umull	r3, r7, sl, r3
2ffc4686:	230a      	movs	r3, #10
2ffc4688:	0cff      	lsrs	r7, r7, #19
2ffc468a:	fb03 f707 	mul.w	r7, r3, r7
  __IO uint32_t wait_loop_index = 0U;
2ffc468e:	2300      	movs	r3, #0
2ffc4690:	9304      	str	r3, [sp, #16]
  wait_loop_index = (delay_us * (SystemCoreClock / (1000000UL * 2UL)));
2ffc4692:	9704      	str	r7, [sp, #16]
  while (wait_loop_index != 0UL)
2ffc4694:	9b04      	ldr	r3, [sp, #16]
2ffc4696:	b12b      	cbz	r3, 2ffc46a4 <HAL_DDR_Init+0x398>
    wait_loop_index--;
2ffc4698:	9b04      	ldr	r3, [sp, #16]
2ffc469a:	3b01      	subs	r3, #1
2ffc469c:	9304      	str	r3, [sp, #16]
  while (wait_loop_index != 0UL)
2ffc469e:	9b04      	ldr	r3, [sp, #16]
2ffc46a0:	2b00      	cmp	r3, #0
2ffc46a2:	d1f9      	bne.n	2ffc4698 <HAL_DDR_Init+0x38c>
  return ddrphy_idone_wait();
2ffc46a4:	f7fe ff80 	bl	2ffc35a8 <ddrphy_idone_wait>
  if (ret != HAL_OK)
2ffc46a8:	2800      	cmp	r0, #0
2ffc46aa:	f47f aefd 	bne.w	2ffc44a8 <HAL_DDR_Init+0x19c>
  if (iddr->self_refresh)
2ffc46ae:	f1bb 0f00 	cmp.w	fp, #0
2ffc46b2:	f000 826d 	beq.w	2ffc4b90 <HAL_DDR_Init+0x884>
    ret = self_refresh_zcal(iddr->zdata);
2ffc46b6:	f8d8 e004 	ldr.w	lr, [r8, #4]
  SET_BIT(DDRPHYC->ZQ0CR0, DDRPHYC_ZQ0CR0_ZDEN);
2ffc46ba:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
2ffc46be:	f6c5 2300 	movt	r3, #23040	@ 0x5a00
  SET_BIT(PWR->CR3, PWR_CR3_DDRSRDIS);
2ffc46c2:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
2ffc46c6:	f2c5 0100 	movt	r1, #20480	@ 0x5000
  WRITE_REG(DDRPHYC->PIR, pir_init);
2ffc46ca:	f04f 0c09 	mov.w	ip, #9
  SET_BIT(DDRPHYC->ZQ0CR0, DDRPHYC_ZQ0CR0_ZDEN);
2ffc46ce:	f8d3 2180 	ldr.w	r2, [r3, #384]	@ 0x180
2ffc46d2:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
2ffc46d6:	f8c3 2180 	str.w	r2, [r3, #384]	@ 0x180
  MODIFY_REG(DDRPHYC->ZQ0CR0,
2ffc46da:	f8d3 2180 	ldr.w	r2, [r3, #384]	@ 0x180
2ffc46de:	0d12      	lsrs	r2, r2, #20
2ffc46e0:	0512      	lsls	r2, r2, #20
2ffc46e2:	ea42 020e 	orr.w	r2, r2, lr
2ffc46e6:	f8c3 2180 	str.w	r2, [r3, #384]	@ 0x180
  SET_BIT(PWR->CR3, PWR_CR3_DDRSRDIS);
2ffc46ea:	68ca      	ldr	r2, [r1, #12]
2ffc46ec:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
2ffc46f0:	60ca      	str	r2, [r1, #12]
  CLEAR_BIT(PWR->CR3, PWR_CR3_DDRRETEN);
2ffc46f2:	68ca      	ldr	r2, [r1, #12]
2ffc46f4:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
2ffc46f8:	60ca      	str	r2, [r1, #12]
  CLEAR_BIT(DDRPHYC->ZQ0CR0, DDRPHYC_ZQ0CR0_ZDEN);
2ffc46fa:	f8d3 2180 	ldr.w	r2, [r3, #384]	@ 0x180
2ffc46fe:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
2ffc4702:	f8c3 2180 	str.w	r2, [r3, #384]	@ 0x180
  WRITE_REG(DDRPHYC->PIR, pir_init);
2ffc4706:	f8c3 c004 	str.w	ip, [r3, #4]
  __IO uint32_t wait_loop_index = 0U;
2ffc470a:	9005      	str	r0, [sp, #20]
  wait_loop_index = (delay_us * (SystemCoreClock / (1000000UL * 2UL)));
2ffc470c:	9705      	str	r7, [sp, #20]
  while (wait_loop_index != 0UL)
2ffc470e:	9b05      	ldr	r3, [sp, #20]
2ffc4710:	b12b      	cbz	r3, 2ffc471e <HAL_DDR_Init+0x412>
    wait_loop_index--;
2ffc4712:	9b05      	ldr	r3, [sp, #20]
2ffc4714:	3b01      	subs	r3, #1
2ffc4716:	9305      	str	r3, [sp, #20]
  while (wait_loop_index != 0UL)
2ffc4718:	9b05      	ldr	r3, [sp, #20]
2ffc471a:	2b00      	cmp	r3, #0
2ffc471c:	d1f9      	bne.n	2ffc4712 <HAL_DDR_Init+0x406>
  return ddrphy_idone_wait();
2ffc471e:	f7fe ff43 	bl	2ffc35a8 <ddrphy_idone_wait>
    if (ret != HAL_OK)
2ffc4722:	2800      	cmp	r0, #0
2ffc4724:	f47f aec0 	bne.w	2ffc44a8 <HAL_DDR_Init+0x19c>
  CLEAR_BIT(DDRCTRL->SWCTL, DDRCTRL_SWCTL_SW_DONE);
2ffc4728:	f44f 5740 	mov.w	r7, #12288	@ 0x3000
2ffc472c:	f6c5 2700 	movt	r7, #23040	@ 0x5a00
2ffc4730:	f8d7 3320 	ldr.w	r3, [r7, #800]	@ 0x320
2ffc4734:	f023 0301 	bic.w	r3, r3, #1
2ffc4738:	f8c7 3320 	str.w	r3, [r7, #800]	@ 0x320
  SET_BIT(DDRCTRL->DFIMISC, DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
2ffc473c:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
2ffc4740:	f043 0301 	orr.w	r3, r3, #1
2ffc4744:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0
  ret = wait_sw_done_ack();
2ffc4748:	f7fe ff5c 	bl	2ffc3604 <wait_sw_done_ack>
  if (ret != HAL_OK)
2ffc474c:	2800      	cmp	r0, #0
2ffc474e:	f47f aeab 	bne.w	2ffc44a8 <HAL_DDR_Init+0x19c>
    CLEAR_BIT(DDRCTRL->PWRCTL, DDRCTRL_PWRCTL_SELFREF_SW);
2ffc4752:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2ffc4754:	f023 0320 	bic.w	r3, r3, #32
2ffc4758:	633b      	str	r3, [r7, #48]	@ 0x30
  ret = wait_operating_mode(DDRCTRL_STAT_OPERATING_MODE_NORMAL);
2ffc475a:	2001      	movs	r0, #1
2ffc475c:	f7fe ff7c 	bl	2ffc3658 <wait_operating_mode>
2ffc4760:	4603      	mov	r3, r0
  if (ret != HAL_OK)
2ffc4762:	2800      	cmp	r0, #0
2ffc4764:	f47f aea0 	bne.w	2ffc44a8 <HAL_DDR_Init+0x19c>
  if ((static_ddr_config.c_reg.MSTR & DDRCTRL_MSTR_DLL_OFF_MODE) != 0U)
2ffc4768:	0431      	lsls	r1, r6, #16
2ffc476a:	f140 80ad 	bpl.w	2ffc48c8 <HAL_DDR_Init+0x5bc>
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc476e:	f8d9 2000 	ldr.w	r2, [r9]
2ffc4772:	f64d 6183 	movw	r1, #56963	@ 0xde83
2ffc4776:	f2c4 311b 	movt	r1, #17179	@ 0x431b
  uint32_t mr1 = READ_REG(DDRPHYC->MR1);
2ffc477a:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc477e:	fba1 1202 	umull	r1, r2, r1, r2
  uint32_t mr1 = READ_REG(DDRPHYC->MR1);
2ffc4782:	f6c5 2000 	movt	r0, #23040	@ 0x5a00
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc4786:	f44f 6154 	mov.w	r1, #3392	@ 0xd40
2ffc478a:	f2c0 0103 	movt	r1, #3
  SET_BIT(DDRCTRL->DBG1, DDRCTRL_DBG1_DIS_HIF);
2ffc478e:	f44f 5640 	mov.w	r6, #12288	@ 0x3000
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc4792:	0cd2      	lsrs	r2, r2, #19
2ffc4794:	fb01 f202 	mul.w	r2, r1, r2
  uint32_t mr1 = READ_REG(DDRPHYC->MR1);
2ffc4798:	6c47      	ldr	r7, [r0, #68]	@ 0x44
           && ((dbgcam & DDRCTRL_DBGCAM_DBG_Q_DEPTH) == 0U));
2ffc479a:	f641 711f 	movw	r1, #7967	@ 0x1f1f
  uint32_t mr2 = READ_REG(DDRPHYC->MR2);
2ffc479e:	f8d0 b048 	ldr.w	fp, [r0, #72]	@ 0x48
  __IO uint32_t wait_loop_index = 0U;
2ffc47a2:	9307      	str	r3, [sp, #28]
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc47a4:	9207      	str	r2, [sp, #28]
  return wait_loop_index;
2ffc47a6:	9b07      	ldr	r3, [sp, #28]
  SET_BIT(DDRCTRL->DBG1, DDRCTRL_DBG1_DIS_HIF);
2ffc47a8:	f6c5 2600 	movt	r6, #23040	@ 0x5a00
  __IO uint32_t timeout = ddr_timeout_init_us(DDR_TIMEOUT_200_MS);
2ffc47ac:	9306      	str	r3, [sp, #24]
  SET_BIT(DDRCTRL->DBG1, DDRCTRL_DBG1_DIS_HIF);
2ffc47ae:	f8d6 3304 	ldr.w	r3, [r6, #772]	@ 0x304
           && ((dbgcam & DDRCTRL_DBGCAM_DBG_Q_DEPTH) == 0U));
2ffc47b2:	f2c3 4100 	movt	r1, #13312	@ 0x3400
  SET_BIT(DDRCTRL->DBG1, DDRCTRL_DBG1_DIS_HIF);
2ffc47b6:	f043 0302 	orr.w	r3, r3, #2
2ffc47ba:	f8c6 3304 	str.w	r3, [r6, #772]	@ 0x304
    timeout--;
2ffc47be:	9b06      	ldr	r3, [sp, #24]
2ffc47c0:	3b01      	subs	r3, #1
2ffc47c2:	9306      	str	r3, [sp, #24]
    if (ddr_timeout_elapsed(timeout))
2ffc47c4:	9b06      	ldr	r3, [sp, #24]
  if (timeout == 0U)
2ffc47c6:	2b00      	cmp	r3, #0
2ffc47c8:	f000 8205 	beq.w	2ffc4bd6 <HAL_DDR_Init+0x8ca>
    dbgcam = READ_REG(DDRCTRL->DBGCAM);
2ffc47cc:	f8d6 3308 	ldr.w	r3, [r6, #776]	@ 0x308
           && ((dbgcam & DDRCTRL_DBGCAM_DBG_Q_DEPTH) == 0U));
2ffc47d0:	400b      	ands	r3, r1
2ffc47d2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
2ffc47d6:	d0f2      	beq.n	2ffc47be <HAL_DDR_Init+0x4b2>
  mr1 &= ~(DDRPHYC_MR1_RTT0 | DDRPHYC_MR1_RTT1
2ffc47d8:	f427 7711 	bic.w	r7, r7, #580	@ 0x244
  ret = mode_register_write(1U, mr1);
2ffc47dc:	2001      	movs	r0, #1
2ffc47de:	4639      	mov	r1, r7
2ffc47e0:	f7ff f832 	bl	2ffc3848 <mode_register_write>
  if (ret != HAL_OK)
2ffc47e4:	2800      	cmp	r0, #0
2ffc47e6:	f47f ae5f 	bne.w	2ffc44a8 <HAL_DDR_Init+0x19c>
  ret = mode_register_write(2U, mr2);
2ffc47ea:	f42b 61c0 	bic.w	r1, fp, #1536	@ 0x600
2ffc47ee:	2002      	movs	r0, #2
2ffc47f0:	f7ff f82a 	bl	2ffc3848 <mode_register_write>
  if (ret != HAL_OK)
2ffc47f4:	2800      	cmp	r0, #0
2ffc47f6:	f47f ae57 	bne.w	2ffc44a8 <HAL_DDR_Init+0x19c>
  ret = mode_register_write(1U, mr1);
2ffc47fa:	f047 0101 	orr.w	r1, r7, #1
2ffc47fe:	2001      	movs	r0, #1
2ffc4800:	f7ff f822 	bl	2ffc3848 <mode_register_write>
  if (ret != HAL_OK)
2ffc4804:	2800      	cmp	r0, #0
2ffc4806:	f47f ae4f 	bne.w	2ffc44a8 <HAL_DDR_Init+0x19c>
  SET_BIT(DDRCTRL->PWRCTL, DDRCTRL_PWRCTL_SELFREF_SW);
2ffc480a:	6b33      	ldr	r3, [r6, #48]	@ 0x30
  ret = wait_operating_mode(DDRCTRL_STAT_OPERATING_MODE_SR);
2ffc480c:	2003      	movs	r0, #3
  SET_BIT(DDRCTRL->PWRCTL, DDRCTRL_PWRCTL_SELFREF_SW);
2ffc480e:	f043 0320 	orr.w	r3, r3, #32
2ffc4812:	6333      	str	r3, [r6, #48]	@ 0x30
  ret = wait_operating_mode(DDRCTRL_STAT_OPERATING_MODE_SR);
2ffc4814:	f7fe ff20 	bl	2ffc3658 <wait_operating_mode>
  if (ret != HAL_OK)
2ffc4818:	2800      	cmp	r0, #0
2ffc481a:	f47f ae45 	bne.w	2ffc44a8 <HAL_DDR_Init+0x19c>
  CLEAR_BIT(DDRCTRL->SWCTL, DDRCTRL_SWCTL_SW_DONE);
2ffc481e:	f8d6 3320 	ldr.w	r3, [r6, #800]	@ 0x320
2ffc4822:	f023 0301 	bic.w	r3, r3, #1
2ffc4826:	f8c6 3320 	str.w	r3, [r6, #800]	@ 0x320
  SET_BIT(DDRCTRL->MSTR, DDRCTRL_MSTR_DLL_OFF_MODE);
2ffc482a:	6833      	ldr	r3, [r6, #0]
2ffc482c:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
2ffc4830:	6033      	str	r3, [r6, #0]
  ret = wait_sw_done_ack();
2ffc4832:	f7fe fee7 	bl	2ffc3604 <wait_sw_done_ack>
  if (ret != HAL_OK)
2ffc4836:	2800      	cmp	r0, #0
2ffc4838:	f47f ae36 	bne.w	2ffc44a8 <HAL_DDR_Init+0x19c>
  if (static_ddr_config.info.speed < 100000U)
2ffc483c:	686a      	ldr	r2, [r5, #4]
2ffc483e:	f248 639f 	movw	r3, #34463	@ 0x869f
2ffc4842:	f2c0 0301 	movt	r3, #1
  CLEAR_BIT(DDRCTRL->PWRCTL, DDRCTRL_PWRCTL_SELFREF_SW);
2ffc4846:	f44f 5640 	mov.w	r6, #12288	@ 0x3000
  if (static_ddr_config.info.speed < 100000U)
2ffc484a:	429a      	cmp	r2, r3
    CLEAR_BIT(DDRPHYC->DLLGCR, DDRPHYC_DLLGCR_BPS200);
2ffc484c:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
2ffc4850:	f6c5 2300 	movt	r3, #23040	@ 0x5a00
  ret = wait_operating_mode(DDRCTRL_STAT_OPERATING_MODE_NORMAL);
2ffc4854:	f04f 0001 	mov.w	r0, #1
  CLEAR_BIT(DDRCTRL->PWRCTL, DDRCTRL_PWRCTL_SELFREF_SW);
2ffc4858:	f6c5 2600 	movt	r6, #23040	@ 0x5a00
    CLEAR_BIT(DDRPHYC->DLLGCR, DDRPHYC_DLLGCR_BPS200);
2ffc485c:	691a      	ldr	r2, [r3, #16]
2ffc485e:	bf94      	ite	ls
2ffc4860:	f422 0200 	bicls.w	r2, r2, #8388608	@ 0x800000
    SET_BIT(DDRPHYC->DLLGCR, DDRPHYC_DLLGCR_BPS200);
2ffc4864:	f442 0200 	orrhi.w	r2, r2, #8388608	@ 0x800000
2ffc4868:	611a      	str	r2, [r3, #16]
  SET_BIT(DDRPHYC->ACDLLCR, DDRPHYC_ACDLLCR_DLLDIS);
2ffc486a:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
2ffc486e:	f6c5 2300 	movt	r3, #23040	@ 0x5a00
2ffc4872:	695a      	ldr	r2, [r3, #20]
2ffc4874:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
2ffc4878:	615a      	str	r2, [r3, #20]
  SET_BIT(DDRPHYC->DX0DLLCR, DDRPHYC_DX0DLLCR_DLLDIS);
2ffc487a:	f8d3 21cc 	ldr.w	r2, [r3, #460]	@ 0x1cc
2ffc487e:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
2ffc4882:	f8c3 21cc 	str.w	r2, [r3, #460]	@ 0x1cc
  SET_BIT(DDRPHYC->DX1DLLCR, DDRPHYC_DX1DLLCR_DLLDIS);
2ffc4886:	f8d3 220c 	ldr.w	r2, [r3, #524]	@ 0x20c
2ffc488a:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
2ffc488e:	f8c3 220c 	str.w	r2, [r3, #524]	@ 0x20c
  SET_BIT(DDRPHYC->DX2DLLCR, DDRPHYC_DX2DLLCR_DLLDIS);
2ffc4892:	f8d3 224c 	ldr.w	r2, [r3, #588]	@ 0x24c
2ffc4896:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
2ffc489a:	f8c3 224c 	str.w	r2, [r3, #588]	@ 0x24c
  SET_BIT(DDRPHYC->DX3DLLCR, DDRPHYC_DX3DLLCR_DLLDIS);
2ffc489e:	f8d3 228c 	ldr.w	r2, [r3, #652]	@ 0x28c
2ffc48a2:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
2ffc48a6:	f8c3 228c 	str.w	r2, [r3, #652]	@ 0x28c
  CLEAR_BIT(DDRCTRL->PWRCTL, DDRCTRL_PWRCTL_SELFREF_SW);
2ffc48aa:	6b33      	ldr	r3, [r6, #48]	@ 0x30
2ffc48ac:	f023 0320 	bic.w	r3, r3, #32
2ffc48b0:	6333      	str	r3, [r6, #48]	@ 0x30
  ret = wait_operating_mode(DDRCTRL_STAT_OPERATING_MODE_NORMAL);
2ffc48b2:	f7fe fed1 	bl	2ffc3658 <wait_operating_mode>
  if (ret != HAL_OK)
2ffc48b6:	2800      	cmp	r0, #0
2ffc48b8:	f47f adf6 	bne.w	2ffc44a8 <HAL_DDR_Init+0x19c>
  CLEAR_BIT(DDRCTRL->DBG1, DDRCTRL_DBG1_DIS_HIF);
2ffc48bc:	f8d6 3304 	ldr.w	r3, [r6, #772]	@ 0x304
2ffc48c0:	f023 0302 	bic.w	r3, r3, #2
2ffc48c4:	f8c6 3304 	str.w	r3, [r6, #772]	@ 0x304
2ffc48c8:	ec57 6f0e 	mrrc	15, 0, r6, r7, cr14
  if (disable_host_interface() != 0)
2ffc48cc:	f7fe ff42 	bl	2ffc3754 <disable_host_interface>
2ffc48d0:	2800      	cmp	r0, #0
2ffc48d2:	f47f ade8 	bne.w	2ffc44a6 <HAL_DDR_Init+0x19a>
  CLEAR_BIT(DDRCTRL->SWCTL, DDRCTRL_SWCTL_SW_DONE);
2ffc48d6:	f44f 5b40 	mov.w	fp, #12288	@ 0x3000
2ffc48da:	f6c5 2b00 	movt	fp, #23040	@ 0x5a00
2ffc48de:	f8db 3320 	ldr.w	r3, [fp, #800]	@ 0x320
2ffc48e2:	f023 0301 	bic.w	r3, r3, #1
2ffc48e6:	f8cb 3320 	str.w	r3, [fp, #800]	@ 0x320
  SET_BIT(DDRCTRL->RFSHCTL3, DDRCTRL_RFSHCTL3_DIS_AUTO_REFRESH);
2ffc48ea:	f8db 3060 	ldr.w	r3, [fp, #96]	@ 0x60
2ffc48ee:	f043 0301 	orr.w	r3, r3, #1
2ffc48f2:	f8cb 3060 	str.w	r3, [fp, #96]	@ 0x60
  if (wait_refresh_update_done_ack() != 0)
2ffc48f6:	f7fe ff6d 	bl	2ffc37d4 <wait_refresh_update_done_ack>
2ffc48fa:	2800      	cmp	r0, #0
2ffc48fc:	f47f add3 	bne.w	2ffc44a6 <HAL_DDR_Init+0x19a>
  CLEAR_BIT(DDRCTRL->PWRCTL, DDRCTRL_PWRCTL_POWERDOWN_EN
2ffc4900:	f8db 3030 	ldr.w	r3, [fp, #48]	@ 0x30
2ffc4904:	f023 0303 	bic.w	r3, r3, #3
2ffc4908:	f8cb 3030 	str.w	r3, [fp, #48]	@ 0x30
  CLEAR_BIT(DDRCTRL->DFIMISC, DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
2ffc490c:	f8db 31b0 	ldr.w	r3, [fp, #432]	@ 0x1b0
2ffc4910:	f023 0301 	bic.w	r3, r3, #1
2ffc4914:	f8cb 31b0 	str.w	r3, [fp, #432]	@ 0x1b0
  ret = wait_sw_done_ack();
2ffc4918:	f7fe fe74 	bl	2ffc3604 <wait_sw_done_ack>
  if (ret != HAL_OK)
2ffc491c:	2800      	cmp	r0, #0
2ffc491e:	f47f adc3 	bne.w	2ffc44a8 <HAL_DDR_Init+0x19c>
  CLEAR_BIT(DDRCTRL->DBG1, DDRCTRL_DBG1_DIS_HIF);
2ffc4922:	f8db 3304 	ldr.w	r3, [fp, #772]	@ 0x304
  WRITE_REG(DDRPHYC->PIR, pir_init);
2ffc4926:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
2ffc492a:	f6c5 2200 	movt	r2, #23040	@ 0x5a00
  CLEAR_BIT(DDRCTRL->DBG1, DDRCTRL_DBG1_DIS_HIF);
2ffc492e:	f023 0302 	bic.w	r3, r3, #2
2ffc4932:	f8cb 3304 	str.w	r3, [fp, #772]	@ 0x304
  if ((static_ddr_config.c_reg.MSTR & DDRCTRL_MSTR_DDR3) == 0U)
2ffc4936:	68eb      	ldr	r3, [r5, #12]
2ffc4938:	f013 0f01 	tst.w	r3, #1
2ffc493c:	f240 1381 	movw	r3, #385	@ 0x181
2ffc4940:	bf18      	it	ne
2ffc4942:	2381      	movne	r3, #129	@ 0x81
  WRITE_REG(DDRPHYC->PIR, pir_init);
2ffc4944:	6053      	str	r3, [r2, #4]
  wait_loop_index = (delay_us * (SystemCoreClock / (1000000UL * 2UL)));
2ffc4946:	f8d9 3000 	ldr.w	r3, [r9]
  __IO uint32_t wait_loop_index = 0U;
2ffc494a:	9008      	str	r0, [sp, #32]
  wait_loop_index = (delay_us * (SystemCoreClock / (1000000UL * 2UL)));
2ffc494c:	fbaa 2303 	umull	r2, r3, sl, r3
2ffc4950:	220a      	movs	r2, #10
2ffc4952:	0cdb      	lsrs	r3, r3, #19
2ffc4954:	fb02 f303 	mul.w	r3, r2, r3
2ffc4958:	9308      	str	r3, [sp, #32]
  while (wait_loop_index != 0UL)
2ffc495a:	9b08      	ldr	r3, [sp, #32]
2ffc495c:	b12b      	cbz	r3, 2ffc496a <HAL_DDR_Init+0x65e>
    wait_loop_index--;
2ffc495e:	9b08      	ldr	r3, [sp, #32]
2ffc4960:	3b01      	subs	r3, #1
2ffc4962:	9308      	str	r3, [sp, #32]
  while (wait_loop_index != 0UL)
2ffc4964:	9b08      	ldr	r3, [sp, #32]
2ffc4966:	2b00      	cmp	r3, #0
2ffc4968:	d1f9      	bne.n	2ffc495e <HAL_DDR_Init+0x652>
  return ddrphy_idone_wait();
2ffc496a:	f7fe fe1d 	bl	2ffc35a8 <ddrphy_idone_wait>
  if (ret != HAL_OK)
2ffc496e:	2800      	cmp	r0, #0
2ffc4970:	f47f ad9a 	bne.w	2ffc44a8 <HAL_DDR_Init+0x19c>
  ret = ddrphy_idone_wait();
2ffc4974:	f7fe fe18 	bl	2ffc35a8 <ddrphy_idone_wait>
  if (ret != HAL_OK)
2ffc4978:	2800      	cmp	r0, #0
2ffc497a:	f47f ad95 	bne.w	2ffc44a8 <HAL_DDR_Init+0x19c>
  if (iddr->self_refresh)
2ffc497e:	f898 3001 	ldrb.w	r3, [r8, #1]
2ffc4982:	2b00      	cmp	r3, #0
2ffc4984:	d057      	beq.n	2ffc4a36 <HAL_DDR_Init+0x72a>
2ffc4986:	ec53 2f0e 	mrrc	15, 0, r2, r3, cr14
2ffc498a:	e9cd 2300 	strd	r2, r3, [sp]
  __get_CP(15, 0, result, 14, 0 , 0);
2ffc498e:	ee1e cf10 	mrc	15, 0, ip, cr14, cr0, {0}
  tck_ps = 1000000000U / static_ddr_config.info.speed;
2ffc4992:	6869      	ldr	r1, [r5, #4]
  if (tck_ps == 0U)
2ffc4994:	f44f 4e4a 	mov.w	lr, #51712	@ 0xca00
2ffc4998:	f6c3 3e9a 	movt	lr, #15258	@ 0x3b9a
2ffc499c:	4571      	cmp	r1, lr
2ffc499e:	d84a      	bhi.n	2ffc4a36 <HAL_DDR_Init+0x72a>
  trefi = ((READ_REG(DDRCTRL->RFSHTMG) & DDRCTRL_RFSHTMG_T_RFC_NOM_X1_X32_Msk)
2ffc49a0:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
2ffc49a4:	f6c5 2300 	movt	r3, #23040	@ 0x5a00
2ffc49a8:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
           >> DDRCTRL_RFSHTMG_T_RFC_NOM_X1_X32_Pos) * 32U;
2ffc49aa:	f3c2 420b 	ubfx	r2, r2, #16, #12
  if (trefi == 0U)
2ffc49ae:	ea4f 1b42 	mov.w	fp, r2, lsl #5
2ffc49b2:	2a00      	cmp	r2, #0
2ffc49b4:	d03f      	beq.n	2ffc4a36 <HAL_DDR_Init+0x72a>
  return (uint32_t)PL1_GetCurrentPhysicalValue() - base;
2ffc49b6:	9a00      	ldr	r2, [sp, #0]
  time_us = time / TIMESLOT_1US;
2ffc49b8:	f64d 6783 	movw	r7, #56963	@ 0xde83
2ffc49bc:	f2c4 371b 	movt	r7, #17179	@ 0x431b
  return (uint32_t)PL1_GetCurrentPhysicalValue() - base;
2ffc49c0:	1b92      	subs	r2, r2, r6
  time_us = time / TIMESLOT_1US;
2ffc49c2:	fba7 c60c 	umull	ip, r6, r7, ip
  tck_ps = 1000000000U / static_ddr_config.info.speed;
2ffc49c6:	fbbe f1f1 	udiv	r1, lr, r1
  time_us = time / TIMESLOT_1US;
2ffc49ca:	0cb6      	lsrs	r6, r6, #18
2ffc49cc:	fbb2 f2f6 	udiv	r2, r2, r6
  tref = time_us * 1000000U / tck_ps;
2ffc49d0:	f244 2640 	movw	r6, #16960	@ 0x4240
2ffc49d4:	f2c0 060f 	movt	r6, #15
2ffc49d8:	fb06 f202 	mul.w	r2, r6, r2
2ffc49dc:	fbb2 f2f1 	udiv	r2, r2, r1
  refcomp = (tref + trefi - 1U) / trefi;
2ffc49e0:	f10b 31ff 	add.w	r1, fp, #4294967295	@ 0xffffffff
2ffc49e4:	440a      	add	r2, r1
  for (i = 0U; i < refcomp; i++)
2ffc49e6:	4593      	cmp	fp, r2
  refcomp = (tref + trefi - 1U) / trefi;
2ffc49e8:	fbb2 f1fb 	udiv	r1, r2, fp
  for (i = 0U; i < refcomp; i++)
2ffc49ec:	d823      	bhi.n	2ffc4a36 <HAL_DDR_Init+0x72a>
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc49ee:	f8d9 2000 	ldr.w	r2, [r9]
2ffc49f2:	fba7 7602 	umull	r7, r6, r7, r2
2ffc49f6:	f44f 6254 	mov.w	r2, #3392	@ 0xd40
  __IO uint32_t wait_loop_index = 0U;
2ffc49fa:	4607      	mov	r7, r0
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc49fc:	0cf6      	lsrs	r6, r6, #19
2ffc49fe:	f2c0 0203 	movt	r2, #3
2ffc4a02:	fb02 f606 	mul.w	r6, r2, r6
  __IO uint32_t wait_loop_index = 0U;
2ffc4a06:	970a      	str	r7, [sp, #40]	@ 0x28
  wait_loop_index = timeout_us * (SystemCoreClock / (1000000UL * 2UL));
2ffc4a08:	960a      	str	r6, [sp, #40]	@ 0x28
  return wait_loop_index;
2ffc4a0a:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
  __IO uint32_t timeout = ddr_timeout_init_us(DDR_TIMEOUT_200_MS);
2ffc4a0c:	9209      	str	r2, [sp, #36]	@ 0x24
    timeout--;
2ffc4a0e:	9a09      	ldr	r2, [sp, #36]	@ 0x24
2ffc4a10:	3a01      	subs	r2, #1
2ffc4a12:	9209      	str	r2, [sp, #36]	@ 0x24
    if (ddr_timeout_elapsed(timeout))
2ffc4a14:	9a09      	ldr	r2, [sp, #36]	@ 0x24
  if (timeout == 0U)
2ffc4a16:	2a00      	cmp	r2, #0
2ffc4a18:	f000 80dd 	beq.w	2ffc4bd6 <HAL_DDR_Init+0x8ca>
    dbgstat = READ_REG(DDRCTRL->DBGSTAT);
2ffc4a1c:	f8d3 2310 	ldr.w	r2, [r3, #784]	@ 0x310
  } while ((dbgstat & DDRCTRL_DBGSTAT_RANK0_REFRESH_BUSY) != 0U);
2ffc4a20:	07d2      	lsls	r2, r2, #31
2ffc4a22:	d4f4      	bmi.n	2ffc4a0e <HAL_DDR_Init+0x702>
  SET_BIT(DDRCTRL->DBGCMD, DDRCTRL_DBGCMD_RANK0_REFRESH);
2ffc4a24:	f8d3 230c 	ldr.w	r2, [r3, #780]	@ 0x30c
  for (i = 0U; i < refcomp; i++)
2ffc4a28:	3001      	adds	r0, #1
2ffc4a2a:	4281      	cmp	r1, r0
  SET_BIT(DDRCTRL->DBGCMD, DDRCTRL_DBGCMD_RANK0_REFRESH);
2ffc4a2c:	f042 0201 	orr.w	r2, r2, #1
2ffc4a30:	f8c3 230c 	str.w	r2, [r3, #780]	@ 0x30c
  for (i = 0U; i < refcomp; i++)
2ffc4a34:	d8e7      	bhi.n	2ffc4a06 <HAL_DDR_Init+0x6fa>
  ret = HAL_DDR_Refresh_Restore(static_ddr_config.c_reg.RFSHCTL3,
2ffc4a36:	6b2f      	ldr	r7, [r5, #48]	@ 0x30
2ffc4a38:	6a2e      	ldr	r6, [r5, #32]
  if (disable_host_interface() != 0)
2ffc4a3a:	f7fe fe8b 	bl	2ffc3754 <disable_host_interface>
2ffc4a3e:	2800      	cmp	r0, #0
2ffc4a40:	f47f ad31 	bne.w	2ffc44a6 <HAL_DDR_Init+0x19a>
  CLEAR_BIT(DDRCTRL->SWCTL, DDRCTRL_SWCTL_SW_DONE);
2ffc4a44:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
2ffc4a48:	f6c5 2300 	movt	r3, #23040	@ 0x5a00
2ffc4a4c:	f8d3 2320 	ldr.w	r2, [r3, #800]	@ 0x320
2ffc4a50:	f022 0201 	bic.w	r2, r2, #1
2ffc4a54:	f8c3 2320 	str.w	r2, [r3, #800]	@ 0x320
  if ((rfshctl3 & DDRCTRL_RFSHCTL3_DIS_AUTO_REFRESH) == 0U)
2ffc4a58:	07fa      	lsls	r2, r7, #31
2ffc4a5a:	f140 80d1 	bpl.w	2ffc4c00 <HAL_DDR_Init+0x8f4>
  if ((pwrctl & DDRCTRL_PWRCTL_POWERDOWN_EN) != 0U)
2ffc4a5e:	07b7      	lsls	r7, r6, #30
2ffc4a60:	d507      	bpl.n	2ffc4a72 <HAL_DDR_Init+0x766>
    SET_BIT(DDRCTRL->PWRCTL, DDRCTRL_PWRCTL_POWERDOWN_EN);
2ffc4a62:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
2ffc4a66:	f6c5 2300 	movt	r3, #23040	@ 0x5a00
2ffc4a6a:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
2ffc4a6c:	f042 0202 	orr.w	r2, r2, #2
2ffc4a70:	631a      	str	r2, [r3, #48]	@ 0x30
  if ((pwrctl & DDRCTRL_PWRCTL_SELFREF_EN) != 0U)
2ffc4a72:	07f0      	lsls	r0, r6, #31
2ffc4a74:	d507      	bpl.n	2ffc4a86 <HAL_DDR_Init+0x77a>
    SET_BIT(DDRCTRL->PWRCTL, DDRCTRL_PWRCTL_SELFREF_EN);
2ffc4a76:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
2ffc4a7a:	f6c5 2300 	movt	r3, #23040	@ 0x5a00
2ffc4a7e:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
2ffc4a80:	f042 0201 	orr.w	r2, r2, #1
2ffc4a84:	631a      	str	r2, [r3, #48]	@ 0x30
  SET_BIT(DDRCTRL->DFIMISC, DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
2ffc4a86:	f44f 5640 	mov.w	r6, #12288	@ 0x3000
2ffc4a8a:	f6c5 2600 	movt	r6, #23040	@ 0x5a00
2ffc4a8e:	f8d6 31b0 	ldr.w	r3, [r6, #432]	@ 0x1b0
2ffc4a92:	f043 0301 	orr.w	r3, r3, #1
2ffc4a96:	f8c6 31b0 	str.w	r3, [r6, #432]	@ 0x1b0
  ret = wait_sw_done_ack();
2ffc4a9a:	f7fe fdb3 	bl	2ffc3604 <wait_sw_done_ack>
  if (ret != HAL_OK)
2ffc4a9e:	2800      	cmp	r0, #0
2ffc4aa0:	f47f ad02 	bne.w	2ffc44a8 <HAL_DDR_Init+0x19c>
  CLEAR_BIT(DDRCTRL->DBG1, DDRCTRL_DBG1_DIS_HIF);
2ffc4aa4:	f8d6 3304 	ldr.w	r3, [r6, #772]	@ 0x304
  if (INTERACTIVE(STEP_DDR_READY))
2ffc4aa8:	2003      	movs	r0, #3
  CLEAR_BIT(DDRCTRL->DBG1, DDRCTRL_DBG1_DIS_HIF);
2ffc4aaa:	f023 0302 	bic.w	r3, r3, #2
2ffc4aae:	f8c6 3304 	str.w	r3, [r6, #772]	@ 0x304
  SET_BIT(DDRCTRL->PCTRL_0, DDRCTRL_PCTRL_0_PORT_EN);
2ffc4ab2:	f8d6 3490 	ldr.w	r3, [r6, #1168]	@ 0x490
2ffc4ab6:	f043 0301 	orr.w	r3, r3, #1
2ffc4aba:	f8c6 3490 	str.w	r3, [r6, #1168]	@ 0x490
  SET_BIT(DDRCTRL->PCTRL_1, DDRCTRL_PCTRL_0_PORT_EN);
2ffc4abe:	f8d6 3540 	ldr.w	r3, [r6, #1344]	@ 0x540
2ffc4ac2:	f043 0301 	orr.w	r3, r3, #1
2ffc4ac6:	f8c6 3540 	str.w	r3, [r6, #1344]	@ 0x540
  if (INTERACTIVE(STEP_DDR_READY))
2ffc4aca:	f005 fb49 	bl	2ffca160 <HAL_DDR_Interactive>
2ffc4ace:	2800      	cmp	r0, #0
2ffc4ad0:	f47f ac63 	bne.w	2ffc439a <HAL_DDR_Init+0x8e>
  if ((iddr->wakeup_from_standby) && !iddr->self_refresh)
2ffc4ad4:	f898 1000 	ldrb.w	r1, [r8]
  SET_BIT(RCC->DDRITFCR, RCC_DDRITFCR_AXIDCGEN);
2ffc4ad8:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc4adc:	f8d2 30d8 	ldr.w	r3, [r2, #216]	@ 0xd8
2ffc4ae0:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
2ffc4ae4:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
  if ((iddr->wakeup_from_standby) && !iddr->self_refresh)
2ffc4ae8:	b129      	cbz	r1, 2ffc4af6 <HAL_DDR_Init+0x7ea>
2ffc4aea:	f898 3001 	ldrb.w	r3, [r8, #1]
2ffc4aee:	b913      	cbnz	r3, 2ffc4af6 <HAL_DDR_Init+0x7ea>
    iddr->clear_bkp = true;
2ffc4af0:	2301      	movs	r3, #1
2ffc4af2:	f888 3008 	strb.w	r3, [r8, #8]
  __get_CP(15, 0, result, 1, 0, 0);
2ffc4af6:	ee11 3f10 	mrc	15, 0, r3, cr1, cr0, {0}
  __set_SCTLR(__get_SCTLR() & ~SCTLR_C_BIT);
2ffc4afa:	f023 0304 	bic.w	r3, r3, #4
  __set_CP(15, 0, sctlr, 1, 0, 0);
2ffc4afe:	ee01 3f10 	mcr	15, 0, r3, cr1, cr0, {0}
  if (iddr->self_refresh)
2ffc4b02:	f898 3001 	ldrb.w	r3, [r8, #1]
2ffc4b06:	2b00      	cmp	r3, #0
2ffc4b08:	f000 8084 	beq.w	2ffc4c14 <HAL_DDR_Init+0x908>
  uint32_t saved_value = READ_REG(*(volatile uint32_t *)DDR_BASE_ADDR);
2ffc4b0c:	f04f 4440 	mov.w	r4, #3221225472	@ 0xc0000000
  WRITE_REG(*(volatile uint32_t *)DDR_BASE_ADDR, DDR_PATTERN);
2ffc4b10:	f04f 32aa 	mov.w	r2, #2863311530	@ 0xaaaaaaaa
  uint32_t saved_value = READ_REG(*(volatile uint32_t *)DDR_BASE_ADDR);
2ffc4b14:	6823      	ldr	r3, [r4, #0]
  WRITE_REG(*(volatile uint32_t *)DDR_BASE_ADDR, DDR_PATTERN);
2ffc4b16:	6022      	str	r2, [r4, #0]
  if (READ_REG(*(volatile uint32_t *)DDR_BASE_ADDR) != DDR_PATTERN)
2ffc4b18:	6822      	ldr	r2, [r4, #0]
2ffc4b1a:	f1b2 3faa 	cmp.w	r2, #2863311530	@ 0xaaaaaaaa
2ffc4b1e:	f47f acc2 	bne.w	2ffc44a6 <HAL_DDR_Init+0x19a>
  WRITE_REG(*(volatile uint32_t *)DDR_BASE_ADDR, saved_value);
2ffc4b22:	6023      	str	r3, [r4, #0]
  SET_BIT(RCC->MP_AHB5ENSETR, RCC_MP_AHB5ENSETR_BKPSRAMEN);
2ffc4b24:	f04f 46a0 	mov.w	r6, #1342177280	@ 0x50000000
  if (memcpy((uint32_t *)DDR_BASE_ADDR, (uint32_t *)BKPSRAM_BASE,
2ffc4b28:	f04f 45a8 	mov.w	r5, #1409286144	@ 0x54000000
  SET_BIT(RCC->MP_AHB5ENSETR, RCC_MP_AHB5ENSETR_BKPSRAMEN);
2ffc4b2c:	f8d6 3210 	ldr.w	r3, [r6, #528]	@ 0x210
2ffc4b30:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
2ffc4b34:	f8c6 3210 	str.w	r3, [r6, #528]	@ 0x210
  if (memcpy((uint32_t *)DDR_BASE_ADDR, (uint32_t *)BKPSRAM_BASE,
2ffc4b38:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
2ffc4b3a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
2ffc4b3c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
2ffc4b3e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
2ffc4b40:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
2ffc4b42:	c40f      	stmia	r4!, {r0, r1, r2, r3}
2ffc4b44:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
2ffc4b48:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  __ASM volatile ("dsb 0xF":::"memory");
2ffc4b4c:	f3bf 8f4f 	dsb	sy
  CLEAR_BIT(RCC->MP_AHB5ENSETR, RCC_MP_AHB5ENSETR_BKPSRAMEN);
2ffc4b50:	f8d6 3210 	ldr.w	r3, [r6, #528]	@ 0x210
2ffc4b54:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
2ffc4b58:	f8c6 3210 	str.w	r3, [r6, #528]	@ 0x210
  uint32_t pwrctl = READ_REG(DDRCTRL->PWRCTL);
2ffc4b5c:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
  if (HAL_DDR_SR_SetMode(ddr_sr_read_mode()) != HAL_OK)
2ffc4b60:	f24e 6314 	movw	r3, #58900	@ 0xe614
  uint32_t pwrctl = READ_REG(DDRCTRL->PWRCTL);
2ffc4b64:	f6c5 2200 	movt	r2, #23040	@ 0x5a00
  if (HAL_DDR_SR_SetMode(ddr_sr_read_mode()) != HAL_OK)
2ffc4b68:	f6c2 73fc 	movt	r3, #12284	@ 0x2ffc
  uint32_t pwrctl = READ_REG(DDRCTRL->PWRCTL);
2ffc4b6c:	6b12      	ldr	r2, [r2, #48]	@ 0x30
  switch (pwrctl & (DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE |
2ffc4b6e:	f002 0209 	and.w	r2, r2, #9
  if (HAL_DDR_SR_SetMode(ddr_sr_read_mode()) != HAL_OK)
2ffc4b72:	4413      	add	r3, r2
2ffc4b74:	f893 0300 	ldrb.w	r0, [r3, #768]	@ 0x300
2ffc4b78:	f7ff fa7a 	bl	2ffc4070 <HAL_DDR_SR_SetMode>
2ffc4b7c:	2800      	cmp	r0, #0
2ffc4b7e:	f47f ac92 	bne.w	2ffc44a6 <HAL_DDR_Init+0x19a>
  __get_CP(15, 0, result, 1, 0, 0);
2ffc4b82:	ee11 3f10 	mrc	15, 0, r3, cr1, cr0, {0}
  __set_SCTLR(__get_SCTLR() | SCTLR_C_BIT);
2ffc4b86:	f043 0304 	orr.w	r3, r3, #4
  __set_CP(15, 0, sctlr, 1, 0, 0);
2ffc4b8a:	ee01 3f10 	mcr	15, 0, r3, cr1, cr0, {0}
  return ret;
2ffc4b8e:	e48b      	b.n	2ffc44a8 <HAL_DDR_Init+0x19c>
  CLEAR_BIT(DDRCTRL->SWCTL, DDRCTRL_SWCTL_SW_DONE);
2ffc4b90:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
2ffc4b94:	f6c5 2300 	movt	r3, #23040	@ 0x5a00
2ffc4b98:	f8d3 2320 	ldr.w	r2, [r3, #800]	@ 0x320
2ffc4b9c:	f022 0201 	bic.w	r2, r2, #1
2ffc4ba0:	f8c3 2320 	str.w	r2, [r3, #800]	@ 0x320
  SET_BIT(DDRCTRL->DFIMISC, DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
2ffc4ba4:	f8d3 21b0 	ldr.w	r2, [r3, #432]	@ 0x1b0
2ffc4ba8:	f042 0201 	orr.w	r2, r2, #1
2ffc4bac:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
  ret = wait_sw_done_ack();
2ffc4bb0:	f7fe fd28 	bl	2ffc3604 <wait_sw_done_ack>
  if (ret != HAL_OK)
2ffc4bb4:	2800      	cmp	r0, #0
2ffc4bb6:	f43f add0 	beq.w	2ffc475a <HAL_DDR_Init+0x44e>
2ffc4bba:	e475      	b.n	2ffc44a8 <HAL_DDR_Init+0x19c>
    if (ddr_reten != 0U)
2ffc4bbc:	2a00      	cmp	r2, #0
2ffc4bbe:	f43f abe0 	beq.w	2ffc4382 <HAL_DDR_Init+0x76>
      SET_BIT(PWR->CR3, PWR_CR3_DDRSRDIS);
2ffc4bc2:	68da      	ldr	r2, [r3, #12]
2ffc4bc4:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
2ffc4bc8:	60da      	str	r2, [r3, #12]
      CLEAR_BIT(PWR->CR3, PWR_CR3_DDRRETEN);
2ffc4bca:	68da      	ldr	r2, [r3, #12]
2ffc4bcc:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
2ffc4bd0:	60da      	str	r2, [r3, #12]
2ffc4bd2:	f7ff bbd6 	b.w	2ffc4382 <HAL_DDR_Init+0x76>
    return HAL_ERROR;
2ffc4bd6:	2003      	movs	r0, #3
}
2ffc4bd8:	b00f      	add	sp, #60	@ 0x3c
2ffc4bda:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  else if ((static_ddr_config.c_reg.MSTR & DDRCTRL_MSTR_LPDDR3) != 0U)
2ffc4bde:	071c      	lsls	r4, r3, #28
2ffc4be0:	f57f ac61 	bpl.w	2ffc44a6 <HAL_DDR_Init+0x19a>
      iret = HAL_DDR_MspInit(STM32MP_LPDDR3_16);
2ffc4be4:	2003      	movs	r0, #3
2ffc4be6:	f006 fb99 	bl	2ffcb31c <HAL_DDR_MspInit>
2ffc4bea:	f7ff bbb8 	b.w	2ffc435e <HAL_DDR_Init+0x52>
      iddr->self_refresh = false;
2ffc4bee:	f888 0001 	strb.w	r0, [r8, #1]
2ffc4bf2:	f7ff bbc6 	b.w	2ffc4382 <HAL_DDR_Init+0x76>
      iret = HAL_DDR_MspInit(STM32MP_LPDDR2_32);
2ffc4bf6:	2002      	movs	r0, #2
2ffc4bf8:	f006 fb90 	bl	2ffcb31c <HAL_DDR_MspInit>
2ffc4bfc:	f7ff bbaf 	b.w	2ffc435e <HAL_DDR_Init+0x52>
    CLEAR_BIT(DDRCTRL->RFSHCTL3, DDRCTRL_RFSHCTL3_DIS_AUTO_REFRESH);
2ffc4c00:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
2ffc4c02:	f022 0201 	bic.w	r2, r2, #1
2ffc4c06:	661a      	str	r2, [r3, #96]	@ 0x60
    if (wait_refresh_update_done_ack() != 0)
2ffc4c08:	f7fe fde4 	bl	2ffc37d4 <wait_refresh_update_done_ack>
2ffc4c0c:	2800      	cmp	r0, #0
2ffc4c0e:	f43f af26 	beq.w	2ffc4a5e <HAL_DDR_Init+0x752>
2ffc4c12:	e448      	b.n	2ffc44a6 <HAL_DDR_Init+0x19a>
    pattern = (uint32_t)1 << i;
2ffc4c14:	2001      	movs	r0, #1
    WRITE_REG(*(volatile uint32_t *)DDR_BASE_ADDR, pattern);
2ffc4c16:	f04f 4240 	mov.w	r2, #3221225472	@ 0xc0000000
2ffc4c1a:	e001      	b.n	2ffc4c20 <HAL_DDR_Init+0x914>
  for (i = 0U; i < 32U; i++)
2ffc4c1c:	2b20      	cmp	r3, #32
2ffc4c1e:	d007      	beq.n	2ffc4c30 <HAL_DDR_Init+0x924>
    pattern = (uint32_t)1 << i;
2ffc4c20:	fa00 f103 	lsl.w	r1, r0, r3
    WRITE_REG(*(volatile uint32_t *)DDR_BASE_ADDR, pattern);
2ffc4c24:	3301      	adds	r3, #1
2ffc4c26:	6011      	str	r1, [r2, #0]
    if (READ_REG(*(volatile uint32_t *)DDR_BASE_ADDR) != pattern)
2ffc4c28:	6814      	ldr	r4, [r2, #0]
2ffc4c2a:	42a1      	cmp	r1, r4
2ffc4c2c:	d0f6      	beq.n	2ffc4c1c <HAL_DDR_Init+0x910>
2ffc4c2e:	e43a      	b.n	2ffc44a6 <HAL_DDR_Init+0x19a>
  uint32_t addressmask = (static_ddr_config.info.size - 1U);
2ffc4c30:	68ab      	ldr	r3, [r5, #8]
2ffc4c32:	3b01      	subs	r3, #1
  for (offset = sizeof(uint32_t); (offset & addressmask) != 0U; offset <<= 1)
2ffc4c34:	0759      	lsls	r1, r3, #29
2ffc4c36:	bf44      	itt	mi
2ffc4c38:	2204      	movmi	r2, #4
    WRITE_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)offset),
2ffc4c3a:	f04f 31aa 	movmi.w	r1, #2863311530	@ 0xaaaaaaaa
  for (offset = sizeof(uint32_t); (offset & addressmask) != 0U; offset <<= 1)
2ffc4c3e:	d517      	bpl.n	2ffc4c70 <HAL_DDR_Init+0x964>
    WRITE_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)offset),
2ffc4c40:	f102 4040 	add.w	r0, r2, #3221225472	@ 0xc0000000
  for (offset = sizeof(uint32_t); (offset & addressmask) != 0U; offset <<= 1)
2ffc4c44:	0052      	lsls	r2, r2, #1
2ffc4c46:	4213      	tst	r3, r2
    WRITE_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)offset),
2ffc4c48:	6001      	str	r1, [r0, #0]
  for (offset = sizeof(uint32_t); (offset & addressmask) != 0U; offset <<= 1)
2ffc4c4a:	d1f9      	bne.n	2ffc4c40 <HAL_DDR_Init+0x934>
  WRITE_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)testoffset),
2ffc4c4c:	f04f 4140 	mov.w	r1, #3221225472	@ 0xc0000000
2ffc4c50:	f04f 3055 	mov.w	r0, #1431655765	@ 0x55555555
  for (offset = sizeof(uint32_t); (offset & addressmask) != 0U; offset <<= 1)
2ffc4c54:	2204      	movs	r2, #4
  WRITE_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)testoffset),
2ffc4c56:	6008      	str	r0, [r1, #0]
  for (offset = sizeof(uint32_t); (offset & addressmask) != 0U; offset <<= 1)
2ffc4c58:	e001      	b.n	2ffc4c5e <HAL_DDR_Init+0x952>
2ffc4c5a:	4213      	tst	r3, r2
2ffc4c5c:	d02a      	beq.n	2ffc4cb4 <HAL_DDR_Init+0x9a8>
    if (READ_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)offset))
2ffc4c5e:	f102 4040 	add.w	r0, r2, #3221225472	@ 0xc0000000
  for (offset = sizeof(uint32_t); (offset & addressmask) != 0U; offset <<= 1)
2ffc4c62:	0052      	lsls	r2, r2, #1
    if (READ_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)offset))
2ffc4c64:	6806      	ldr	r6, [r0, #0]
2ffc4c66:	f1b6 3faa 	cmp.w	r6, #2863311530	@ 0xaaaaaaaa
2ffc4c6a:	d0f6      	beq.n	2ffc4c5a <HAL_DDR_Init+0x94e>
    if (uret != 0U)
2ffc4c6c:	b130      	cbz	r0, 2ffc4c7c <HAL_DDR_Init+0x970>
2ffc4c6e:	e41a      	b.n	2ffc44a6 <HAL_DDR_Init+0x19a>
  WRITE_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)testoffset),
2ffc4c70:	f04f 3155 	mov.w	r1, #1431655765	@ 0x55555555
  WRITE_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)testoffset),
2ffc4c74:	f04f 33aa 	mov.w	r3, #2863311530	@ 0xaaaaaaaa
  WRITE_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)testoffset),
2ffc4c78:	6011      	str	r1, [r2, #0]
  WRITE_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)testoffset),
2ffc4c7a:	6013      	str	r3, [r2, #0]
  WRITE_REG(*(volatile uint32_t *)DDR_BASE_ADDR, DDR_PATTERN);
2ffc4c7c:	f04f 4140 	mov.w	r1, #3221225472	@ 0xc0000000
2ffc4c80:	f04f 30aa 	mov.w	r0, #2863311530	@ 0xaaaaaaaa
2ffc4c84:	221c      	movs	r2, #28
  uint32_t offset = sizeof(uint32_t);
2ffc4c86:	2304      	movs	r3, #4
  WRITE_REG(*(volatile uint32_t *)DDR_BASE_ADDR, DDR_PATTERN);
2ffc4c88:	6008      	str	r0, [r1, #0]
    WRITE_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + offset), DDR_ANTIPATTERN);
2ffc4c8a:	f04f 3455 	mov.w	r4, #1431655765	@ 0x55555555
2ffc4c8e:	e002      	b.n	2ffc4c96 <HAL_DDR_Init+0x98a>
    offset <<= 1;
2ffc4c90:	005b      	lsls	r3, r3, #1
  while (offset < DDR_MAX_SIZE)
2ffc4c92:	3a01      	subs	r2, #1
2ffc4c94:	d008      	beq.n	2ffc4ca8 <HAL_DDR_Init+0x99c>
    WRITE_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + offset), DDR_ANTIPATTERN);
2ffc4c96:	f103 4040 	add.w	r0, r3, #3221225472	@ 0xc0000000
2ffc4c9a:	6004      	str	r4, [r0, #0]
2ffc4c9c:	f3bf 8f4f 	dsb	sy
    if (READ_REG(*(volatile uint32_t *)DDR_BASE_ADDR) != DDR_PATTERN)
2ffc4ca0:	6808      	ldr	r0, [r1, #0]
2ffc4ca2:	f1b0 3faa 	cmp.w	r0, #2863311530	@ 0xaaaaaaaa
2ffc4ca6:	d0f3      	beq.n	2ffc4c90 <HAL_DDR_Init+0x984>
    if (uret < static_ddr_config.info.size)
2ffc4ca8:	68aa      	ldr	r2, [r5, #8]
2ffc4caa:	4293      	cmp	r3, r2
2ffc4cac:	f4bf af56 	bcs.w	2ffc4b5c <HAL_DDR_Init+0x850>
2ffc4cb0:	f7ff bbf9 	b.w	2ffc44a6 <HAL_DDR_Init+0x19a>
  WRITE_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)testoffset),
2ffc4cb4:	f04f 4440 	mov.w	r4, #3221225472	@ 0xc0000000
  for (testoffset = sizeof(uint32_t); (testoffset & addressmask) != 0U;
2ffc4cb8:	2204      	movs	r2, #4
    WRITE_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)testoffset),
2ffc4cba:	f04f 3c55 	mov.w	ip, #1431655765	@ 0x55555555
  WRITE_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)testoffset),
2ffc4cbe:	6026      	str	r6, [r4, #0]
    WRITE_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)testoffset),
2ffc4cc0:	f102 4740 	add.w	r7, r2, #3221225472	@ 0xc0000000
2ffc4cc4:	f8c7 c000 	str.w	ip, [r7]
    if (READ_REG(*(volatile uint32_t *)DDR_BASE_ADDR) != DDR_PATTERN)
2ffc4cc8:	6821      	ldr	r1, [r4, #0]
2ffc4cca:	f1b1 3faa 	cmp.w	r1, #2863311530	@ 0xaaaaaaaa
2ffc4cce:	f47f abea 	bne.w	2ffc44a6 <HAL_DDR_Init+0x19a>
      if ((READ_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)offset))
2ffc4cd2:	6861      	ldr	r1, [r4, #4]
          && (offset != testoffset))
2ffc4cd4:	f1b1 3faa 	cmp.w	r1, #2863311530	@ 0xaaaaaaaa
2ffc4cd8:	bf18      	it	ne
2ffc4cda:	2a04      	cmpne	r2, #4
2ffc4cdc:	f47f abe3 	bne.w	2ffc44a6 <HAL_DDR_Init+0x19a>
    for (offset = sizeof(uint32_t); (offset & addressmask) != 0U;
2ffc4ce0:	2104      	movs	r1, #4
2ffc4ce2:	e006      	b.n	2ffc4cf2 <HAL_DDR_Init+0x9e6>
      if ((READ_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)offset))
2ffc4ce4:	f8d0 e000 	ldr.w	lr, [r0]
          && (offset != testoffset))
2ffc4ce8:	428a      	cmp	r2, r1
2ffc4cea:	bf18      	it	ne
2ffc4cec:	f1be 3faa 	cmpne.w	lr, #2863311530	@ 0xaaaaaaaa
2ffc4cf0:	d1bc      	bne.n	2ffc4c6c <HAL_DDR_Init+0x960>
         offset <<= 1)
2ffc4cf2:	0049      	lsls	r1, r1, #1
    for (offset = sizeof(uint32_t); (offset & addressmask) != 0U;
2ffc4cf4:	420b      	tst	r3, r1
      if ((READ_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)offset))
2ffc4cf6:	f101 4040 	add.w	r0, r1, #3221225472	@ 0xc0000000
    for (offset = sizeof(uint32_t); (offset & addressmask) != 0U;
2ffc4cfa:	d1f3      	bne.n	2ffc4ce4 <HAL_DDR_Init+0x9d8>
       testoffset <<= 1)
2ffc4cfc:	0052      	lsls	r2, r2, #1
  for (testoffset = sizeof(uint32_t); (testoffset & addressmask) != 0U;
2ffc4cfe:	4213      	tst	r3, r2
    WRITE_REG(*(volatile uint32_t *)(DDR_BASE_ADDR + (uint32_t)testoffset),
2ffc4d00:	603e      	str	r6, [r7, #0]
  for (testoffset = sizeof(uint32_t); (testoffset & addressmask) != 0U;
2ffc4d02:	d1dd      	bne.n	2ffc4cc0 <HAL_DDR_Init+0x9b4>
2ffc4d04:	e7ba      	b.n	2ffc4c7c <HAL_DDR_Init+0x970>
2ffc4d06:	bf00      	nop

2ffc4d08 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
2ffc4d08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        temp = EXTI->EXTICR[position >> 2U];
        temp &= ~(0xFFU << (8U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
2ffc4d0c:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
2ffc4d10:	f2c5 0200 	movt	r2, #20480	@ 0x5000
{
2ffc4d14:	b085      	sub	sp, #20
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
2ffc4d16:	680d      	ldr	r5, [r1, #0]
        EXTI->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
2ffc4d18:	f44f 4750 	mov.w	r7, #53248	@ 0xd000
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
2ffc4d1c:	9201      	str	r2, [sp, #4]
2ffc4d1e:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
2ffc4d22:	f2c5 0200 	movt	r2, #20480	@ 0x5000
  for(position = 0; position < GPIO_NUMBER; position++)
2ffc4d26:	2300      	movs	r3, #0
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
2ffc4d28:	9202      	str	r2, [sp, #8]
2ffc4d2a:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
        temp = EXTI_CurrentCPU->IMR1;
2ffc4d2e:	f2c5 0700 	movt	r7, #20480	@ 0x5000
    ioposition = ((uint32_t)0x01) << position;
2ffc4d32:	f04f 0801 	mov.w	r8, #1
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
2ffc4d36:	f2c5 0200 	movt	r2, #20480	@ 0x5000
2ffc4d3a:	9203      	str	r2, [sp, #12]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
2ffc4d3c:	9700      	str	r7, [sp, #0]
2ffc4d3e:	e003      	b.n	2ffc4d48 <HAL_GPIO_Init+0x40>
  for(position = 0; position < GPIO_NUMBER; position++)
2ffc4d40:	3301      	adds	r3, #1
2ffc4d42:	2b10      	cmp	r3, #16
2ffc4d44:	f000 80df 	beq.w	2ffc4f06 <HAL_GPIO_Init+0x1fe>
    ioposition = ((uint32_t)0x01) << position;
2ffc4d48:	fa08 f203 	lsl.w	r2, r8, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
2ffc4d4c:	ea02 0e05 	and.w	lr, r2, r5
    if(iocurrent == ioposition)
2ffc4d50:	ea32 0405 	bics.w	r4, r2, r5
2ffc4d54:	d1f4      	bne.n	2ffc4d40 <HAL_GPIO_Init+0x38>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
2ffc4d56:	684c      	ldr	r4, [r1, #4]
2ffc4d58:	f024 0910 	bic.w	r9, r4, #16
2ffc4d5c:	f1b9 0f02 	cmp.w	r9, #2
2ffc4d60:	f040 80d4 	bne.w	2ffc4f0c <HAL_GPIO_Init+0x204>
        temp = GPIOx->AFR[position >> 3];
2ffc4d64:	ea4f 09d3 	mov.w	r9, r3, lsr #3
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
2ffc4d68:	f003 0c07 	and.w	ip, r3, #7
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
2ffc4d6c:	690e      	ldr	r6, [r1, #16]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
2ffc4d6e:	270f      	movs	r7, #15
2ffc4d70:	eb00 0989 	add.w	r9, r0, r9, lsl #2
2ffc4d74:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
        temp = GPIOx->AFR[position >> 3];
2ffc4d78:	f8d9 a020 	ldr.w	sl, [r9, #32]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
2ffc4d7c:	fa06 f60c 	lsl.w	r6, r6, ip
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
2ffc4d80:	fa07 fc0c 	lsl.w	ip, r7, ip
2ffc4d84:	ea2a 0a0c 	bic.w	sl, sl, ip
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
2ffc4d88:	ea46 060a 	orr.w	r6, r6, sl
        GPIOx->AFR[position >> 3] = temp;
2ffc4d8c:	f8c9 6020 	str.w	r6, [r9, #32]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
2ffc4d90:	2603      	movs	r6, #3
2ffc4d92:	ea4f 0c43 	mov.w	ip, r3, lsl #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
2ffc4d96:	f004 0903 	and.w	r9, r4, #3
      temp = GPIOx->MODER;
2ffc4d9a:	f8d0 a000 	ldr.w	sl, [r0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
2ffc4d9e:	fa06 f60c 	lsl.w	r6, r6, ip
2ffc4da2:	ea2a 0a06 	bic.w	sl, sl, r6
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
2ffc4da6:	fa09 f90c 	lsl.w	r9, r9, ip
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
2ffc4daa:	43f6      	mvns	r6, r6
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
2ffc4dac:	ea49 090a 	orr.w	r9, r9, sl
      GPIOx->MODER = temp;
2ffc4db0:	f8c0 9000 	str.w	r9, [r0]
        temp = GPIOx->OSPEEDR;
2ffc4db4:	f8d0 9008 	ldr.w	r9, [r0, #8]
        temp |= (GPIO_Init->Speed << (position * 2));
2ffc4db8:	68cf      	ldr	r7, [r1, #12]
        temp &= ~(GPIO_OSPEEDR_OSPEEDR0 << (position * 2));
2ffc4dba:	ea09 0906 	and.w	r9, r9, r6
        temp |= (GPIO_Init->Speed << (position * 2));
2ffc4dbe:	fa07 fa0c 	lsl.w	sl, r7, ip
2ffc4dc2:	ea4a 0a09 	orr.w	sl, sl, r9
        GPIOx->OSPEEDR = temp;
2ffc4dc6:	f8c0 a008 	str.w	sl, [r0, #8]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
2ffc4dca:	f3c4 1900 	ubfx	r9, r4, #4, #1
        temp = GPIOx->OTYPER;
2ffc4dce:	f8d0 a004 	ldr.w	sl, [r0, #4]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
2ffc4dd2:	fa09 f903 	lsl.w	r9, r9, r3
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
2ffc4dd6:	ea2a 0a02 	bic.w	sl, sl, r2
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
2ffc4dda:	ea49 020a 	orr.w	r2, r9, sl
        GPIOx->OTYPER = temp;
2ffc4dde:	6042      	str	r2, [r0, #4]
      temp = GPIOx->PUPDR;
2ffc4de0:	68c2      	ldr	r2, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
2ffc4de2:	4016      	ands	r6, r2
      temp |= ((GPIO_Init->Pull) << (position * 2));
2ffc4de4:	688a      	ldr	r2, [r1, #8]
2ffc4de6:	fa02 f20c 	lsl.w	r2, r2, ip
2ffc4dea:	4332      	orrs	r2, r6
      GPIOx->PUPDR = temp;
2ffc4dec:	60c2      	str	r2, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
2ffc4dee:	00e2      	lsls	r2, r4, #3
2ffc4df0:	d5a6      	bpl.n	2ffc4d40 <HAL_GPIO_Init+0x38>
        temp = EXTI->EXTICR[position >> 2U];
2ffc4df2:	f023 0203 	bic.w	r2, r3, #3
        temp &= ~(0xFFU << (8U * (position & 0x03U)));
2ffc4df6:	f003 0c03 	and.w	ip, r3, #3
2ffc4dfa:	27ff      	movs	r7, #255	@ 0xff
2ffc4dfc:	f102 42a0 	add.w	r2, r2, #1342177280	@ 0x50000000
2ffc4e00:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
2ffc4e04:	f502 4250 	add.w	r2, r2, #53248	@ 0xd000
2ffc4e08:	fa07 f90c 	lsl.w	r9, r7, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
2ffc4e0c:	9f01      	ldr	r7, [sp, #4]
        temp = EXTI->EXTICR[position >> 2U];
2ffc4e0e:	6e16      	ldr	r6, [r2, #96]	@ 0x60
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
2ffc4e10:	42b8      	cmp	r0, r7
        temp &= ~(0xFFU << (8U * (position & 0x03U)));
2ffc4e12:	ea26 0609 	bic.w	r6, r6, r9
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
2ffc4e16:	d04a      	beq.n	2ffc4eae <HAL_GPIO_Init+0x1a6>
2ffc4e18:	9f02      	ldr	r7, [sp, #8]
2ffc4e1a:	42b8      	cmp	r0, r7
2ffc4e1c:	f000 8090 	beq.w	2ffc4f40 <HAL_GPIO_Init+0x238>
2ffc4e20:	9f03      	ldr	r7, [sp, #12]
2ffc4e22:	42b8      	cmp	r0, r7
2ffc4e24:	f000 8093 	beq.w	2ffc4f4e <HAL_GPIO_Init+0x246>
2ffc4e28:	f1b0 2f50 	cmp.w	r0, #1342197760	@ 0x50005000
2ffc4e2c:	f000 8096 	beq.w	2ffc4f5c <HAL_GPIO_Init+0x254>
2ffc4e30:	f44f 49c0 	mov.w	r9, #24576	@ 0x6000
2ffc4e34:	f2c5 0900 	movt	r9, #20480	@ 0x5000
2ffc4e38:	4548      	cmp	r0, r9
2ffc4e3a:	f000 8096 	beq.w	2ffc4f6a <HAL_GPIO_Init+0x262>
2ffc4e3e:	f44f 49e0 	mov.w	r9, #28672	@ 0x7000
2ffc4e42:	f2c5 0900 	movt	r9, #20480	@ 0x5000
2ffc4e46:	4548      	cmp	r0, r9
2ffc4e48:	f000 809d 	beq.w	2ffc4f86 <HAL_GPIO_Init+0x27e>
2ffc4e4c:	f44f 4900 	mov.w	r9, #32768	@ 0x8000
2ffc4e50:	f2c5 0900 	movt	r9, #20480	@ 0x5000
2ffc4e54:	4548      	cmp	r0, r9
2ffc4e56:	f000 809d 	beq.w	2ffc4f94 <HAL_GPIO_Init+0x28c>
2ffc4e5a:	f44f 4910 	mov.w	r9, #36864	@ 0x9000
2ffc4e5e:	f2c5 0900 	movt	r9, #20480	@ 0x5000
2ffc4e62:	4548      	cmp	r0, r9
2ffc4e64:	f000 8088 	beq.w	2ffc4f78 <HAL_GPIO_Init+0x270>
2ffc4e68:	f44f 4920 	mov.w	r9, #40960	@ 0xa000
2ffc4e6c:	f2c5 0900 	movt	r9, #20480	@ 0x5000
2ffc4e70:	4548      	cmp	r0, r9
2ffc4e72:	f000 8096 	beq.w	2ffc4fa2 <HAL_GPIO_Init+0x29a>
2ffc4e76:	f44f 4930 	mov.w	r9, #45056	@ 0xb000
2ffc4e7a:	f2c5 0900 	movt	r9, #20480	@ 0x5000
2ffc4e7e:	4548      	cmp	r0, r9
2ffc4e80:	f000 8096 	beq.w	2ffc4fb0 <HAL_GPIO_Init+0x2a8>
2ffc4e84:	f44f 4940 	mov.w	r9, #49152	@ 0xc000
2ffc4e88:	f2c5 0900 	movt	r9, #20480	@ 0x5000
2ffc4e8c:	4548      	cmp	r0, r9
2ffc4e8e:	f000 8096 	beq.w	2ffc4fbe <HAL_GPIO_Init+0x2b6>
2ffc4e92:	f44f 4980 	mov.w	r9, #16384	@ 0x4000
2ffc4e96:	f2c5 4900 	movt	r9, #21504	@ 0x5400
2ffc4e9a:	4548      	cmp	r0, r9
2ffc4e9c:	bf0c      	ite	eq
2ffc4e9e:	f04f 090b 	moveq.w	r9, #11
2ffc4ea2:	f04f 0919 	movne.w	r9, #25
2ffc4ea6:	fa09 f90c 	lsl.w	r9, r9, ip
2ffc4eaa:	ea46 0609 	orr.w	r6, r6, r9
        EXTI->EXTICR[position >> 2U] = temp;
2ffc4eae:	6616      	str	r6, [r2, #96]	@ 0x60
  for(position = 0; position < GPIO_NUMBER; position++)
2ffc4eb0:	3301      	adds	r3, #1
        temp = EXTI_CurrentCPU->IMR1;
2ffc4eb2:	9a00      	ldr	r2, [sp, #0]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
2ffc4eb4:	03e7      	lsls	r7, r4, #15
        temp = EXTI_CurrentCPU->IMR1;
2ffc4eb6:	f8d2 2080 	ldr.w	r2, [r2, #128]	@ 0x80
        {
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->IMR1 = temp;
2ffc4eba:	9f00      	ldr	r7, [sp, #0]
        temp &= ~((uint32_t)iocurrent);
2ffc4ebc:	ea6f 060e 	mvn.w	r6, lr
          temp |= iocurrent;
2ffc4ec0:	bf4c      	ite	mi
2ffc4ec2:	ea4e 0202 	orrmi.w	r2, lr, r2
        temp &= ~((uint32_t)iocurrent);
2ffc4ec6:	4032      	andpl	r2, r6
        EXTI_CurrentCPU->IMR1 = temp;
2ffc4ec8:	f8c7 2080 	str.w	r2, [r7, #128]	@ 0x80

        temp = EXTI_CurrentCPU->EMR1;
2ffc4ecc:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
2ffc4ed0:	03a7      	lsls	r7, r4, #14
        {
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->EMR1 = temp;
2ffc4ed2:	9f00      	ldr	r7, [sp, #0]
        temp &= ~((uint32_t)iocurrent);
2ffc4ed4:	bf54      	ite	pl
2ffc4ed6:	4032      	andpl	r2, r6
          temp |= iocurrent;
2ffc4ed8:	ea4e 0202 	orrmi.w	r2, lr, r2
        EXTI_CurrentCPU->EMR1 = temp;
2ffc4edc:	f8c7 2084 	str.w	r2, [r7, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
2ffc4ee0:	683a      	ldr	r2, [r7, #0]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
2ffc4ee2:	02e7      	lsls	r7, r4, #11
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;
2ffc4ee4:	9f00      	ldr	r7, [sp, #0]
        temp &= ~((uint32_t)iocurrent);
2ffc4ee6:	bf54      	ite	pl
2ffc4ee8:	4032      	andpl	r2, r6
          temp |= iocurrent;
2ffc4eea:	ea4e 0202 	orrmi.w	r2, lr, r2
        EXTI->RTSR1 = temp;
2ffc4eee:	603a      	str	r2, [r7, #0]

        temp = EXTI->FTSR1;
2ffc4ef0:	687a      	ldr	r2, [r7, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
2ffc4ef2:	02a4      	lsls	r4, r4, #10
        {
          temp |= iocurrent;
2ffc4ef4:	bf4c      	ite	mi
2ffc4ef6:	ea4e 0202 	orrmi.w	r2, lr, r2
        temp &= ~((uint32_t)iocurrent);
2ffc4efa:	4032      	andpl	r2, r6
        }
        EXTI->FTSR1 = temp;
2ffc4efc:	9c00      	ldr	r4, [sp, #0]
  for(position = 0; position < GPIO_NUMBER; position++)
2ffc4efe:	2b10      	cmp	r3, #16
        EXTI->FTSR1 = temp;
2ffc4f00:	6062      	str	r2, [r4, #4]
  for(position = 0; position < GPIO_NUMBER; position++)
2ffc4f02:	f47f af21 	bne.w	2ffc4d48 <HAL_GPIO_Init+0x40>
      }
    }
  }
}
2ffc4f06:	b005      	add	sp, #20
2ffc4f08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      temp = GPIOx->MODER;
2ffc4f0c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
2ffc4f10:	2603      	movs	r6, #3
      temp = GPIOx->MODER;
2ffc4f12:	f8d0 b000 	ldr.w	fp, [r0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
2ffc4f16:	f004 0a03 	and.w	sl, r4, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
2ffc4f1a:	fa06 f60c 	lsl.w	r6, r6, ip
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
2ffc4f1e:	f109 39ff 	add.w	r9, r9, #4294967295	@ 0xffffffff
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
2ffc4f22:	ea2b 0b06 	bic.w	fp, fp, r6
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
2ffc4f26:	f1b9 0f01 	cmp.w	r9, #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
2ffc4f2a:	fa0a fa0c 	lsl.w	sl, sl, ip
2ffc4f2e:	ea4a 0a0b 	orr.w	sl, sl, fp
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
2ffc4f32:	ea6f 0606 	mvn.w	r6, r6
      GPIOx->MODER = temp;
2ffc4f36:	f8c0 a000 	str.w	sl, [r0]
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
2ffc4f3a:	f63f af51 	bhi.w	2ffc4de0 <HAL_GPIO_Init+0xd8>
2ffc4f3e:	e739      	b.n	2ffc4db4 <HAL_GPIO_Init+0xac>
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
2ffc4f40:	f04f 0901 	mov.w	r9, #1
2ffc4f44:	fa09 f90c 	lsl.w	r9, r9, ip
2ffc4f48:	ea46 0609 	orr.w	r6, r6, r9
2ffc4f4c:	e7af      	b.n	2ffc4eae <HAL_GPIO_Init+0x1a6>
2ffc4f4e:	f04f 0902 	mov.w	r9, #2
2ffc4f52:	fa09 f90c 	lsl.w	r9, r9, ip
2ffc4f56:	ea46 0609 	orr.w	r6, r6, r9
2ffc4f5a:	e7a8      	b.n	2ffc4eae <HAL_GPIO_Init+0x1a6>
2ffc4f5c:	f04f 0903 	mov.w	r9, #3
2ffc4f60:	fa09 f90c 	lsl.w	r9, r9, ip
2ffc4f64:	ea46 0609 	orr.w	r6, r6, r9
2ffc4f68:	e7a1      	b.n	2ffc4eae <HAL_GPIO_Init+0x1a6>
2ffc4f6a:	f04f 0904 	mov.w	r9, #4
2ffc4f6e:	fa09 f90c 	lsl.w	r9, r9, ip
2ffc4f72:	ea46 0609 	orr.w	r6, r6, r9
2ffc4f76:	e79a      	b.n	2ffc4eae <HAL_GPIO_Init+0x1a6>
2ffc4f78:	f04f 0907 	mov.w	r9, #7
2ffc4f7c:	fa09 f90c 	lsl.w	r9, r9, ip
2ffc4f80:	ea46 0609 	orr.w	r6, r6, r9
2ffc4f84:	e793      	b.n	2ffc4eae <HAL_GPIO_Init+0x1a6>
2ffc4f86:	f04f 0905 	mov.w	r9, #5
2ffc4f8a:	fa09 f90c 	lsl.w	r9, r9, ip
2ffc4f8e:	ea46 0609 	orr.w	r6, r6, r9
2ffc4f92:	e78c      	b.n	2ffc4eae <HAL_GPIO_Init+0x1a6>
2ffc4f94:	f04f 0906 	mov.w	r9, #6
2ffc4f98:	fa09 f90c 	lsl.w	r9, r9, ip
2ffc4f9c:	ea46 0609 	orr.w	r6, r6, r9
2ffc4fa0:	e785      	b.n	2ffc4eae <HAL_GPIO_Init+0x1a6>
2ffc4fa2:	f04f 0908 	mov.w	r9, #8
2ffc4fa6:	fa09 f90c 	lsl.w	r9, r9, ip
2ffc4faa:	ea46 0609 	orr.w	r6, r6, r9
2ffc4fae:	e77e      	b.n	2ffc4eae <HAL_GPIO_Init+0x1a6>
2ffc4fb0:	f04f 0909 	mov.w	r9, #9
2ffc4fb4:	fa09 f90c 	lsl.w	r9, r9, ip
2ffc4fb8:	ea46 0609 	orr.w	r6, r6, r9
2ffc4fbc:	e777      	b.n	2ffc4eae <HAL_GPIO_Init+0x1a6>
2ffc4fbe:	f04f 090a 	mov.w	r9, #10
2ffc4fc2:	fa09 f90c 	lsl.w	r9, r9, ip
2ffc4fc6:	ea46 0609 	orr.w	r6, r6, r9
2ffc4fca:	e770      	b.n	2ffc4eae <HAL_GPIO_Init+0x1a6>

2ffc4fcc <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
2ffc4fcc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(iocurrent == ioposition)
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      tmp = EXTI->EXTICR[position >> 2];
      tmp &= (((uint32_t)0xFF) << (8 * (position & 0x03)));
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (8 * (position & 0x03))))
2ffc4fd0:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
2ffc4fd4:	f2c5 0200 	movt	r2, #20480	@ 0x5000
{
2ffc4fd8:	b085      	sub	sp, #20
      {
        /* Clear EXTI line configuration for Current CPU */
        EXTI_CurrentCPU->IMR1 &= ~((uint32_t)iocurrent);
2ffc4fda:	f44f 4750 	mov.w	r7, #53248	@ 0xd000
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (8 * (position & 0x03))))
2ffc4fde:	f44f 5900 	mov.w	r9, #8192	@ 0x2000
2ffc4fe2:	9202      	str	r2, [sp, #8]
2ffc4fe4:	f44f 42c0 	mov.w	r2, #24576	@ 0x6000
        EXTI_CurrentCPU->IMR1 &= ~((uint32_t)iocurrent);
2ffc4fe8:	f2c5 0700 	movt	r7, #20480	@ 0x5000
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (8 * (position & 0x03))))
2ffc4fec:	f44f 5a40 	mov.w	sl, #12288	@ 0x3000
2ffc4ff0:	f2c5 0200 	movt	r2, #20480	@ 0x5000
  for(position = 0; position < GPIO_NUMBER; position++)
2ffc4ff4:	2300      	movs	r3, #0
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (8 * (position & 0x03))))
2ffc4ff6:	f2c5 0900 	movt	r9, #20480	@ 0x5000
    ioposition = ((uint32_t)0x01) << position;
2ffc4ffa:	2601      	movs	r6, #1
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (8 * (position & 0x03))))
2ffc4ffc:	f2c5 0a00 	movt	sl, #20480	@ 0x5000
2ffc5000:	9203      	str	r2, [sp, #12]
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODER0 << (position * 2));

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
2ffc5002:	9701      	str	r7, [sp, #4]
2ffc5004:	e003      	b.n	2ffc500e <HAL_GPIO_DeInit+0x42>
  for(position = 0; position < GPIO_NUMBER; position++)
2ffc5006:	3301      	adds	r3, #1
2ffc5008:	2b10      	cmp	r3, #16
2ffc500a:	f000 80ae 	beq.w	2ffc516a <HAL_GPIO_DeInit+0x19e>
    ioposition = ((uint32_t)0x01) << position;
2ffc500e:	fa06 f203 	lsl.w	r2, r6, r3
    iocurrent = (GPIO_Pin) & ioposition;
2ffc5012:	ea02 0c01 	and.w	ip, r2, r1
    if(iocurrent == ioposition)
2ffc5016:	ea32 0401 	bics.w	r4, r2, r1
2ffc501a:	d1f4      	bne.n	2ffc5006 <HAL_GPIO_DeInit+0x3a>
      tmp = EXTI->EXTICR[position >> 2];
2ffc501c:	f023 0403 	bic.w	r4, r3, #3
      tmp &= (((uint32_t)0xFF) << (8 * (position & 0x03)));
2ffc5020:	f003 0503 	and.w	r5, r3, #3
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (8 * (position & 0x03))))
2ffc5024:	4548      	cmp	r0, r9
2ffc5026:	f104 44a0 	add.w	r4, r4, #1342177280	@ 0x50000000
      tmp &= (((uint32_t)0xFF) << (8 * (position & 0x03)));
2ffc502a:	ea4f 07c5 	mov.w	r7, r5, lsl #3
2ffc502e:	f504 4450 	add.w	r4, r4, #53248	@ 0xd000
2ffc5032:	f04f 05ff 	mov.w	r5, #255	@ 0xff
      tmp = EXTI->EXTICR[position >> 2];
2ffc5036:	f8d4 e060 	ldr.w	lr, [r4, #96]	@ 0x60
      tmp &= (((uint32_t)0xFF) << (8 * (position & 0x03)));
2ffc503a:	fa05 f807 	lsl.w	r8, r5, r7
2ffc503e:	bf08      	it	eq
2ffc5040:	2500      	moveq	r5, #0
2ffc5042:	ea08 0e0e 	and.w	lr, r8, lr
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (8 * (position & 0x03))))
2ffc5046:	d046      	beq.n	2ffc50d6 <HAL_GPIO_DeInit+0x10a>
2ffc5048:	4550      	cmp	r0, sl
2ffc504a:	bf04      	itt	eq
2ffc504c:	463d      	moveq	r5, r7
2ffc504e:	fa06 f505 	lsleq.w	r5, r6, r5
2ffc5052:	d040      	beq.n	2ffc50d6 <HAL_GPIO_DeInit+0x10a>
2ffc5054:	9d02      	ldr	r5, [sp, #8]
2ffc5056:	42a8      	cmp	r0, r5
2ffc5058:	f000 808a 	beq.w	2ffc5170 <HAL_GPIO_DeInit+0x1a4>
2ffc505c:	f1b0 2f50 	cmp.w	r0, #1342197760	@ 0x50005000
2ffc5060:	f000 808b 	beq.w	2ffc517a <HAL_GPIO_DeInit+0x1ae>
2ffc5064:	9d03      	ldr	r5, [sp, #12]
2ffc5066:	42a8      	cmp	r0, r5
2ffc5068:	f000 808c 	beq.w	2ffc5184 <HAL_GPIO_DeInit+0x1b8>
2ffc506c:	f44f 4be0 	mov.w	fp, #28672	@ 0x7000
2ffc5070:	f2c5 0b00 	movt	fp, #20480	@ 0x5000
2ffc5074:	4558      	cmp	r0, fp
2ffc5076:	f000 808a 	beq.w	2ffc518e <HAL_GPIO_DeInit+0x1c2>
2ffc507a:	f44f 4b00 	mov.w	fp, #32768	@ 0x8000
2ffc507e:	f2c5 0b00 	movt	fp, #20480	@ 0x5000
2ffc5082:	4558      	cmp	r0, fp
2ffc5084:	f000 8088 	beq.w	2ffc5198 <HAL_GPIO_DeInit+0x1cc>
2ffc5088:	f44f 4b10 	mov.w	fp, #36864	@ 0x9000
2ffc508c:	f2c5 0b00 	movt	fp, #20480	@ 0x5000
2ffc5090:	4558      	cmp	r0, fp
2ffc5092:	f000 808b 	beq.w	2ffc51ac <HAL_GPIO_DeInit+0x1e0>
2ffc5096:	f44f 4b20 	mov.w	fp, #40960	@ 0xa000
2ffc509a:	f2c5 0b00 	movt	fp, #20480	@ 0x5000
2ffc509e:	4558      	cmp	r0, fp
2ffc50a0:	f000 8089 	beq.w	2ffc51b6 <HAL_GPIO_DeInit+0x1ea>
2ffc50a4:	f44f 4b30 	mov.w	fp, #45056	@ 0xb000
2ffc50a8:	f2c5 0b00 	movt	fp, #20480	@ 0x5000
2ffc50ac:	4558      	cmp	r0, fp
2ffc50ae:	d078      	beq.n	2ffc51a2 <HAL_GPIO_DeInit+0x1d6>
2ffc50b0:	f44f 4b40 	mov.w	fp, #49152	@ 0xc000
2ffc50b4:	f2c5 0b00 	movt	fp, #20480	@ 0x5000
2ffc50b8:	4558      	cmp	r0, fp
2ffc50ba:	f000 8081 	beq.w	2ffc51c0 <HAL_GPIO_DeInit+0x1f4>
2ffc50be:	f44f 4b80 	mov.w	fp, #16384	@ 0x4000
2ffc50c2:	f2c5 4b00 	movt	fp, #21504	@ 0x5400
2ffc50c6:	4558      	cmp	r0, fp
2ffc50c8:	bf14      	ite	ne
2ffc50ca:	f04f 0b19 	movne.w	fp, #25
2ffc50ce:	f04f 0b0b 	moveq.w	fp, #11
2ffc50d2:	fa0b f507 	lsl.w	r5, fp, r7
2ffc50d6:	45ae      	cmp	lr, r5
2ffc50d8:	d11f      	bne.n	2ffc511a <HAL_GPIO_DeInit+0x14e>
        EXTI_CurrentCPU->IMR1 &= ~((uint32_t)iocurrent);
2ffc50da:	9d01      	ldr	r5, [sp, #4]
2ffc50dc:	9f01      	ldr	r7, [sp, #4]
2ffc50de:	f8d5 5080 	ldr.w	r5, [r5, #128]	@ 0x80
2ffc50e2:	ea25 050c 	bic.w	r5, r5, ip
2ffc50e6:	f8c7 5080 	str.w	r5, [r7, #128]	@ 0x80
        EXTI_CurrentCPU->EMR1 &= ~((uint32_t)iocurrent);
2ffc50ea:	9d01      	ldr	r5, [sp, #4]
2ffc50ec:	9f01      	ldr	r7, [sp, #4]
2ffc50ee:	f8d5 5084 	ldr.w	r5, [r5, #132]	@ 0x84
2ffc50f2:	ea25 050c 	bic.w	r5, r5, ip
2ffc50f6:	f8c7 5084 	str.w	r5, [r7, #132]	@ 0x84
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
2ffc50fa:	9d01      	ldr	r5, [sp, #4]
2ffc50fc:	9f01      	ldr	r7, [sp, #4]
2ffc50fe:	682d      	ldr	r5, [r5, #0]
2ffc5100:	ea25 050c 	bic.w	r5, r5, ip
2ffc5104:	603d      	str	r5, [r7, #0]
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
2ffc5106:	9d01      	ldr	r5, [sp, #4]
2ffc5108:	9f01      	ldr	r7, [sp, #4]
2ffc510a:	686d      	ldr	r5, [r5, #4]
2ffc510c:	ea25 050c 	bic.w	r5, r5, ip
2ffc5110:	607d      	str	r5, [r7, #4]
        EXTI->EXTICR[position >> 2] &= ~tmp;
2ffc5112:	6e25      	ldr	r5, [r4, #96]	@ 0x60
2ffc5114:	ea25 0508 	bic.w	r5, r5, r8
2ffc5118:	6625      	str	r5, [r4, #96]	@ 0x60
      GPIOx->MODER |= (GPIO_MODER_MODER0 << (position * 2));
2ffc511a:	2503      	movs	r5, #3
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
2ffc511c:	f04f 0e0f 	mov.w	lr, #15
      GPIOx->MODER |= (GPIO_MODER_MODER0 << (position * 2));
2ffc5120:	005c      	lsls	r4, r3, #1
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
2ffc5122:	fa23 fc05 	lsr.w	ip, r3, r5
      GPIOx->MODER |= (GPIO_MODER_MODER0 << (position * 2));
2ffc5126:	fa05 f404 	lsl.w	r4, r5, r4
2ffc512a:	6805      	ldr	r5, [r0, #0]
2ffc512c:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
2ffc5130:	4325      	orrs	r5, r4
2ffc5132:	6005      	str	r5, [r0, #0]
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
2ffc5134:	f003 0507 	and.w	r5, r3, #7
  for(position = 0; position < GPIO_NUMBER; position++)
2ffc5138:	3301      	adds	r3, #1
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
2ffc513a:	00ad      	lsls	r5, r5, #2
  for(position = 0; position < GPIO_NUMBER; position++)
2ffc513c:	2b10      	cmp	r3, #16
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
2ffc513e:	fa0e f505 	lsl.w	r5, lr, r5
2ffc5142:	f8dc e020 	ldr.w	lr, [ip, #32]
2ffc5146:	ea2e 0505 	bic.w	r5, lr, r5
2ffc514a:	f8cc 5020 	str.w	r5, [ip, #32]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEEDR0 << (position * 2));
2ffc514e:	6885      	ldr	r5, [r0, #8]
2ffc5150:	ea25 0504 	bic.w	r5, r5, r4
2ffc5154:	6085      	str	r5, [r0, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
2ffc5156:	6845      	ldr	r5, [r0, #4]
2ffc5158:	ea25 0202 	bic.w	r2, r5, r2
2ffc515c:	6042      	str	r2, [r0, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
2ffc515e:	68c2      	ldr	r2, [r0, #12]
2ffc5160:	ea22 0204 	bic.w	r2, r2, r4
2ffc5164:	60c2      	str	r2, [r0, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
2ffc5166:	f47f af52 	bne.w	2ffc500e <HAL_GPIO_DeInit+0x42>
    }
  }
}
2ffc516a:	b005      	add	sp, #20
2ffc516c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (8 * (position & 0x03))))
2ffc5170:	f04f 0b02 	mov.w	fp, #2
2ffc5174:	fa0b f507 	lsl.w	r5, fp, r7
2ffc5178:	e7ad      	b.n	2ffc50d6 <HAL_GPIO_DeInit+0x10a>
2ffc517a:	f04f 0b03 	mov.w	fp, #3
2ffc517e:	fa0b f507 	lsl.w	r5, fp, r7
2ffc5182:	e7a8      	b.n	2ffc50d6 <HAL_GPIO_DeInit+0x10a>
2ffc5184:	f04f 0b04 	mov.w	fp, #4
2ffc5188:	fa0b f507 	lsl.w	r5, fp, r7
2ffc518c:	e7a3      	b.n	2ffc50d6 <HAL_GPIO_DeInit+0x10a>
2ffc518e:	f04f 0b05 	mov.w	fp, #5
2ffc5192:	fa0b f507 	lsl.w	r5, fp, r7
2ffc5196:	e79e      	b.n	2ffc50d6 <HAL_GPIO_DeInit+0x10a>
2ffc5198:	f04f 0b06 	mov.w	fp, #6
2ffc519c:	fa0b f507 	lsl.w	r5, fp, r7
2ffc51a0:	e799      	b.n	2ffc50d6 <HAL_GPIO_DeInit+0x10a>
2ffc51a2:	f04f 0b09 	mov.w	fp, #9
2ffc51a6:	fa0b f507 	lsl.w	r5, fp, r7
2ffc51aa:	e794      	b.n	2ffc50d6 <HAL_GPIO_DeInit+0x10a>
2ffc51ac:	f04f 0b07 	mov.w	fp, #7
2ffc51b0:	fa0b f507 	lsl.w	r5, fp, r7
2ffc51b4:	e78f      	b.n	2ffc50d6 <HAL_GPIO_DeInit+0x10a>
2ffc51b6:	f04f 0b08 	mov.w	fp, #8
2ffc51ba:	fa0b f507 	lsl.w	r5, fp, r7
2ffc51be:	e78a      	b.n	2ffc50d6 <HAL_GPIO_DeInit+0x10a>
2ffc51c0:	f04f 0b0a 	mov.w	fp, #10
2ffc51c4:	fa0b f507 	lsl.w	r5, fp, r7
2ffc51c8:	e785      	b.n	2ffc50d6 <HAL_GPIO_DeInit+0x10a>
2ffc51ca:	bf00      	nop

2ffc51cc <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
2ffc51cc:	b902      	cbnz	r2, 2ffc51d0 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
2ffc51ce:	0409      	lsls	r1, r1, #16
2ffc51d0:	6181      	str	r1, [r0, #24]
  }
}
2ffc51d2:	4770      	bx	lr

2ffc51d4 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) != 0x00u)
2ffc51d4:	6943      	ldr	r3, [r0, #20]
2ffc51d6:	420b      	tst	r3, r1
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
2ffc51d8:	bf14      	ite	ne
2ffc51da:	6281      	strne	r1, [r0, #40]	@ 0x28
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
2ffc51dc:	6181      	streq	r1, [r0, #24]
  }
}
2ffc51de:	4770      	bx	lr

2ffc51e0 <I2C_IsErrorOccurred>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t itflag   = hi2c->Instance->ISR;
2ffc51e0:	6803      	ldr	r3, [r0, #0]
{
2ffc51e2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
2ffc51e6:	460f      	mov	r7, r1
  uint32_t itflag   = hi2c->Instance->ISR;
2ffc51e8:	6999      	ldr	r1, [r3, #24]
{
2ffc51ea:	4604      	mov	r4, r0
  uint32_t error_code = 0;
  uint32_t tickstart = Tickstart;
  uint32_t tmp1;
  HAL_I2C_ModeTypeDef tmp2;

  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
2ffc51ec:	f011 0c10 	ands.w	ip, r1, #16
  HAL_StatusTypeDef status = HAL_OK;
2ffc51f0:	bf08      	it	eq
2ffc51f2:	4660      	moveq	r0, ip
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
2ffc51f4:	d015      	beq.n	2ffc5222 <I2C_IsErrorOccurred+0x42>
  HAL_StatusTypeDef status = HAL_OK;
2ffc51f6:	f04f 0800 	mov.w	r8, #0
2ffc51fa:	4616      	mov	r6, r2
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2ffc51fc:	2210      	movs	r2, #16
2ffc51fe:	61da      	str	r2, [r3, #28]

    /* Wait until STOP Flag is set or timeout occurred */
    /* AutoEnd should be initiate after AF */
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
2ffc5200:	699a      	ldr	r2, [r3, #24]
2ffc5202:	0692      	lsls	r2, r2, #26
2ffc5204:	f100 8091 	bmi.w	2ffc532a <I2C_IsErrorOccurred+0x14a>
2ffc5208:	f1b8 0f00 	cmp.w	r8, #0
2ffc520c:	d106      	bne.n	2ffc521c <I2C_IsErrorOccurred+0x3c>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
2ffc520e:	1c7a      	adds	r2, r7, #1
2ffc5210:	d144      	bne.n	2ffc529c <I2C_IsErrorOccurred+0xbc>
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
2ffc5212:	699a      	ldr	r2, [r3, #24]
2ffc5214:	0696      	lsls	r6, r2, #26
2ffc5216:	d5fc      	bpl.n	2ffc5212 <I2C_IsErrorOccurred+0x32>

    /* In case STOP Flag is detected, clear it */
    if (status == HAL_OK)
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2ffc5218:	2220      	movs	r2, #32
2ffc521a:	61da      	str	r2, [r3, #28]
    }

    error_code |= HAL_I2C_ERROR_AF;
2ffc521c:	f04f 0c04 	mov.w	ip, #4

    status = HAL_ERROR;
2ffc5220:	2001      	movs	r0, #1
  }

  /* Refresh Content of Status register */
  itflag = hi2c->Instance->ISR;
2ffc5222:	699a      	ldr	r2, [r3, #24]

  /* Then verify if an additional errors occurs */
  /* Check if a Bus error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
2ffc5224:	05d5      	lsls	r5, r2, #23
2ffc5226:	d52f      	bpl.n	2ffc5288 <I2C_IsErrorOccurred+0xa8>
  {
    error_code |= HAL_I2C_ERROR_BERR;

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
2ffc5228:	f44f 7180 	mov.w	r1, #256	@ 0x100
    error_code |= HAL_I2C_ERROR_BERR;
2ffc522c:	f04c 0c01 	orr.w	ip, ip, #1
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
2ffc5230:	61d9      	str	r1, [r3, #28]

    status = HAL_ERROR;
  }

  /* Check if an Over-Run/Under-Run error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
2ffc5232:	0551      	lsls	r1, r2, #21
2ffc5234:	d504      	bpl.n	2ffc5240 <I2C_IsErrorOccurred+0x60>
  {
    error_code |= HAL_I2C_ERROR_OVR;
2ffc5236:	f04c 0c08 	orr.w	ip, ip, #8

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
2ffc523a:	f44f 6180 	mov.w	r1, #1024	@ 0x400
2ffc523e:	61d9      	str	r1, [r3, #28]

    status = HAL_ERROR;
  }

  /* Check if an Arbitration Loss error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
2ffc5240:	0596      	lsls	r6, r2, #22
2ffc5242:	d425      	bmi.n	2ffc5290 <I2C_IsErrorOccurred+0xb0>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
2ffc5244:	699a      	ldr	r2, [r3, #24]
    hi2c->ErrorCode |= error_code;
    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode = HAL_I2C_MODE_NONE;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2ffc5246:	2001      	movs	r0, #1
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
2ffc5248:	0791      	lsls	r1, r2, #30
    I2C_RESET_CR2(hi2c);
2ffc524a:	f44f 4168 	mov.w	r1, #59392	@ 0xe800
2ffc524e:	f6cf 6100 	movt	r1, #65024	@ 0xfe00
    hi2c->Instance->TXDR = 0x00U;
2ffc5252:	bf44      	itt	mi
2ffc5254:	2200      	movmi	r2, #0
2ffc5256:	629a      	strmi	r2, [r3, #40]	@ 0x28
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
2ffc5258:	699a      	ldr	r2, [r3, #24]
2ffc525a:	07d2      	lsls	r2, r2, #31
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
2ffc525c:	bf5e      	ittt	pl
2ffc525e:	699a      	ldrpl	r2, [r3, #24]
2ffc5260:	f042 0201 	orrpl.w	r2, r2, #1
2ffc5264:	619a      	strpl	r2, [r3, #24]
    I2C_RESET_CR2(hi2c);
2ffc5266:	685a      	ldr	r2, [r3, #4]
2ffc5268:	400a      	ands	r2, r1
2ffc526a:	605a      	str	r2, [r3, #4]
    hi2c->Mode = HAL_I2C_MODE_NONE;
2ffc526c:	2200      	movs	r2, #0
    hi2c->ErrorCode |= error_code;
2ffc526e:	6c63      	ldr	r3, [r4, #68]	@ 0x44
    __HAL_UNLOCK(hi2c);
2ffc5270:	f884 2040 	strb.w	r2, [r4, #64]	@ 0x40
    hi2c->ErrorCode |= error_code;
2ffc5274:	ea43 030c 	orr.w	r3, r3, ip
2ffc5278:	6463      	str	r3, [r4, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
2ffc527a:	2320      	movs	r3, #32
2ffc527c:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
2ffc5280:	f884 2042 	strb.w	r2, [r4, #66]	@ 0x42
  }

  return status;
}
2ffc5284:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
2ffc5288:	0557      	lsls	r7, r2, #21
2ffc528a:	d4d4      	bmi.n	2ffc5236 <I2C_IsErrorOccurred+0x56>
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
2ffc528c:	0595      	lsls	r5, r2, #22
2ffc528e:	d515      	bpl.n	2ffc52bc <I2C_IsErrorOccurred+0xdc>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
2ffc5290:	f44f 7200 	mov.w	r2, #512	@ 0x200
    error_code |= HAL_I2C_ERROR_ARLO;
2ffc5294:	f04c 0c02 	orr.w	ip, ip, #2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
2ffc5298:	61da      	str	r2, [r3, #28]
  if (status != HAL_OK)
2ffc529a:	e7d3      	b.n	2ffc5244 <I2C_IsErrorOccurred+0x64>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2ffc529c:	f7fe f956 	bl	2ffc354c <HAL_GetTick>
2ffc52a0:	fab7 f387 	clz	r3, r7
2ffc52a4:	1b80      	subs	r0, r0, r6
2ffc52a6:	095b      	lsrs	r3, r3, #5
2ffc52a8:	42b8      	cmp	r0, r7
2ffc52aa:	bf88      	it	hi
2ffc52ac:	f043 0301 	orrhi.w	r3, r3, #1
2ffc52b0:	b943      	cbnz	r3, 2ffc52c4 <I2C_IsErrorOccurred+0xe4>
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
2ffc52b2:	6823      	ldr	r3, [r4, #0]
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
2ffc52b4:	699a      	ldr	r2, [r3, #24]
2ffc52b6:	0695      	lsls	r5, r2, #26
2ffc52b8:	d5a9      	bpl.n	2ffc520e <I2C_IsErrorOccurred+0x2e>
2ffc52ba:	e7ad      	b.n	2ffc5218 <I2C_IsErrorOccurred+0x38>
  if (status != HAL_OK)
2ffc52bc:	2800      	cmp	r0, #0
2ffc52be:	d1c1      	bne.n	2ffc5244 <I2C_IsErrorOccurred+0x64>
}
2ffc52c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
2ffc52c4:	6823      	ldr	r3, [r4, #0]
2ffc52c6:	6859      	ldr	r1, [r3, #4]
          tmp2 = hi2c->Mode;
2ffc52c8:	f894 2042 	ldrb.w	r2, [r4, #66]	@ 0x42
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
2ffc52cc:	6998      	ldr	r0, [r3, #24]
          tmp2 = hi2c->Mode;
2ffc52ce:	b2d2      	uxtb	r2, r2
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
2ffc52d0:	0400      	lsls	r0, r0, #16
2ffc52d2:	d511      	bpl.n	2ffc52f8 <I2C_IsErrorOccurred+0x118>
              (tmp2 != HAL_I2C_MODE_SLAVE))
2ffc52d4:	3a20      	subs	r2, #32
              (tmp1 != I2C_CR2_STOP) && \
2ffc52d6:	f481 4180 	eor.w	r1, r1, #16384	@ 0x4000
              (tmp2 != HAL_I2C_MODE_SLAVE))
2ffc52da:	bf18      	it	ne
2ffc52dc:	2201      	movne	r2, #1
              (tmp1 != I2C_CR2_STOP) && \
2ffc52de:	ea12 3291 	ands.w	r2, r2, r1, lsr #14
2ffc52e2:	d009      	beq.n	2ffc52f8 <I2C_IsErrorOccurred+0x118>
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
2ffc52e4:	685a      	ldr	r2, [r3, #4]
2ffc52e6:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
2ffc52ea:	605a      	str	r2, [r3, #4]
            tickstart = HAL_GetTick();
2ffc52ec:	f7fe f92e 	bl	2ffc354c <HAL_GetTick>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2ffc52f0:	6823      	ldr	r3, [r4, #0]
            tickstart = HAL_GetTick();
2ffc52f2:	4606      	mov	r6, r0
2ffc52f4:	e000      	b.n	2ffc52f8 <I2C_IsErrorOccurred+0x118>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2ffc52f6:	6823      	ldr	r3, [r4, #0]
2ffc52f8:	699d      	ldr	r5, [r3, #24]
2ffc52fa:	f015 0520 	ands.w	r5, r5, #32
2ffc52fe:	f47f af7f 	bne.w	2ffc5200 <I2C_IsErrorOccurred+0x20>
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
2ffc5302:	f7fe f923 	bl	2ffc354c <HAL_GetTick>
2ffc5306:	1b80      	subs	r0, r0, r6
2ffc5308:	2819      	cmp	r0, #25
2ffc530a:	d9f4      	bls.n	2ffc52f6 <I2C_IsErrorOccurred+0x116>
              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc530c:	6c62      	ldr	r2, [r4, #68]	@ 0x44
              hi2c->State = HAL_I2C_STATE_READY;
2ffc530e:	2120      	movs	r1, #32
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2ffc5310:	6823      	ldr	r3, [r4, #0]
              status = HAL_ERROR;
2ffc5312:	f04f 0801 	mov.w	r8, #1
              __HAL_UNLOCK(hi2c);
2ffc5316:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc531a:	f042 0220 	orr.w	r2, r2, #32
2ffc531e:	6462      	str	r2, [r4, #68]	@ 0x44
              hi2c->State = HAL_I2C_STATE_READY;
2ffc5320:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
              hi2c->Mode = HAL_I2C_MODE_NONE;
2ffc5324:	f884 5042 	strb.w	r5, [r4, #66]	@ 0x42
              status = HAL_ERROR;
2ffc5328:	e7e6      	b.n	2ffc52f8 <I2C_IsErrorOccurred+0x118>
    if (status == HAL_OK)
2ffc532a:	f1b8 0f00 	cmp.w	r8, #0
2ffc532e:	f47f af75 	bne.w	2ffc521c <I2C_IsErrorOccurred+0x3c>
2ffc5332:	e771      	b.n	2ffc5218 <I2C_IsErrorOccurred+0x38>

2ffc5334 <I2C_WaitOnTXISFlagUntilTimeout>:
{
2ffc5334:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2ffc5336:	4605      	mov	r5, r0
2ffc5338:	460e      	mov	r6, r1
2ffc533a:	4617      	mov	r7, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
2ffc533c:	e005      	b.n	2ffc534a <I2C_WaitOnTXISFlagUntilTimeout+0x16>
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
2ffc533e:	f7ff ff4f 	bl	2ffc51e0 <I2C_IsErrorOccurred>
2ffc5342:	4604      	mov	r4, r0
2ffc5344:	bb00      	cbnz	r0, 2ffc5388 <I2C_WaitOnTXISFlagUntilTimeout+0x54>
    if (Timeout != HAL_MAX_DELAY)
2ffc5346:	1c72      	adds	r2, r6, #1
2ffc5348:	d108      	bne.n	2ffc535c <I2C_WaitOnTXISFlagUntilTimeout+0x28>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
2ffc534a:	682b      	ldr	r3, [r5, #0]
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
2ffc534c:	463a      	mov	r2, r7
2ffc534e:	4631      	mov	r1, r6
2ffc5350:	4628      	mov	r0, r5
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
2ffc5352:	699b      	ldr	r3, [r3, #24]
2ffc5354:	079b      	lsls	r3, r3, #30
2ffc5356:	d5f2      	bpl.n	2ffc533e <I2C_WaitOnTXISFlagUntilTimeout+0xa>
  return HAL_OK;
2ffc5358:	2000      	movs	r0, #0
}
2ffc535a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2ffc535c:	f7fe f8f6 	bl	2ffc354c <HAL_GetTick>
2ffc5360:	fab6 f386 	clz	r3, r6
2ffc5364:	1bc0      	subs	r0, r0, r7
2ffc5366:	095b      	lsrs	r3, r3, #5
2ffc5368:	42b0      	cmp	r0, r6
2ffc536a:	bf88      	it	hi
2ffc536c:	f043 0301 	orrhi.w	r3, r3, #1
2ffc5370:	2b00      	cmp	r3, #0
2ffc5372:	d0ea      	beq.n	2ffc534a <I2C_WaitOnTXISFlagUntilTimeout+0x16>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc5374:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2ffc5376:	2220      	movs	r2, #32
        __HAL_UNLOCK(hi2c);
2ffc5378:	f885 4040 	strb.w	r4, [r5, #64]	@ 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc537c:	4313      	orrs	r3, r2
2ffc537e:	646b      	str	r3, [r5, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2ffc5380:	f885 2041 	strb.w	r2, [r5, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2ffc5384:	f885 4042 	strb.w	r4, [r5, #66]	@ 0x42
      return HAL_ERROR;
2ffc5388:	2001      	movs	r0, #1
}
2ffc538a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

2ffc538c <I2C_WaitOnSTOPFlagUntilTimeout>:
{
2ffc538c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2ffc538e:	4606      	mov	r6, r0
2ffc5390:	460d      	mov	r5, r1
2ffc5392:	4617      	mov	r7, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2ffc5394:	6833      	ldr	r3, [r6, #0]
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
2ffc5396:	463a      	mov	r2, r7
2ffc5398:	4629      	mov	r1, r5
2ffc539a:	4630      	mov	r0, r6
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2ffc539c:	699b      	ldr	r3, [r3, #24]
2ffc539e:	069b      	lsls	r3, r3, #26
2ffc53a0:	d41b      	bmi.n	2ffc53da <I2C_WaitOnSTOPFlagUntilTimeout+0x4e>
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
2ffc53a2:	f7ff ff1d 	bl	2ffc51e0 <I2C_IsErrorOccurred>
2ffc53a6:	4604      	mov	r4, r0
2ffc53a8:	b9a8      	cbnz	r0, 2ffc53d6 <I2C_WaitOnSTOPFlagUntilTimeout+0x4a>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2ffc53aa:	f7fe f8cf 	bl	2ffc354c <HAL_GetTick>
2ffc53ae:	fab5 f385 	clz	r3, r5
2ffc53b2:	1bc0      	subs	r0, r0, r7
2ffc53b4:	095b      	lsrs	r3, r3, #5
2ffc53b6:	42a8      	cmp	r0, r5
2ffc53b8:	bf88      	it	hi
2ffc53ba:	f043 0301 	orrhi.w	r3, r3, #1
2ffc53be:	2b00      	cmp	r3, #0
2ffc53c0:	d0e8      	beq.n	2ffc5394 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc53c2:	6c73      	ldr	r3, [r6, #68]	@ 0x44
      hi2c->State = HAL_I2C_STATE_READY;
2ffc53c4:	2220      	movs	r2, #32
      __HAL_UNLOCK(hi2c);
2ffc53c6:	f886 4040 	strb.w	r4, [r6, #64]	@ 0x40
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc53ca:	4313      	orrs	r3, r2
2ffc53cc:	6473      	str	r3, [r6, #68]	@ 0x44
      hi2c->State = HAL_I2C_STATE_READY;
2ffc53ce:	f886 2041 	strb.w	r2, [r6, #65]	@ 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
2ffc53d2:	f886 4042 	strb.w	r4, [r6, #66]	@ 0x42
      return HAL_ERROR;
2ffc53d6:	2001      	movs	r0, #1
}
2ffc53d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return HAL_OK;
2ffc53da:	2000      	movs	r0, #0
}
2ffc53dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
2ffc53de:	bf00      	nop

2ffc53e0 <I2C_RequestMemoryWrite>:
{
2ffc53e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
2ffc53e4:	4698      	mov	r8, r3
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
                            (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
                              (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc53e6:	f8d0 c000 	ldr.w	ip, [r0]
                            (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
2ffc53ea:	b2db      	uxtb	r3, r3
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
2ffc53ec:	f3c1 0109 	ubfx	r1, r1, #0, #10
{
2ffc53f0:	4614      	mov	r4, r2
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc53f2:	f8dc e004 	ldr.w	lr, [ip, #4]
{
2ffc53f6:	4606      	mov	r6, r0
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
2ffc53f8:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc53fc:	f44f 4318 	mov.w	r3, #38912	@ 0x9800
2ffc5400:	f6cf 4300 	movt	r3, #64512	@ 0xfc00
2ffc5404:	ea0e 0e03 	and.w	lr, lr, r3
2ffc5408:	ea41 010e 	orr.w	r1, r1, lr
{
2ffc540c:	e9dd 5708 	ldrd	r5, r7, [sp, #32]
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc5410:	f041 7180 	orr.w	r1, r1, #16777216	@ 0x1000000
2ffc5414:	f441 5100 	orr.w	r1, r1, #8192	@ 0x2000
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2ffc5418:	463a      	mov	r2, r7
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc541a:	f8cc 1004 	str.w	r1, [ip, #4]
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2ffc541e:	4629      	mov	r1, r5
2ffc5420:	f7ff ff88 	bl	2ffc5334 <I2C_WaitOnTXISFlagUntilTimeout>
2ffc5424:	bb88      	cbnz	r0, 2ffc548a <I2C_RequestMemoryWrite+0xaa>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2ffc5426:	6832      	ldr	r2, [r6, #0]
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
2ffc5428:	f1b8 0f01 	cmp.w	r8, #1
2ffc542c:	4681      	mov	r9, r0
2ffc542e:	d10b      	bne.n	2ffc5448 <I2C_RequestMemoryWrite+0x68>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2ffc5430:	b2e4      	uxtb	r4, r4
2ffc5432:	6294      	str	r4, [r2, #40]	@ 0x28
2ffc5434:	e001      	b.n	2ffc543a <I2C_RequestMemoryWrite+0x5a>
    if (Timeout != HAL_MAX_DELAY)
2ffc5436:	1c6b      	adds	r3, r5, #1
2ffc5438:	d110      	bne.n	2ffc545c <I2C_RequestMemoryWrite+0x7c>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc543a:	6994      	ldr	r4, [r2, #24]
2ffc543c:	f014 0480 	ands.w	r4, r4, #128	@ 0x80
2ffc5440:	d0f9      	beq.n	2ffc5436 <I2C_RequestMemoryWrite+0x56>
}
2ffc5442:	4648      	mov	r0, r9
2ffc5444:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
2ffc5448:	0a23      	lsrs	r3, r4, #8
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2ffc544a:	4629      	mov	r1, r5
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
2ffc544c:	6293      	str	r3, [r2, #40]	@ 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2ffc544e:	4630      	mov	r0, r6
2ffc5450:	463a      	mov	r2, r7
2ffc5452:	f7ff ff6f 	bl	2ffc5334 <I2C_WaitOnTXISFlagUntilTimeout>
2ffc5456:	b9c0      	cbnz	r0, 2ffc548a <I2C_RequestMemoryWrite+0xaa>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2ffc5458:	6832      	ldr	r2, [r6, #0]
2ffc545a:	e7e9      	b.n	2ffc5430 <I2C_RequestMemoryWrite+0x50>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2ffc545c:	f7fe f876 	bl	2ffc354c <HAL_GetTick>
2ffc5460:	fab5 f385 	clz	r3, r5
2ffc5464:	1bc0      	subs	r0, r0, r7
2ffc5466:	095b      	lsrs	r3, r3, #5
2ffc5468:	4285      	cmp	r5, r0
2ffc546a:	bf38      	it	cc
2ffc546c:	f043 0301 	orrcc.w	r3, r3, #1
2ffc5470:	b90b      	cbnz	r3, 2ffc5476 <I2C_RequestMemoryWrite+0x96>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc5472:	6832      	ldr	r2, [r6, #0]
2ffc5474:	e7e1      	b.n	2ffc543a <I2C_RequestMemoryWrite+0x5a>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc5476:	6c73      	ldr	r3, [r6, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2ffc5478:	2220      	movs	r2, #32
        __HAL_UNLOCK(hi2c);
2ffc547a:	f886 4040 	strb.w	r4, [r6, #64]	@ 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc547e:	4313      	orrs	r3, r2
2ffc5480:	6473      	str	r3, [r6, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2ffc5482:	f886 2041 	strb.w	r2, [r6, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2ffc5486:	f886 4042 	strb.w	r4, [r6, #66]	@ 0x42
    return HAL_ERROR;
2ffc548a:	f04f 0901 	mov.w	r9, #1
}
2ffc548e:	4648      	mov	r0, r9
2ffc5490:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

2ffc5494 <I2C_RequestMemoryRead>:
{
2ffc5494:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
2ffc5498:	4698      	mov	r8, r3
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc549a:	f8d0 c000 	ldr.w	ip, [r0]
                            (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
2ffc549e:	b2db      	uxtb	r3, r3
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
2ffc54a0:	f3c1 0109 	ubfx	r1, r1, #0, #10
{
2ffc54a4:	4614      	mov	r4, r2
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc54a6:	f8dc e004 	ldr.w	lr, [ip, #4]
{
2ffc54aa:	4606      	mov	r6, r0
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
2ffc54ac:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc54b0:	f44f 4318 	mov.w	r3, #38912	@ 0x9800
2ffc54b4:	f6cf 4300 	movt	r3, #64512	@ 0xfc00
2ffc54b8:	ea0e 0e03 	and.w	lr, lr, r3
{
2ffc54bc:	e9dd 5708 	ldrd	r5, r7, [sp, #32]
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc54c0:	ea41 010e 	orr.w	r1, r1, lr
2ffc54c4:	f441 5100 	orr.w	r1, r1, #8192	@ 0x2000
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2ffc54c8:	463a      	mov	r2, r7
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc54ca:	f8cc 1004 	str.w	r1, [ip, #4]
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2ffc54ce:	4629      	mov	r1, r5
2ffc54d0:	f7ff ff30 	bl	2ffc5334 <I2C_WaitOnTXISFlagUntilTimeout>
2ffc54d4:	bb88      	cbnz	r0, 2ffc553a <I2C_RequestMemoryRead+0xa6>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2ffc54d6:	6831      	ldr	r1, [r6, #0]
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
2ffc54d8:	f1b8 0f01 	cmp.w	r8, #1
2ffc54dc:	4681      	mov	r9, r0
2ffc54de:	d10b      	bne.n	2ffc54f8 <I2C_RequestMemoryRead+0x64>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2ffc54e0:	b2e4      	uxtb	r4, r4
2ffc54e2:	628c      	str	r4, [r1, #40]	@ 0x28
2ffc54e4:	e001      	b.n	2ffc54ea <I2C_RequestMemoryRead+0x56>
    if (Timeout != HAL_MAX_DELAY)
2ffc54e6:	1c6b      	adds	r3, r5, #1
2ffc54e8:	d110      	bne.n	2ffc550c <I2C_RequestMemoryRead+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc54ea:	698c      	ldr	r4, [r1, #24]
2ffc54ec:	f014 0440 	ands.w	r4, r4, #64	@ 0x40
2ffc54f0:	d0f9      	beq.n	2ffc54e6 <I2C_RequestMemoryRead+0x52>
}
2ffc54f2:	4648      	mov	r0, r9
2ffc54f4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
2ffc54f8:	0a23      	lsrs	r3, r4, #8
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2ffc54fa:	463a      	mov	r2, r7
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
2ffc54fc:	628b      	str	r3, [r1, #40]	@ 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2ffc54fe:	4630      	mov	r0, r6
2ffc5500:	4629      	mov	r1, r5
2ffc5502:	f7ff ff17 	bl	2ffc5334 <I2C_WaitOnTXISFlagUntilTimeout>
2ffc5506:	b9c0      	cbnz	r0, 2ffc553a <I2C_RequestMemoryRead+0xa6>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2ffc5508:	6831      	ldr	r1, [r6, #0]
2ffc550a:	e7e9      	b.n	2ffc54e0 <I2C_RequestMemoryRead+0x4c>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2ffc550c:	f7fe f81e 	bl	2ffc354c <HAL_GetTick>
2ffc5510:	fab5 f385 	clz	r3, r5
2ffc5514:	1bc0      	subs	r0, r0, r7
2ffc5516:	095b      	lsrs	r3, r3, #5
2ffc5518:	4285      	cmp	r5, r0
2ffc551a:	bf38      	it	cc
2ffc551c:	f043 0301 	orrcc.w	r3, r3, #1
2ffc5520:	b90b      	cbnz	r3, 2ffc5526 <I2C_RequestMemoryRead+0x92>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc5522:	6831      	ldr	r1, [r6, #0]
2ffc5524:	e7e1      	b.n	2ffc54ea <I2C_RequestMemoryRead+0x56>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc5526:	6c73      	ldr	r3, [r6, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2ffc5528:	2220      	movs	r2, #32
        __HAL_UNLOCK(hi2c);
2ffc552a:	f886 4040 	strb.w	r4, [r6, #64]	@ 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc552e:	4313      	orrs	r3, r2
2ffc5530:	6473      	str	r3, [r6, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2ffc5532:	f886 2041 	strb.w	r2, [r6, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2ffc5536:	f886 4042 	strb.w	r4, [r6, #66]	@ 0x42
    return HAL_ERROR;
2ffc553a:	f04f 0901 	mov.w	r9, #1
}
2ffc553e:	4648      	mov	r0, r9
2ffc5540:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

2ffc5544 <HAL_I2C_MspInit>:
}
2ffc5544:	4770      	bx	lr
2ffc5546:	bf00      	nop

2ffc5548 <HAL_I2C_Init>:
  if (hi2c == NULL)
2ffc5548:	2800      	cmp	r0, #0
2ffc554a:	d050      	beq.n	2ffc55ee <HAL_I2C_Init+0xa6>
{
2ffc554c:	b510      	push	{r4, lr}
2ffc554e:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_RESET)
2ffc5550:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
2ffc5554:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
2ffc5558:	2b00      	cmp	r3, #0
2ffc555a:	d043      	beq.n	2ffc55e4 <HAL_I2C_Init+0x9c>
  __HAL_I2C_DISABLE(hi2c);
2ffc555c:	6823      	ldr	r3, [r4, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
2ffc555e:	2224      	movs	r2, #36	@ 0x24
2ffc5560:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
2ffc5564:	6862      	ldr	r2, [r4, #4]
  __HAL_I2C_DISABLE(hi2c);
2ffc5566:	6819      	ldr	r1, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
2ffc5568:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
  __HAL_I2C_DISABLE(hi2c);
2ffc556c:	f021 0101 	bic.w	r1, r1, #1
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
2ffc5570:	68e0      	ldr	r0, [r4, #12]
  __HAL_I2C_DISABLE(hi2c);
2ffc5572:	6019      	str	r1, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
2ffc5574:	611a      	str	r2, [r3, #16]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
2ffc5576:	2801      	cmp	r0, #1
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
2ffc5578:	689a      	ldr	r2, [r3, #8]
2ffc557a:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
2ffc557e:	609a      	str	r2, [r3, #8]
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
2ffc5580:	68a2      	ldr	r2, [r4, #8]
2ffc5582:	bf04      	itt	eq
2ffc5584:	f442 4200 	orreq.w	r2, r2, #32768	@ 0x8000
2ffc5588:	609a      	streq	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
2ffc558a:	d007      	beq.n	2ffc559c <HAL_I2C_Init+0x54>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
2ffc558c:	f442 4204 	orr.w	r2, r2, #33792	@ 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
2ffc5590:	2802      	cmp	r0, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
2ffc5592:	609a      	str	r2, [r3, #8]
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
2ffc5594:	bf04      	itt	eq
2ffc5596:	f44f 6200 	moveq.w	r2, #2048	@ 0x800
2ffc559a:	605a      	streq	r2, [r3, #4]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
2ffc559c:	6859      	ldr	r1, [r3, #4]
  hi2c->State = HAL_I2C_STATE_READY;
2ffc559e:	f04f 0c20 	mov.w	ip, #32
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
2ffc55a2:	e9d4 2004 	ldrd	r2, r0, [r4, #16]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
2ffc55a6:	f041 7100 	orr.w	r1, r1, #33554432	@ 0x2000000
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
2ffc55aa:	4302      	orrs	r2, r0
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
2ffc55ac:	f441 4100 	orr.w	r1, r1, #32768	@ 0x8000
                          (hi2c->Init.OwnAddress2Masks << 8));
2ffc55b0:	69a0      	ldr	r0, [r4, #24]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
2ffc55b2:	6059      	str	r1, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
2ffc55b4:	68d9      	ldr	r1, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
2ffc55b6:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
2ffc55ba:	f421 4100 	bic.w	r1, r1, #32768	@ 0x8000
2ffc55be:	60d9      	str	r1, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
2ffc55c0:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
2ffc55c2:	e9d4 2107 	ldrd	r2, r1, [r4, #28]
2ffc55c6:	4311      	orrs	r1, r2
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2ffc55c8:	2200      	movs	r2, #0
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
2ffc55ca:	6019      	str	r1, [r3, #0]
  return HAL_OK;
2ffc55cc:	4610      	mov	r0, r2
  __HAL_I2C_ENABLE(hi2c);
2ffc55ce:	6819      	ldr	r1, [r3, #0]
2ffc55d0:	f041 0101 	orr.w	r1, r1, #1
2ffc55d4:	6019      	str	r1, [r3, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2ffc55d6:	6462      	str	r2, [r4, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
2ffc55d8:	f884 c041 	strb.w	ip, [r4, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
2ffc55dc:	6322      	str	r2, [r4, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
2ffc55de:	f884 2042 	strb.w	r2, [r4, #66]	@ 0x42
}
2ffc55e2:	bd10      	pop	{r4, pc}
    hi2c->Lock = HAL_UNLOCKED;
2ffc55e4:	f880 2040 	strb.w	r2, [r0, #64]	@ 0x40
    HAL_I2C_MspInit(hi2c);
2ffc55e8:	f7ff ffac 	bl	2ffc5544 <HAL_I2C_MspInit>
2ffc55ec:	e7b6      	b.n	2ffc555c <HAL_I2C_Init+0x14>
    return HAL_ERROR;
2ffc55ee:	2001      	movs	r0, #1
}
2ffc55f0:	4770      	bx	lr
2ffc55f2:	bf00      	nop

2ffc55f4 <HAL_I2C_Mem_Write>:
{
2ffc55f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
2ffc55f8:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
2ffc55fa:	f890 0041 	ldrb.w	r0, [r0, #65]	@ 0x41
{
2ffc55fe:	b083      	sub	sp, #12
2ffc5600:	f8bd a034 	ldrh.w	sl, [sp, #52]	@ 0x34
  if (hi2c->State == HAL_I2C_STATE_READY)
2ffc5604:	2820      	cmp	r0, #32
{
2ffc5606:	9d0e      	ldr	r5, [sp, #56]	@ 0x38
  if (hi2c->State == HAL_I2C_STATE_READY)
2ffc5608:	f040 8094 	bne.w	2ffc5734 <HAL_I2C_Mem_Write+0x140>
    if ((pData == NULL) || (Size == 0U))
2ffc560c:	4699      	mov	r9, r3
2ffc560e:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
2ffc5610:	f1ba 0f00 	cmp.w	sl, #0
2ffc5614:	bf18      	it	ne
2ffc5616:	2b00      	cmpne	r3, #0
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2ffc5618:	bf04      	itt	eq
2ffc561a:	f44f 7300 	moveq.w	r3, #512	@ 0x200
2ffc561e:	6463      	streq	r3, [r4, #68]	@ 0x44
    if ((pData == NULL) || (Size == 0U))
2ffc5620:	f000 808e 	beq.w	2ffc5740 <HAL_I2C_Mem_Write+0x14c>
    __HAL_LOCK(hi2c);
2ffc5624:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
2ffc5628:	2b01      	cmp	r3, #1
2ffc562a:	f000 8083 	beq.w	2ffc5734 <HAL_I2C_Mem_Write+0x140>
2ffc562e:	2301      	movs	r3, #1
2ffc5630:	460f      	mov	r7, r1
2ffc5632:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
2ffc5636:	4690      	mov	r8, r2
    tickstart = HAL_GetTick();
2ffc5638:	f7fd ff88 	bl	2ffc354c <HAL_GetTick>
2ffc563c:	4606      	mov	r6, r0
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc563e:	e005      	b.n	2ffc564c <HAL_I2C_Mem_Write+0x58>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2ffc5640:	f7fd ff84 	bl	2ffc354c <HAL_GetTick>
2ffc5644:	1b80      	subs	r0, r0, r6
2ffc5646:	2819      	cmp	r0, #25
2ffc5648:	f200 808a 	bhi.w	2ffc5760 <HAL_I2C_Mem_Write+0x16c>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc564c:	6823      	ldr	r3, [r4, #0]
2ffc564e:	699b      	ldr	r3, [r3, #24]
2ffc5650:	f413 4b00 	ands.w	fp, r3, #32768	@ 0x8000
2ffc5654:	d1f4      	bne.n	2ffc5640 <HAL_I2C_Mem_Write+0x4c>
    hi2c->pBuffPtr  = pData;
2ffc5656:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2ffc5658:	2121      	movs	r1, #33	@ 0x21
    hi2c->XferISR   = NULL;
2ffc565a:	f8c4 b034 	str.w	fp, [r4, #52]	@ 0x34
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2ffc565e:	4642      	mov	r2, r8
    hi2c->pBuffPtr  = pData;
2ffc5660:	6263      	str	r3, [r4, #36]	@ 0x24
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2ffc5662:	4620      	mov	r0, r4
2ffc5664:	e9cd 5600 	strd	r5, r6, [sp]
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2ffc5668:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
2ffc566c:	2140      	movs	r1, #64	@ 0x40
2ffc566e:	f884 1042 	strb.w	r1, [r4, #66]	@ 0x42
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2ffc5672:	464b      	mov	r3, r9
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2ffc5674:	f8c4 b044 	str.w	fp, [r4, #68]	@ 0x44
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2ffc5678:	4639      	mov	r1, r7
    hi2c->XferCount = Size;
2ffc567a:	f8a4 a02a 	strh.w	sl, [r4, #42]	@ 0x2a
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2ffc567e:	f7ff feaf 	bl	2ffc53e0 <I2C_RequestMemoryWrite>
2ffc5682:	2800      	cmp	r0, #0
2ffc5684:	d15a      	bne.n	2ffc573c <HAL_I2C_Mem_Write+0x148>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2ffc5686:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
2ffc5688:	f3c7 0709 	ubfx	r7, r7, #0, #10
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc568c:	6822      	ldr	r2, [r4, #0]
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2ffc568e:	b29b      	uxth	r3, r3
2ffc5690:	2bff      	cmp	r3, #255	@ 0xff
2ffc5692:	f240 8082 	bls.w	2ffc579a <HAL_I2C_Mem_Write+0x1a6>
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc5696:	6853      	ldr	r3, [r2, #4]
2ffc5698:	f44f 411c 	mov.w	r1, #39936	@ 0x9c00
2ffc569c:	f6cf 4100 	movt	r1, #64512	@ 0xfc00
2ffc56a0:	400b      	ands	r3, r1
      hi2c->XferSize = MAX_NBYTE_SIZE;
2ffc56a2:	21ff      	movs	r1, #255	@ 0xff
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc56a4:	433b      	orrs	r3, r7
      hi2c->XferSize = MAX_NBYTE_SIZE;
2ffc56a6:	8521      	strh	r1, [r4, #40]	@ 0x28
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc56a8:	f043 73ff 	orr.w	r3, r3, #33423360	@ 0x1fe0000
2ffc56ac:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
2ffc56b0:	6053      	str	r3, [r2, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
                I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
2ffc56b2:	e003      	b.n	2ffc56bc <HAL_I2C_Mem_Write+0xc8>
    } while (hi2c->XferCount > 0U);
2ffc56b4:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
2ffc56b6:	b29b      	uxth	r3, r3
2ffc56b8:	2b00      	cmp	r3, #0
2ffc56ba:	d07f      	beq.n	2ffc57bc <HAL_I2C_Mem_Write+0x1c8>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2ffc56bc:	4632      	mov	r2, r6
2ffc56be:	4629      	mov	r1, r5
2ffc56c0:	4620      	mov	r0, r4
2ffc56c2:	f7ff fe37 	bl	2ffc5334 <I2C_WaitOnTXISFlagUntilTimeout>
2ffc56c6:	2800      	cmp	r0, #0
2ffc56c8:	d13a      	bne.n	2ffc5740 <HAL_I2C_Mem_Write+0x14c>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2ffc56ca:	6a60      	ldr	r0, [r4, #36]	@ 0x24
2ffc56cc:	6821      	ldr	r1, [r4, #0]
2ffc56ce:	f810 2b01 	ldrb.w	r2, [r0], #1
      hi2c->XferSize--;
2ffc56d2:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2ffc56d4:	628a      	str	r2, [r1, #40]	@ 0x28
      hi2c->XferCount--;
2ffc56d6:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
2ffc56d8:	3b01      	subs	r3, #1
      hi2c->pBuffPtr++;
2ffc56da:	6260      	str	r0, [r4, #36]	@ 0x24
      hi2c->XferSize--;
2ffc56dc:	b29b      	uxth	r3, r3
2ffc56de:	8523      	strh	r3, [r4, #40]	@ 0x28
      hi2c->XferCount--;
2ffc56e0:	3a01      	subs	r2, #1
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2ffc56e2:	fab3 f383 	clz	r3, r3
      hi2c->XferCount--;
2ffc56e6:	b292      	uxth	r2, r2
2ffc56e8:	8562      	strh	r2, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2ffc56ea:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
2ffc56ec:	095b      	lsrs	r3, r3, #5
2ffc56ee:	b292      	uxth	r2, r2
2ffc56f0:	2a00      	cmp	r2, #0
2ffc56f2:	bf08      	it	eq
2ffc56f4:	2300      	moveq	r3, #0
2ffc56f6:	2b00      	cmp	r3, #0
2ffc56f8:	d0dc      	beq.n	2ffc56b4 <HAL_I2C_Mem_Write+0xc0>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc56fa:	698b      	ldr	r3, [r1, #24]
2ffc56fc:	f013 0880 	ands.w	r8, r3, #128	@ 0x80
2ffc5700:	d105      	bne.n	2ffc570e <HAL_I2C_Mem_Write+0x11a>
    if (Timeout != HAL_MAX_DELAY)
2ffc5702:	1c6b      	adds	r3, r5, #1
2ffc5704:	d11e      	bne.n	2ffc5744 <HAL_I2C_Mem_Write+0x150>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc5706:	698b      	ldr	r3, [r1, #24]
2ffc5708:	f013 0880 	ands.w	r8, r3, #128	@ 0x80
2ffc570c:	d0f9      	beq.n	2ffc5702 <HAL_I2C_Mem_Write+0x10e>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
2ffc570e:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
2ffc5710:	b29b      	uxth	r3, r3
2ffc5712:	2bff      	cmp	r3, #255	@ 0xff
2ffc5714:	d930      	bls.n	2ffc5778 <HAL_I2C_Mem_Write+0x184>
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc5716:	684b      	ldr	r3, [r1, #4]
2ffc5718:	f44f 421c 	mov.w	r2, #39936	@ 0x9c00
2ffc571c:	f6cf 4200 	movt	r2, #64512	@ 0xfc00
2ffc5720:	4013      	ands	r3, r2
          hi2c->XferSize = MAX_NBYTE_SIZE;
2ffc5722:	22ff      	movs	r2, #255	@ 0xff
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc5724:	433b      	orrs	r3, r7
          hi2c->XferSize = MAX_NBYTE_SIZE;
2ffc5726:	8522      	strh	r2, [r4, #40]	@ 0x28
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc5728:	f043 73ff 	orr.w	r3, r3, #33423360	@ 0x1fe0000
2ffc572c:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
2ffc5730:	604b      	str	r3, [r1, #4]
}
2ffc5732:	e7bf      	b.n	2ffc56b4 <HAL_I2C_Mem_Write+0xc0>
    __HAL_LOCK(hi2c);
2ffc5734:	2002      	movs	r0, #2
}
2ffc5736:	b003      	add	sp, #12
2ffc5738:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      __HAL_UNLOCK(hi2c);
2ffc573c:	f884 b040 	strb.w	fp, [r4, #64]	@ 0x40
      return  HAL_ERROR;
2ffc5740:	2001      	movs	r0, #1
2ffc5742:	e7f8      	b.n	2ffc5736 <HAL_I2C_Mem_Write+0x142>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2ffc5744:	f7fd ff02 	bl	2ffc354c <HAL_GetTick>
2ffc5748:	fab5 f385 	clz	r3, r5
2ffc574c:	1b80      	subs	r0, r0, r6
2ffc574e:	095b      	lsrs	r3, r3, #5
2ffc5750:	4285      	cmp	r5, r0
2ffc5752:	bf38      	it	cc
2ffc5754:	f043 0301 	orrcc.w	r3, r3, #1
2ffc5758:	2b00      	cmp	r3, #0
2ffc575a:	d147      	bne.n	2ffc57ec <HAL_I2C_Mem_Write+0x1f8>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc575c:	6821      	ldr	r1, [r4, #0]
2ffc575e:	e7d2      	b.n	2ffc5706 <HAL_I2C_Mem_Write+0x112>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc5760:	6c63      	ldr	r3, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2ffc5762:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
2ffc5764:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc5766:	430b      	orrs	r3, r1
2ffc5768:	6463      	str	r3, [r4, #68]	@ 0x44
        __HAL_UNLOCK(hi2c);
2ffc576a:	f884 2040 	strb.w	r2, [r4, #64]	@ 0x40
        hi2c->State = HAL_I2C_STATE_READY;
2ffc576e:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2ffc5772:	f884 2042 	strb.w	r2, [r4, #66]	@ 0x42
        return HAL_ERROR;
2ffc5776:	e7e3      	b.n	2ffc5740 <HAL_I2C_Mem_Write+0x14c>
          hi2c->XferSize = hi2c->XferCount;
2ffc5778:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc577a:	f44f 401c 	mov.w	r0, #39936	@ 0x9c00
2ffc577e:	684b      	ldr	r3, [r1, #4]
2ffc5780:	f6cf 4000 	movt	r0, #64512	@ 0xfc00
          hi2c->XferSize = hi2c->XferCount;
2ffc5784:	b292      	uxth	r2, r2
2ffc5786:	8522      	strh	r2, [r4, #40]	@ 0x28
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc5788:	4003      	ands	r3, r0
2ffc578a:	433b      	orrs	r3, r7
                            (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
2ffc578c:	b2d2      	uxtb	r2, r2
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc578e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
2ffc5792:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
2ffc5796:	604b      	str	r3, [r1, #4]
}
2ffc5798:	e78c      	b.n	2ffc56b4 <HAL_I2C_Mem_Write+0xc0>
      hi2c->XferSize = hi2c->XferCount;
2ffc579a:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc579c:	f44f 401c 	mov.w	r0, #39936	@ 0x9c00
2ffc57a0:	6851      	ldr	r1, [r2, #4]
2ffc57a2:	f6cf 4000 	movt	r0, #64512	@ 0xfc00
      hi2c->XferSize = hi2c->XferCount;
2ffc57a6:	b29b      	uxth	r3, r3
2ffc57a8:	8523      	strh	r3, [r4, #40]	@ 0x28
                            (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
2ffc57aa:	b2db      	uxtb	r3, r3
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc57ac:	4001      	ands	r1, r0
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
2ffc57ae:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc57b2:	430b      	orrs	r3, r1
2ffc57b4:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
2ffc57b8:	6053      	str	r3, [r2, #4]
}
2ffc57ba:	e77f      	b.n	2ffc56bc <HAL_I2C_Mem_Write+0xc8>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2ffc57bc:	4632      	mov	r2, r6
2ffc57be:	4629      	mov	r1, r5
2ffc57c0:	4620      	mov	r0, r4
2ffc57c2:	f7ff fde3 	bl	2ffc538c <I2C_WaitOnSTOPFlagUntilTimeout>
2ffc57c6:	2800      	cmp	r0, #0
2ffc57c8:	d1ba      	bne.n	2ffc5740 <HAL_I2C_Mem_Write+0x14c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2ffc57ca:	6823      	ldr	r3, [r4, #0]
2ffc57cc:	2120      	movs	r1, #32
    I2C_RESET_CR2(hi2c);
2ffc57ce:	f44f 4568 	mov.w	r5, #59392	@ 0xe800
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2ffc57d2:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
2ffc57d4:	685a      	ldr	r2, [r3, #4]
2ffc57d6:	f6cf 6500 	movt	r5, #65024	@ 0xfe00
2ffc57da:	402a      	ands	r2, r5
2ffc57dc:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
2ffc57de:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
2ffc57e2:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2ffc57e6:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
2ffc57ea:	e7a4      	b.n	2ffc5736 <HAL_I2C_Mem_Write+0x142>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc57ec:	6c63      	ldr	r3, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2ffc57ee:	2220      	movs	r2, #32
        __HAL_UNLOCK(hi2c);
2ffc57f0:	f884 8040 	strb.w	r8, [r4, #64]	@ 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc57f4:	4313      	orrs	r3, r2
2ffc57f6:	6463      	str	r3, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2ffc57f8:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2ffc57fc:	f884 8042 	strb.w	r8, [r4, #66]	@ 0x42
        return HAL_ERROR;
2ffc5800:	e79e      	b.n	2ffc5740 <HAL_I2C_Mem_Write+0x14c>
2ffc5802:	bf00      	nop

2ffc5804 <HAL_I2C_Mem_Read>:
{
2ffc5804:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
2ffc5808:	4606      	mov	r6, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
2ffc580a:	f890 0041 	ldrb.w	r0, [r0, #65]	@ 0x41
{
2ffc580e:	b083      	sub	sp, #12
2ffc5810:	f8bd a034 	ldrh.w	sl, [sp, #52]	@ 0x34
  if (hi2c->State == HAL_I2C_STATE_READY)
2ffc5814:	2820      	cmp	r0, #32
{
2ffc5816:	9d0e      	ldr	r5, [sp, #56]	@ 0x38
  if (hi2c->State == HAL_I2C_STATE_READY)
2ffc5818:	d175      	bne.n	2ffc5906 <HAL_I2C_Mem_Read+0x102>
    if ((pData == NULL) || (Size == 0U))
2ffc581a:	4699      	mov	r9, r3
2ffc581c:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
2ffc581e:	f1ba 0f00 	cmp.w	sl, #0
2ffc5822:	bf18      	it	ne
2ffc5824:	2b00      	cmpne	r3, #0
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2ffc5826:	bf04      	itt	eq
2ffc5828:	f44f 7300 	moveq.w	r3, #512	@ 0x200
2ffc582c:	6473      	streq	r3, [r6, #68]	@ 0x44
    if ((pData == NULL) || (Size == 0U))
2ffc582e:	d079      	beq.n	2ffc5924 <HAL_I2C_Mem_Read+0x120>
    __HAL_LOCK(hi2c);
2ffc5830:	f896 3040 	ldrb.w	r3, [r6, #64]	@ 0x40
2ffc5834:	2b01      	cmp	r3, #1
2ffc5836:	d066      	beq.n	2ffc5906 <HAL_I2C_Mem_Read+0x102>
2ffc5838:	2301      	movs	r3, #1
2ffc583a:	460c      	mov	r4, r1
2ffc583c:	f886 3040 	strb.w	r3, [r6, #64]	@ 0x40
2ffc5840:	4690      	mov	r8, r2
    tickstart = HAL_GetTick();
2ffc5842:	f7fd fe83 	bl	2ffc354c <HAL_GetTick>
2ffc5846:	4607      	mov	r7, r0
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc5848:	e004      	b.n	2ffc5854 <HAL_I2C_Mem_Read+0x50>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2ffc584a:	f7fd fe7f 	bl	2ffc354c <HAL_GetTick>
2ffc584e:	1bc0      	subs	r0, r0, r7
2ffc5850:	2819      	cmp	r0, #25
2ffc5852:	d85c      	bhi.n	2ffc590e <HAL_I2C_Mem_Read+0x10a>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc5854:	6833      	ldr	r3, [r6, #0]
2ffc5856:	699b      	ldr	r3, [r3, #24]
2ffc5858:	f413 4b00 	ands.w	fp, r3, #32768	@ 0x8000
2ffc585c:	d1f5      	bne.n	2ffc584a <HAL_I2C_Mem_Read+0x46>
    hi2c->pBuffPtr  = pData;
2ffc585e:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2ffc5860:	2122      	movs	r1, #34	@ 0x22
    hi2c->XferISR   = NULL;
2ffc5862:	f8c6 b034 	str.w	fp, [r6, #52]	@ 0x34
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2ffc5866:	4642      	mov	r2, r8
    hi2c->pBuffPtr  = pData;
2ffc5868:	6273      	str	r3, [r6, #36]	@ 0x24
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2ffc586a:	4630      	mov	r0, r6
2ffc586c:	e9cd 5700 	strd	r5, r7, [sp]
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2ffc5870:	f886 1041 	strb.w	r1, [r6, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
2ffc5874:	2140      	movs	r1, #64	@ 0x40
2ffc5876:	f886 1042 	strb.w	r1, [r6, #66]	@ 0x42
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2ffc587a:	464b      	mov	r3, r9
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2ffc587c:	f8c6 b044 	str.w	fp, [r6, #68]	@ 0x44
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2ffc5880:	4621      	mov	r1, r4
    hi2c->XferCount = Size;
2ffc5882:	f8a6 a02a 	strh.w	sl, [r6, #42]	@ 0x2a
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2ffc5886:	f7ff fe05 	bl	2ffc5494 <I2C_RequestMemoryRead>
2ffc588a:	2800      	cmp	r0, #0
2ffc588c:	d173      	bne.n	2ffc5976 <HAL_I2C_Mem_Read+0x172>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2ffc588e:	8d73      	ldrh	r3, [r6, #42]	@ 0x2a
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
2ffc5890:	f3c4 0809 	ubfx	r8, r4, #0, #10
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc5894:	6832      	ldr	r2, [r6, #0]
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2ffc5896:	b29b      	uxth	r3, r3
2ffc5898:	2bff      	cmp	r3, #255	@ 0xff
2ffc589a:	f240 8098 	bls.w	2ffc59ce <HAL_I2C_Mem_Read+0x1ca>
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc589e:	6853      	ldr	r3, [r2, #4]
2ffc58a0:	f44f 4118 	mov.w	r1, #38912	@ 0x9800
2ffc58a4:	f6cf 4100 	movt	r1, #64512	@ 0xfc00
2ffc58a8:	400b      	ands	r3, r1
      hi2c->XferSize = MAX_NBYTE_SIZE;
2ffc58aa:	21ff      	movs	r1, #255	@ 0xff
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc58ac:	ea43 0308 	orr.w	r3, r3, r8
      hi2c->XferSize = MAX_NBYTE_SIZE;
2ffc58b0:	8531      	strh	r1, [r6, #40]	@ 0x28
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc58b2:	f043 73ff 	orr.w	r3, r3, #33423360	@ 0x1fe0000
2ffc58b6:	f443 3392 	orr.w	r3, r3, #74752	@ 0x12400
2ffc58ba:	6053      	str	r3, [r2, #4]
}
2ffc58bc:	e001      	b.n	2ffc58c2 <HAL_I2C_Mem_Read+0xbe>
    if (Timeout != HAL_MAX_DELAY)
2ffc58be:	1c69      	adds	r1, r5, #1
2ffc58c0:	d15c      	bne.n	2ffc597c <HAL_I2C_Mem_Read+0x178>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc58c2:	6994      	ldr	r4, [r2, #24]
2ffc58c4:	f014 0404 	ands.w	r4, r4, #4
2ffc58c8:	d0f9      	beq.n	2ffc58be <HAL_I2C_Mem_Read+0xba>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2ffc58ca:	6a52      	ldr	r2, [r2, #36]	@ 0x24
2ffc58cc:	6a73      	ldr	r3, [r6, #36]	@ 0x24
2ffc58ce:	701a      	strb	r2, [r3, #0]
      hi2c->XferCount--;
2ffc58d0:	8d71      	ldrh	r1, [r6, #42]	@ 0x2a
      hi2c->XferSize--;
2ffc58d2:	8d33      	ldrh	r3, [r6, #40]	@ 0x28
      hi2c->pBuffPtr++;
2ffc58d4:	6a72      	ldr	r2, [r6, #36]	@ 0x24
      hi2c->XferCount--;
2ffc58d6:	3901      	subs	r1, #1
2ffc58d8:	b289      	uxth	r1, r1
      hi2c->XferSize--;
2ffc58da:	3b01      	subs	r3, #1
      hi2c->XferCount--;
2ffc58dc:	8571      	strh	r1, [r6, #42]	@ 0x2a
      hi2c->XferSize--;
2ffc58de:	b29b      	uxth	r3, r3
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2ffc58e0:	8d71      	ldrh	r1, [r6, #42]	@ 0x2a
      hi2c->pBuffPtr++;
2ffc58e2:	3201      	adds	r2, #1
2ffc58e4:	6272      	str	r2, [r6, #36]	@ 0x24
      hi2c->XferSize--;
2ffc58e6:	8533      	strh	r3, [r6, #40]	@ 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2ffc58e8:	b28a      	uxth	r2, r1
2ffc58ea:	fab3 f383 	clz	r3, r3
2ffc58ee:	2a00      	cmp	r2, #0
2ffc58f0:	ea4f 1353 	mov.w	r3, r3, lsr #5
2ffc58f4:	bf08      	it	eq
2ffc58f6:	2300      	moveq	r3, #0
2ffc58f8:	bb0b      	cbnz	r3, 2ffc593e <HAL_I2C_Mem_Read+0x13a>
    } while (hi2c->XferCount > 0U);
2ffc58fa:	8d73      	ldrh	r3, [r6, #42]	@ 0x2a
2ffc58fc:	b29b      	uxth	r3, r3
2ffc58fe:	2b00      	cmp	r3, #0
2ffc5900:	d078      	beq.n	2ffc59f4 <HAL_I2C_Mem_Read+0x1f0>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc5902:	6832      	ldr	r2, [r6, #0]
2ffc5904:	e7dd      	b.n	2ffc58c2 <HAL_I2C_Mem_Read+0xbe>
    __HAL_LOCK(hi2c);
2ffc5906:	2002      	movs	r0, #2
}
2ffc5908:	b003      	add	sp, #12
2ffc590a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc590e:	6c73      	ldr	r3, [r6, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2ffc5910:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
2ffc5912:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc5914:	430b      	orrs	r3, r1
2ffc5916:	6473      	str	r3, [r6, #68]	@ 0x44
        __HAL_UNLOCK(hi2c);
2ffc5918:	f886 2040 	strb.w	r2, [r6, #64]	@ 0x40
        hi2c->State = HAL_I2C_STATE_READY;
2ffc591c:	f886 1041 	strb.w	r1, [r6, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2ffc5920:	f886 2042 	strb.w	r2, [r6, #66]	@ 0x42
      return  HAL_ERROR;
2ffc5924:	2001      	movs	r0, #1
2ffc5926:	e7ef      	b.n	2ffc5908 <HAL_I2C_Mem_Read+0x104>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2ffc5928:	f7fd fe10 	bl	2ffc354c <HAL_GetTick>
2ffc592c:	fab5 f385 	clz	r3, r5
2ffc5930:	1bc2      	subs	r2, r0, r7
2ffc5932:	095b      	lsrs	r3, r3, #5
2ffc5934:	4295      	cmp	r5, r2
2ffc5936:	bf38      	it	cc
2ffc5938:	f043 0301 	orrcc.w	r3, r3, #1
2ffc593c:	bb53      	cbnz	r3, 2ffc5994 <HAL_I2C_Mem_Read+0x190>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc593e:	6832      	ldr	r2, [r6, #0]
2ffc5940:	e001      	b.n	2ffc5946 <HAL_I2C_Mem_Read+0x142>
    if (Timeout != HAL_MAX_DELAY)
2ffc5942:	1c6b      	adds	r3, r5, #1
2ffc5944:	d1f0      	bne.n	2ffc5928 <HAL_I2C_Mem_Read+0x124>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc5946:	6994      	ldr	r4, [r2, #24]
2ffc5948:	f014 0480 	ands.w	r4, r4, #128	@ 0x80
2ffc594c:	d0f9      	beq.n	2ffc5942 <HAL_I2C_Mem_Read+0x13e>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
2ffc594e:	8d73      	ldrh	r3, [r6, #42]	@ 0x2a
2ffc5950:	b29b      	uxth	r3, r3
2ffc5952:	2bff      	cmp	r3, #255	@ 0xff
2ffc5954:	d92a      	bls.n	2ffc59ac <HAL_I2C_Mem_Read+0x1a8>
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc5956:	6853      	ldr	r3, [r2, #4]
2ffc5958:	f44f 411c 	mov.w	r1, #39936	@ 0x9c00
2ffc595c:	f6cf 4100 	movt	r1, #64512	@ 0xfc00
2ffc5960:	400b      	ands	r3, r1
          hi2c->XferSize = MAX_NBYTE_SIZE;
2ffc5962:	21ff      	movs	r1, #255	@ 0xff
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc5964:	ea43 0308 	orr.w	r3, r3, r8
          hi2c->XferSize = MAX_NBYTE_SIZE;
2ffc5968:	8531      	strh	r1, [r6, #40]	@ 0x28
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc596a:	f043 73ff 	orr.w	r3, r3, #33423360	@ 0x1fe0000
2ffc596e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
2ffc5972:	6053      	str	r3, [r2, #4]
}
2ffc5974:	e7c1      	b.n	2ffc58fa <HAL_I2C_Mem_Read+0xf6>
      __HAL_UNLOCK(hi2c);
2ffc5976:	f886 b040 	strb.w	fp, [r6, #64]	@ 0x40
      return HAL_ERROR;
2ffc597a:	e7d3      	b.n	2ffc5924 <HAL_I2C_Mem_Read+0x120>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2ffc597c:	f7fd fde6 	bl	2ffc354c <HAL_GetTick>
2ffc5980:	fab5 f385 	clz	r3, r5
2ffc5984:	1bc0      	subs	r0, r0, r7
2ffc5986:	095b      	lsrs	r3, r3, #5
2ffc5988:	4285      	cmp	r5, r0
2ffc598a:	bf38      	it	cc
2ffc598c:	f043 0301 	orrcc.w	r3, r3, #1
2ffc5990:	2b00      	cmp	r3, #0
2ffc5992:	d0b6      	beq.n	2ffc5902 <HAL_I2C_Mem_Read+0xfe>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc5994:	6c73      	ldr	r3, [r6, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2ffc5996:	2220      	movs	r2, #32
        __HAL_UNLOCK(hi2c);
2ffc5998:	f886 4040 	strb.w	r4, [r6, #64]	@ 0x40
      return  HAL_ERROR;
2ffc599c:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc599e:	4313      	orrs	r3, r2
2ffc59a0:	6473      	str	r3, [r6, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2ffc59a2:	f886 2041 	strb.w	r2, [r6, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2ffc59a6:	f886 4042 	strb.w	r4, [r6, #66]	@ 0x42
        return HAL_ERROR;
2ffc59aa:	e7ad      	b.n	2ffc5908 <HAL_I2C_Mem_Read+0x104>
          hi2c->XferSize = hi2c->XferCount;
2ffc59ac:	8d73      	ldrh	r3, [r6, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc59ae:	f44f 401c 	mov.w	r0, #39936	@ 0x9c00
2ffc59b2:	6851      	ldr	r1, [r2, #4]
2ffc59b4:	f6cf 4000 	movt	r0, #64512	@ 0xfc00
          hi2c->XferSize = hi2c->XferCount;
2ffc59b8:	b29b      	uxth	r3, r3
2ffc59ba:	8533      	strh	r3, [r6, #40]	@ 0x28
                            (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
2ffc59bc:	b2db      	uxtb	r3, r3
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc59be:	4001      	ands	r1, r0
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
2ffc59c0:	ea48 4303 	orr.w	r3, r8, r3, lsl #16
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc59c4:	430b      	orrs	r3, r1
2ffc59c6:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
2ffc59ca:	6053      	str	r3, [r2, #4]
}
2ffc59cc:	e795      	b.n	2ffc58fa <HAL_I2C_Mem_Read+0xf6>
      hi2c->XferSize = hi2c->XferCount;
2ffc59ce:	8d73      	ldrh	r3, [r6, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc59d0:	f44f 4018 	mov.w	r0, #38912	@ 0x9800
2ffc59d4:	6851      	ldr	r1, [r2, #4]
2ffc59d6:	f6cf 4000 	movt	r0, #64512	@ 0xfc00
      hi2c->XferSize = hi2c->XferCount;
2ffc59da:	b29b      	uxth	r3, r3
2ffc59dc:	8533      	strh	r3, [r6, #40]	@ 0x28
                            (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
2ffc59de:	b2db      	uxtb	r3, r3
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc59e0:	4001      	ands	r1, r0
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
2ffc59e2:	ea48 4303 	orr.w	r3, r8, r3, lsl #16
  MODIFY_REG(hi2c->Instance->CR2, \
2ffc59e6:	430b      	orrs	r3, r1
2ffc59e8:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
2ffc59ec:	f443 5310 	orr.w	r3, r3, #9216	@ 0x2400
2ffc59f0:	6053      	str	r3, [r2, #4]
}
2ffc59f2:	e766      	b.n	2ffc58c2 <HAL_I2C_Mem_Read+0xbe>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2ffc59f4:	463a      	mov	r2, r7
2ffc59f6:	4629      	mov	r1, r5
2ffc59f8:	4630      	mov	r0, r6
2ffc59fa:	f7ff fcc7 	bl	2ffc538c <I2C_WaitOnSTOPFlagUntilTimeout>
2ffc59fe:	2800      	cmp	r0, #0
2ffc5a00:	d190      	bne.n	2ffc5924 <HAL_I2C_Mem_Read+0x120>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2ffc5a02:	6833      	ldr	r3, [r6, #0]
2ffc5a04:	2120      	movs	r1, #32
    I2C_RESET_CR2(hi2c);
2ffc5a06:	f44f 4468 	mov.w	r4, #59392	@ 0xe800
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2ffc5a0a:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
2ffc5a0c:	685a      	ldr	r2, [r3, #4]
2ffc5a0e:	f6cf 6400 	movt	r4, #65024	@ 0xfe00
2ffc5a12:	4022      	ands	r2, r4
2ffc5a14:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
2ffc5a16:	f886 1041 	strb.w	r1, [r6, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
2ffc5a1a:	f886 0040 	strb.w	r0, [r6, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2ffc5a1e:	f886 0042 	strb.w	r0, [r6, #66]	@ 0x42
    return HAL_OK;
2ffc5a22:	e771      	b.n	2ffc5908 <HAL_I2C_Mem_Read+0x104>

2ffc5a24 <HAL_I2C_IsDeviceReady>:
{
2ffc5a24:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
2ffc5a28:	b082      	sub	sp, #8
  __IO uint32_t I2C_Trials = 0UL;
2ffc5a2a:	2400      	movs	r4, #0
2ffc5a2c:	9401      	str	r4, [sp, #4]
{
2ffc5a2e:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
2ffc5a30:	f890 0041 	ldrb.w	r0, [r0, #65]	@ 0x41
2ffc5a34:	2820      	cmp	r0, #32
2ffc5a36:	d167      	bne.n	2ffc5b08 <HAL_I2C_IsDeviceReady+0xe4>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2ffc5a38:	4617      	mov	r7, r2
2ffc5a3a:	4699      	mov	r9, r3
2ffc5a3c:	6822      	ldr	r2, [r4, #0]
2ffc5a3e:	6993      	ldr	r3, [r2, #24]
2ffc5a40:	f413 4300 	ands.w	r3, r3, #32768	@ 0x8000
2ffc5a44:	d160      	bne.n	2ffc5b08 <HAL_I2C_IsDeviceReady+0xe4>
    __HAL_LOCK(hi2c);
2ffc5a46:	f894 0040 	ldrb.w	r0, [r4, #64]	@ 0x40
2ffc5a4a:	2801      	cmp	r0, #1
2ffc5a4c:	d05c      	beq.n	2ffc5b08 <HAL_I2C_IsDeviceReady+0xe4>
2ffc5a4e:	f3c1 0609 	ubfx	r6, r1, #0, #10
2ffc5a52:	2101      	movs	r1, #1
2ffc5a54:	f884 1040 	strb.w	r1, [r4, #64]	@ 0x40
      hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode, DevAddress);
2ffc5a58:	f446 5820 	orr.w	r8, r6, #10240	@ 0x2800
    hi2c->State = HAL_I2C_STATE_BUSY;
2ffc5a5c:	2124      	movs	r1, #36	@ 0x24
2ffc5a5e:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2ffc5a62:	6463      	str	r3, [r4, #68]	@ 0x44
      hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode, DevAddress);
2ffc5a64:	68e3      	ldr	r3, [r4, #12]
2ffc5a66:	2b01      	cmp	r3, #1
2ffc5a68:	bf0a      	itet	eq
2ffc5a6a:	f046 7300 	orreq.w	r3, r6, #33554432	@ 0x2000000
2ffc5a6e:	4643      	movne	r3, r8
2ffc5a70:	f443 5300 	orreq.w	r3, r3, #8192	@ 0x2000
2ffc5a74:	6053      	str	r3, [r2, #4]
      tickstart = HAL_GetTick();
2ffc5a76:	f7fd fd69 	bl	2ffc354c <HAL_GetTick>
      tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
2ffc5a7a:	6822      	ldr	r2, [r4, #0]
      tickstart = HAL_GetTick();
2ffc5a7c:	4605      	mov	r5, r0
      tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
2ffc5a7e:	6993      	ldr	r3, [r2, #24]
2ffc5a80:	4610      	mov	r0, r2
      tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
2ffc5a82:	6991      	ldr	r1, [r2, #24]
      tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
2ffc5a84:	f003 0320 	and.w	r3, r3, #32
      tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
2ffc5a88:	f001 0110 	and.w	r1, r1, #16
      while ((tmp1 == RESET) && (tmp2 == RESET))
2ffc5a8c:	430b      	orrs	r3, r1
2ffc5a8e:	d117      	bne.n	2ffc5ac0 <HAL_I2C_IsDeviceReady+0x9c>
        if (Timeout != HAL_MAX_DELAY)
2ffc5a90:	f1b9 3fff 	cmp.w	r9, #4294967295	@ 0xffffffff
2ffc5a94:	d00b      	beq.n	2ffc5aae <HAL_I2C_IsDeviceReady+0x8a>
          if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2ffc5a96:	f7fd fd59 	bl	2ffc354c <HAL_GetTick>
2ffc5a9a:	fab9 f389 	clz	r3, r9
2ffc5a9e:	1b40      	subs	r0, r0, r5
2ffc5aa0:	095b      	lsrs	r3, r3, #5
2ffc5aa2:	4548      	cmp	r0, r9
2ffc5aa4:	bf88      	it	hi
2ffc5aa6:	f043 0301 	orrhi.w	r3, r3, #1
2ffc5aaa:	bb0b      	cbnz	r3, 2ffc5af0 <HAL_I2C_IsDeviceReady+0xcc>
2ffc5aac:	6822      	ldr	r2, [r4, #0]
        tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
2ffc5aae:	6991      	ldr	r1, [r2, #24]
2ffc5ab0:	4610      	mov	r0, r2
        tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
2ffc5ab2:	6993      	ldr	r3, [r2, #24]
        tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
2ffc5ab4:	f001 0120 	and.w	r1, r1, #32
        tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
2ffc5ab8:	f003 0310 	and.w	r3, r3, #16
      while ((tmp1 == RESET) && (tmp2 == RESET))
2ffc5abc:	4319      	orrs	r1, r3
2ffc5abe:	d0e7      	beq.n	2ffc5a90 <HAL_I2C_IsDeviceReady+0x6c>
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
2ffc5ac0:	6993      	ldr	r3, [r2, #24]
2ffc5ac2:	06db      	lsls	r3, r3, #27
2ffc5ac4:	d403      	bmi.n	2ffc5ace <HAL_I2C_IsDeviceReady+0xaa>
2ffc5ac6:	e033      	b.n	2ffc5b30 <HAL_I2C_IsDeviceReady+0x10c>
    if (Timeout != HAL_MAX_DELAY)
2ffc5ac8:	f1b9 3fff 	cmp.w	r9, #4294967295	@ 0xffffffff
2ffc5acc:	d120      	bne.n	2ffc5b10 <HAL_I2C_IsDeviceReady+0xec>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc5ace:	6993      	ldr	r3, [r2, #24]
2ffc5ad0:	f013 0a20 	ands.w	sl, r3, #32
2ffc5ad4:	d0f8      	beq.n	2ffc5ac8 <HAL_I2C_IsDeviceReady+0xa4>
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2ffc5ad6:	2310      	movs	r3, #16
2ffc5ad8:	61d3      	str	r3, [r2, #28]
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2ffc5ada:	2320      	movs	r3, #32
2ffc5adc:	61d3      	str	r3, [r2, #28]
      if (I2C_Trials == Trials)
2ffc5ade:	9b01      	ldr	r3, [sp, #4]
2ffc5ae0:	42bb      	cmp	r3, r7
2ffc5ae2:	d032      	beq.n	2ffc5b4a <HAL_I2C_IsDeviceReady+0x126>
      I2C_Trials++;
2ffc5ae4:	9b01      	ldr	r3, [sp, #4]
2ffc5ae6:	3301      	adds	r3, #1
2ffc5ae8:	9301      	str	r3, [sp, #4]
    } while (I2C_Trials < Trials);
2ffc5aea:	9b01      	ldr	r3, [sp, #4]
2ffc5aec:	42bb      	cmp	r3, r7
2ffc5aee:	d3b9      	bcc.n	2ffc5a64 <HAL_I2C_IsDeviceReady+0x40>
    hi2c->State = HAL_I2C_STATE_READY;
2ffc5af0:	2320      	movs	r3, #32
2ffc5af2:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc5af6:	6c63      	ldr	r3, [r4, #68]	@ 0x44
2ffc5af8:	f043 0320 	orr.w	r3, r3, #32
2ffc5afc:	6463      	str	r3, [r4, #68]	@ 0x44
        __HAL_UNLOCK(hi2c);
2ffc5afe:	2300      	movs	r3, #0
            return HAL_ERROR;
2ffc5b00:	2001      	movs	r0, #1
        __HAL_UNLOCK(hi2c);
2ffc5b02:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
2ffc5b06:	e000      	b.n	2ffc5b0a <HAL_I2C_IsDeviceReady+0xe6>
      return HAL_BUSY;
2ffc5b08:	2002      	movs	r0, #2
}
2ffc5b0a:	b002      	add	sp, #8
2ffc5b0c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2ffc5b10:	f7fd fd1c 	bl	2ffc354c <HAL_GetTick>
2ffc5b14:	fab9 f389 	clz	r3, r9
2ffc5b18:	1b40      	subs	r0, r0, r5
2ffc5b1a:	095b      	lsrs	r3, r3, #5
2ffc5b1c:	4581      	cmp	r9, r0
2ffc5b1e:	bf38      	it	cc
2ffc5b20:	f043 0301 	orrcc.w	r3, r3, #1
2ffc5b24:	bb6b      	cbnz	r3, 2ffc5b82 <HAL_I2C_IsDeviceReady+0x15e>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc5b26:	6822      	ldr	r2, [r4, #0]
2ffc5b28:	e7d1      	b.n	2ffc5ace <HAL_I2C_IsDeviceReady+0xaa>
    if (Timeout != HAL_MAX_DELAY)
2ffc5b2a:	f1b9 3fff 	cmp.w	r9, #4294967295	@ 0xffffffff
2ffc5b2e:	d131      	bne.n	2ffc5b94 <HAL_I2C_IsDeviceReady+0x170>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc5b30:	6986      	ldr	r6, [r0, #24]
2ffc5b32:	f016 0620 	ands.w	r6, r6, #32
2ffc5b36:	d0f8      	beq.n	2ffc5b2a <HAL_I2C_IsDeviceReady+0x106>
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2ffc5b38:	2220      	movs	r2, #32
        __HAL_UNLOCK(hi2c);
2ffc5b3a:	2300      	movs	r3, #0
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2ffc5b3c:	61c2      	str	r2, [r0, #28]
        return HAL_OK;
2ffc5b3e:	4618      	mov	r0, r3
        hi2c->State = HAL_I2C_STATE_READY;
2ffc5b40:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
        __HAL_UNLOCK(hi2c);
2ffc5b44:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
        return HAL_OK;
2ffc5b48:	e7df      	b.n	2ffc5b0a <HAL_I2C_IsDeviceReady+0xe6>
        hi2c->Instance->CR2 |= I2C_CR2_STOP;
2ffc5b4a:	6853      	ldr	r3, [r2, #4]
2ffc5b4c:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
2ffc5b50:	6053      	str	r3, [r2, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc5b52:	e002      	b.n	2ffc5b5a <HAL_I2C_IsDeviceReady+0x136>
    if (Timeout != HAL_MAX_DELAY)
2ffc5b54:	f1b9 3fff 	cmp.w	r9, #4294967295	@ 0xffffffff
2ffc5b58:	d106      	bne.n	2ffc5b68 <HAL_I2C_IsDeviceReady+0x144>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc5b5a:	6993      	ldr	r3, [r2, #24]
2ffc5b5c:	f013 0a20 	ands.w	sl, r3, #32
2ffc5b60:	d0f8      	beq.n	2ffc5b54 <HAL_I2C_IsDeviceReady+0x130>
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2ffc5b62:	2320      	movs	r3, #32
2ffc5b64:	61d3      	str	r3, [r2, #28]
2ffc5b66:	e7bd      	b.n	2ffc5ae4 <HAL_I2C_IsDeviceReady+0xc0>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2ffc5b68:	f7fd fcf0 	bl	2ffc354c <HAL_GetTick>
2ffc5b6c:	fab9 f389 	clz	r3, r9
2ffc5b70:	1b42      	subs	r2, r0, r5
2ffc5b72:	095b      	lsrs	r3, r3, #5
2ffc5b74:	4591      	cmp	r9, r2
2ffc5b76:	bf38      	it	cc
2ffc5b78:	f043 0301 	orrcc.w	r3, r3, #1
2ffc5b7c:	b90b      	cbnz	r3, 2ffc5b82 <HAL_I2C_IsDeviceReady+0x15e>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc5b7e:	6822      	ldr	r2, [r4, #0]
2ffc5b80:	e7eb      	b.n	2ffc5b5a <HAL_I2C_IsDeviceReady+0x136>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc5b82:	6c63      	ldr	r3, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2ffc5b84:	2220      	movs	r2, #32
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc5b86:	4313      	orrs	r3, r2
2ffc5b88:	6463      	str	r3, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2ffc5b8a:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2ffc5b8e:	f884 a042 	strb.w	sl, [r4, #66]	@ 0x42
        return HAL_ERROR;
2ffc5b92:	e7b4      	b.n	2ffc5afe <HAL_I2C_IsDeviceReady+0xda>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2ffc5b94:	f7fd fcda 	bl	2ffc354c <HAL_GetTick>
2ffc5b98:	fab9 f389 	clz	r3, r9
2ffc5b9c:	1b42      	subs	r2, r0, r5
2ffc5b9e:	095b      	lsrs	r3, r3, #5
2ffc5ba0:	4591      	cmp	r9, r2
2ffc5ba2:	bf38      	it	cc
2ffc5ba4:	f043 0301 	orrcc.w	r3, r3, #1
2ffc5ba8:	b90b      	cbnz	r3, 2ffc5bae <HAL_I2C_IsDeviceReady+0x18a>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2ffc5baa:	6820      	ldr	r0, [r4, #0]
2ffc5bac:	e7c0      	b.n	2ffc5b30 <HAL_I2C_IsDeviceReady+0x10c>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc5bae:	6c63      	ldr	r3, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2ffc5bb0:	2220      	movs	r2, #32
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2ffc5bb2:	4313      	orrs	r3, r2
2ffc5bb4:	6463      	str	r3, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2ffc5bb6:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2ffc5bba:	f884 6042 	strb.w	r6, [r4, #66]	@ 0x42
        return HAL_ERROR;
2ffc5bbe:	e79e      	b.n	2ffc5afe <HAL_I2C_IsDeviceReady+0xda>

2ffc5bc0 <HAL_I2C_GetState>:
  return hi2c->State;
2ffc5bc0:	f890 0041 	ldrb.w	r0, [r0, #65]	@ 0x41
}
2ffc5bc4:	4770      	bx	lr
2ffc5bc6:	bf00      	nop

2ffc5bc8 <HAL_RCC_DeInit>:
  *            - LSI, LSE and RTC clock
  *            - HSECSS and LSECSS
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_DeInit(void)
{
2ffc5bc8:	b570      	push	{r4, r5, r6, lr}
  uint32_t tickstart;

  /* Set HSION bit to enable HSI oscillator */
  SET_BIT(RCC->OCENSETR, RCC_OCENSETR_HSION);
2ffc5bca:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
2ffc5bce:	68e3      	ldr	r3, [r4, #12]
2ffc5bd0:	f043 0301 	orr.w	r3, r3, #1
2ffc5bd4:	60e3      	str	r3, [r4, #12]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
2ffc5bd6:	f7fd fcb9 	bl	2ffc354c <HAL_GetTick>
2ffc5bda:	4605      	mov	r5, r0

  /* Wait till HSI is ready */
  while ((RCC->OCRDYR & RCC_OCRDYR_HSIRDY) == 0U)
2ffc5bdc:	e005      	b.n	2ffc5bea <HAL_RCC_DeInit+0x22>
  {
    if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
2ffc5bde:	f7fd fcb5 	bl	2ffc354c <HAL_GetTick>
2ffc5be2:	1b40      	subs	r0, r0, r5
2ffc5be4:	2864      	cmp	r0, #100	@ 0x64
2ffc5be6:	f200 8158 	bhi.w	2ffc5e9a <HAL_RCC_DeInit+0x2d2>
  while ((RCC->OCRDYR & RCC_OCRDYR_HSIRDY) == 0U)
2ffc5bea:	f8d4 3808 	ldr.w	r3, [r4, #2056]	@ 0x808
2ffc5bee:	07de      	lsls	r6, r3, #31
2ffc5bf0:	d5f5      	bpl.n	2ffc5bde <HAL_RCC_DeInit+0x16>
      return HAL_TIMEOUT;
    }
  }

  /* Reset MCO1 Configuration Register */
  CLEAR_REG(RCC->MCO1CFGR);
2ffc5bf2:	2300      	movs	r3, #0

  /* Disable PLL1 */
  CLEAR_BIT(RCC->PLL1CR, RCC_PLL1CR_PLLON);

  /* Wait till PLL is disabled */
  while ((RCC->PLL1CR & RCC_PLL1CR_PLL1RDY) != 0U)
2ffc5bf4:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
  CLEAR_REG(RCC->MCO1CFGR);
2ffc5bf8:	f8c4 3800 	str.w	r3, [r4, #2048]	@ 0x800
  CLEAR_REG(RCC->MCO2CFGR);
2ffc5bfc:	f8c4 3804 	str.w	r3, [r4, #2052]	@ 0x804
  MODIFY_REG(RCC->MPCKSELR, (RCC_MPCKSELR_MPUSRC), 0U);
2ffc5c00:	6a23      	ldr	r3, [r4, #32]
2ffc5c02:	f023 0303 	bic.w	r3, r3, #3
2ffc5c06:	6223      	str	r3, [r4, #32]
  MODIFY_REG(RCC->ASSCKSELR, (RCC_ASSCKSELR_AXISSRC), 0U);
2ffc5c08:	6a63      	ldr	r3, [r4, #36]	@ 0x24
2ffc5c0a:	f023 0307 	bic.w	r3, r3, #7
2ffc5c0e:	6263      	str	r3, [r4, #36]	@ 0x24
  MODIFY_REG(RCC->MSSCKSELR, (RCC_MSSCKSELR_MCUSSRC), 0U);
2ffc5c10:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
2ffc5c12:	f023 0303 	bic.w	r3, r3, #3
2ffc5c16:	64a3      	str	r3, [r4, #72]	@ 0x48
  MODIFY_REG(RCC->MPCKDIVR, (RCC_MPCKDIVR_MPUDIV), RCC_MPCKDIVR_MPUDIV_0);
2ffc5c18:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
2ffc5c1a:	f023 0307 	bic.w	r3, r3, #7
2ffc5c1e:	f043 0301 	orr.w	r3, r3, #1
2ffc5c22:	62e3      	str	r3, [r4, #44]	@ 0x2c
  MODIFY_REG(RCC->AXIDIVR, (RCC_AXIDIVR_AXIDIV), 0U);
2ffc5c24:	6b23      	ldr	r3, [r4, #48]	@ 0x30
2ffc5c26:	f023 0307 	bic.w	r3, r3, #7
2ffc5c2a:	6323      	str	r3, [r4, #48]	@ 0x30
  MODIFY_REG(RCC->APB4DIVR, (RCC_APB4DIVR_APB4DIV), 0U);
2ffc5c2c:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
2ffc5c2e:	f023 0307 	bic.w	r3, r3, #7
2ffc5c32:	63e3      	str	r3, [r4, #60]	@ 0x3c
  MODIFY_REG(RCC->APB5DIVR, (RCC_APB5DIVR_APB5DIV), 0U);
2ffc5c34:	6c23      	ldr	r3, [r4, #64]	@ 0x40
2ffc5c36:	f023 0307 	bic.w	r3, r3, #7
2ffc5c3a:	6423      	str	r3, [r4, #64]	@ 0x40
  MODIFY_REG(RCC->MCUDIVR, (RCC_MCUDIVR_MCUDIV), 0U);
2ffc5c3c:	f8d4 3830 	ldr.w	r3, [r4, #2096]	@ 0x830
2ffc5c40:	f023 030f 	bic.w	r3, r3, #15
2ffc5c44:	f8c4 3830 	str.w	r3, [r4, #2096]	@ 0x830
  MODIFY_REG(RCC->APB1DIVR, (RCC_APB1DIVR_APB1DIV), 0U);
2ffc5c48:	f8d4 3834 	ldr.w	r3, [r4, #2100]	@ 0x834
2ffc5c4c:	f023 0307 	bic.w	r3, r3, #7
2ffc5c50:	f8c4 3834 	str.w	r3, [r4, #2100]	@ 0x834
  MODIFY_REG(RCC->APB2DIVR, (RCC_APB2DIVR_APB2DIV), 0U);
2ffc5c54:	f8d4 3838 	ldr.w	r3, [r4, #2104]	@ 0x838
2ffc5c58:	f023 0307 	bic.w	r3, r3, #7
2ffc5c5c:	f8c4 3838 	str.w	r3, [r4, #2104]	@ 0x838
  MODIFY_REG(RCC->APB3DIVR, (RCC_APB3DIVR_APB3DIV), 0U);
2ffc5c60:	f8d4 383c 	ldr.w	r3, [r4, #2108]	@ 0x83c
2ffc5c64:	f023 0307 	bic.w	r3, r3, #7
2ffc5c68:	f8c4 383c 	str.w	r3, [r4, #2108]	@ 0x83c
  CLEAR_BIT(RCC->PLL1CR, RCC_PLL1CR_DIVPEN | RCC_PLL1CR_DIVQEN |
2ffc5c6c:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
2ffc5c70:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
2ffc5c74:	f8c4 3080 	str.w	r3, [r4, #128]	@ 0x80
  tickstart = HAL_GetTick();
2ffc5c78:	f7fd fc68 	bl	2ffc354c <HAL_GetTick>
  CLEAR_BIT(RCC->PLL1CR, RCC_PLL1CR_PLLON);
2ffc5c7c:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
  tickstart = HAL_GetTick();
2ffc5c80:	4606      	mov	r6, r0
  CLEAR_BIT(RCC->PLL1CR, RCC_PLL1CR_PLLON);
2ffc5c82:	f023 0301 	bic.w	r3, r3, #1
2ffc5c86:	f8c4 3080 	str.w	r3, [r4, #128]	@ 0x80
  while ((RCC->PLL1CR & RCC_PLL1CR_PLL1RDY) != 0U)
2ffc5c8a:	e005      	b.n	2ffc5c98 <HAL_RCC_DeInit+0xd0>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc5c8c:	f7fd fc5e 	bl	2ffc354c <HAL_GetTick>
2ffc5c90:	1b80      	subs	r0, r0, r6
2ffc5c92:	2864      	cmp	r0, #100	@ 0x64
2ffc5c94:	f200 8101 	bhi.w	2ffc5e9a <HAL_RCC_DeInit+0x2d2>
  while ((RCC->PLL1CR & RCC_PLL1CR_PLL1RDY) != 0U)
2ffc5c98:	f8d5 3080 	ldr.w	r3, [r5, #128]	@ 0x80
2ffc5c9c:	0798      	lsls	r0, r3, #30
2ffc5c9e:	d4f5      	bmi.n	2ffc5c8c <HAL_RCC_DeInit+0xc4>
      return HAL_TIMEOUT;
    }
  }

  /* Clear remaining SSCG_CTRL bit */
  CLEAR_BIT(RCC->PLL1CR, RCC_PLL1CR_SSCG_CTRL);
2ffc5ca0:	f8d5 3080 	ldr.w	r3, [r5, #128]	@ 0x80

  /* Disable PLL2 */
  CLEAR_BIT(RCC->PLL2CR, RCC_PLL2CR_PLLON);

  /* Wait till PLL is disabled */
  while ((RCC->PLL2CR & RCC_PLL2CR_PLL2RDY) != 0U)
2ffc5ca4:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
  CLEAR_BIT(RCC->PLL1CR, RCC_PLL1CR_SSCG_CTRL);
2ffc5ca8:	f023 0304 	bic.w	r3, r3, #4
2ffc5cac:	f8c5 3080 	str.w	r3, [r5, #128]	@ 0x80
  CLEAR_BIT(RCC->PLL2CR, RCC_PLL2CR_DIVPEN | RCC_PLL2CR_DIVQEN |
2ffc5cb0:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
2ffc5cb4:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
2ffc5cb8:	f8c5 3094 	str.w	r3, [r5, #148]	@ 0x94
  tickstart = HAL_GetTick();
2ffc5cbc:	f7fd fc46 	bl	2ffc354c <HAL_GetTick>
  CLEAR_BIT(RCC->PLL2CR, RCC_PLL2CR_PLLON);
2ffc5cc0:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
  tickstart = HAL_GetTick();
2ffc5cc4:	4606      	mov	r6, r0
  CLEAR_BIT(RCC->PLL2CR, RCC_PLL2CR_PLLON);
2ffc5cc6:	f023 0301 	bic.w	r3, r3, #1
2ffc5cca:	f8c5 3094 	str.w	r3, [r5, #148]	@ 0x94
  while ((RCC->PLL2CR & RCC_PLL2CR_PLL2RDY) != 0U)
2ffc5cce:	e005      	b.n	2ffc5cdc <HAL_RCC_DeInit+0x114>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc5cd0:	f7fd fc3c 	bl	2ffc354c <HAL_GetTick>
2ffc5cd4:	1b80      	subs	r0, r0, r6
2ffc5cd6:	2864      	cmp	r0, #100	@ 0x64
2ffc5cd8:	f200 80df 	bhi.w	2ffc5e9a <HAL_RCC_DeInit+0x2d2>
  while ((RCC->PLL2CR & RCC_PLL2CR_PLL2RDY) != 0U)
2ffc5cdc:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94
2ffc5ce0:	0799      	lsls	r1, r3, #30
2ffc5ce2:	d4f5      	bmi.n	2ffc5cd0 <HAL_RCC_DeInit+0x108>
      return HAL_TIMEOUT;
    }
  }

  /* Clear remaining SSCG_CTRL bit */
  CLEAR_BIT(RCC->PLL2CR, RCC_PLL2CR_SSCG_CTRL);
2ffc5ce4:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94

  /* Disable PLL3 */
  CLEAR_BIT(RCC->PLL3CR, RCC_PLL3CR_PLLON);

  /* Wait till PLL is disabled */
  while ((RCC->PLL3CR & RCC_PLL3CR_PLL3RDY) != 0U)
2ffc5ce8:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
  CLEAR_BIT(RCC->PLL2CR, RCC_PLL2CR_SSCG_CTRL);
2ffc5cec:	f023 0304 	bic.w	r3, r3, #4
2ffc5cf0:	f8c4 3094 	str.w	r3, [r4, #148]	@ 0x94
  CLEAR_BIT(RCC->PLL3CR, RCC_PLL3CR_DIVPEN | RCC_PLL3CR_DIVQEN |
2ffc5cf4:	f8d4 3880 	ldr.w	r3, [r4, #2176]	@ 0x880
2ffc5cf8:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
2ffc5cfc:	f8c4 3880 	str.w	r3, [r4, #2176]	@ 0x880
  tickstart = HAL_GetTick();
2ffc5d00:	f7fd fc24 	bl	2ffc354c <HAL_GetTick>
  CLEAR_BIT(RCC->PLL3CR, RCC_PLL3CR_PLLON);
2ffc5d04:	f8d4 3880 	ldr.w	r3, [r4, #2176]	@ 0x880
  tickstart = HAL_GetTick();
2ffc5d08:	4606      	mov	r6, r0
  CLEAR_BIT(RCC->PLL3CR, RCC_PLL3CR_PLLON);
2ffc5d0a:	f023 0301 	bic.w	r3, r3, #1
2ffc5d0e:	f8c4 3880 	str.w	r3, [r4, #2176]	@ 0x880
  while ((RCC->PLL3CR & RCC_PLL3CR_PLL3RDY) != 0U)
2ffc5d12:	e005      	b.n	2ffc5d20 <HAL_RCC_DeInit+0x158>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc5d14:	f7fd fc1a 	bl	2ffc354c <HAL_GetTick>
2ffc5d18:	1b80      	subs	r0, r0, r6
2ffc5d1a:	2864      	cmp	r0, #100	@ 0x64
2ffc5d1c:	f200 80bd 	bhi.w	2ffc5e9a <HAL_RCC_DeInit+0x2d2>
  while ((RCC->PLL3CR & RCC_PLL3CR_PLL3RDY) != 0U)
2ffc5d20:	f8d5 3880 	ldr.w	r3, [r5, #2176]	@ 0x880
2ffc5d24:	079a      	lsls	r2, r3, #30
2ffc5d26:	d4f5      	bmi.n	2ffc5d14 <HAL_RCC_DeInit+0x14c>
      return HAL_TIMEOUT;
    }
  }

  /* Clear remaining SSCG_CTRL bit */
  CLEAR_BIT(RCC->PLL3CR, RCC_PLL3CR_SSCG_CTRL);
2ffc5d28:	f8d5 3880 	ldr.w	r3, [r5, #2176]	@ 0x880

  /* Disable PLL4 */
  CLEAR_BIT(RCC->PLL4CR, RCC_PLL4CR_PLLON);

  /* Wait till PLL is disabled */
  while ((RCC->PLL4CR & RCC_PLL4CR_PLL4RDY) != 0U)
2ffc5d2c:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
  CLEAR_BIT(RCC->PLL3CR, RCC_PLL3CR_SSCG_CTRL);
2ffc5d30:	f023 0304 	bic.w	r3, r3, #4
2ffc5d34:	f8c5 3880 	str.w	r3, [r5, #2176]	@ 0x880
  CLEAR_BIT(RCC->PLL4CR, RCC_PLL4CR_DIVPEN | RCC_PLL4CR_DIVQEN |
2ffc5d38:	f8d5 3894 	ldr.w	r3, [r5, #2196]	@ 0x894
2ffc5d3c:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
2ffc5d40:	f8c5 3894 	str.w	r3, [r5, #2196]	@ 0x894
  tickstart = HAL_GetTick();
2ffc5d44:	f7fd fc02 	bl	2ffc354c <HAL_GetTick>
  CLEAR_BIT(RCC->PLL4CR, RCC_PLL4CR_PLLON);
2ffc5d48:	f8d5 3894 	ldr.w	r3, [r5, #2196]	@ 0x894
  tickstart = HAL_GetTick();
2ffc5d4c:	4606      	mov	r6, r0
  CLEAR_BIT(RCC->PLL4CR, RCC_PLL4CR_PLLON);
2ffc5d4e:	f023 0301 	bic.w	r3, r3, #1
2ffc5d52:	f8c5 3894 	str.w	r3, [r5, #2196]	@ 0x894
  while ((RCC->PLL4CR & RCC_PLL4CR_PLL4RDY) != 0U)
2ffc5d56:	e005      	b.n	2ffc5d64 <HAL_RCC_DeInit+0x19c>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc5d58:	f7fd fbf8 	bl	2ffc354c <HAL_GetTick>
2ffc5d5c:	1b80      	subs	r0, r0, r6
2ffc5d5e:	2864      	cmp	r0, #100	@ 0x64
2ffc5d60:	f200 809b 	bhi.w	2ffc5e9a <HAL_RCC_DeInit+0x2d2>
  while ((RCC->PLL4CR & RCC_PLL4CR_PLL4RDY) != 0U)
2ffc5d64:	f8d4 3894 	ldr.w	r3, [r4, #2196]	@ 0x894
2ffc5d68:	f013 0302 	ands.w	r3, r3, #2
2ffc5d6c:	d1f4      	bne.n	2ffc5d58 <HAL_RCC_DeInit+0x190>
      return HAL_TIMEOUT;
    }
  }

  /* Clear remaining SSCG_CTRL bit */
  CLEAR_BIT(RCC->PLL4CR, RCC_PLL4CR_SSCG_CTRL);
2ffc5d6e:	f8d4 1894 	ldr.w	r1, [r4, #2196]	@ 0x894

  /* Reset PLL4 Ref. Clock Selection Register */
  MODIFY_REG(RCC->RCK4SELR, (RCC_RCK4SELR_PLL4SRC), 0U);

  /* Reset RCC PLL1 Configuration Register 1 */
  WRITE_REG(RCC->PLL1CFGR1, 0x00010031U);
2ffc5d72:	2231      	movs	r2, #49	@ 0x31
2ffc5d74:	f2c0 0201 	movt	r2, #1

  /* Reset RCC PLL1 Configuration Register 2 */
  WRITE_REG(RCC->PLL1CFGR2, 0x00010100U);
2ffc5d78:	f44f 7080 	mov.w	r0, #256	@ 0x100
  CLEAR_BIT(RCC->PLL4CR, RCC_PLL4CR_SSCG_CTRL);
2ffc5d7c:	f021 0104 	bic.w	r1, r1, #4

  /* Get Start Tick*/
  tickstart = HAL_GetTick();

  /* Wait till HSIDIV is ready */
  while ((RCC->OCRDYR & RCC_OCRDYR_HSIDIVRDY) == 0U)
2ffc5d80:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
  CLEAR_BIT(RCC->PLL4CR, RCC_PLL4CR_SSCG_CTRL);
2ffc5d84:	f8c4 1894 	str.w	r1, [r4, #2196]	@ 0x894
  MODIFY_REG(RCC->RCK12SELR, (RCC_RCK12SELR_PLL12SRC), 0U);
2ffc5d88:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
  WRITE_REG(RCC->PLL1CFGR2, 0x00010100U);
2ffc5d8a:	f2c0 0001 	movt	r0, #1
  MODIFY_REG(RCC->RCK12SELR, (RCC_RCK12SELR_PLL12SRC), 0U);
2ffc5d8e:	f021 0103 	bic.w	r1, r1, #3
2ffc5d92:	62a1      	str	r1, [r4, #40]	@ 0x28
  MODIFY_REG(RCC->RCK3SELR, (RCC_RCK3SELR_PLL3SRC), 0U);
2ffc5d94:	f8d4 1820 	ldr.w	r1, [r4, #2080]	@ 0x820
2ffc5d98:	f021 0103 	bic.w	r1, r1, #3
2ffc5d9c:	f8c4 1820 	str.w	r1, [r4, #2080]	@ 0x820
  MODIFY_REG(RCC->RCK4SELR, (RCC_RCK4SELR_PLL4SRC), 0U);
2ffc5da0:	f8d4 1824 	ldr.w	r1, [r4, #2084]	@ 0x824
2ffc5da4:	f021 0103 	bic.w	r1, r1, #3
2ffc5da8:	f8c4 1824 	str.w	r1, [r4, #2084]	@ 0x824
  WRITE_REG(RCC->PLL2CFGR1, 0x00010063U);
2ffc5dac:	2163      	movs	r1, #99	@ 0x63
2ffc5dae:	f2c0 0101 	movt	r1, #1
  WRITE_REG(RCC->PLL1CFGR1, 0x00010031U);
2ffc5db2:	f8c4 2084 	str.w	r2, [r4, #132]	@ 0x84
  WRITE_REG(RCC->PLL1CFGR2, 0x00010100U);
2ffc5db6:	f8c4 0088 	str.w	r0, [r4, #136]	@ 0x88
  CLEAR_REG(RCC->PLL1FRACR);
2ffc5dba:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
  CLEAR_REG(RCC->PLL1CSGR);
2ffc5dbe:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
  WRITE_REG(RCC->PLL2CFGR1, 0x00010063U);
2ffc5dc2:	f8c4 1098 	str.w	r1, [r4, #152]	@ 0x98
  WRITE_REG(RCC->PLL2CFGR2, 0x00010101U);
2ffc5dc6:	f240 1101 	movw	r1, #257	@ 0x101
2ffc5dca:	f2c0 0101 	movt	r1, #1
2ffc5dce:	f8c4 109c 	str.w	r1, [r4, #156]	@ 0x9c
  CLEAR_REG(RCC->PLL2FRACR);
2ffc5dd2:	f8c4 30a0 	str.w	r3, [r4, #160]	@ 0xa0
  CLEAR_REG(RCC->PLL2CSGR);
2ffc5dd6:	f8c4 30a4 	str.w	r3, [r4, #164]	@ 0xa4
  WRITE_REG(RCC->PLL3CFGR1, 0x00010031U);
2ffc5dda:	f8c4 2884 	str.w	r2, [r4, #2180]	@ 0x884
  WRITE_REG(RCC->PLL3CFGR2, 0x00010101U);
2ffc5dde:	f8c4 1888 	str.w	r1, [r4, #2184]	@ 0x888
  CLEAR_REG(RCC->PLL3FRACR);
2ffc5de2:	f8c4 388c 	str.w	r3, [r4, #2188]	@ 0x88c
  CLEAR_REG(RCC->PLL3CSGR);
2ffc5de6:	f8c4 3890 	str.w	r3, [r4, #2192]	@ 0x890
  WRITE_REG(RCC->PLL4CFGR1, 0x00010031U);
2ffc5dea:	f8c4 2898 	str.w	r2, [r4, #2200]	@ 0x898
  WRITE_REG(RCC->PLL4CFGR2, 0x00000000U);
2ffc5dee:	f8c4 389c 	str.w	r3, [r4, #2204]	@ 0x89c
  CLEAR_REG(RCC->PLL4FRACR);
2ffc5df2:	f8c4 38a0 	str.w	r3, [r4, #2208]	@ 0x8a0
  CLEAR_REG(RCC->PLL4CSGR);
2ffc5df6:	f8c4 38a4 	str.w	r3, [r4, #2212]	@ 0x8a4
  CLEAR_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV);
2ffc5dfa:	69a3      	ldr	r3, [r4, #24]
2ffc5dfc:	f023 0303 	bic.w	r3, r3, #3
2ffc5e00:	61a3      	str	r3, [r4, #24]
  tickstart = HAL_GetTick();
2ffc5e02:	f7fd fba3 	bl	2ffc354c <HAL_GetTick>
2ffc5e06:	4604      	mov	r4, r0
  while ((RCC->OCRDYR & RCC_OCRDYR_HSIDIVRDY) == 0U)
2ffc5e08:	e004      	b.n	2ffc5e14 <HAL_RCC_DeInit+0x24c>
  {
    if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
2ffc5e0a:	f7fd fb9f 	bl	2ffc354c <HAL_GetTick>
2ffc5e0e:	1b00      	subs	r0, r0, r4
2ffc5e10:	2864      	cmp	r0, #100	@ 0x64
2ffc5e12:	d842      	bhi.n	2ffc5e9a <HAL_RCC_DeInit+0x2d2>
  while ((RCC->OCRDYR & RCC_OCRDYR_HSIDIVRDY) == 0U)
2ffc5e14:	f8d5 3808 	ldr.w	r3, [r5, #2056]	@ 0x808
2ffc5e18:	075b      	lsls	r3, r3, #29
2ffc5e1a:	d5f6      	bpl.n	2ffc5e0a <HAL_RCC_DeInit+0x242>
      return HAL_TIMEOUT;
    }
  }

  /* Reset HSITRIM value */
  CLEAR_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM);
2ffc5e1c:	69ab      	ldr	r3, [r5, #24]

  /* Reset the Oscillator Enable Control registers */
  WRITE_REG(RCC->OCENCLRR, RCC_OCENCLRR_HSIKERON | RCC_OCENCLRR_CSION |
2ffc5e1e:	f240 71b2 	movw	r1, #1970	@ 0x7b2
  /* Reset CSITRIM value */
  CLEAR_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM);

#ifdef CORE_CA7
  /* Reset RCC Clock Source Interrupt Enable Register */
  CLEAR_BIT(RCC->MP_CIER, (RCC_MP_CIER_LSIRDYIE | RCC_MP_CIER_LSERDYIE |
2ffc5e22:	f24f 02e0 	movw	r2, #61664	@ 0xf0e0

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HSI_VALUE;

  /* Adapt Systick interrupt period */
  if (HAL_InitTick(uwTickPrio) != HAL_OK)
2ffc5e26:	f241 7018 	movw	r0, #5912	@ 0x1718
  CLEAR_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM);
2ffc5e2a:	f423 43fe 	bic.w	r3, r3, #32512	@ 0x7f00
2ffc5e2e:	61ab      	str	r3, [r5, #24]
  SET_BIT(RCC->MP_CIFR, (RCC_MP_CIFR_LSIRDYF | RCC_MP_CIFR_LSERDYF |
2ffc5e30:	f640 731f 	movw	r3, #3871	@ 0xf1f
  WRITE_REG(RCC->OCENCLRR, RCC_OCENCLRR_HSIKERON | RCC_OCENCLRR_CSION |
2ffc5e34:	6129      	str	r1, [r5, #16]
  CLEAR_BIT(RCC->RDLSICR, RCC_RDLSICR_LSION);
2ffc5e36:	f8d5 1144 	ldr.w	r1, [r5, #324]	@ 0x144
  CLEAR_BIT(RCC->MP_CIER, (RCC_MP_CIER_LSIRDYIE | RCC_MP_CIER_LSERDYIE |
2ffc5e3a:	f6cf 72ee 	movt	r2, #65518	@ 0xffee
  CLEAR_BIT(RCC->RDLSICR, RCC_RDLSICR_LSION);
2ffc5e3e:	f021 0101 	bic.w	r1, r1, #1
2ffc5e42:	f8c5 1144 	str.w	r1, [r5, #324]	@ 0x144
  CLEAR_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM);
2ffc5e46:	69e9      	ldr	r1, [r5, #28]
  SET_BIT(RCC->MP_CIFR, (RCC_MP_CIFR_LSIRDYF | RCC_MP_CIFR_LSERDYF |
2ffc5e48:	f2c0 0311 	movt	r3, #17
  CLEAR_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM);
2ffc5e4c:	f421 51f8 	bic.w	r1, r1, #7936	@ 0x1f00
2ffc5e50:	61e9      	str	r1, [r5, #28]
  CLEAR_BIT(RCC->MP_CIER, (RCC_MP_CIER_LSIRDYIE | RCC_MP_CIER_LSERDYIE |
2ffc5e52:	f8d5 1414 	ldr.w	r1, [r5, #1044]	@ 0x414
  if (HAL_InitTick(uwTickPrio) != HAL_OK)
2ffc5e56:	f6c2 70fd 	movt	r0, #12285	@ 0x2ffd
  CLEAR_BIT(RCC->MP_CIER, (RCC_MP_CIER_LSIRDYIE | RCC_MP_CIER_LSERDYIE |
2ffc5e5a:	400a      	ands	r2, r1
  SystemCoreClock = HSI_VALUE;
2ffc5e5c:	f241 7110 	movw	r1, #5904	@ 0x1710
  CLEAR_BIT(RCC->MP_CIER, (RCC_MP_CIER_LSIRDYIE | RCC_MP_CIER_LSERDYIE |
2ffc5e60:	f8c5 2414 	str.w	r2, [r5, #1044]	@ 0x414
  SET_BIT(RCC->MP_CIFR, (RCC_MP_CIFR_LSIRDYF | RCC_MP_CIFR_LSERDYF |
2ffc5e64:	f8d5 2418 	ldr.w	r2, [r5, #1048]	@ 0x418
  SystemCoreClock = HSI_VALUE;
2ffc5e68:	f6c2 71fd 	movt	r1, #12285	@ 0x2ffd
  SET_BIT(RCC->MP_CIFR, (RCC_MP_CIFR_LSIRDYF | RCC_MP_CIFR_LSERDYF |
2ffc5e6c:	4313      	orrs	r3, r2
  SystemCoreClock = HSI_VALUE;
2ffc5e6e:	f44f 4210 	mov.w	r2, #36864	@ 0x9000
  SET_BIT(RCC->MP_CIFR, (RCC_MP_CIFR_LSIRDYF | RCC_MP_CIFR_LSERDYF |
2ffc5e72:	f8c5 3418 	str.w	r3, [r5, #1048]	@ 0x418
  SET_BIT(RCC->MP_RSTSCLRR, (RCC_MP_RSTSCLRR_MPUP1RSTF |
2ffc5e76:	f8d5 3408 	ldr.w	r3, [r5, #1032]	@ 0x408
  SystemCoreClock = HSI_VALUE;
2ffc5e7a:	f2c0 32d0 	movt	r2, #976	@ 0x3d0
  SET_BIT(RCC->MP_RSTSCLRR, (RCC_MP_RSTSCLRR_MPUP1RSTF |
2ffc5e7e:	f443 43f7 	orr.w	r3, r3, #31616	@ 0x7b80
2ffc5e82:	f043 035f 	orr.w	r3, r3, #95	@ 0x5f
2ffc5e86:	f8c5 3408 	str.w	r3, [r5, #1032]	@ 0x408
  if (HAL_InitTick(uwTickPrio) != HAL_OK)
2ffc5e8a:	6800      	ldr	r0, [r0, #0]
  SystemCoreClock = HSI_VALUE;
2ffc5e8c:	600a      	str	r2, [r1, #0]
  if (HAL_InitTick(uwTickPrio) != HAL_OK)
2ffc5e8e:	f7fd fb2b 	bl	2ffc34e8 <HAL_InitTick>
2ffc5e92:	3800      	subs	r0, #0
2ffc5e94:	bf18      	it	ne
2ffc5e96:	2001      	movne	r0, #1
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
2ffc5e98:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_TIMEOUT;
2ffc5e9a:	2003      	movs	r0, #3
}
2ffc5e9c:	bd70      	pop	{r4, r5, r6, pc}
2ffc5e9e:	bf00      	nop

2ffc5ea0 <HAL_RCC_HSEConfig>:
  *               @arg RCC_HSE_BYPASS_DIG: HSE oscillator bypassed with external
  *                    clock using a full-swing digital signal provided to OSC_IN
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_HSEConfig(uint32_t State)
{
2ffc5ea0:	b570      	push	{r4, r5, r6, lr}

  /* Check parameter */
  assert_param(IS_RCC_HSE(State));

  /* Disable HSEON before configuring the HSE --------------*/
  WRITE_REG(RCC->OCENCLRR, RCC_OCENCLRR_HSEON);
2ffc5ea2:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
2ffc5ea6:	f44f 7380 	mov.w	r3, #256	@ 0x100
{
2ffc5eaa:	4606      	mov	r6, r0
  WRITE_REG(RCC->OCENCLRR, RCC_OCENCLRR_HSEON);
2ffc5eac:	6123      	str	r3, [r4, #16]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
2ffc5eae:	f7fd fb4d 	bl	2ffc354c <HAL_GetTick>
2ffc5eb2:	4605      	mov	r5, r0

  /* Wait till HSE is disabled */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
2ffc5eb4:	e004      	b.n	2ffc5ec0 <HAL_RCC_HSEConfig+0x20>
  {
    if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
2ffc5eb6:	f7fd fb49 	bl	2ffc354c <HAL_GetTick>
2ffc5eba:	1b40      	subs	r0, r0, r5
2ffc5ebc:	2864      	cmp	r0, #100	@ 0x64
2ffc5ebe:	d822      	bhi.n	2ffc5f06 <HAL_RCC_HSEConfig+0x66>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
2ffc5ec0:	f8d4 3808 	ldr.w	r3, [r4, #2056]	@ 0x808
2ffc5ec4:	05da      	lsls	r2, r3, #23
2ffc5ec6:	d4f6      	bmi.n	2ffc5eb6 <HAL_RCC_HSEConfig+0x16>
      return HAL_TIMEOUT;
    }
  }

  /* Clear remaining bits */
  WRITE_REG(RCC->OCENCLRR, (RCC_OCENCLRR_DIGBYP | RCC_OCENSETR_HSEBYP));
2ffc5ec8:	f44f 6390 	mov.w	r3, #1152	@ 0x480
2ffc5ecc:	6123      	str	r3, [r4, #16]

  /* Enable HSE if needed ---------------------------------------*/
  if (State != RCC_HSE_OFF)
2ffc5ece:	b1c6      	cbz	r6, 2ffc5f02 <HAL_RCC_HSEConfig+0x62>
  {
    if (State == RCC_HSE_BYPASS)
2ffc5ed0:	f5b6 6fa0 	cmp.w	r6, #1280	@ 0x500
2ffc5ed4:	d01d      	beq.n	2ffc5f12 <HAL_RCC_HSEConfig+0x72>
    {
      SET_BIT(RCC->OCENSETR, RCC_OCENSETR_HSEBYP);
    }
    else if (State == RCC_HSE_BYPASS_DIG)
2ffc5ed6:	f5b6 6fb0 	cmp.w	r6, #1408	@ 0x580
2ffc5eda:	d016      	beq.n	2ffc5f0a <HAL_RCC_HSEConfig+0x6a>
      SET_BIT(RCC->OCENSETR, RCC_OCENCLRR_DIGBYP);
      SET_BIT(RCC->OCENSETR, RCC_OCENSETR_HSEBYP);
    }

    /* Enable oscillator */
    SET_BIT(RCC->OCENSETR, RCC_OCENSETR_HSEON);
2ffc5edc:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
2ffc5ee0:	68e3      	ldr	r3, [r4, #12]
2ffc5ee2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
2ffc5ee6:	60e3      	str	r3, [r4, #12]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2ffc5ee8:	f7fd fb30 	bl	2ffc354c <HAL_GetTick>
2ffc5eec:	4605      	mov	r5, r0

    /* Wait till HSE is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
2ffc5eee:	e004      	b.n	2ffc5efa <HAL_RCC_HSEConfig+0x5a>
    {
      if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
2ffc5ef0:	f7fd fb2c 	bl	2ffc354c <HAL_GetTick>
2ffc5ef4:	1b40      	subs	r0, r0, r5
2ffc5ef6:	2864      	cmp	r0, #100	@ 0x64
2ffc5ef8:	d805      	bhi.n	2ffc5f06 <HAL_RCC_HSEConfig+0x66>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
2ffc5efa:	f8d4 3808 	ldr.w	r3, [r4, #2056]	@ 0x808
2ffc5efe:	05db      	lsls	r3, r3, #23
2ffc5f00:	d5f6      	bpl.n	2ffc5ef0 <HAL_RCC_HSEConfig+0x50>
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
2ffc5f02:	2000      	movs	r0, #0
}
2ffc5f04:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_TIMEOUT;
2ffc5f06:	2003      	movs	r0, #3
}
2ffc5f08:	bd70      	pop	{r4, r5, r6, pc}
      SET_BIT(RCC->OCENSETR, RCC_OCENCLRR_DIGBYP);
2ffc5f0a:	68e3      	ldr	r3, [r4, #12]
2ffc5f0c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
2ffc5f10:	60e3      	str	r3, [r4, #12]
      SET_BIT(RCC->OCENSETR, RCC_OCENSETR_HSEBYP);
2ffc5f12:	68e3      	ldr	r3, [r4, #12]
2ffc5f14:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
2ffc5f18:	60e3      	str	r3, [r4, #12]
2ffc5f1a:	e7df      	b.n	2ffc5edc <HAL_RCC_HSEConfig+0x3c>

2ffc5f1c <HAL_RCC_LSEConfig>:
  *            @arg RCC_LSE_BYPASS_DIG: LSE oscillator bypassed with external
  *                 clock using a full-swing digital signal provided to OSC32_IN
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_LSEConfig(uint32_t State)
{
2ffc5f1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* Check parameter */
  assert_param(IS_RCC_LSE(State));

  /* Turning LSE off is needed before configuring */
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
2ffc5f1e:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
{
2ffc5f22:	4607      	mov	r7, r0
  tickstart = HAL_GetTick();

  /* Wait till LSE is disabled */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
  {
    if ((HAL_GetTick() - tickstart) > LSE_TIMEOUT_VALUE)
2ffc5f24:	f241 3688 	movw	r6, #5000	@ 0x1388
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
2ffc5f28:	f8d4 3140 	ldr.w	r3, [r4, #320]	@ 0x140
2ffc5f2c:	f023 0301 	bic.w	r3, r3, #1
2ffc5f30:	f8c4 3140 	str.w	r3, [r4, #320]	@ 0x140
  tickstart = HAL_GetTick();
2ffc5f34:	f7fd fb0a 	bl	2ffc354c <HAL_GetTick>
2ffc5f38:	4605      	mov	r5, r0
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
2ffc5f3a:	e004      	b.n	2ffc5f46 <HAL_RCC_LSEConfig+0x2a>
    if ((HAL_GetTick() - tickstart) > LSE_TIMEOUT_VALUE)
2ffc5f3c:	f7fd fb06 	bl	2ffc354c <HAL_GetTick>
2ffc5f40:	1b40      	subs	r0, r0, r5
2ffc5f42:	42b0      	cmp	r0, r6
2ffc5f44:	d827      	bhi.n	2ffc5f96 <HAL_RCC_LSEConfig+0x7a>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
2ffc5f46:	f8d4 3140 	ldr.w	r3, [r4, #320]	@ 0x140
2ffc5f4a:	075a      	lsls	r2, r3, #29
2ffc5f4c:	d4f6      	bmi.n	2ffc5f3c <HAL_RCC_LSEConfig+0x20>
      return HAL_TIMEOUT;
    }
  }

  /* Clear remaining bits */
  CLEAR_BIT(RCC->BDCR, (RCC_BDCR_LSEBYP | RCC_BDCR_DIGBYP));
2ffc5f4e:	f8d4 3140 	ldr.w	r3, [r4, #320]	@ 0x140
2ffc5f52:	f023 030a 	bic.w	r3, r3, #10
2ffc5f56:	f8c4 3140 	str.w	r3, [r4, #320]	@ 0x140

  /* Enable LSE if needed */
  if (State != RCC_LSE_OFF)
2ffc5f5a:	b1d7      	cbz	r7, 2ffc5f92 <HAL_RCC_LSEConfig+0x76>
  {
    if (State == RCC_LSE_BYPASS)
2ffc5f5c:	2f03      	cmp	r7, #3
2ffc5f5e:	d022      	beq.n	2ffc5fa6 <HAL_RCC_LSEConfig+0x8a>
    {
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
    }
    else if (State == RCC_LSE_BYPASS_DIG)
2ffc5f60:	2f0b      	cmp	r7, #11
2ffc5f62:	d01a      	beq.n	2ffc5f9a <HAL_RCC_LSEConfig+0x7e>
      SET_BIT(RCC->BDCR, RCC_BDCR_DIGBYP);
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
    }

    /* Enable oscillator */
    SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
2ffc5f64:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
    tickstart = HAL_GetTick();

    /* Wait till LSE is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
    {
      if ((HAL_GetTick() - tickstart) > LSE_TIMEOUT_VALUE)
2ffc5f68:	f241 3688 	movw	r6, #5000	@ 0x1388
    SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
2ffc5f6c:	f8d4 3140 	ldr.w	r3, [r4, #320]	@ 0x140
2ffc5f70:	f043 0301 	orr.w	r3, r3, #1
2ffc5f74:	f8c4 3140 	str.w	r3, [r4, #320]	@ 0x140
    tickstart = HAL_GetTick();
2ffc5f78:	f7fd fae8 	bl	2ffc354c <HAL_GetTick>
2ffc5f7c:	4605      	mov	r5, r0
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
2ffc5f7e:	e004      	b.n	2ffc5f8a <HAL_RCC_LSEConfig+0x6e>
      if ((HAL_GetTick() - tickstart) > LSE_TIMEOUT_VALUE)
2ffc5f80:	f7fd fae4 	bl	2ffc354c <HAL_GetTick>
2ffc5f84:	1b40      	subs	r0, r0, r5
2ffc5f86:	42b0      	cmp	r0, r6
2ffc5f88:	d805      	bhi.n	2ffc5f96 <HAL_RCC_LSEConfig+0x7a>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
2ffc5f8a:	f8d4 3140 	ldr.w	r3, [r4, #320]	@ 0x140
2ffc5f8e:	075b      	lsls	r3, r3, #29
2ffc5f90:	d5f6      	bpl.n	2ffc5f80 <HAL_RCC_LSEConfig+0x64>
        return HAL_TIMEOUT;
      }
    }
  } /* Enable LSE if needed */

  return HAL_OK;
2ffc5f92:	2000      	movs	r0, #0
}
2ffc5f94:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      return HAL_TIMEOUT;
2ffc5f96:	2003      	movs	r0, #3
}
2ffc5f98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      SET_BIT(RCC->BDCR, RCC_BDCR_DIGBYP);
2ffc5f9a:	f8d4 3140 	ldr.w	r3, [r4, #320]	@ 0x140
2ffc5f9e:	f043 0308 	orr.w	r3, r3, #8
2ffc5fa2:	f8c4 3140 	str.w	r3, [r4, #320]	@ 0x140
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
2ffc5fa6:	f8d4 3140 	ldr.w	r3, [r4, #320]	@ 0x140
2ffc5faa:	f043 0302 	orr.w	r3, r3, #2
2ffc5fae:	f8c4 3140 	str.w	r3, [r4, #320]	@ 0x140
2ffc5fb2:	e7d7      	b.n	2ffc5f64 <HAL_RCC_LSEConfig+0x48>

2ffc5fb4 <RCC_PLL1_Config>:
{
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_RCC_PLL(pll1->PLLState));
  if ((pll1->PLLState) != RCC_PLL_NONE)
2ffc5fb4:	6803      	ldr	r3, [r0, #0]
2ffc5fb6:	b90b      	cbnz	r3, 2ffc5fbc <RCC_PLL1_Config+0x8>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
2ffc5fb8:	2000      	movs	r0, #0

}
2ffc5fba:	4770      	bx	lr
    if (!__IS_PLL1_IN_USE()) /* If not used then */
2ffc5fbc:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
{
2ffc5fc0:	b570      	push	{r4, r5, r6, lr}
2ffc5fc2:	4604      	mov	r4, r0
    if (!__IS_PLL1_IN_USE()) /* If not used then */
2ffc5fc4:	6a0a      	ldr	r2, [r1, #32]
2ffc5fc6:	f002 0203 	and.w	r2, r2, #3
2ffc5fca:	2a02      	cmp	r2, #2
2ffc5fcc:	d027      	beq.n	2ffc601e <RCC_PLL1_Config+0x6a>
2ffc5fce:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc5fd2:	6a0a      	ldr	r2, [r1, #32]
2ffc5fd4:	f002 0203 	and.w	r2, r2, #3
2ffc5fd8:	2a03      	cmp	r2, #3
2ffc5fda:	d025      	beq.n	2ffc6028 <RCC_PLL1_Config+0x74>
      if ((pll1->PLLState) == RCC_PLL_ON)
2ffc5fdc:	2b02      	cmp	r3, #2
2ffc5fde:	d028      	beq.n	2ffc6032 <RCC_PLL1_Config+0x7e>
        __HAL_RCC_PLL1CLKOUT_DISABLE(RCC_PLL1_DIVP | RCC_PLL1_DIVQ | RCC_PLL1_DIVR);
2ffc5fe0:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
2ffc5fe4:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
2ffc5fe8:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
2ffc5fec:	f8c4 3080 	str.w	r3, [r4, #128]	@ 0x80
        __HAL_RCC_PLL1_DISABLE();
2ffc5ff0:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
2ffc5ff4:	f023 0301 	bic.w	r3, r3, #1
2ffc5ff8:	f8c4 3080 	str.w	r3, [r4, #128]	@ 0x80
        tickstart = HAL_GetTick();
2ffc5ffc:	f7fd faa6 	bl	2ffc354c <HAL_GetTick>
2ffc6000:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL1RDY) != RESET)
2ffc6002:	e004      	b.n	2ffc600e <RCC_PLL1_Config+0x5a>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc6004:	f7fd faa2 	bl	2ffc354c <HAL_GetTick>
2ffc6008:	1b40      	subs	r0, r0, r5
2ffc600a:	2864      	cmp	r0, #100	@ 0x64
2ffc600c:	d805      	bhi.n	2ffc601a <RCC_PLL1_Config+0x66>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL1RDY) != RESET)
2ffc600e:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
2ffc6012:	079b      	lsls	r3, r3, #30
2ffc6014:	d4f6      	bmi.n	2ffc6004 <RCC_PLL1_Config+0x50>
  return HAL_OK;
2ffc6016:	2000      	movs	r0, #0
}
2ffc6018:	bd70      	pop	{r4, r5, r6, pc}
            return HAL_TIMEOUT;
2ffc601a:	2003      	movs	r0, #3
}
2ffc601c:	bd70      	pop	{r4, r5, r6, pc}
    if (!__IS_PLL1_IN_USE()) /* If not used then */
2ffc601e:	6a0a      	ldr	r2, [r1, #32]
2ffc6020:	2a00      	cmp	r2, #0
2ffc6022:	dad4      	bge.n	2ffc5fce <RCC_PLL1_Config+0x1a>
            return HAL_ERROR;
2ffc6024:	2001      	movs	r0, #1
}
2ffc6026:	bd70      	pop	{r4, r5, r6, pc}
    if (!__IS_PLL1_IN_USE()) /* If not used then */
2ffc6028:	6a0a      	ldr	r2, [r1, #32]
2ffc602a:	2a00      	cmp	r2, #0
2ffc602c:	dbfa      	blt.n	2ffc6024 <RCC_PLL1_Config+0x70>
      if ((pll1->PLLState) == RCC_PLL_ON)
2ffc602e:	2b02      	cmp	r3, #2
2ffc6030:	d1d6      	bne.n	2ffc5fe0 <RCC_PLL1_Config+0x2c>
        __HAL_RCC_PLL1CLKOUT_DISABLE(RCC_PLL1_DIVP | RCC_PLL1_DIVQ | RCC_PLL1_DIVR);
2ffc6032:	f04f 46a0 	mov.w	r6, #1342177280	@ 0x50000000
2ffc6036:	f8d6 3080 	ldr.w	r3, [r6, #128]	@ 0x80
2ffc603a:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
2ffc603e:	f8c6 3080 	str.w	r3, [r6, #128]	@ 0x80
        __HAL_RCC_PLL1_DISABLE();
2ffc6042:	f8d6 3080 	ldr.w	r3, [r6, #128]	@ 0x80
2ffc6046:	f023 0301 	bic.w	r3, r3, #1
2ffc604a:	f8c6 3080 	str.w	r3, [r6, #128]	@ 0x80
        tickstart = HAL_GetTick();
2ffc604e:	f7fd fa7d 	bl	2ffc354c <HAL_GetTick>
2ffc6052:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL1RDY) != RESET)
2ffc6054:	e004      	b.n	2ffc6060 <RCC_PLL1_Config+0xac>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc6056:	f7fd fa79 	bl	2ffc354c <HAL_GetTick>
2ffc605a:	1b43      	subs	r3, r0, r5
2ffc605c:	2b64      	cmp	r3, #100	@ 0x64
2ffc605e:	d8dc      	bhi.n	2ffc601a <RCC_PLL1_Config+0x66>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL1RDY) != RESET)
2ffc6060:	f8d6 3080 	ldr.w	r3, [r6, #128]	@ 0x80
2ffc6064:	0799      	lsls	r1, r3, #30
2ffc6066:	d4f6      	bmi.n	2ffc6056 <RCC_PLL1_Config+0xa2>
        if (__IS_PLL2_IN_USE())
2ffc6068:	6a73      	ldr	r3, [r6, #36]	@ 0x24
          if (pll1->PLLSource != __HAL_RCC_GET_PLL12_SOURCE())
2ffc606a:	6861      	ldr	r1, [r4, #4]
        if (__IS_PLL2_IN_USE())
2ffc606c:	f003 0307 	and.w	r3, r3, #7
2ffc6070:	2b02      	cmp	r3, #2
2ffc6072:	f000 8083 	beq.w	2ffc617c <RCC_PLL1_Config+0x1c8>
          __HAL_RCC_PLL12_SOURCE(pll1->PLLSource);
2ffc6076:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc607a:	6a93      	ldr	r3, [r2, #40]	@ 0x28
2ffc607c:	f023 0303 	bic.w	r3, r3, #3
2ffc6080:	430b      	orrs	r3, r1
2ffc6082:	6293      	str	r3, [r2, #40]	@ 0x28
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL12SRCRDY) == RESET)
2ffc6084:	f04f 46a0 	mov.w	r6, #1342177280	@ 0x50000000
2ffc6088:	e004      	b.n	2ffc6094 <RCC_PLL1_Config+0xe0>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc608a:	f7fd fa5f 	bl	2ffc354c <HAL_GetTick>
2ffc608e:	1b40      	subs	r0, r0, r5
2ffc6090:	2864      	cmp	r0, #100	@ 0x64
2ffc6092:	d8c2      	bhi.n	2ffc601a <RCC_PLL1_Config+0x66>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL12SRCRDY) == RESET)
2ffc6094:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
2ffc6096:	2b00      	cmp	r3, #0
2ffc6098:	daf7      	bge.n	2ffc608a <RCC_PLL1_Config+0xd6>
        __HAL_RCC_PLL1_CONFIG(
2ffc609a:	f8d6 0084 	ldr.w	r0, [r6, #132]	@ 0x84
2ffc609e:	f44f 427e 	mov.w	r2, #65024	@ 0xfe00
2ffc60a2:	e9d4 1302 	ldrd	r1, r3, [r4, #8]
2ffc60a6:	f6cf 72c0 	movt	r2, #65472	@ 0xffc0
2ffc60aa:	4002      	ands	r2, r0
2ffc60ac:	3901      	subs	r1, #1
2ffc60ae:	3b01      	subs	r3, #1
2ffc60b0:	4313      	orrs	r3, r2
2ffc60b2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
2ffc60b6:	f8c6 3084 	str.w	r3, [r6, #132]	@ 0x84
2ffc60ba:	f8d6 2088 	ldr.w	r2, [r6, #136]	@ 0x88
2ffc60be:	e9d4 3104 	ldrd	r3, r1, [r4, #16]
2ffc60c2:	f022 127f 	bic.w	r2, r2, #8323199	@ 0x7f007f
2ffc60c6:	f422 42fe 	bic.w	r2, r2, #32512	@ 0x7f00
2ffc60ca:	3b01      	subs	r3, #1
2ffc60cc:	4313      	orrs	r3, r2
2ffc60ce:	3901      	subs	r1, #1
2ffc60d0:	69a2      	ldr	r2, [r4, #24]
2ffc60d2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
2ffc60d6:	3a01      	subs	r2, #1
2ffc60d8:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
2ffc60dc:	f8c6 3088 	str.w	r3, [r6, #136]	@ 0x88
        __HAL_RCC_PLL1FRACV_DISABLE(); /*Set FRACLE to '0' */
2ffc60e0:	f8d6 308c 	ldr.w	r3, [r6, #140]	@ 0x8c
2ffc60e4:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
2ffc60e8:	f8c6 308c 	str.w	r3, [r6, #140]	@ 0x8c
        if ((pll1->PLLMODE == RCC_PLL_SPREAD_SPECTRUM) || (pll1->PLLMODE == RCC_PLL_INTEGER))
2ffc60ec:	6a62      	ldr	r2, [r4, #36]	@ 0x24
2ffc60ee:	f032 0302 	bics.w	r3, r2, #2
          __HAL_RCC_PLL1FRACV_CONFIG(0U); /* Set FRACV to '0' */
2ffc60f2:	f8d6 308c 	ldr.w	r3, [r6, #140]	@ 0x8c
        if ((pll1->PLLMODE == RCC_PLL_SPREAD_SPECTRUM) || (pll1->PLLMODE == RCC_PLL_INTEGER))
2ffc60f6:	d14c      	bne.n	2ffc6192 <RCC_PLL1_Config+0x1de>
          __HAL_RCC_PLL1FRACV_CONFIG(0U); /* Set FRACV to '0' */
2ffc60f8:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
        if (pll1->PLLMODE == RCC_PLL_SPREAD_SPECTRUM)
2ffc60fc:	2a02      	cmp	r2, #2
          __HAL_RCC_PLL1FRACV_CONFIG(0U); /* Set FRACV to '0' */
2ffc60fe:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
2ffc6102:	f8c6 308c 	str.w	r3, [r6, #140]	@ 0x8c
        __HAL_RCC_PLL1FRACV_ENABLE(); /* Set FRACLE to 1 */
2ffc6106:	f8d6 308c 	ldr.w	r3, [r6, #140]	@ 0x8c
2ffc610a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
2ffc610e:	f8c6 308c 	str.w	r3, [r6, #140]	@ 0x8c
        if (pll1->PLLMODE == RCC_PLL_SPREAD_SPECTRUM)
2ffc6112:	d14d      	bne.n	2ffc61b0 <RCC_PLL1_Config+0x1fc>
          __HAL_RCC_PLL1CSGCONFIG(pll1->MOD_PER, pll1->TPDFN_DIS, pll1->RPDFN_DIS,
2ffc6114:	f8d6 2090 	ldr.w	r2, [r6, #144]	@ 0x90
2ffc6118:	6b21      	ldr	r1, [r4, #48]	@ 0x30
2ffc611a:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2ffc611c:	f002 4200 	and.w	r2, r2, #2147483648	@ 0x80000000
2ffc6120:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
2ffc6122:	430b      	orrs	r3, r1
2ffc6124:	4313      	orrs	r3, r2
2ffc6126:	6b61      	ldr	r1, [r4, #52]	@ 0x34
2ffc6128:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
2ffc612a:	4303      	orrs	r3, r0
2ffc612c:	430b      	orrs	r3, r1
2ffc612e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
2ffc6132:	f8c6 3090 	str.w	r3, [r6, #144]	@ 0x90
          __HAL_RCC_PLL1_SSMODE_ENABLE();
2ffc6136:	f8d6 3080 	ldr.w	r3, [r6, #128]	@ 0x80
2ffc613a:	f043 0304 	orr.w	r3, r3, #4
2ffc613e:	f8c6 3080 	str.w	r3, [r6, #128]	@ 0x80
        __HAL_RCC_PLL1_ENABLE();
2ffc6142:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
2ffc6146:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
2ffc614a:	f043 0301 	orr.w	r3, r3, #1
2ffc614e:	f8c4 3080 	str.w	r3, [r4, #128]	@ 0x80
        tickstart = HAL_GetTick();
2ffc6152:	f7fd f9fb 	bl	2ffc354c <HAL_GetTick>
2ffc6156:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL1RDY) == RESET)
2ffc6158:	e005      	b.n	2ffc6166 <RCC_PLL1_Config+0x1b2>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc615a:	f7fd f9f7 	bl	2ffc354c <HAL_GetTick>
2ffc615e:	1b40      	subs	r0, r0, r5
2ffc6160:	2864      	cmp	r0, #100	@ 0x64
2ffc6162:	f63f af5a 	bhi.w	2ffc601a <RCC_PLL1_Config+0x66>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL1RDY) == RESET)
2ffc6166:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
2ffc616a:	079a      	lsls	r2, r3, #30
2ffc616c:	d5f5      	bpl.n	2ffc615a <RCC_PLL1_Config+0x1a6>
        __HAL_RCC_PLL1CLKOUT_ENABLE(RCC_PLL1_DIVP | RCC_PLL1_DIVQ | RCC_PLL1_DIVR);
2ffc616e:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
2ffc6172:	f043 0370 	orr.w	r3, r3, #112	@ 0x70
2ffc6176:	f8c4 3080 	str.w	r3, [r4, #128]	@ 0x80
2ffc617a:	e74c      	b.n	2ffc6016 <RCC_PLL1_Config+0x62>
        if (__IS_PLL2_IN_USE())
2ffc617c:	6a73      	ldr	r3, [r6, #36]	@ 0x24
2ffc617e:	2b00      	cmp	r3, #0
2ffc6180:	f6bf af79 	bge.w	2ffc6076 <RCC_PLL1_Config+0xc2>
          if (pll1->PLLSource != __HAL_RCC_GET_PLL12_SOURCE())
2ffc6184:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
2ffc6186:	f003 0303 	and.w	r3, r3, #3
2ffc618a:	428b      	cmp	r3, r1
2ffc618c:	f47f af4a 	bne.w	2ffc6024 <RCC_PLL1_Config+0x70>
2ffc6190:	e778      	b.n	2ffc6084 <RCC_PLL1_Config+0xd0>
          __HAL_RCC_PLL1FRACV_CONFIG(pll1->PLLFRACV);
2ffc6192:	6a22      	ldr	r2, [r4, #32]
2ffc6194:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
2ffc6198:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
2ffc619c:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
2ffc61a0:	f8c6 308c 	str.w	r3, [r6, #140]	@ 0x8c
        __HAL_RCC_PLL1FRACV_ENABLE(); /* Set FRACLE to 1 */
2ffc61a4:	f8d6 308c 	ldr.w	r3, [r6, #140]	@ 0x8c
2ffc61a8:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
2ffc61ac:	f8c6 308c 	str.w	r3, [r6, #140]	@ 0x8c
          __HAL_RCC_PLL1_SSMODE_DISABLE();
2ffc61b0:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc61b4:	f8d2 3080 	ldr.w	r3, [r2, #128]	@ 0x80
2ffc61b8:	f023 0304 	bic.w	r3, r3, #4
2ffc61bc:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
2ffc61c0:	e7bf      	b.n	2ffc6142 <RCC_PLL1_Config+0x18e>
2ffc61c2:	bf00      	nop

2ffc61c4 <RCC_AXISSConfig>:
  return HAL_OK;
}


HAL_StatusTypeDef RCC_AXISSConfig(RCC_AXISSInitTypeDef *RCC_AXISSInitStruct)
{
2ffc61c4:	b570      	push	{r4, r5, r6, lr}
2ffc61c6:	4605      	mov	r5, r0

  assert_param(IS_RCC_AXISSOURCE(RCC_AXISSInitStruct->AXI_Clock));
  assert_param(IS_RCC_AXIDIV(RCC_AXISSInitStruct->AXI_Div));

  /* Ensure clock source is ready*/
  switch (RCC_AXISSInitStruct->AXI_Clock)
2ffc61c8:	6800      	ldr	r0, [r0, #0]
2ffc61ca:	2801      	cmp	r0, #1
2ffc61cc:	d05a      	beq.n	2ffc6284 <RCC_AXISSConfig+0xc0>
2ffc61ce:	2802      	cmp	r0, #2
2ffc61d0:	d02f      	beq.n	2ffc6232 <RCC_AXISSConfig+0x6e>
2ffc61d2:	2800      	cmp	r0, #0
2ffc61d4:	d04b      	beq.n	2ffc626e <RCC_AXISSConfig+0xaa>
      break;

  }

  /* Set AXISS clock source */
  __HAL_RCC_AXISS_SOURCE(RCC_AXISSInitStruct->AXI_Clock);
2ffc61d6:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000

  if (RCC_AXISSInitStruct->AXI_Clock != RCC_AXISSOURCE_OFF)
2ffc61da:	2803      	cmp	r0, #3
  __HAL_RCC_AXISS_SOURCE(RCC_AXISSInitStruct->AXI_Clock);
2ffc61dc:	6a62      	ldr	r2, [r4, #36]	@ 0x24
2ffc61de:	f022 0207 	bic.w	r2, r2, #7
2ffc61e2:	ea42 0200 	orr.w	r2, r2, r0
2ffc61e6:	6262      	str	r2, [r4, #36]	@ 0x24
  if (RCC_AXISSInitStruct->AXI_Clock != RCC_AXISSOURCE_OFF)
2ffc61e8:	d12f      	bne.n	2ffc624a <RCC_AXISSConfig+0x86>
  }
  else
  {
    // RCC_AXISSOURCE_OFF case
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2ffc61ea:	f7fd f9af 	bl	2ffc354c <HAL_GetTick>
2ffc61ee:	4606      	mov	r6, r0

    /* Wait till AXISS is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_AXISSRCRDY) != RESET)
2ffc61f0:	e005      	b.n	2ffc61fe <RCC_AXISSConfig+0x3a>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
2ffc61f2:	f7fd f9ab 	bl	2ffc354c <HAL_GetTick>
2ffc61f6:	1b83      	subs	r3, r0, r6
2ffc61f8:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
2ffc61fc:	d835      	bhi.n	2ffc626a <RCC_AXISSConfig+0xa6>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_AXISSRCRDY) != RESET)
2ffc61fe:	6a63      	ldr	r3, [r4, #36]	@ 0x24
2ffc6200:	2b00      	cmp	r3, #0
2ffc6202:	dbf6      	blt.n	2ffc61f2 <RCC_AXISSConfig+0x2e>
      }
    }
  }

  /* Set AXISS division factor */
  __HAL_RCC_AXI_DIV(RCC_AXISSInitStruct->AXI_Div);
2ffc6204:	686a      	ldr	r2, [r5, #4]
2ffc6206:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
2ffc620a:	6b23      	ldr	r3, [r4, #48]	@ 0x30
2ffc620c:	f023 0307 	bic.w	r3, r3, #7
2ffc6210:	4313      	orrs	r3, r2
2ffc6212:	6323      	str	r3, [r4, #48]	@ 0x30

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
2ffc6214:	f7fd f99a 	bl	2ffc354c <HAL_GetTick>
2ffc6218:	4605      	mov	r5, r0

  /* Wait till AXISS is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_AXIDIVRDY) == RESET)
2ffc621a:	e005      	b.n	2ffc6228 <RCC_AXISSConfig+0x64>
  {
    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
2ffc621c:	f7fd f996 	bl	2ffc354c <HAL_GetTick>
2ffc6220:	1b40      	subs	r0, r0, r5
2ffc6222:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
2ffc6226:	d820      	bhi.n	2ffc626a <RCC_AXISSConfig+0xa6>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_AXIDIVRDY) == RESET)
2ffc6228:	6b23      	ldr	r3, [r4, #48]	@ 0x30
2ffc622a:	2b00      	cmp	r3, #0
2ffc622c:	daf6      	bge.n	2ffc621c <RCC_AXISSConfig+0x58>
    {
      return HAL_TIMEOUT;
    }
  }

  return HAL_OK;
2ffc622e:	2000      	movs	r0, #0
}
2ffc6230:	bd70      	pop	{r4, r5, r6, pc}
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == RESET)
2ffc6232:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc6236:	f8d2 3094 	ldr.w	r3, [r2, #148]	@ 0x94
2ffc623a:	079b      	lsls	r3, r3, #30
2ffc623c:	d52f      	bpl.n	2ffc629e <RCC_AXISSConfig+0xda>
  __HAL_RCC_AXISS_SOURCE(RCC_AXISSInitStruct->AXI_Clock);
2ffc623e:	6a53      	ldr	r3, [r2, #36]	@ 0x24
2ffc6240:	f023 0307 	bic.w	r3, r3, #7
2ffc6244:	f043 0302 	orr.w	r3, r3, #2
2ffc6248:	6253      	str	r3, [r2, #36]	@ 0x24
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_AXISSRCRDY) == RESET)
2ffc624a:	f04f 46a0 	mov.w	r6, #1342177280	@ 0x50000000
    tickstart = HAL_GetTick();
2ffc624e:	f7fd f97d 	bl	2ffc354c <HAL_GetTick>
2ffc6252:	4604      	mov	r4, r0
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_AXISSRCRDY) == RESET)
2ffc6254:	e005      	b.n	2ffc6262 <RCC_AXISSConfig+0x9e>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
2ffc6256:	f7fd f979 	bl	2ffc354c <HAL_GetTick>
2ffc625a:	1b03      	subs	r3, r0, r4
2ffc625c:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
2ffc6260:	d803      	bhi.n	2ffc626a <RCC_AXISSConfig+0xa6>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_AXISSRCRDY) == RESET)
2ffc6262:	6a73      	ldr	r3, [r6, #36]	@ 0x24
2ffc6264:	2b00      	cmp	r3, #0
2ffc6266:	daf6      	bge.n	2ffc6256 <RCC_AXISSConfig+0x92>
2ffc6268:	e7cc      	b.n	2ffc6204 <RCC_AXISSConfig+0x40>
        return HAL_TIMEOUT;
2ffc626a:	2003      	movs	r0, #3
}
2ffc626c:	bd70      	pop	{r4, r5, r6, pc}
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
2ffc626e:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc6272:	f8d3 2808 	ldr.w	r2, [r3, #2056]	@ 0x808
2ffc6276:	07d0      	lsls	r0, r2, #31
2ffc6278:	d511      	bpl.n	2ffc629e <RCC_AXISSConfig+0xda>
  __HAL_RCC_AXISS_SOURCE(RCC_AXISSInitStruct->AXI_Clock);
2ffc627a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
2ffc627c:	f022 0207 	bic.w	r2, r2, #7
2ffc6280:	625a      	str	r2, [r3, #36]	@ 0x24
  if (RCC_AXISSInitStruct->AXI_Clock != RCC_AXISSOURCE_OFF)
2ffc6282:	e7e2      	b.n	2ffc624a <RCC_AXISSConfig+0x86>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
2ffc6284:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc6288:	f8d2 1808 	ldr.w	r1, [r2, #2056]	@ 0x808
2ffc628c:	05c9      	lsls	r1, r1, #23
2ffc628e:	d5cf      	bpl.n	2ffc6230 <RCC_AXISSConfig+0x6c>
  __HAL_RCC_AXISS_SOURCE(RCC_AXISSInitStruct->AXI_Clock);
2ffc6290:	6a53      	ldr	r3, [r2, #36]	@ 0x24
2ffc6292:	f023 0307 	bic.w	r3, r3, #7
2ffc6296:	f043 0301 	orr.w	r3, r3, #1
2ffc629a:	6253      	str	r3, [r2, #36]	@ 0x24
  if (RCC_AXISSInitStruct->AXI_Clock != RCC_AXISSOURCE_OFF)
2ffc629c:	e7d5      	b.n	2ffc624a <RCC_AXISSConfig+0x86>
        return HAL_ERROR;
2ffc629e:	2001      	movs	r0, #1
}
2ffc62a0:	bd70      	pop	{r4, r5, r6, pc}
2ffc62a2:	bf00      	nop

2ffc62a4 <RCC_MCUConfig>:

  assert_param(IS_RCC_MCUSSOURCE(MCUInitStruct->MCU_Clock));
  assert_param(IS_RCC_MCUDIV(MCUInitStruct->MCU_Div));

  /* Ensure clock source is ready*/
  switch (MCUInitStruct->MCU_Clock)
2ffc62a4:	6802      	ldr	r2, [r0, #0]
{
2ffc62a6:	b570      	push	{r4, r5, r6, lr}
2ffc62a8:	4606      	mov	r6, r0
  switch (MCUInitStruct->MCU_Clock)
2ffc62aa:	2a03      	cmp	r2, #3
2ffc62ac:	d809      	bhi.n	2ffc62c2 <RCC_MCUConfig+0x1e>
2ffc62ae:	e8df f002 	tbb	[pc, r2]
2ffc62b2:	4702      	.short	0x4702
2ffc62b4:	3840      	.short	0x3840
  {
    case (RCC_MCUSSOURCE_HSI):
    {
      /* Check the HSI ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
2ffc62b6:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc62ba:	f8d3 3808 	ldr.w	r3, [r3, #2056]	@ 0x808
2ffc62be:	07dc      	lsls	r4, r3, #31
2ffc62c0:	d535      	bpl.n	2ffc632e <RCC_MCUConfig+0x8a>
      break;

  }

  /* Set MCU clock source */
  __HAL_RCC_MCU_SOURCE(MCUInitStruct->MCU_Clock);
2ffc62c2:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
2ffc62c6:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
2ffc62c8:	f023 0303 	bic.w	r3, r3, #3
2ffc62cc:	4313      	orrs	r3, r2
2ffc62ce:	64a3      	str	r3, [r4, #72]	@ 0x48

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
2ffc62d0:	f7fd f93c 	bl	2ffc354c <HAL_GetTick>
2ffc62d4:	4605      	mov	r5, r0

  /* Wait till MCU is ready */

  while (__HAL_RCC_GET_FLAG(RCC_FLAG_MCUSSRCRDY) == RESET)
2ffc62d6:	e005      	b.n	2ffc62e4 <RCC_MCUConfig+0x40>
  {
    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
2ffc62d8:	f7fd f938 	bl	2ffc354c <HAL_GetTick>
2ffc62dc:	1b43      	subs	r3, r0, r5
2ffc62de:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
2ffc62e2:	d81c      	bhi.n	2ffc631e <RCC_MCUConfig+0x7a>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_MCUSSRCRDY) == RESET)
2ffc62e4:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
2ffc62e6:	2b00      	cmp	r3, #0
2ffc62e8:	daf6      	bge.n	2ffc62d8 <RCC_MCUConfig+0x34>
  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick(uwTickPrio);
#endif

  /* Set MCU division factor */
  __HAL_RCC_MCU_DIV(MCUInitStruct->MCU_Div);
2ffc62ea:	f8d4 3830 	ldr.w	r3, [r4, #2096]	@ 0x830

  /* Get Start Tick*/
  tickstart = HAL_GetTick();

  /* Wait till MCU is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_MCUDIVRDY) == RESET)
2ffc62ee:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
  __HAL_RCC_MCU_DIV(MCUInitStruct->MCU_Div);
2ffc62f2:	6872      	ldr	r2, [r6, #4]
2ffc62f4:	f023 030f 	bic.w	r3, r3, #15
2ffc62f8:	4313      	orrs	r3, r2
2ffc62fa:	f8c4 3830 	str.w	r3, [r4, #2096]	@ 0x830
  tickstart = HAL_GetTick();
2ffc62fe:	f7fd f925 	bl	2ffc354c <HAL_GetTick>
2ffc6302:	4604      	mov	r4, r0
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_MCUDIVRDY) == RESET)
2ffc6304:	e005      	b.n	2ffc6312 <RCC_MCUConfig+0x6e>
  {
    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
2ffc6306:	f7fd f921 	bl	2ffc354c <HAL_GetTick>
2ffc630a:	1b00      	subs	r0, r0, r4
2ffc630c:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
2ffc6310:	d805      	bhi.n	2ffc631e <RCC_MCUConfig+0x7a>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_MCUDIVRDY) == RESET)
2ffc6312:	f8d5 3830 	ldr.w	r3, [r5, #2096]	@ 0x830
2ffc6316:	2b00      	cmp	r3, #0
2ffc6318:	daf5      	bge.n	2ffc6306 <RCC_MCUConfig+0x62>

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick(uwTickPrio);
#endif

  return HAL_OK;
2ffc631a:	2000      	movs	r0, #0
}
2ffc631c:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_TIMEOUT;
2ffc631e:	2003      	movs	r0, #3
}
2ffc6320:	bd70      	pop	{r4, r5, r6, pc}
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == RESET)
2ffc6322:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc6326:	f8d3 3880 	ldr.w	r3, [r3, #2176]	@ 0x880
2ffc632a:	079b      	lsls	r3, r3, #30
2ffc632c:	d4c9      	bmi.n	2ffc62c2 <RCC_MCUConfig+0x1e>
        return HAL_ERROR;
2ffc632e:	2001      	movs	r0, #1
}
2ffc6330:	bd70      	pop	{r4, r5, r6, pc}
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == RESET)
2ffc6332:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc6336:	f8d3 3808 	ldr.w	r3, [r3, #2056]	@ 0x808
2ffc633a:	06d9      	lsls	r1, r3, #27
2ffc633c:	d4c1      	bmi.n	2ffc62c2 <RCC_MCUConfig+0x1e>
2ffc633e:	e7f6      	b.n	2ffc632e <RCC_MCUConfig+0x8a>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
2ffc6340:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc6344:	f8d3 3808 	ldr.w	r3, [r3, #2056]	@ 0x808
2ffc6348:	05d8      	lsls	r0, r3, #23
2ffc634a:	d4ba      	bmi.n	2ffc62c2 <RCC_MCUConfig+0x1e>
2ffc634c:	e7ef      	b.n	2ffc632e <RCC_MCUConfig+0x8a>
2ffc634e:	bf00      	nop

2ffc6350 <HAL_RCC_GetPLL1ClockFreq>:

  pllsource = __HAL_RCC_GET_PLL12_SOURCE();
  pll1m = ((RCC->PLL1CFGR1 & RCC_PLL1CFGR1_DIVM1) >> RCC_PLL1CFGR1_DIVM1_Pos) + 1U;
  pll1fracen = (RCC->PLL1FRACR & RCC_PLL1FRACR_FRACLE) >> RCC_PLL1FRACR_FRACLE_Pos;
  fracn1 = (float)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACV) >> RCC_PLL1FRACR_FRACV_Pos));
  pll1vco = (float)((float)((RCC->PLL1CFGR1 & RCC_PLL1CFGR1_DIVN) + 1U) + (fracn1 / (float)0x2000));  //Intermediary value
2ffc6350:	eddf 6a41 	vldr	s13, [pc, #260]	@ 2ffc6458 <HAL_RCC_GetPLL1ClockFreq+0x108>
  pllsource = __HAL_RCC_GET_PLL12_SOURCE();
2ffc6354:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
{
2ffc6358:	b430      	push	{r4, r5}
  pllsource = __HAL_RCC_GET_PLL12_SOURCE();
2ffc635a:	6a95      	ldr	r5, [r2, #40]	@ 0x28
  pll1m = ((RCC->PLL1CFGR1 & RCC_PLL1CFGR1_DIVM1) >> RCC_PLL1CFGR1_DIVM1_Pos) + 1U;
2ffc635c:	f8d2 4084 	ldr.w	r4, [r2, #132]	@ 0x84
  pll1fracen = (RCC->PLL1FRACR & RCC_PLL1FRACR_FRACLE) >> RCC_PLL1FRACR_FRACLE_Pos;
2ffc6360:	f8d2 108c 	ldr.w	r1, [r2, #140]	@ 0x8c
  fracn1 = (float)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACV) >> RCC_PLL1FRACR_FRACV_Pos));
2ffc6364:	f8d2 308c 	ldr.w	r3, [r2, #140]	@ 0x8c
  pll1fracen = (RCC->PLL1FRACR & RCC_PLL1FRACR_FRACLE) >> RCC_PLL1FRACR_FRACLE_Pos;
2ffc6368:	f3c1 4100 	ubfx	r1, r1, #16, #1
  fracn1 = (float)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACV) >> RCC_PLL1FRACR_FRACV_Pos));
2ffc636c:	f3c3 03cc 	ubfx	r3, r3, #3, #13
2ffc6370:	fb01 f303 	mul.w	r3, r1, r3
  pll1m = ((RCC->PLL1CFGR1 & RCC_PLL1CFGR1_DIVM1) >> RCC_PLL1CFGR1_DIVM1_Pos) + 1U;
2ffc6374:	f3c4 4405 	ubfx	r4, r4, #16, #6
  fracn1 = (float)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACV) >> RCC_PLL1FRACR_FRACV_Pos));
2ffc6378:	ee07 3a90 	vmov	s15, r3
  pll1vco = (float)((float)((RCC->PLL1CFGR1 & RCC_PLL1CFGR1_DIVN) + 1U) + (fracn1 / (float)0x2000));  //Intermediary value
2ffc637c:	f8d2 3084 	ldr.w	r3, [r2, #132]	@ 0x84
  pll1m = ((RCC->PLL1CFGR1 & RCC_PLL1CFGR1_DIVM1) >> RCC_PLL1CFGR1_DIVM1_Pos) + 1U;
2ffc6380:	3401      	adds	r4, #1
  pll1vco = (float)((float)((RCC->PLL1CFGR1 & RCC_PLL1CFGR1_DIVN) + 1U) + (fracn1 / (float)0x2000));  //Intermediary value
2ffc6382:	f3c3 0308 	ubfx	r3, r3, #0, #9
  fracn1 = (float)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACV) >> RCC_PLL1FRACR_FRACV_Pos));
2ffc6386:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  pll1vco = (float)((float)((RCC->PLL1CFGR1 & RCC_PLL1CFGR1_DIVN) + 1U) + (fracn1 / (float)0x2000));  //Intermediary value
2ffc638a:	3301      	adds	r3, #1
2ffc638c:	ee07 3a90 	vmov	s15, r3
  switch (pllsource)
2ffc6390:	f015 0303 	ands.w	r3, r5, #3
  pll1vco = (float)((float)((RCC->PLL1CFGR1 & RCC_PLL1CFGR1_DIVN) + 1U) + (fracn1 / (float)0x2000));  //Intermediary value
2ffc6394:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2ffc6398:	eee7 7a26 	vfma.f32	s15, s14, s13
  switch (pllsource)
2ffc639c:	d041      	beq.n	2ffc6422 <HAL_RCC_GetPLL1ClockFreq+0xd2>
2ffc639e:	2b01      	cmp	r3, #1
2ffc63a0:	d13c      	bne.n	2ffc641c <HAL_RCC_GetPLL1ClockFreq+0xcc>
        pll1vco *= (float)(HSI_VALUE / pll1m);
      }
      break;

    case RCC_PLL12SOURCE_HSE:  /* HSE used as PLL clock source */
      pll1vco *= (float)(HSE_VALUE / pll1m);
2ffc63a2:	f44f 5358 	mov.w	r3, #13824	@ 0x3600
2ffc63a6:	f2c0 136e 	movt	r3, #366	@ 0x16e
2ffc63aa:	fbb3 f3f4 	udiv	r3, r3, r4
2ffc63ae:	ee07 3a10 	vmov	s14, r3
2ffc63b2:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc63b6:	ee67 7a27 	vmul.f32	s15, s14, s15
    default:
      pll1vco = 0;
      break;
  }

  PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(pll1vco / ((float)(((RCC->PLL1CFGR2 & RCC_PLL1CFGR2_DIVP) >> RCC_PLL1CFGR2_DIVP_Pos) + 1U)));
2ffc63ba:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
  PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(pll1vco / ((float)(((RCC->PLL1CFGR2 & RCC_PLL1CFGR2_DIVQ) >> RCC_PLL1CFGR2_DIVQ_Pos) + 1U)));
  PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(pll1vco / ((float)(((RCC->PLL1CFGR2 & RCC_PLL1CFGR2_DIVR) >> RCC_PLL1CFGR2_DIVR_Pos) + 1U)));
}
2ffc63be:	bc30      	pop	{r4, r5}
  PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(pll1vco / ((float)(((RCC->PLL1CFGR2 & RCC_PLL1CFGR2_DIVP) >> RCC_PLL1CFGR2_DIVP_Pos) + 1U)));
2ffc63c0:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
2ffc63c4:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
2ffc63c8:	3301      	adds	r3, #1
2ffc63ca:	ee07 3a10 	vmov	s14, r3
2ffc63ce:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc63d2:	eec7 6a87 	vdiv.f32	s13, s15, s14
2ffc63d6:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2ffc63da:	edc0 6a00 	vstr	s13, [r0]
  PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(pll1vco / ((float)(((RCC->PLL1CFGR2 & RCC_PLL1CFGR2_DIVQ) >> RCC_PLL1CFGR2_DIVQ_Pos) + 1U)));
2ffc63de:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
2ffc63e2:	f3c3 2306 	ubfx	r3, r3, #8, #7
2ffc63e6:	3301      	adds	r3, #1
2ffc63e8:	ee07 3a10 	vmov	s14, r3
2ffc63ec:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc63f0:	eec7 6a87 	vdiv.f32	s13, s15, s14
2ffc63f4:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2ffc63f8:	edc0 6a01 	vstr	s13, [r0, #4]
  PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(pll1vco / ((float)(((RCC->PLL1CFGR2 & RCC_PLL1CFGR2_DIVR) >> RCC_PLL1CFGR2_DIVR_Pos) + 1U)));
2ffc63fc:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
2ffc6400:	f3c3 4306 	ubfx	r3, r3, #16, #7
2ffc6404:	3301      	adds	r3, #1
2ffc6406:	ee07 3a10 	vmov	s14, r3
2ffc640a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc640e:	eec7 6a87 	vdiv.f32	s13, s15, s14
2ffc6412:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2ffc6416:	edc0 6a02 	vstr	s13, [r0, #8]
}
2ffc641a:	4770      	bx	lr
  switch (pllsource)
2ffc641c:	eddf 7a0f 	vldr	s15, [pc, #60]	@ 2ffc645c <HAL_RCC_GetPLL1ClockFreq+0x10c>
2ffc6420:	e7cb      	b.n	2ffc63ba <HAL_RCC_GetPLL1ClockFreq+0x6a>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIVRDY) != 0U)
2ffc6422:	f8d2 3808 	ldr.w	r3, [r2, #2056]	@ 0x808
2ffc6426:	075b      	lsls	r3, r3, #29
        hsivalue = (HSI_VALUE >> __HAL_RCC_GET_HSI_DIV());
2ffc6428:	bf49      	itett	mi
2ffc642a:	f44f 4310 	movmi.w	r3, #36864	@ 0x9000
        pll1vco *= (float)(HSI_VALUE / pll1m);
2ffc642e:	f44f 4310 	movpl.w	r3, #36864	@ 0x9000
        hsivalue = (HSI_VALUE >> __HAL_RCC_GET_HSI_DIV());
2ffc6432:	6992      	ldrmi	r2, [r2, #24]
2ffc6434:	f2c0 33d0 	movtmi	r3, #976	@ 0x3d0
        pll1vco *= (float)(HSI_VALUE / pll1m);
2ffc6438:	bf52      	itee	pl
2ffc643a:	f2c0 33d0 	movtpl	r3, #976	@ 0x3d0
        hsivalue = (HSI_VALUE >> __HAL_RCC_GET_HSI_DIV());
2ffc643e:	f002 0203 	andmi.w	r2, r2, #3
2ffc6442:	40d3      	lsrmi	r3, r2
        pll1vco *= (float)(HSI_VALUE / pll1m);
2ffc6444:	fbb3 f3f4 	udiv	r3, r3, r4
2ffc6448:	ee07 3a10 	vmov	s14, r3
2ffc644c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc6450:	ee67 7a27 	vmul.f32	s15, s14, s15
2ffc6454:	e7b1      	b.n	2ffc63ba <HAL_RCC_GetPLL1ClockFreq+0x6a>
2ffc6456:	bf00      	nop
2ffc6458:	39000000 	.word	0x39000000
2ffc645c:	00000000 	.word	0x00000000

2ffc6460 <HAL_RCC_GetPLL2ClockFreq>:

  pllsource = __HAL_RCC_GET_PLL12_SOURCE();
  pll2m = ((RCC->PLL2CFGR1 & RCC_PLL2CFGR1_DIVM2) >> RCC_PLL2CFGR1_DIVM2_Pos) + 1U;
  pll2fracen = (RCC->PLL2FRACR & RCC_PLL2FRACR_FRACLE) >> RCC_PLL2FRACR_FRACLE_Pos;
  fracn1 = (float)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACV) >> RCC_PLL2FRACR_FRACV_Pos));
  pll2vco = (float)((float)((RCC->PLL2CFGR1 & RCC_PLL2CFGR1_DIVN) + 1U) + (fracn1 / (float)0x2000));  //Intermediary value
2ffc6460:	eddf 6a41 	vldr	s13, [pc, #260]	@ 2ffc6568 <HAL_RCC_GetPLL2ClockFreq+0x108>
  pllsource = __HAL_RCC_GET_PLL12_SOURCE();
2ffc6464:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
{
2ffc6468:	b430      	push	{r4, r5}
  pllsource = __HAL_RCC_GET_PLL12_SOURCE();
2ffc646a:	6a95      	ldr	r5, [r2, #40]	@ 0x28
  pll2m = ((RCC->PLL2CFGR1 & RCC_PLL2CFGR1_DIVM2) >> RCC_PLL2CFGR1_DIVM2_Pos) + 1U;
2ffc646c:	f8d2 4098 	ldr.w	r4, [r2, #152]	@ 0x98
  pll2fracen = (RCC->PLL2FRACR & RCC_PLL2FRACR_FRACLE) >> RCC_PLL2FRACR_FRACLE_Pos;
2ffc6470:	f8d2 10a0 	ldr.w	r1, [r2, #160]	@ 0xa0
  fracn1 = (float)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACV) >> RCC_PLL2FRACR_FRACV_Pos));
2ffc6474:	f8d2 30a0 	ldr.w	r3, [r2, #160]	@ 0xa0
  pll2fracen = (RCC->PLL2FRACR & RCC_PLL2FRACR_FRACLE) >> RCC_PLL2FRACR_FRACLE_Pos;
2ffc6478:	f3c1 4100 	ubfx	r1, r1, #16, #1
  fracn1 = (float)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACV) >> RCC_PLL2FRACR_FRACV_Pos));
2ffc647c:	f3c3 03cc 	ubfx	r3, r3, #3, #13
2ffc6480:	fb01 f303 	mul.w	r3, r1, r3
  pll2m = ((RCC->PLL2CFGR1 & RCC_PLL2CFGR1_DIVM2) >> RCC_PLL2CFGR1_DIVM2_Pos) + 1U;
2ffc6484:	f3c4 4405 	ubfx	r4, r4, #16, #6
  fracn1 = (float)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACV) >> RCC_PLL2FRACR_FRACV_Pos));
2ffc6488:	ee07 3a90 	vmov	s15, r3
  pll2vco = (float)((float)((RCC->PLL2CFGR1 & RCC_PLL2CFGR1_DIVN) + 1U) + (fracn1 / (float)0x2000));  //Intermediary value
2ffc648c:	f8d2 3098 	ldr.w	r3, [r2, #152]	@ 0x98
  pll2m = ((RCC->PLL2CFGR1 & RCC_PLL2CFGR1_DIVM2) >> RCC_PLL2CFGR1_DIVM2_Pos) + 1U;
2ffc6490:	3401      	adds	r4, #1
  pll2vco = (float)((float)((RCC->PLL2CFGR1 & RCC_PLL2CFGR1_DIVN) + 1U) + (fracn1 / (float)0x2000));  //Intermediary value
2ffc6492:	f3c3 0308 	ubfx	r3, r3, #0, #9
  fracn1 = (float)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACV) >> RCC_PLL2FRACR_FRACV_Pos));
2ffc6496:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  pll2vco = (float)((float)((RCC->PLL2CFGR1 & RCC_PLL2CFGR1_DIVN) + 1U) + (fracn1 / (float)0x2000));  //Intermediary value
2ffc649a:	3301      	adds	r3, #1
2ffc649c:	ee07 3a90 	vmov	s15, r3
  switch (pllsource)
2ffc64a0:	f015 0303 	ands.w	r3, r5, #3
  pll2vco = (float)((float)((RCC->PLL2CFGR1 & RCC_PLL2CFGR1_DIVN) + 1U) + (fracn1 / (float)0x2000));  //Intermediary value
2ffc64a4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2ffc64a8:	eee7 7a26 	vfma.f32	s15, s14, s13
  switch (pllsource)
2ffc64ac:	d041      	beq.n	2ffc6532 <HAL_RCC_GetPLL2ClockFreq+0xd2>
2ffc64ae:	2b01      	cmp	r3, #1
2ffc64b0:	d13c      	bne.n	2ffc652c <HAL_RCC_GetPLL2ClockFreq+0xcc>
        pll2vco *= (float)(HSI_VALUE / pll2m);
      }
      break;

    case RCC_PLL12SOURCE_HSE:  /* HSE used as PLL clock source */
      pll2vco *= (float)(HSE_VALUE / pll2m);
2ffc64b2:	f44f 5358 	mov.w	r3, #13824	@ 0x3600
2ffc64b6:	f2c0 136e 	movt	r3, #366	@ 0x16e
2ffc64ba:	fbb3 f3f4 	udiv	r3, r3, r4
2ffc64be:	ee07 3a10 	vmov	s14, r3
2ffc64c2:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc64c6:	ee67 7a27 	vmul.f32	s15, s14, s15
    default:
      pll2vco = 0;
      break;
  }

  PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(pll2vco / ((float)(((RCC->PLL2CFGR2 & RCC_PLL2CFGR2_DIVP) >> RCC_PLL2CFGR2_DIVP_Pos) + 1U)));
2ffc64ca:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
  PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(pll2vco / ((float)(((RCC->PLL2CFGR2 & RCC_PLL2CFGR2_DIVQ) >> RCC_PLL2CFGR2_DIVQ_Pos) + 1U)));
  PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(pll2vco / ((float)(((RCC->PLL2CFGR2 & RCC_PLL2CFGR2_DIVR) >> RCC_PLL2CFGR2_DIVR_Pos) + 1U)));
}
2ffc64ce:	bc30      	pop	{r4, r5}
  PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(pll2vco / ((float)(((RCC->PLL2CFGR2 & RCC_PLL2CFGR2_DIVP) >> RCC_PLL2CFGR2_DIVP_Pos) + 1U)));
2ffc64d0:	f8d2 309c 	ldr.w	r3, [r2, #156]	@ 0x9c
2ffc64d4:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
2ffc64d8:	3301      	adds	r3, #1
2ffc64da:	ee07 3a10 	vmov	s14, r3
2ffc64de:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc64e2:	eec7 6a87 	vdiv.f32	s13, s15, s14
2ffc64e6:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2ffc64ea:	edc0 6a00 	vstr	s13, [r0]
  PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(pll2vco / ((float)(((RCC->PLL2CFGR2 & RCC_PLL2CFGR2_DIVQ) >> RCC_PLL2CFGR2_DIVQ_Pos) + 1U)));
2ffc64ee:	f8d2 309c 	ldr.w	r3, [r2, #156]	@ 0x9c
2ffc64f2:	f3c3 2306 	ubfx	r3, r3, #8, #7
2ffc64f6:	3301      	adds	r3, #1
2ffc64f8:	ee07 3a10 	vmov	s14, r3
2ffc64fc:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc6500:	eec7 6a87 	vdiv.f32	s13, s15, s14
2ffc6504:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2ffc6508:	edc0 6a01 	vstr	s13, [r0, #4]
  PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(pll2vco / ((float)(((RCC->PLL2CFGR2 & RCC_PLL2CFGR2_DIVR) >> RCC_PLL2CFGR2_DIVR_Pos) + 1U)));
2ffc650c:	f8d2 309c 	ldr.w	r3, [r2, #156]	@ 0x9c
2ffc6510:	f3c3 4306 	ubfx	r3, r3, #16, #7
2ffc6514:	3301      	adds	r3, #1
2ffc6516:	ee07 3a10 	vmov	s14, r3
2ffc651a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc651e:	eec7 6a87 	vdiv.f32	s13, s15, s14
2ffc6522:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2ffc6526:	edc0 6a02 	vstr	s13, [r0, #8]
}
2ffc652a:	4770      	bx	lr
  switch (pllsource)
2ffc652c:	eddf 7a0f 	vldr	s15, [pc, #60]	@ 2ffc656c <HAL_RCC_GetPLL2ClockFreq+0x10c>
2ffc6530:	e7cb      	b.n	2ffc64ca <HAL_RCC_GetPLL2ClockFreq+0x6a>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIVRDY) != 0U)
2ffc6532:	f8d2 3808 	ldr.w	r3, [r2, #2056]	@ 0x808
2ffc6536:	075b      	lsls	r3, r3, #29
        hsivalue = (HSI_VALUE >> __HAL_RCC_GET_HSI_DIV());
2ffc6538:	bf49      	itett	mi
2ffc653a:	f44f 4310 	movmi.w	r3, #36864	@ 0x9000
        pll2vco *= (float)(HSI_VALUE / pll2m);
2ffc653e:	f44f 4310 	movpl.w	r3, #36864	@ 0x9000
        hsivalue = (HSI_VALUE >> __HAL_RCC_GET_HSI_DIV());
2ffc6542:	6992      	ldrmi	r2, [r2, #24]
2ffc6544:	f2c0 33d0 	movtmi	r3, #976	@ 0x3d0
        pll2vco *= (float)(HSI_VALUE / pll2m);
2ffc6548:	bf52      	itee	pl
2ffc654a:	f2c0 33d0 	movtpl	r3, #976	@ 0x3d0
        hsivalue = (HSI_VALUE >> __HAL_RCC_GET_HSI_DIV());
2ffc654e:	f002 0203 	andmi.w	r2, r2, #3
2ffc6552:	40d3      	lsrmi	r3, r2
        pll2vco *= (float)(HSI_VALUE / pll2m);
2ffc6554:	fbb3 f3f4 	udiv	r3, r3, r4
2ffc6558:	ee07 3a10 	vmov	s14, r3
2ffc655c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc6560:	ee67 7a27 	vmul.f32	s15, s14, s15
2ffc6564:	e7b1      	b.n	2ffc64ca <HAL_RCC_GetPLL2ClockFreq+0x6a>
2ffc6566:	bf00      	nop
2ffc6568:	39000000 	.word	0x39000000
2ffc656c:	00000000 	.word	0x00000000

2ffc6570 <HAL_RCC_GetPLL3ClockFreq>:

  pllsource = __HAL_RCC_GET_PLL3_SOURCE();
  pll3m = ((RCC->PLL3CFGR1 & RCC_PLL3CFGR1_DIVM3) >> RCC_PLL3CFGR1_DIVM3_Pos) + 1U;
  pll3fracen = (RCC->PLL3FRACR & RCC_PLL3FRACR_FRACLE) >> RCC_PLL3FRACR_FRACLE_Pos;
  fracn1 = (float)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACV) >> RCC_PLL3FRACR_FRACV_Pos));
  pll3vco = (float)((float)((RCC->PLL3CFGR1 & RCC_PLL3CFGR1_DIVN) + 1U) + (fracn1 / (float) 0x2000));  //Intermediary value
2ffc6570:	eddf 6a4b 	vldr	s13, [pc, #300]	@ 2ffc66a0 <HAL_RCC_GetPLL3ClockFreq+0x130>
  pllsource = __HAL_RCC_GET_PLL3_SOURCE();
2ffc6574:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
{
2ffc6578:	b410      	push	{r4}
  pllsource = __HAL_RCC_GET_PLL3_SOURCE();
2ffc657a:	f8d2 1820 	ldr.w	r1, [r2, #2080]	@ 0x820
  pll3m = ((RCC->PLL3CFGR1 & RCC_PLL3CFGR1_DIVM3) >> RCC_PLL3CFGR1_DIVM3_Pos) + 1U;
2ffc657e:	f8d2 4884 	ldr.w	r4, [r2, #2180]	@ 0x884
  pll3fracen = (RCC->PLL3FRACR & RCC_PLL3FRACR_FRACLE) >> RCC_PLL3FRACR_FRACLE_Pos;
2ffc6582:	f8d2 388c 	ldr.w	r3, [r2, #2188]	@ 0x88c
  pllsource = __HAL_RCC_GET_PLL3_SOURCE();
2ffc6586:	f001 0103 	and.w	r1, r1, #3
  pll3m = ((RCC->PLL3CFGR1 & RCC_PLL3CFGR1_DIVM3) >> RCC_PLL3CFGR1_DIVM3_Pos) + 1U;
2ffc658a:	f3c4 4405 	ubfx	r4, r4, #16, #6
  switch (pllsource)
2ffc658e:	2902      	cmp	r1, #2
  pll3fracen = (RCC->PLL3FRACR & RCC_PLL3FRACR_FRACLE) >> RCC_PLL3FRACR_FRACLE_Pos;
2ffc6590:	f3c3 4c00 	ubfx	ip, r3, #16, #1
  pll3m = ((RCC->PLL3CFGR1 & RCC_PLL3CFGR1_DIVM3) >> RCC_PLL3CFGR1_DIVM3_Pos) + 1U;
2ffc6594:	f104 0401 	add.w	r4, r4, #1
  fracn1 = (float)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACV) >> RCC_PLL3FRACR_FRACV_Pos));
2ffc6598:	f8d2 388c 	ldr.w	r3, [r2, #2188]	@ 0x88c
2ffc659c:	f3c3 03cc 	ubfx	r3, r3, #3, #13
2ffc65a0:	fb0c f303 	mul.w	r3, ip, r3
2ffc65a4:	ee07 3a90 	vmov	s15, r3
  pll3vco = (float)((float)((RCC->PLL3CFGR1 & RCC_PLL3CFGR1_DIVN) + 1U) + (fracn1 / (float) 0x2000));  //Intermediary value
2ffc65a8:	f8d2 3884 	ldr.w	r3, [r2, #2180]	@ 0x884
2ffc65ac:	f3c3 0308 	ubfx	r3, r3, #0, #9
  fracn1 = (float)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACV) >> RCC_PLL3FRACR_FRACV_Pos));
2ffc65b0:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  pll3vco = (float)((float)((RCC->PLL3CFGR1 & RCC_PLL3CFGR1_DIVN) + 1U) + (fracn1 / (float) 0x2000));  //Intermediary value
2ffc65b4:	f103 0301 	add.w	r3, r3, #1
2ffc65b8:	ee07 3a90 	vmov	s15, r3
2ffc65bc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2ffc65c0:	eee7 7a26 	vfma.f32	s15, s14, s13
  switch (pllsource)
2ffc65c4:	d051      	beq.n	2ffc666a <HAL_RCC_GetPLL3ClockFreq+0xfa>
2ffc65c6:	2903      	cmp	r1, #3
2ffc65c8:	d04c      	beq.n	2ffc6664 <HAL_RCC_GetPLL3ClockFreq+0xf4>
2ffc65ca:	2901      	cmp	r1, #1
2ffc65cc:	d05a      	beq.n	2ffc6684 <HAL_RCC_GetPLL3ClockFreq+0x114>
  {
    case RCC_PLL3SOURCE_HSI:  /* HSI used as PLL clock source */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIVRDY) != 0U)
2ffc65ce:	f8d2 3808 	ldr.w	r3, [r2, #2056]	@ 0x808
2ffc65d2:	075b      	lsls	r3, r3, #29
      {
        hsivalue = (HSI_VALUE >> __HAL_RCC_GET_HSI_DIV());
2ffc65d4:	bf49      	itett	mi
2ffc65d6:	f44f 4310 	movmi.w	r3, #36864	@ 0x9000
        pll3vco *= (float)(hsivalue / pll3m);
      }
      else
      {
        pll3vco *= (float)(HSI_VALUE / pll3m);
2ffc65da:	f44f 4310 	movpl.w	r3, #36864	@ 0x9000
        hsivalue = (HSI_VALUE >> __HAL_RCC_GET_HSI_DIV());
2ffc65de:	6992      	ldrmi	r2, [r2, #24]
2ffc65e0:	f2c0 33d0 	movtmi	r3, #976	@ 0x3d0
        pll3vco *= (float)(HSI_VALUE / pll3m);
2ffc65e4:	bf52      	itee	pl
2ffc65e6:	f2c0 33d0 	movtpl	r3, #976	@ 0x3d0
        hsivalue = (HSI_VALUE >> __HAL_RCC_GET_HSI_DIV());
2ffc65ea:	f002 0203 	andmi.w	r2, r2, #3
2ffc65ee:	40d3      	lsrmi	r3, r2
        pll3vco *= (float)(HSI_VALUE / pll3m);
2ffc65f0:	fbb3 f3f4 	udiv	r3, r3, r4
2ffc65f4:	ee07 3a10 	vmov	s14, r3
2ffc65f8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc65fc:	ee67 7a27 	vmul.f32	s15, s14, s15
  }

  PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(pll3vco / ((float)(((RCC->PLL3CFGR2 & RCC_PLL3CFGR2_DIVP) >> RCC_PLL3CFGR2_DIVP_Pos) + 1U)));
  PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(pll3vco / ((float)(((RCC->PLL3CFGR2 & RCC_PLL3CFGR2_DIVQ) >> RCC_PLL3CFGR2_DIVQ_Pos) + 1U)));
  PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(pll3vco / ((float)(((RCC->PLL3CFGR2 & RCC_PLL3CFGR2_DIVR) >> RCC_PLL3CFGR2_DIVR_Pos) + 1U)));
}
2ffc6600:	f85d 4b04 	ldr.w	r4, [sp], #4
  PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(pll3vco / ((float)(((RCC->PLL3CFGR2 & RCC_PLL3CFGR2_DIVP) >> RCC_PLL3CFGR2_DIVP_Pos) + 1U)));
2ffc6604:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc6608:	f8d2 3888 	ldr.w	r3, [r2, #2184]	@ 0x888
2ffc660c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
2ffc6610:	3301      	adds	r3, #1
2ffc6612:	ee07 3a10 	vmov	s14, r3
2ffc6616:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc661a:	eec7 6a87 	vdiv.f32	s13, s15, s14
2ffc661e:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2ffc6622:	edc0 6a00 	vstr	s13, [r0]
  PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(pll3vco / ((float)(((RCC->PLL3CFGR2 & RCC_PLL3CFGR2_DIVQ) >> RCC_PLL3CFGR2_DIVQ_Pos) + 1U)));
2ffc6626:	f8d2 3888 	ldr.w	r3, [r2, #2184]	@ 0x888
2ffc662a:	f3c3 2306 	ubfx	r3, r3, #8, #7
2ffc662e:	3301      	adds	r3, #1
2ffc6630:	ee07 3a10 	vmov	s14, r3
2ffc6634:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc6638:	eec7 6a87 	vdiv.f32	s13, s15, s14
2ffc663c:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2ffc6640:	edc0 6a01 	vstr	s13, [r0, #4]
  PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(pll3vco / ((float)(((RCC->PLL3CFGR2 & RCC_PLL3CFGR2_DIVR) >> RCC_PLL3CFGR2_DIVR_Pos) + 1U)));
2ffc6644:	f8d2 3888 	ldr.w	r3, [r2, #2184]	@ 0x888
2ffc6648:	f3c3 4306 	ubfx	r3, r3, #16, #7
2ffc664c:	3301      	adds	r3, #1
2ffc664e:	ee07 3a10 	vmov	s14, r3
2ffc6652:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc6656:	eec7 6a87 	vdiv.f32	s13, s15, s14
2ffc665a:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2ffc665e:	edc0 6a02 	vstr	s13, [r0, #8]
}
2ffc6662:	4770      	bx	lr
  switch (pllsource)
2ffc6664:	eddf 7a0f 	vldr	s15, [pc, #60]	@ 2ffc66a4 <HAL_RCC_GetPLL3ClockFreq+0x134>
2ffc6668:	e7ca      	b.n	2ffc6600 <HAL_RCC_GetPLL3ClockFreq+0x90>
      pll3vco *= (float)(CSI_VALUE / pll3m);
2ffc666a:	f44f 6310 	mov.w	r3, #2304	@ 0x900
2ffc666e:	f2c0 033d 	movt	r3, #61	@ 0x3d
2ffc6672:	fbb3 f3f4 	udiv	r3, r3, r4
2ffc6676:	ee07 3a10 	vmov	s14, r3
2ffc667a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc667e:	ee67 7a27 	vmul.f32	s15, s14, s15
      break;
2ffc6682:	e7bd      	b.n	2ffc6600 <HAL_RCC_GetPLL3ClockFreq+0x90>
      pll3vco *= (float)(HSE_VALUE / pll3m);
2ffc6684:	f44f 5358 	mov.w	r3, #13824	@ 0x3600
2ffc6688:	f2c0 136e 	movt	r3, #366	@ 0x16e
2ffc668c:	fbb3 f3f4 	udiv	r3, r3, r4
2ffc6690:	ee07 3a10 	vmov	s14, r3
2ffc6694:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc6698:	ee67 7a27 	vmul.f32	s15, s14, s15
      break;
2ffc669c:	e7b0      	b.n	2ffc6600 <HAL_RCC_GetPLL3ClockFreq+0x90>
2ffc669e:	bf00      	nop
2ffc66a0:	39000000 	.word	0x39000000
2ffc66a4:	00000000 	.word	0x00000000

2ffc66a8 <HAL_RCC_GetPLL4ClockFreq>:

  pllsource = __HAL_RCC_GET_PLL4_SOURCE();
  pll4m = ((RCC->PLL4CFGR1 & RCC_PLL4CFGR1_DIVM4) >> RCC_PLL4CFGR1_DIVM4_Pos) + 1U;
  pll4fracen = (RCC->PLL4FRACR & RCC_PLL4FRACR_FRACLE) >> RCC_PLL4FRACR_FRACLE_Pos;
  fracn1 = (float)(pll4fracen * ((RCC->PLL4FRACR & RCC_PLL4FRACR_FRACV) >> RCC_PLL4FRACR_FRACV_Pos));
  pll4vco = (float)((float)((RCC->PLL4CFGR1 & RCC_PLL4CFGR1_DIVN) + 1U) + (fracn1 / (float) 0x2000));  //Intermediary value
2ffc66a8:	eddf 6a50 	vldr	s13, [pc, #320]	@ 2ffc67ec <HAL_RCC_GetPLL4ClockFreq+0x144>
  pllsource = __HAL_RCC_GET_PLL4_SOURCE();
2ffc66ac:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
{
2ffc66b0:	b410      	push	{r4}
  pllsource = __HAL_RCC_GET_PLL4_SOURCE();
2ffc66b2:	f8d2 1824 	ldr.w	r1, [r2, #2084]	@ 0x824
  pll4m = ((RCC->PLL4CFGR1 & RCC_PLL4CFGR1_DIVM4) >> RCC_PLL4CFGR1_DIVM4_Pos) + 1U;
2ffc66b6:	f8d2 4898 	ldr.w	r4, [r2, #2200]	@ 0x898
  pll4fracen = (RCC->PLL4FRACR & RCC_PLL4FRACR_FRACLE) >> RCC_PLL4FRACR_FRACLE_Pos;
2ffc66ba:	f8d2 38a0 	ldr.w	r3, [r2, #2208]	@ 0x8a0
  pllsource = __HAL_RCC_GET_PLL4_SOURCE();
2ffc66be:	f001 0103 	and.w	r1, r1, #3
  pll4m = ((RCC->PLL4CFGR1 & RCC_PLL4CFGR1_DIVM4) >> RCC_PLL4CFGR1_DIVM4_Pos) + 1U;
2ffc66c2:	f3c4 4405 	ubfx	r4, r4, #16, #6
  switch (pllsource)
2ffc66c6:	2902      	cmp	r1, #2
  pll4fracen = (RCC->PLL4FRACR & RCC_PLL4FRACR_FRACLE) >> RCC_PLL4FRACR_FRACLE_Pos;
2ffc66c8:	f3c3 4c00 	ubfx	ip, r3, #16, #1
  pll4m = ((RCC->PLL4CFGR1 & RCC_PLL4CFGR1_DIVM4) >> RCC_PLL4CFGR1_DIVM4_Pos) + 1U;
2ffc66cc:	f104 0401 	add.w	r4, r4, #1
  fracn1 = (float)(pll4fracen * ((RCC->PLL4FRACR & RCC_PLL4FRACR_FRACV) >> RCC_PLL4FRACR_FRACV_Pos));
2ffc66d0:	f8d2 38a0 	ldr.w	r3, [r2, #2208]	@ 0x8a0
2ffc66d4:	f3c3 03cc 	ubfx	r3, r3, #3, #13
2ffc66d8:	fb0c f303 	mul.w	r3, ip, r3
2ffc66dc:	ee07 3a90 	vmov	s15, r3
  pll4vco = (float)((float)((RCC->PLL4CFGR1 & RCC_PLL4CFGR1_DIVN) + 1U) + (fracn1 / (float) 0x2000));  //Intermediary value
2ffc66e0:	f8d2 3898 	ldr.w	r3, [r2, #2200]	@ 0x898
2ffc66e4:	f3c3 0308 	ubfx	r3, r3, #0, #9
  fracn1 = (float)(pll4fracen * ((RCC->PLL4FRACR & RCC_PLL4FRACR_FRACV) >> RCC_PLL4FRACR_FRACV_Pos));
2ffc66e8:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  pll4vco = (float)((float)((RCC->PLL4CFGR1 & RCC_PLL4CFGR1_DIVN) + 1U) + (fracn1 / (float) 0x2000));  //Intermediary value
2ffc66ec:	f103 0301 	add.w	r3, r3, #1
2ffc66f0:	ee07 3a90 	vmov	s15, r3
2ffc66f4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2ffc66f8:	eee7 7a26 	vfma.f32	s15, s14, s13
  switch (pllsource)
2ffc66fc:	d04e      	beq.n	2ffc679c <HAL_RCC_GetPLL4ClockFreq+0xf4>
2ffc66fe:	2903      	cmp	r1, #3
2ffc6700:	d066      	beq.n	2ffc67d0 <HAL_RCC_GetPLL4ClockFreq+0x128>
2ffc6702:	2901      	cmp	r1, #1
2ffc6704:	d057      	beq.n	2ffc67b6 <HAL_RCC_GetPLL4ClockFreq+0x10e>
  {
    case RCC_PLL4SOURCE_HSI:  /* HSI used as PLL clock source */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIVRDY) != 0U)
2ffc6706:	f8d2 3808 	ldr.w	r3, [r2, #2056]	@ 0x808
2ffc670a:	075b      	lsls	r3, r3, #29
      {
        hsivalue = (HSI_VALUE >> __HAL_RCC_GET_HSI_DIV());
2ffc670c:	bf49      	itett	mi
2ffc670e:	f44f 4310 	movmi.w	r3, #36864	@ 0x9000
        pll4vco *= (float)(hsivalue / pll4m);
      }
      else
      {
        pll4vco *= (float)(HSI_VALUE / pll4m);
2ffc6712:	f44f 4310 	movpl.w	r3, #36864	@ 0x9000
        hsivalue = (HSI_VALUE >> __HAL_RCC_GET_HSI_DIV());
2ffc6716:	6992      	ldrmi	r2, [r2, #24]
2ffc6718:	f2c0 33d0 	movtmi	r3, #976	@ 0x3d0
        pll4vco *= (float)(HSI_VALUE / pll4m);
2ffc671c:	bf52      	itee	pl
2ffc671e:	f2c0 33d0 	movtpl	r3, #976	@ 0x3d0
        hsivalue = (HSI_VALUE >> __HAL_RCC_GET_HSI_DIV());
2ffc6722:	f002 0203 	andmi.w	r2, r2, #3
2ffc6726:	40d3      	lsrmi	r3, r2
        pll4vco *= (float)(HSI_VALUE / pll4m);
2ffc6728:	fbb3 f3f4 	udiv	r3, r3, r4
2ffc672c:	ee07 3a10 	vmov	s14, r3
2ffc6730:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc6734:	ee67 7a27 	vmul.f32	s15, s14, s15
  }

  PLL4_Clocks->PLL4_P_Frequency = (uint32_t)(pll4vco / ((float)(((RCC->PLL4CFGR2 & RCC_PLL4CFGR2_DIVP) >> RCC_PLL4CFGR2_DIVP_Pos) + 1U)));
  PLL4_Clocks->PLL4_Q_Frequency = (uint32_t)(pll4vco / ((float)(((RCC->PLL4CFGR2 & RCC_PLL4CFGR2_DIVQ) >> RCC_PLL4CFGR2_DIVQ_Pos) + 1U)));
  PLL4_Clocks->PLL4_R_Frequency = (uint32_t)(pll4vco / ((float)(((RCC->PLL4CFGR2 & RCC_PLL4CFGR2_DIVR) >> RCC_PLL4CFGR2_DIVR_Pos) + 1U)));
}
2ffc6738:	f85d 4b04 	ldr.w	r4, [sp], #4
  PLL4_Clocks->PLL4_P_Frequency = (uint32_t)(pll4vco / ((float)(((RCC->PLL4CFGR2 & RCC_PLL4CFGR2_DIVP) >> RCC_PLL4CFGR2_DIVP_Pos) + 1U)));
2ffc673c:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc6740:	f8d2 389c 	ldr.w	r3, [r2, #2204]	@ 0x89c
2ffc6744:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
2ffc6748:	3301      	adds	r3, #1
2ffc674a:	ee07 3a10 	vmov	s14, r3
2ffc674e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc6752:	eec7 6a87 	vdiv.f32	s13, s15, s14
2ffc6756:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2ffc675a:	edc0 6a00 	vstr	s13, [r0]
  PLL4_Clocks->PLL4_Q_Frequency = (uint32_t)(pll4vco / ((float)(((RCC->PLL4CFGR2 & RCC_PLL4CFGR2_DIVQ) >> RCC_PLL4CFGR2_DIVQ_Pos) + 1U)));
2ffc675e:	f8d2 389c 	ldr.w	r3, [r2, #2204]	@ 0x89c
2ffc6762:	f3c3 2306 	ubfx	r3, r3, #8, #7
2ffc6766:	3301      	adds	r3, #1
2ffc6768:	ee07 3a10 	vmov	s14, r3
2ffc676c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc6770:	eec7 6a87 	vdiv.f32	s13, s15, s14
2ffc6774:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2ffc6778:	edc0 6a01 	vstr	s13, [r0, #4]
  PLL4_Clocks->PLL4_R_Frequency = (uint32_t)(pll4vco / ((float)(((RCC->PLL4CFGR2 & RCC_PLL4CFGR2_DIVR) >> RCC_PLL4CFGR2_DIVR_Pos) + 1U)));
2ffc677c:	f8d2 389c 	ldr.w	r3, [r2, #2204]	@ 0x89c
2ffc6780:	f3c3 4306 	ubfx	r3, r3, #16, #7
2ffc6784:	3301      	adds	r3, #1
2ffc6786:	ee07 3a10 	vmov	s14, r3
2ffc678a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc678e:	eec7 6a87 	vdiv.f32	s13, s15, s14
2ffc6792:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2ffc6796:	edc0 6a02 	vstr	s13, [r0, #8]
}
2ffc679a:	4770      	bx	lr
      pll4vco *= (float)(CSI_VALUE / pll4m);
2ffc679c:	f44f 6310 	mov.w	r3, #2304	@ 0x900
2ffc67a0:	f2c0 033d 	movt	r3, #61	@ 0x3d
2ffc67a4:	fbb3 f3f4 	udiv	r3, r3, r4
2ffc67a8:	ee07 3a10 	vmov	s14, r3
2ffc67ac:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc67b0:	ee67 7a27 	vmul.f32	s15, s14, s15
      break;
2ffc67b4:	e7c0      	b.n	2ffc6738 <HAL_RCC_GetPLL4ClockFreq+0x90>
      pll4vco *= (float)(HSE_VALUE / pll4m);
2ffc67b6:	f44f 5358 	mov.w	r3, #13824	@ 0x3600
2ffc67ba:	f2c0 136e 	movt	r3, #366	@ 0x16e
2ffc67be:	fbb3 f3f4 	udiv	r3, r3, r4
2ffc67c2:	ee07 3a10 	vmov	s14, r3
2ffc67c6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc67ca:	ee67 7a27 	vmul.f32	s15, s14, s15
      break;
2ffc67ce:	e7b3      	b.n	2ffc6738 <HAL_RCC_GetPLL4ClockFreq+0x90>
      pll4vco *= (float)(EXTERNAL_CLOCK_VALUE / pll4m);
2ffc67d0:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
2ffc67d4:	f2c0 03bb 	movt	r3, #187	@ 0xbb
2ffc67d8:	fbb3 f3f4 	udiv	r3, r3, r4
2ffc67dc:	ee07 3a10 	vmov	s14, r3
2ffc67e0:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2ffc67e4:	ee67 7a27 	vmul.f32	s15, s14, s15
      break;
2ffc67e8:	e7a6      	b.n	2ffc6738 <HAL_RCC_GetPLL4ClockFreq+0x90>
2ffc67ea:	bf00      	nop
2ffc67ec:	39000000 	.word	0x39000000

2ffc67f0 <HAL_RCC_GetPCLK1Freq>:
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  uint32_t apb1div = 0;

  /* Compute PCLK1 frequency ---------------------------*/
  apb1div = __HAL_RCC_GET_APB1_DIV();
2ffc67f0:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
{
2ffc67f4:	b530      	push	{r4, r5, lr}
2ffc67f6:	b085      	sub	sp, #20
  apb1div = __HAL_RCC_GET_APB1_DIV();
2ffc67f8:	f8d2 4834 	ldr.w	r4, [r2, #2100]	@ 0x834
uint32_t HAL_RCC_GetMCUFreq(void)
{
  uint32_t mcudiv = 0;

  /* Compute MCU frequency ---------------------------*/
  mcudiv = __HAL_RCC_GET_MCU_DIV();
2ffc67fc:	f8d2 5830 	ldr.w	r5, [r2, #2096]	@ 0x830
uint32_t HAL_RCC_GetMCUSSFreq()
{
  uint32_t mcussfreq = 0;
  PLL3_ClocksTypeDef pll3_clocks;

  switch (__HAL_RCC_GET_MCU_SOURCE())
2ffc6800:	6c93      	ldr	r3, [r2, #72]	@ 0x48
  apb1div = __HAL_RCC_GET_APB1_DIV();
2ffc6802:	f004 0407 	and.w	r4, r4, #7
  mcudiv = __HAL_RCC_GET_MCU_DIV();
2ffc6806:	f005 050f 	and.w	r5, r5, #15
  if (apb1div > RCC_APB1_DIV16)
2ffc680a:	2c04      	cmp	r4, #4
  switch (__HAL_RCC_GET_MCU_SOURCE())
2ffc680c:	f003 0303 	and.w	r3, r3, #3
  if (apb1div > RCC_APB1_DIV16)
2ffc6810:	bf28      	it	cs
2ffc6812:	2404      	movcs	r4, #4
  if (mcudiv > RCC_MCU_DIV512)
2ffc6814:	2d09      	cmp	r5, #9
2ffc6816:	bf28      	it	cs
2ffc6818:	2509      	movcs	r5, #9
  switch (__HAL_RCC_GET_MCU_SOURCE())
2ffc681a:	2b02      	cmp	r3, #2
2ffc681c:	d01f      	beq.n	2ffc685e <HAL_RCC_GetPCLK1Freq+0x6e>
2ffc681e:	2b03      	cmp	r3, #3
2ffc6820:	d015      	beq.n	2ffc684e <HAL_RCC_GetPCLK1Freq+0x5e>
2ffc6822:	2b01      	cmp	r3, #1
2ffc6824:	d00b      	beq.n	2ffc683e <HAL_RCC_GetPCLK1Freq+0x4e>
      HAL_RCC_GetPLL3ClockFreq(&pll3_clocks);
      mcussfreq = pll3_clocks.PLL3_P_Frequency;
      break;

    case RCC_MCUSSOURCE_HSI:
      mcussfreq = (HSI_VALUE >> __HAL_RCC_GET_HSI_DIV());
2ffc6826:	6993      	ldr	r3, [r2, #24]
2ffc6828:	f44f 4010 	mov.w	r0, #36864	@ 0x9000
2ffc682c:	f2c0 30d0 	movt	r0, #976	@ 0x3d0
2ffc6830:	f003 0303 	and.w	r3, r3, #3
2ffc6834:	40d8      	lsrs	r0, r3
  return HAL_RCC_GetMCUSSFreq() >> mcudiv;
2ffc6836:	40e8      	lsrs	r0, r5
}
2ffc6838:	40e0      	lsrs	r0, r4
2ffc683a:	b005      	add	sp, #20
2ffc683c:	bd30      	pop	{r4, r5, pc}

      break;

    case RCC_MCUSSOURCE_HSE:
      mcussfreq = HSE_VALUE;
2ffc683e:	f44f 5058 	mov.w	r0, #13824	@ 0x3600
2ffc6842:	f2c0 106e 	movt	r0, #366	@ 0x16e
  return HAL_RCC_GetMCUSSFreq() >> mcudiv;
2ffc6846:	40e8      	lsrs	r0, r5
}
2ffc6848:	40e0      	lsrs	r0, r4
2ffc684a:	b005      	add	sp, #20
2ffc684c:	bd30      	pop	{r4, r5, pc}
      HAL_RCC_GetPLL3ClockFreq(&pll3_clocks);
2ffc684e:	a801      	add	r0, sp, #4
2ffc6850:	f7ff fe8e 	bl	2ffc6570 <HAL_RCC_GetPLL3ClockFreq>
      mcussfreq = pll3_clocks.PLL3_P_Frequency;
2ffc6854:	9801      	ldr	r0, [sp, #4]
  return HAL_RCC_GetMCUSSFreq() >> mcudiv;
2ffc6856:	40e8      	lsrs	r0, r5
}
2ffc6858:	40e0      	lsrs	r0, r4
2ffc685a:	b005      	add	sp, #20
2ffc685c:	bd30      	pop	{r4, r5, pc}
  switch (__HAL_RCC_GET_MCU_SOURCE())
2ffc685e:	f44f 6010 	mov.w	r0, #2304	@ 0x900
2ffc6862:	f2c0 003d 	movt	r0, #61	@ 0x3d
  return HAL_RCC_GetMCUSSFreq() >> mcudiv;
2ffc6866:	40e8      	lsrs	r0, r5
}
2ffc6868:	40e0      	lsrs	r0, r4
2ffc686a:	b005      	add	sp, #20
2ffc686c:	bd30      	pop	{r4, r5, pc}
2ffc686e:	bf00      	nop

2ffc6870 <HAL_RCC_GetPCLK2Freq>:
  apb2div = __HAL_RCC_GET_APB2_DIV();
2ffc6870:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
{
2ffc6874:	b530      	push	{r4, r5, lr}
2ffc6876:	b085      	sub	sp, #20
  apb2div = __HAL_RCC_GET_APB2_DIV();
2ffc6878:	f8d2 4838 	ldr.w	r4, [r2, #2104]	@ 0x838
  mcudiv = __HAL_RCC_GET_MCU_DIV();
2ffc687c:	f8d2 5830 	ldr.w	r5, [r2, #2096]	@ 0x830
  switch (__HAL_RCC_GET_MCU_SOURCE())
2ffc6880:	6c93      	ldr	r3, [r2, #72]	@ 0x48
  apb2div = __HAL_RCC_GET_APB2_DIV();
2ffc6882:	f004 0407 	and.w	r4, r4, #7
  mcudiv = __HAL_RCC_GET_MCU_DIV();
2ffc6886:	f005 050f 	and.w	r5, r5, #15
  if (apb2div > RCC_APB2_DIV16)
2ffc688a:	2c04      	cmp	r4, #4
  switch (__HAL_RCC_GET_MCU_SOURCE())
2ffc688c:	f003 0303 	and.w	r3, r3, #3
  if (apb2div > RCC_APB2_DIV16)
2ffc6890:	bf28      	it	cs
2ffc6892:	2404      	movcs	r4, #4
  if (mcudiv > RCC_MCU_DIV512)
2ffc6894:	2d09      	cmp	r5, #9
2ffc6896:	bf28      	it	cs
2ffc6898:	2509      	movcs	r5, #9
  switch (__HAL_RCC_GET_MCU_SOURCE())
2ffc689a:	2b02      	cmp	r3, #2
2ffc689c:	d01f      	beq.n	2ffc68de <HAL_RCC_GetPCLK2Freq+0x6e>
2ffc689e:	2b03      	cmp	r3, #3
2ffc68a0:	d015      	beq.n	2ffc68ce <HAL_RCC_GetPCLK2Freq+0x5e>
2ffc68a2:	2b01      	cmp	r3, #1
2ffc68a4:	d00b      	beq.n	2ffc68be <HAL_RCC_GetPCLK2Freq+0x4e>
      mcussfreq = (HSI_VALUE >> __HAL_RCC_GET_HSI_DIV());
2ffc68a6:	6993      	ldr	r3, [r2, #24]
2ffc68a8:	f44f 4010 	mov.w	r0, #36864	@ 0x9000
2ffc68ac:	f2c0 30d0 	movt	r0, #976	@ 0x3d0
2ffc68b0:	f003 0303 	and.w	r3, r3, #3
2ffc68b4:	40d8      	lsrs	r0, r3
  return HAL_RCC_GetMCUSSFreq() >> mcudiv;
2ffc68b6:	40e8      	lsrs	r0, r5
}
2ffc68b8:	40e0      	lsrs	r0, r4
2ffc68ba:	b005      	add	sp, #20
2ffc68bc:	bd30      	pop	{r4, r5, pc}
      mcussfreq = HSE_VALUE;
2ffc68be:	f44f 5058 	mov.w	r0, #13824	@ 0x3600
2ffc68c2:	f2c0 106e 	movt	r0, #366	@ 0x16e
  return HAL_RCC_GetMCUSSFreq() >> mcudiv;
2ffc68c6:	40e8      	lsrs	r0, r5
}
2ffc68c8:	40e0      	lsrs	r0, r4
2ffc68ca:	b005      	add	sp, #20
2ffc68cc:	bd30      	pop	{r4, r5, pc}
      HAL_RCC_GetPLL3ClockFreq(&pll3_clocks);
2ffc68ce:	a801      	add	r0, sp, #4
2ffc68d0:	f7ff fe4e 	bl	2ffc6570 <HAL_RCC_GetPLL3ClockFreq>
      mcussfreq = pll3_clocks.PLL3_P_Frequency;
2ffc68d4:	9801      	ldr	r0, [sp, #4]
  return HAL_RCC_GetMCUSSFreq() >> mcudiv;
2ffc68d6:	40e8      	lsrs	r0, r5
}
2ffc68d8:	40e0      	lsrs	r0, r4
2ffc68da:	b005      	add	sp, #20
2ffc68dc:	bd30      	pop	{r4, r5, pc}
  switch (__HAL_RCC_GET_MCU_SOURCE())
2ffc68de:	f44f 6010 	mov.w	r0, #2304	@ 0x900
2ffc68e2:	f2c0 003d 	movt	r0, #61	@ 0x3d
  return HAL_RCC_GetMCUSSFreq() >> mcudiv;
2ffc68e6:	40e8      	lsrs	r0, r5
}
2ffc68e8:	40e0      	lsrs	r0, r4
2ffc68ea:	b005      	add	sp, #20
2ffc68ec:	bd30      	pop	{r4, r5, pc}
2ffc68ee:	bf00      	nop

2ffc68f0 <HAL_RCC_GetMPUSSFreq>:
  switch (__HAL_RCC_GET_MPU_SOURCE())
2ffc68f0:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
{
2ffc68f4:	b510      	push	{r4, lr}
2ffc68f6:	b084      	sub	sp, #16
  switch (__HAL_RCC_GET_MPU_SOURCE())
2ffc68f8:	6a13      	ldr	r3, [r2, #32]
2ffc68fa:	f003 0303 	and.w	r3, r3, #3
2ffc68fe:	2b02      	cmp	r3, #2
2ffc6900:	d019      	beq.n	2ffc6936 <HAL_RCC_GetMPUSSFreq+0x46>
2ffc6902:	2b03      	cmp	r3, #3
2ffc6904:	d01e      	beq.n	2ffc6944 <HAL_RCC_GetMPUSSFreq+0x54>
2ffc6906:	2b01      	cmp	r3, #1
2ffc6908:	d00e      	beq.n	2ffc6928 <HAL_RCC_GetMPUSSFreq+0x38>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIVRDY) != 0U)
2ffc690a:	f8d2 3808 	ldr.w	r3, [r2, #2056]	@ 0x808
2ffc690e:	075b      	lsls	r3, r3, #29
2ffc6910:	d525      	bpl.n	2ffc695e <HAL_RCC_GetMPUSSFreq+0x6e>
        mpussfreq = (HSI_VALUE >> __HAL_RCC_GET_HSI_DIV());
2ffc6912:	6993      	ldr	r3, [r2, #24]
2ffc6914:	f44f 4410 	mov.w	r4, #36864	@ 0x9000
2ffc6918:	f2c0 34d0 	movt	r4, #976	@ 0x3d0
2ffc691c:	f003 0303 	and.w	r3, r3, #3
2ffc6920:	40dc      	lsrs	r4, r3
}
2ffc6922:	4620      	mov	r0, r4
2ffc6924:	b004      	add	sp, #16
2ffc6926:	bd10      	pop	{r4, pc}
  switch (__HAL_RCC_GET_MPU_SOURCE())
2ffc6928:	f44f 5458 	mov.w	r4, #13824	@ 0x3600
2ffc692c:	f2c0 146e 	movt	r4, #366	@ 0x16e
}
2ffc6930:	4620      	mov	r0, r4
2ffc6932:	b004      	add	sp, #16
2ffc6934:	bd10      	pop	{r4, pc}
      HAL_RCC_GetPLL1ClockFreq(&pll1_clocks);
2ffc6936:	a801      	add	r0, sp, #4
2ffc6938:	f7ff fd0a 	bl	2ffc6350 <HAL_RCC_GetPLL1ClockFreq>
      mpussfreq = pll1_clocks.PLL1_P_Frequency;
2ffc693c:	9c01      	ldr	r4, [sp, #4]
}
2ffc693e:	4620      	mov	r0, r4
2ffc6940:	b004      	add	sp, #16
2ffc6942:	bd10      	pop	{r4, pc}
      mpudiv = __HAL_RCC_GET_MPU_DIV();
2ffc6944:	6ad4      	ldr	r4, [r2, #44]	@ 0x2c
      if (mpudiv == RCC_MPU_DIV_OFF)
2ffc6946:	f014 0407 	ands.w	r4, r4, #7
2ffc694a:	d0f1      	beq.n	2ffc6930 <HAL_RCC_GetMPUSSFreq+0x40>
      else if (mpudiv <= RCC_MPU_DIV16)
2ffc694c:	2c04      	cmp	r4, #4
        HAL_RCC_GetPLL1ClockFreq(&pll1_clocks);
2ffc694e:	a801      	add	r0, sp, #4
      else if (mpudiv <= RCC_MPU_DIV16)
2ffc6950:	d80a      	bhi.n	2ffc6968 <HAL_RCC_GetMPUSSFreq+0x78>
        HAL_RCC_GetPLL1ClockFreq(&pll1_clocks);
2ffc6952:	f7ff fcfd 	bl	2ffc6350 <HAL_RCC_GetPLL1ClockFreq>
        mpussfreq = (pll1_clocks.PLL1_P_Frequency >> mpudiv);
2ffc6956:	9b01      	ldr	r3, [sp, #4]
2ffc6958:	fa23 f404 	lsr.w	r4, r3, r4
2ffc695c:	e7e8      	b.n	2ffc6930 <HAL_RCC_GetMPUSSFreq+0x40>
        mpussfreq = HSI_VALUE;
2ffc695e:	f44f 4410 	mov.w	r4, #36864	@ 0x9000
2ffc6962:	f2c0 34d0 	movt	r4, #976	@ 0x3d0
  return mpussfreq;
2ffc6966:	e7e3      	b.n	2ffc6930 <HAL_RCC_GetMPUSSFreq+0x40>
        HAL_RCC_GetPLL1ClockFreq(&pll1_clocks);
2ffc6968:	f7ff fcf2 	bl	2ffc6350 <HAL_RCC_GetPLL1ClockFreq>
        mpussfreq = (pll1_clocks.PLL1_P_Frequency >> 16); /* divided by 16 */
2ffc696c:	f8bd 4006 	ldrh.w	r4, [sp, #6]
  return mpussfreq;
2ffc6970:	e7de      	b.n	2ffc6930 <HAL_RCC_GetMPUSSFreq+0x40>
2ffc6972:	bf00      	nop

2ffc6974 <HAL_RCC_GetSystemCoreClockFreq>:
  return HAL_RCC_GetMPUSSFreq();
2ffc6974:	f7ff bfbc 	b.w	2ffc68f0 <HAL_RCC_GetMPUSSFreq>

2ffc6978 <HAL_RCC_OscConfig>:
  if (RCC_OscInitStruct == NULL)
2ffc6978:	2800      	cmp	r0, #0
2ffc697a:	f000 820a 	beq.w	2ffc6d92 <HAL_RCC_OscConfig+0x41a>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
2ffc697e:	6803      	ldr	r3, [r0, #0]
{
2ffc6980:	b570      	push	{r4, r5, r6, lr}
2ffc6982:	4604      	mov	r4, r0
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
2ffc6984:	07da      	lsls	r2, r3, #31
2ffc6986:	d546      	bpl.n	2ffc6a16 <HAL_RCC_OscConfig+0x9e>
    if (IS_HSE_IN_USE())
2ffc6988:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc698c:	6a0a      	ldr	r2, [r1, #32]
2ffc698e:	f002 0203 	and.w	r2, r2, #3
2ffc6992:	2a01      	cmp	r2, #1
2ffc6994:	f000 81ee 	beq.w	2ffc6d74 <HAL_RCC_OscConfig+0x3fc>
2ffc6998:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc699c:	6a4a      	ldr	r2, [r1, #36]	@ 0x24
2ffc699e:	f002 0207 	and.w	r2, r2, #7
2ffc69a2:	2a01      	cmp	r2, #1
2ffc69a4:	f000 81eb 	beq.w	2ffc6d7e <HAL_RCC_OscConfig+0x406>
2ffc69a8:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc69ac:	6c8a      	ldr	r2, [r1, #72]	@ 0x48
2ffc69ae:	f002 0203 	and.w	r2, r2, #3
2ffc69b2:	2a01      	cmp	r2, #1
2ffc69b4:	f000 81e8 	beq.w	2ffc6d88 <HAL_RCC_OscConfig+0x410>
2ffc69b8:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc69bc:	6a8a      	ldr	r2, [r1, #40]	@ 0x28
2ffc69be:	f002 0203 	and.w	r2, r2, #3
2ffc69c2:	2a01      	cmp	r2, #1
2ffc69c4:	f000 819a 	beq.w	2ffc6cfc <HAL_RCC_OscConfig+0x384>
2ffc69c8:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc69cc:	f8d1 2820 	ldr.w	r2, [r1, #2080]	@ 0x820
2ffc69d0:	f002 0203 	and.w	r2, r2, #3
2ffc69d4:	2a01      	cmp	r2, #1
2ffc69d6:	f000 81f1 	beq.w	2ffc6dbc <HAL_RCC_OscConfig+0x444>
2ffc69da:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc69de:	f8d1 2824 	ldr.w	r2, [r1, #2084]	@ 0x824
2ffc69e2:	f002 0203 	and.w	r2, r2, #3
2ffc69e6:	2a01      	cmp	r2, #1
2ffc69e8:	d10f      	bne.n	2ffc6a0a <HAL_RCC_OscConfig+0x92>
2ffc69ea:	f8d1 2894 	ldr.w	r2, [r1, #2196]	@ 0x894
2ffc69ee:	0791      	lsls	r1, r2, #30
2ffc69f0:	d50b      	bpl.n	2ffc6a0a <HAL_RCC_OscConfig+0x92>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState != RCC_HSE_ON))
2ffc69f2:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc69f6:	f8d2 2808 	ldr.w	r2, [r2, #2056]	@ 0x808
2ffc69fa:	05d2      	lsls	r2, r2, #23
2ffc69fc:	d50b      	bpl.n	2ffc6a16 <HAL_RCC_OscConfig+0x9e>
2ffc69fe:	6862      	ldr	r2, [r4, #4]
2ffc6a00:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
2ffc6a04:	d007      	beq.n	2ffc6a16 <HAL_RCC_OscConfig+0x9e>
    return HAL_ERROR;
2ffc6a06:	2001      	movs	r0, #1
}
2ffc6a08:	bd70      	pop	{r4, r5, r6, pc}
      result = HAL_RCC_HSEConfig(RCC_OscInitStruct->HSEState);
2ffc6a0a:	6860      	ldr	r0, [r4, #4]
2ffc6a0c:	f7ff fa48 	bl	2ffc5ea0 <HAL_RCC_HSEConfig>
      if (result != HAL_OK)
2ffc6a10:	2800      	cmp	r0, #0
2ffc6a12:	d1f9      	bne.n	2ffc6a08 <HAL_RCC_OscConfig+0x90>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
2ffc6a14:	6823      	ldr	r3, [r4, #0]
2ffc6a16:	079e      	lsls	r6, r3, #30
2ffc6a18:	f100 8090 	bmi.w	2ffc6b3c <HAL_RCC_OscConfig+0x1c4>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
2ffc6a1c:	06de      	lsls	r6, r3, #27
2ffc6a1e:	d539      	bpl.n	2ffc6a94 <HAL_RCC_OscConfig+0x11c>
    if (IS_CSI_IN_USE())
2ffc6a20:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc6a24:	f8d1 2820 	ldr.w	r2, [r1, #2080]	@ 0x820
2ffc6a28:	f002 0203 	and.w	r2, r2, #3
2ffc6a2c:	2a02      	cmp	r2, #2
2ffc6a2e:	f000 8170 	beq.w	2ffc6d12 <HAL_RCC_OscConfig+0x39a>
2ffc6a32:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc6a36:	6c8a      	ldr	r2, [r1, #72]	@ 0x48
2ffc6a38:	f002 0203 	and.w	r2, r2, #3
2ffc6a3c:	2a02      	cmp	r2, #2
2ffc6a3e:	f000 8181 	beq.w	2ffc6d44 <HAL_RCC_OscConfig+0x3cc>
2ffc6a42:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc6a46:	f8d1 2824 	ldr.w	r2, [r1, #2084]	@ 0x824
2ffc6a4a:	f002 0203 	and.w	r2, r2, #3
2ffc6a4e:	2a02      	cmp	r2, #2
2ffc6a50:	f000 81ba 	beq.w	2ffc6dc8 <HAL_RCC_OscConfig+0x450>
      if ((RCC_OscInitStruct->CSIState) != RCC_CSI_OFF)
2ffc6a54:	69e3      	ldr	r3, [r4, #28]
2ffc6a56:	2b00      	cmp	r3, #0
2ffc6a58:	f000 819d 	beq.w	2ffc6d96 <HAL_RCC_OscConfig+0x41e>
        __HAL_RCC_CSI_ENABLE();
2ffc6a5c:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc6a60:	68eb      	ldr	r3, [r5, #12]
2ffc6a62:	f043 0310 	orr.w	r3, r3, #16
2ffc6a66:	60eb      	str	r3, [r5, #12]
        tickstart = HAL_GetTick();
2ffc6a68:	f7fc fd70 	bl	2ffc354c <HAL_GetTick>
2ffc6a6c:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == RESET)
2ffc6a6e:	e005      	b.n	2ffc6a7c <HAL_RCC_OscConfig+0x104>
          if ((HAL_GetTick() - tickstart) > CSI_TIMEOUT_VALUE)
2ffc6a70:	f7fc fd6c 	bl	2ffc354c <HAL_GetTick>
2ffc6a74:	1b80      	subs	r0, r0, r6
2ffc6a76:	2864      	cmp	r0, #100	@ 0x64
2ffc6a78:	f200 817a 	bhi.w	2ffc6d70 <HAL_RCC_OscConfig+0x3f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == RESET)
2ffc6a7c:	f8d5 3808 	ldr.w	r3, [r5, #2056]	@ 0x808
2ffc6a80:	06da      	lsls	r2, r3, #27
2ffc6a82:	d5f5      	bpl.n	2ffc6a70 <HAL_RCC_OscConfig+0xf8>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
2ffc6a84:	69eb      	ldr	r3, [r5, #28]
2ffc6a86:	6a22      	ldr	r2, [r4, #32]
2ffc6a88:	f423 53f8 	bic.w	r3, r3, #7936	@ 0x1f00
2ffc6a8c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
2ffc6a90:	61eb      	str	r3, [r5, #28]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
2ffc6a92:	6823      	ldr	r3, [r4, #0]
2ffc6a94:	071d      	lsls	r5, r3, #28
2ffc6a96:	d51a      	bpl.n	2ffc6ace <HAL_RCC_OscConfig+0x156>
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
2ffc6a98:	69a3      	ldr	r3, [r4, #24]
      __HAL_RCC_LSI_ENABLE();
2ffc6a9a:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
2ffc6a9e:	2b00      	cmp	r3, #0
2ffc6aa0:	f000 8118 	beq.w	2ffc6cd4 <HAL_RCC_OscConfig+0x35c>
      __HAL_RCC_LSI_ENABLE();
2ffc6aa4:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
2ffc6aa8:	f043 0301 	orr.w	r3, r3, #1
2ffc6aac:	f8c5 3144 	str.w	r3, [r5, #324]	@ 0x144
      tickstart = HAL_GetTick();
2ffc6ab0:	f7fc fd4c 	bl	2ffc354c <HAL_GetTick>
2ffc6ab4:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
2ffc6ab6:	e005      	b.n	2ffc6ac4 <HAL_RCC_OscConfig+0x14c>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
2ffc6ab8:	f7fc fd48 	bl	2ffc354c <HAL_GetTick>
2ffc6abc:	1b80      	subs	r0, r0, r6
2ffc6abe:	2864      	cmp	r0, #100	@ 0x64
2ffc6ac0:	f200 8156 	bhi.w	2ffc6d70 <HAL_RCC_OscConfig+0x3f8>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
2ffc6ac4:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
2ffc6ac8:	0798      	lsls	r0, r3, #30
2ffc6aca:	d5f5      	bpl.n	2ffc6ab8 <HAL_RCC_OscConfig+0x140>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
2ffc6acc:	6823      	ldr	r3, [r4, #0]
2ffc6ace:	075a      	lsls	r2, r3, #29
2ffc6ad0:	d519      	bpl.n	2ffc6b06 <HAL_RCC_OscConfig+0x18e>
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
2ffc6ad2:	f44f 5580 	mov.w	r5, #4096	@ 0x1000
2ffc6ad6:	f2c5 0500 	movt	r5, #20480	@ 0x5000
2ffc6ada:	682b      	ldr	r3, [r5, #0]
2ffc6adc:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
2ffc6ae0:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
2ffc6ae2:	f7fc fd33 	bl	2ffc354c <HAL_GetTick>
2ffc6ae6:	4606      	mov	r6, r0
    while ((PWR->CR1 & PWR_CR1_DBP) == RESET)
2ffc6ae8:	e005      	b.n	2ffc6af6 <HAL_RCC_OscConfig+0x17e>
      if ((HAL_GetTick() - tickstart) > DBP_TIMEOUT_VALUE)
2ffc6aea:	f7fc fd2f 	bl	2ffc354c <HAL_GetTick>
2ffc6aee:	1b80      	subs	r0, r0, r6
2ffc6af0:	2864      	cmp	r0, #100	@ 0x64
2ffc6af2:	f200 813d 	bhi.w	2ffc6d70 <HAL_RCC_OscConfig+0x3f8>
    while ((PWR->CR1 & PWR_CR1_DBP) == RESET)
2ffc6af6:	682b      	ldr	r3, [r5, #0]
2ffc6af8:	05db      	lsls	r3, r3, #23
2ffc6afa:	d5f6      	bpl.n	2ffc6aea <HAL_RCC_OscConfig+0x172>
    result = HAL_RCC_LSEConfig(RCC_OscInitStruct->LSEState);
2ffc6afc:	68a0      	ldr	r0, [r4, #8]
2ffc6afe:	f7ff fa0d 	bl	2ffc5f1c <HAL_RCC_LSEConfig>
    if (result != HAL_OK)
2ffc6b02:	2800      	cmp	r0, #0
2ffc6b04:	d180      	bne.n	2ffc6a08 <HAL_RCC_OscConfig+0x90>
  result = RCC_PLL1_Config(&(RCC_OscInitStruct->PLL));
2ffc6b06:	f104 0024 	add.w	r0, r4, #36	@ 0x24
2ffc6b0a:	f7ff fa53 	bl	2ffc5fb4 <RCC_PLL1_Config>
  if (result != HAL_OK)
2ffc6b0e:	2800      	cmp	r0, #0
2ffc6b10:	f47f af7a 	bne.w	2ffc6a08 <HAL_RCC_OscConfig+0x90>
  result = RCCEx_PLL2_Config(&(RCC_OscInitStruct->PLL2));
2ffc6b14:	f104 0060 	add.w	r0, r4, #96	@ 0x60
2ffc6b18:	f000 faa2 	bl	2ffc7060 <RCCEx_PLL2_Config>
  if (result != HAL_OK)
2ffc6b1c:	2800      	cmp	r0, #0
2ffc6b1e:	f47f af73 	bne.w	2ffc6a08 <HAL_RCC_OscConfig+0x90>
  result = RCCEx_PLL3_Config(&(RCC_OscInitStruct->PLL3));
2ffc6b22:	f104 009c 	add.w	r0, r4, #156	@ 0x9c
2ffc6b26:	f000 fbab 	bl	2ffc7280 <RCCEx_PLL3_Config>
  if (result != HAL_OK)
2ffc6b2a:	2800      	cmp	r0, #0
2ffc6b2c:	f47f af6c 	bne.w	2ffc6a08 <HAL_RCC_OscConfig+0x90>
  result = RCCEx_PLL4_Config(&(RCC_OscInitStruct->PLL4));
2ffc6b30:	f104 00d8 	add.w	r0, r4, #216	@ 0xd8
}
2ffc6b34:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  result = RCCEx_PLL4_Config(&(RCC_OscInitStruct->PLL4));
2ffc6b38:	f000 bc94 	b.w	2ffc7464 <RCCEx_PLL4_Config>
    if (IS_HSI_IN_USE())
2ffc6b3c:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc6b40:	6a1a      	ldr	r2, [r3, #32]
2ffc6b42:	0795      	lsls	r5, r2, #30
2ffc6b44:	d15e      	bne.n	2ffc6c04 <HAL_RCC_OscConfig+0x28c>
2ffc6b46:	6a1b      	ldr	r3, [r3, #32]
2ffc6b48:	2b00      	cmp	r3, #0
2ffc6b4a:	da5b      	bge.n	2ffc6c04 <HAL_RCC_OscConfig+0x28c>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
2ffc6b4c:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc6b50:	f8d3 3808 	ldr.w	r3, [r3, #2056]	@ 0x808
2ffc6b54:	07de      	lsls	r6, r3, #31
2ffc6b56:	d503      	bpl.n	2ffc6b60 <HAL_RCC_OscConfig+0x1e8>
2ffc6b58:	68e3      	ldr	r3, [r4, #12]
2ffc6b5a:	2b01      	cmp	r3, #1
2ffc6b5c:	f47f af53 	bne.w	2ffc6a06 <HAL_RCC_OscConfig+0x8e>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
2ffc6b60:	6921      	ldr	r1, [r4, #16]
2ffc6b62:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc6b66:	6993      	ldr	r3, [r2, #24]
2ffc6b68:	f423 43fe 	bic.w	r3, r3, #32512	@ 0x7f00
2ffc6b6c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
2ffc6b70:	6193      	str	r3, [r2, #24]
        if (((__HAL_RCC_GET_PLL12_SOURCE() != RCC_PLL12SOURCE_HSI) ||
2ffc6b72:	6a93      	ldr	r3, [r2, #40]	@ 0x28
2ffc6b74:	079d      	lsls	r5, r3, #30
2ffc6b76:	d107      	bne.n	2ffc6b88 <HAL_RCC_OscConfig+0x210>
             ((!__HAL_RCC_GET_FLAG(RCC_FLAG_PLL1RDY)) &&
2ffc6b78:	f8d2 3080 	ldr.w	r3, [r2, #128]	@ 0x80
        if (((__HAL_RCC_GET_PLL12_SOURCE() != RCC_PLL12SOURCE_HSI) ||
2ffc6b7c:	0798      	lsls	r0, r3, #30
2ffc6b7e:	d42d      	bmi.n	2ffc6bdc <HAL_RCC_OscConfig+0x264>
              ((!__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY))))) &&
2ffc6b80:	f8d2 3094 	ldr.w	r3, [r2, #148]	@ 0x94
             ((!__HAL_RCC_GET_FLAG(RCC_FLAG_PLL1RDY)) &&
2ffc6b84:	0799      	lsls	r1, r3, #30
2ffc6b86:	d429      	bmi.n	2ffc6bdc <HAL_RCC_OscConfig+0x264>
            ((__HAL_RCC_GET_PLL3_SOURCE() != RCC_PLL3SOURCE_HSI) ||
2ffc6b88:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc6b8c:	f8d3 2820 	ldr.w	r2, [r3, #2080]	@ 0x820
              ((!__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY))))) &&
2ffc6b90:	0792      	lsls	r2, r2, #30
2ffc6b92:	d103      	bne.n	2ffc6b9c <HAL_RCC_OscConfig+0x224>
             (!__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY))) &&
2ffc6b94:	f8d3 3880 	ldr.w	r3, [r3, #2176]	@ 0x880
            ((__HAL_RCC_GET_PLL3_SOURCE() != RCC_PLL3SOURCE_HSI) ||
2ffc6b98:	079b      	lsls	r3, r3, #30
2ffc6b9a:	d41f      	bmi.n	2ffc6bdc <HAL_RCC_OscConfig+0x264>
            ((__HAL_RCC_GET_PLL4_SOURCE() != RCC_PLL4SOURCE_HSI) ||
2ffc6b9c:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc6ba0:	f8d3 2824 	ldr.w	r2, [r3, #2084]	@ 0x824
             (!__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY))) &&
2ffc6ba4:	0796      	lsls	r6, r2, #30
2ffc6ba6:	d103      	bne.n	2ffc6bb0 <HAL_RCC_OscConfig+0x238>
             (!__HAL_RCC_GET_FLAG(RCC_FLAG_PLL4RDY))))
2ffc6ba8:	f8d3 3894 	ldr.w	r3, [r3, #2196]	@ 0x894
            ((__HAL_RCC_GET_PLL4_SOURCE() != RCC_PLL4SOURCE_HSI) ||
2ffc6bac:	079d      	lsls	r5, r3, #30
2ffc6bae:	d415      	bmi.n	2ffc6bdc <HAL_RCC_OscConfig+0x264>
          __HAL_RCC_HSI_DIV(RCC_OscInitStruct->HSIDivValue);
2ffc6bb0:	6962      	ldr	r2, [r4, #20]
2ffc6bb2:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc6bb6:	69ab      	ldr	r3, [r5, #24]
2ffc6bb8:	f023 0303 	bic.w	r3, r3, #3
2ffc6bbc:	4313      	orrs	r3, r2
2ffc6bbe:	61ab      	str	r3, [r5, #24]
          tickstart = HAL_GetTick();
2ffc6bc0:	f7fc fcc4 	bl	2ffc354c <HAL_GetTick>
2ffc6bc4:	4606      	mov	r6, r0
          while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIVRDY) == RESET)
2ffc6bc6:	e005      	b.n	2ffc6bd4 <HAL_RCC_OscConfig+0x25c>
            if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
2ffc6bc8:	f7fc fcc0 	bl	2ffc354c <HAL_GetTick>
2ffc6bcc:	1b80      	subs	r0, r0, r6
2ffc6bce:	2864      	cmp	r0, #100	@ 0x64
2ffc6bd0:	f200 80ce 	bhi.w	2ffc6d70 <HAL_RCC_OscConfig+0x3f8>
          while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIVRDY) == RESET)
2ffc6bd4:	f8d5 3808 	ldr.w	r3, [r5, #2056]	@ 0x808
2ffc6bd8:	0758      	lsls	r0, r3, #29
2ffc6bda:	d5f5      	bpl.n	2ffc6bc8 <HAL_RCC_OscConfig+0x250>
  return HAL_RCC_GetMPUSSFreq();
2ffc6bdc:	f7ff fe88 	bl	2ffc68f0 <HAL_RCC_GetMPUSSFreq>
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
2ffc6be0:	f241 7218 	movw	r2, #5912	@ 0x1718
        SystemCoreClock =  HAL_RCC_GetSystemCoreClockFreq();
2ffc6be4:	f241 7310 	movw	r3, #5904	@ 0x1710
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
2ffc6be8:	f6c2 72fd 	movt	r2, #12285	@ 0x2ffd
  return HAL_RCC_GetMPUSSFreq();
2ffc6bec:	4601      	mov	r1, r0
        SystemCoreClock =  HAL_RCC_GetSystemCoreClockFreq();
2ffc6bee:	f6c2 73fd 	movt	r3, #12285	@ 0x2ffd
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
2ffc6bf2:	6810      	ldr	r0, [r2, #0]
        SystemCoreClock =  HAL_RCC_GetSystemCoreClockFreq();
2ffc6bf4:	6019      	str	r1, [r3, #0]
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
2ffc6bf6:	f7fc fc77 	bl	2ffc34e8 <HAL_InitTick>
2ffc6bfa:	2800      	cmp	r0, #0
2ffc6bfc:	f47f af03 	bne.w	2ffc6a06 <HAL_RCC_OscConfig+0x8e>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
2ffc6c00:	6823      	ldr	r3, [r4, #0]
2ffc6c02:	e70b      	b.n	2ffc6a1c <HAL_RCC_OscConfig+0xa4>
    if (IS_HSI_IN_USE())
2ffc6c04:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc6c08:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
2ffc6c0a:	0750      	lsls	r0, r2, #29
2ffc6c0c:	d102      	bne.n	2ffc6c14 <HAL_RCC_OscConfig+0x29c>
2ffc6c0e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
2ffc6c10:	2b00      	cmp	r3, #0
2ffc6c12:	db9b      	blt.n	2ffc6b4c <HAL_RCC_OscConfig+0x1d4>
2ffc6c14:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc6c18:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
2ffc6c1a:	0791      	lsls	r1, r2, #30
2ffc6c1c:	d056      	beq.n	2ffc6ccc <HAL_RCC_OscConfig+0x354>
2ffc6c1e:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc6c22:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
2ffc6c24:	0792      	lsls	r2, r2, #30
2ffc6c26:	d107      	bne.n	2ffc6c38 <HAL_RCC_OscConfig+0x2c0>
2ffc6c28:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
2ffc6c2c:	0796      	lsls	r6, r2, #30
2ffc6c2e:	d48d      	bmi.n	2ffc6b4c <HAL_RCC_OscConfig+0x1d4>
2ffc6c30:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
2ffc6c34:	079d      	lsls	r5, r3, #30
2ffc6c36:	d489      	bmi.n	2ffc6b4c <HAL_RCC_OscConfig+0x1d4>
2ffc6c38:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc6c3c:	f8d3 2820 	ldr.w	r2, [r3, #2080]	@ 0x820
2ffc6c40:	0790      	lsls	r0, r2, #30
2ffc6c42:	d104      	bne.n	2ffc6c4e <HAL_RCC_OscConfig+0x2d6>
2ffc6c44:	f8d3 3880 	ldr.w	r3, [r3, #2176]	@ 0x880
2ffc6c48:	0799      	lsls	r1, r3, #30
2ffc6c4a:	f53f af7f 	bmi.w	2ffc6b4c <HAL_RCC_OscConfig+0x1d4>
2ffc6c4e:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc6c52:	f8d3 2824 	ldr.w	r2, [r3, #2084]	@ 0x824
2ffc6c56:	0792      	lsls	r2, r2, #30
2ffc6c58:	d104      	bne.n	2ffc6c64 <HAL_RCC_OscConfig+0x2ec>
2ffc6c5a:	f8d3 3894 	ldr.w	r3, [r3, #2196]	@ 0x894
2ffc6c5e:	079b      	lsls	r3, r3, #30
2ffc6c60:	f53f af74 	bmi.w	2ffc6b4c <HAL_RCC_OscConfig+0x1d4>
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
2ffc6c64:	68e3      	ldr	r3, [r4, #12]
2ffc6c66:	2b00      	cmp	r3, #0
2ffc6c68:	d071      	beq.n	2ffc6d4e <HAL_RCC_OscConfig+0x3d6>
        __HAL_RCC_HSI_ENABLE();
2ffc6c6a:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc6c6e:	68eb      	ldr	r3, [r5, #12]
2ffc6c70:	f043 0301 	orr.w	r3, r3, #1
2ffc6c74:	60eb      	str	r3, [r5, #12]
        tickstart = HAL_GetTick();
2ffc6c76:	f7fc fc69 	bl	2ffc354c <HAL_GetTick>
2ffc6c7a:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
2ffc6c7c:	e004      	b.n	2ffc6c88 <HAL_RCC_OscConfig+0x310>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
2ffc6c7e:	f7fc fc65 	bl	2ffc354c <HAL_GetTick>
2ffc6c82:	1b80      	subs	r0, r0, r6
2ffc6c84:	2864      	cmp	r0, #100	@ 0x64
2ffc6c86:	d873      	bhi.n	2ffc6d70 <HAL_RCC_OscConfig+0x3f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
2ffc6c88:	f8d5 3808 	ldr.w	r3, [r5, #2056]	@ 0x808
2ffc6c8c:	07d9      	lsls	r1, r3, #31
2ffc6c8e:	d5f6      	bpl.n	2ffc6c7e <HAL_RCC_OscConfig+0x306>
        __HAL_RCC_HSI_DIV(RCC_OscInitStruct->HSIDivValue);
2ffc6c90:	69ab      	ldr	r3, [r5, #24]
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIVRDY) == RESET)
2ffc6c92:	f04f 46a0 	mov.w	r6, #1342177280	@ 0x50000000
        __HAL_RCC_HSI_DIV(RCC_OscInitStruct->HSIDivValue);
2ffc6c96:	6962      	ldr	r2, [r4, #20]
2ffc6c98:	f023 0303 	bic.w	r3, r3, #3
2ffc6c9c:	4313      	orrs	r3, r2
2ffc6c9e:	61ab      	str	r3, [r5, #24]
        tickstart = HAL_GetTick();
2ffc6ca0:	f7fc fc54 	bl	2ffc354c <HAL_GetTick>
2ffc6ca4:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIVRDY) == RESET)
2ffc6ca6:	e004      	b.n	2ffc6cb2 <HAL_RCC_OscConfig+0x33a>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
2ffc6ca8:	f7fc fc50 	bl	2ffc354c <HAL_GetTick>
2ffc6cac:	1b40      	subs	r0, r0, r5
2ffc6cae:	2864      	cmp	r0, #100	@ 0x64
2ffc6cb0:	d85e      	bhi.n	2ffc6d70 <HAL_RCC_OscConfig+0x3f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIVRDY) == RESET)
2ffc6cb2:	f8d6 3808 	ldr.w	r3, [r6, #2056]	@ 0x808
2ffc6cb6:	075a      	lsls	r2, r3, #29
2ffc6cb8:	d5f6      	bpl.n	2ffc6ca8 <HAL_RCC_OscConfig+0x330>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
2ffc6cba:	69b3      	ldr	r3, [r6, #24]
2ffc6cbc:	6922      	ldr	r2, [r4, #16]
2ffc6cbe:	f423 43fe 	bic.w	r3, r3, #32512	@ 0x7f00
2ffc6cc2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
2ffc6cc6:	61b3      	str	r3, [r6, #24]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
2ffc6cc8:	6823      	ldr	r3, [r4, #0]
2ffc6cca:	e6a7      	b.n	2ffc6a1c <HAL_RCC_OscConfig+0xa4>
    if (IS_HSI_IN_USE())
2ffc6ccc:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
2ffc6cce:	2b00      	cmp	r3, #0
2ffc6cd0:	daa5      	bge.n	2ffc6c1e <HAL_RCC_OscConfig+0x2a6>
2ffc6cd2:	e73b      	b.n	2ffc6b4c <HAL_RCC_OscConfig+0x1d4>
      __HAL_RCC_LSI_DISABLE();
2ffc6cd4:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
2ffc6cd8:	f023 0301 	bic.w	r3, r3, #1
2ffc6cdc:	f8c5 3144 	str.w	r3, [r5, #324]	@ 0x144
      tickstart = HAL_GetTick();
2ffc6ce0:	f7fc fc34 	bl	2ffc354c <HAL_GetTick>
2ffc6ce4:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
2ffc6ce6:	e004      	b.n	2ffc6cf2 <HAL_RCC_OscConfig+0x37a>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
2ffc6ce8:	f7fc fc30 	bl	2ffc354c <HAL_GetTick>
2ffc6cec:	1b80      	subs	r0, r0, r6
2ffc6cee:	2864      	cmp	r0, #100	@ 0x64
2ffc6cf0:	d83e      	bhi.n	2ffc6d70 <HAL_RCC_OscConfig+0x3f8>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
2ffc6cf2:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
2ffc6cf6:	0799      	lsls	r1, r3, #30
2ffc6cf8:	d4f6      	bmi.n	2ffc6ce8 <HAL_RCC_OscConfig+0x370>
2ffc6cfa:	e6e7      	b.n	2ffc6acc <HAL_RCC_OscConfig+0x154>
    if (IS_HSE_IN_USE())
2ffc6cfc:	f8d1 2080 	ldr.w	r2, [r1, #128]	@ 0x80
2ffc6d00:	0796      	lsls	r6, r2, #30
2ffc6d02:	f53f ae76 	bmi.w	2ffc69f2 <HAL_RCC_OscConfig+0x7a>
2ffc6d06:	f8d1 2094 	ldr.w	r2, [r1, #148]	@ 0x94
2ffc6d0a:	0795      	lsls	r5, r2, #30
2ffc6d0c:	f53f ae71 	bmi.w	2ffc69f2 <HAL_RCC_OscConfig+0x7a>
2ffc6d10:	e65a      	b.n	2ffc69c8 <HAL_RCC_OscConfig+0x50>
    if (IS_CSI_IN_USE())
2ffc6d12:	f8d1 2880 	ldr.w	r2, [r1, #2176]	@ 0x880
2ffc6d16:	0795      	lsls	r5, r2, #30
2ffc6d18:	f57f ae8b 	bpl.w	2ffc6a32 <HAL_RCC_OscConfig+0xba>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != RESET) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
2ffc6d1c:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc6d20:	f8d2 2808 	ldr.w	r2, [r2, #2056]	@ 0x808
2ffc6d24:	06d1      	lsls	r1, r2, #27
2ffc6d26:	d503      	bpl.n	2ffc6d30 <HAL_RCC_OscConfig+0x3b8>
2ffc6d28:	69e2      	ldr	r2, [r4, #28]
2ffc6d2a:	2a10      	cmp	r2, #16
2ffc6d2c:	f47f ae6b 	bne.w	2ffc6a06 <HAL_RCC_OscConfig+0x8e>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
2ffc6d30:	6a20      	ldr	r0, [r4, #32]
2ffc6d32:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc6d36:	69ca      	ldr	r2, [r1, #28]
2ffc6d38:	f422 52f8 	bic.w	r2, r2, #7936	@ 0x1f00
2ffc6d3c:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
2ffc6d40:	61ca      	str	r2, [r1, #28]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != RESET) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
2ffc6d42:	e6a7      	b.n	2ffc6a94 <HAL_RCC_OscConfig+0x11c>
    if (IS_CSI_IN_USE())
2ffc6d44:	6c8a      	ldr	r2, [r1, #72]	@ 0x48
2ffc6d46:	2a00      	cmp	r2, #0
2ffc6d48:	f6bf ae7b 	bge.w	2ffc6a42 <HAL_RCC_OscConfig+0xca>
2ffc6d4c:	e7e6      	b.n	2ffc6d1c <HAL_RCC_OscConfig+0x3a4>
        __HAL_RCC_HSI_DISABLE();
2ffc6d4e:	f04f 46a0 	mov.w	r6, #1342177280	@ 0x50000000
2ffc6d52:	2301      	movs	r3, #1
2ffc6d54:	6133      	str	r3, [r6, #16]
        tickstart = HAL_GetTick();
2ffc6d56:	f7fc fbf9 	bl	2ffc354c <HAL_GetTick>
2ffc6d5a:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
2ffc6d5c:	f8d6 3808 	ldr.w	r3, [r6, #2056]	@ 0x808
2ffc6d60:	07db      	lsls	r3, r3, #31
2ffc6d62:	f57f af4d 	bpl.w	2ffc6c00 <HAL_RCC_OscConfig+0x288>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
2ffc6d66:	f7fc fbf1 	bl	2ffc354c <HAL_GetTick>
2ffc6d6a:	1b40      	subs	r0, r0, r5
2ffc6d6c:	2864      	cmp	r0, #100	@ 0x64
2ffc6d6e:	d9f5      	bls.n	2ffc6d5c <HAL_RCC_OscConfig+0x3e4>
              return HAL_TIMEOUT;
2ffc6d70:	2003      	movs	r0, #3
}
2ffc6d72:	bd70      	pop	{r4, r5, r6, pc}
    if (IS_HSE_IN_USE())
2ffc6d74:	6a0a      	ldr	r2, [r1, #32]
2ffc6d76:	2a00      	cmp	r2, #0
2ffc6d78:	f6bf ae0e 	bge.w	2ffc6998 <HAL_RCC_OscConfig+0x20>
2ffc6d7c:	e639      	b.n	2ffc69f2 <HAL_RCC_OscConfig+0x7a>
2ffc6d7e:	6a4a      	ldr	r2, [r1, #36]	@ 0x24
2ffc6d80:	2a00      	cmp	r2, #0
2ffc6d82:	f6bf ae11 	bge.w	2ffc69a8 <HAL_RCC_OscConfig+0x30>
2ffc6d86:	e634      	b.n	2ffc69f2 <HAL_RCC_OscConfig+0x7a>
2ffc6d88:	6c8a      	ldr	r2, [r1, #72]	@ 0x48
2ffc6d8a:	2a00      	cmp	r2, #0
2ffc6d8c:	f6bf ae14 	bge.w	2ffc69b8 <HAL_RCC_OscConfig+0x40>
2ffc6d90:	e62f      	b.n	2ffc69f2 <HAL_RCC_OscConfig+0x7a>
    return HAL_ERROR;
2ffc6d92:	2001      	movs	r0, #1
}
2ffc6d94:	4770      	bx	lr
        __HAL_RCC_CSI_DISABLE();
2ffc6d96:	f04f 46a0 	mov.w	r6, #1342177280	@ 0x50000000
2ffc6d9a:	2310      	movs	r3, #16
2ffc6d9c:	6133      	str	r3, [r6, #16]
        tickstart = HAL_GetTick();
2ffc6d9e:	f7fc fbd5 	bl	2ffc354c <HAL_GetTick>
2ffc6da2:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != RESET)
2ffc6da4:	e004      	b.n	2ffc6db0 <HAL_RCC_OscConfig+0x438>
          if ((HAL_GetTick() - tickstart) > CSI_TIMEOUT_VALUE)
2ffc6da6:	f7fc fbd1 	bl	2ffc354c <HAL_GetTick>
2ffc6daa:	1b40      	subs	r0, r0, r5
2ffc6dac:	2864      	cmp	r0, #100	@ 0x64
2ffc6dae:	d8df      	bhi.n	2ffc6d70 <HAL_RCC_OscConfig+0x3f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != RESET)
2ffc6db0:	f8d6 3808 	ldr.w	r3, [r6, #2056]	@ 0x808
2ffc6db4:	06db      	lsls	r3, r3, #27
2ffc6db6:	d4f6      	bmi.n	2ffc6da6 <HAL_RCC_OscConfig+0x42e>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
2ffc6db8:	6823      	ldr	r3, [r4, #0]
2ffc6dba:	e66b      	b.n	2ffc6a94 <HAL_RCC_OscConfig+0x11c>
    if (IS_HSE_IN_USE())
2ffc6dbc:	f8d1 2880 	ldr.w	r2, [r1, #2176]	@ 0x880
2ffc6dc0:	0790      	lsls	r0, r2, #30
2ffc6dc2:	f53f ae16 	bmi.w	2ffc69f2 <HAL_RCC_OscConfig+0x7a>
2ffc6dc6:	e608      	b.n	2ffc69da <HAL_RCC_OscConfig+0x62>
    if (IS_CSI_IN_USE())
2ffc6dc8:	f8d1 2894 	ldr.w	r2, [r1, #2196]	@ 0x894
2ffc6dcc:	0790      	lsls	r0, r2, #30
2ffc6dce:	f57f ae41 	bpl.w	2ffc6a54 <HAL_RCC_OscConfig+0xdc>
2ffc6dd2:	e7a3      	b.n	2ffc6d1c <HAL_RCC_OscConfig+0x3a4>

2ffc6dd4 <RCC_MPUConfig>:
{
2ffc6dd4:	b538      	push	{r3, r4, r5, lr}
  switch (RCC_MPUInitStruct->MPU_Clock)
2ffc6dd6:	6803      	ldr	r3, [r0, #0]
2ffc6dd8:	2b03      	cmp	r3, #3
2ffc6dda:	d83a      	bhi.n	2ffc6e52 <RCC_MPUConfig+0x7e>
2ffc6ddc:	e8df f003 	tbb	[pc, r3]
2ffc6de0:	02333b42 	.word	0x02333b42
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL1RDY) == RESET)
2ffc6de4:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc6de8:	f8d1 2080 	ldr.w	r2, [r1, #128]	@ 0x80
2ffc6dec:	0792      	lsls	r2, r2, #30
2ffc6dee:	d530      	bpl.n	2ffc6e52 <RCC_MPUConfig+0x7e>
      __HAL_RCC_MPU_DIV(RCC_MPUInitStruct->MPU_Div);
2ffc6df0:	6aca      	ldr	r2, [r1, #44]	@ 0x2c
2ffc6df2:	6840      	ldr	r0, [r0, #4]
2ffc6df4:	f022 0207 	bic.w	r2, r2, #7
2ffc6df8:	4302      	orrs	r2, r0
2ffc6dfa:	62ca      	str	r2, [r1, #44]	@ 0x2c
  __HAL_RCC_MPU_SOURCE(RCC_MPUInitStruct->MPU_Clock);
2ffc6dfc:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
2ffc6e00:	6a22      	ldr	r2, [r4, #32]
2ffc6e02:	f022 0203 	bic.w	r2, r2, #3
2ffc6e06:	4313      	orrs	r3, r2
2ffc6e08:	6223      	str	r3, [r4, #32]
  tickstart = HAL_GetTick();
2ffc6e0a:	f7fc fb9f 	bl	2ffc354c <HAL_GetTick>
2ffc6e0e:	4605      	mov	r5, r0
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_MPUSRCRDY) == RESET)
2ffc6e10:	e005      	b.n	2ffc6e1e <RCC_MPUConfig+0x4a>
    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
2ffc6e12:	f7fc fb9b 	bl	2ffc354c <HAL_GetTick>
2ffc6e16:	1b40      	subs	r0, r0, r5
2ffc6e18:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
2ffc6e1c:	d829      	bhi.n	2ffc6e72 <RCC_MPUConfig+0x9e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_MPUSRCRDY) == RESET)
2ffc6e1e:	6a23      	ldr	r3, [r4, #32]
2ffc6e20:	2b00      	cmp	r3, #0
2ffc6e22:	daf6      	bge.n	2ffc6e12 <RCC_MPUConfig+0x3e>
  return HAL_RCC_GetMPUSSFreq();
2ffc6e24:	f7ff fd64 	bl	2ffc68f0 <HAL_RCC_GetMPUSSFreq>
  HAL_InitTick(uwTickPrio);
2ffc6e28:	f241 7218 	movw	r2, #5912	@ 0x1718
  SystemCoreClock = HAL_RCC_GetSystemCoreClockFreq();
2ffc6e2c:	f241 7310 	movw	r3, #5904	@ 0x1710
  HAL_InitTick(uwTickPrio);
2ffc6e30:	f6c2 72fd 	movt	r2, #12285	@ 0x2ffd
  return HAL_RCC_GetMPUSSFreq();
2ffc6e34:	4601      	mov	r1, r0
  SystemCoreClock = HAL_RCC_GetSystemCoreClockFreq();
2ffc6e36:	f6c2 73fd 	movt	r3, #12285	@ 0x2ffd
  HAL_InitTick(uwTickPrio);
2ffc6e3a:	6810      	ldr	r0, [r2, #0]
  SystemCoreClock = HAL_RCC_GetSystemCoreClockFreq();
2ffc6e3c:	6019      	str	r1, [r3, #0]
  HAL_InitTick(uwTickPrio);
2ffc6e3e:	f7fc fb53 	bl	2ffc34e8 <HAL_InitTick>
  return HAL_OK;
2ffc6e42:	2000      	movs	r0, #0
}
2ffc6e44:	bd38      	pop	{r3, r4, r5, pc}
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL1RDY) == RESET)
2ffc6e46:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc6e4a:	f8d2 2080 	ldr.w	r2, [r2, #128]	@ 0x80
2ffc6e4e:	0791      	lsls	r1, r2, #30
2ffc6e50:	d4d4      	bmi.n	2ffc6dfc <RCC_MPUConfig+0x28>
        return HAL_ERROR;
2ffc6e52:	2001      	movs	r0, #1
}
2ffc6e54:	bd38      	pop	{r3, r4, r5, pc}
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
2ffc6e56:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc6e5a:	f8d2 2808 	ldr.w	r2, [r2, #2056]	@ 0x808
2ffc6e5e:	05d0      	lsls	r0, r2, #23
2ffc6e60:	d4cc      	bmi.n	2ffc6dfc <RCC_MPUConfig+0x28>
2ffc6e62:	e7f6      	b.n	2ffc6e52 <RCC_MPUConfig+0x7e>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
2ffc6e64:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc6e68:	f8d2 2808 	ldr.w	r2, [r2, #2056]	@ 0x808
2ffc6e6c:	07d4      	lsls	r4, r2, #31
2ffc6e6e:	d4c5      	bmi.n	2ffc6dfc <RCC_MPUConfig+0x28>
2ffc6e70:	e7ef      	b.n	2ffc6e52 <RCC_MPUConfig+0x7e>
      return HAL_TIMEOUT;
2ffc6e72:	2003      	movs	r0, #3
}
2ffc6e74:	bd38      	pop	{r3, r4, r5, pc}
2ffc6e76:	bf00      	nop

2ffc6e78 <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
2ffc6e78:	2800      	cmp	r0, #0
2ffc6e7a:	d061      	beq.n	2ffc6f40 <HAL_RCC_ClockConfig+0xc8>
  if ((RCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_MPU) == RCC_CLOCKTYPE_MPU)
2ffc6e7c:	6803      	ldr	r3, [r0, #0]
{
2ffc6e7e:	b570      	push	{r4, r5, r6, lr}
2ffc6e80:	4604      	mov	r4, r0
  if ((RCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_MPU) == RCC_CLOCKTYPE_MPU)
2ffc6e82:	07d9      	lsls	r1, r3, #31
2ffc6e84:	d423      	bmi.n	2ffc6ece <HAL_RCC_ClockConfig+0x56>
  if ((RCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_ACLK) == RCC_CLOCKTYPE_ACLK)
2ffc6e86:	079a      	lsls	r2, r3, #30
2ffc6e88:	d40e      	bmi.n	2ffc6ea8 <HAL_RCC_ClockConfig+0x30>
  if ((RCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
2ffc6e8a:	075e      	lsls	r6, r3, #29
2ffc6e8c:	d415      	bmi.n	2ffc6eba <HAL_RCC_ClockConfig+0x42>
  if ((RCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
2ffc6e8e:	071d      	lsls	r5, r3, #28
2ffc6e90:	d424      	bmi.n	2ffc6edc <HAL_RCC_ClockConfig+0x64>
  if ((RCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
2ffc6e92:	06d8      	lsls	r0, r3, #27
2ffc6e94:	d456      	bmi.n	2ffc6f44 <HAL_RCC_ClockConfig+0xcc>
  if ((RCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
2ffc6e96:	0699      	lsls	r1, r3, #26
2ffc6e98:	d46b      	bmi.n	2ffc6f72 <HAL_RCC_ClockConfig+0xfa>
  if ((RCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
2ffc6e9a:	065a      	lsls	r2, r3, #25
2ffc6e9c:	f100 8083 	bmi.w	2ffc6fa6 <HAL_RCC_ClockConfig+0x12e>
  if ((RCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_PCLK3) == RCC_CLOCKTYPE_PCLK3)
2ffc6ea0:	061b      	lsls	r3, r3, #24
2ffc6ea2:	d432      	bmi.n	2ffc6f0a <HAL_RCC_ClockConfig+0x92>
  return HAL_OK;
2ffc6ea4:	2000      	movs	r0, #0
}
2ffc6ea6:	bd70      	pop	{r4, r5, r6, pc}
    status = RCC_AXISSConfig(&(RCC_ClkInitStruct->AXISSInit));
2ffc6ea8:	f104 000c 	add.w	r0, r4, #12
2ffc6eac:	f7ff f98a 	bl	2ffc61c4 <RCC_AXISSConfig>
    if (status  != HAL_OK)
2ffc6eb0:	2800      	cmp	r0, #0
2ffc6eb2:	d1f8      	bne.n	2ffc6ea6 <HAL_RCC_ClockConfig+0x2e>
  if ((RCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
2ffc6eb4:	6823      	ldr	r3, [r4, #0]
2ffc6eb6:	075e      	lsls	r6, r3, #29
2ffc6eb8:	d5e9      	bpl.n	2ffc6e8e <HAL_RCC_ClockConfig+0x16>
    status = RCC_MCUConfig(&(RCC_ClkInitStruct->MCUInit));
2ffc6eba:	f104 0014 	add.w	r0, r4, #20
2ffc6ebe:	f7ff f9f1 	bl	2ffc62a4 <RCC_MCUConfig>
    if (status  != HAL_OK)
2ffc6ec2:	2800      	cmp	r0, #0
2ffc6ec4:	d1ef      	bne.n	2ffc6ea6 <HAL_RCC_ClockConfig+0x2e>
  if ((RCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
2ffc6ec6:	6823      	ldr	r3, [r4, #0]
2ffc6ec8:	071d      	lsls	r5, r3, #28
2ffc6eca:	d5e2      	bpl.n	2ffc6e92 <HAL_RCC_ClockConfig+0x1a>
2ffc6ecc:	e006      	b.n	2ffc6edc <HAL_RCC_ClockConfig+0x64>
    status = RCC_MPUConfig(&(RCC_ClkInitStruct->MPUInit));
2ffc6ece:	3004      	adds	r0, #4
2ffc6ed0:	f7ff ff80 	bl	2ffc6dd4 <RCC_MPUConfig>
    if (status  != HAL_OK)
2ffc6ed4:	2800      	cmp	r0, #0
2ffc6ed6:	d1e6      	bne.n	2ffc6ea6 <HAL_RCC_ClockConfig+0x2e>
  if ((RCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_ACLK) == RCC_CLOCKTYPE_ACLK)
2ffc6ed8:	6823      	ldr	r3, [r4, #0]
2ffc6eda:	e7d4      	b.n	2ffc6e86 <HAL_RCC_ClockConfig+0xe>
    __HAL_RCC_APB4_DIV(RCC_ClkInitStruct->APB4_Div);
2ffc6edc:	69e2      	ldr	r2, [r4, #28]
2ffc6ede:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc6ee2:	6beb      	ldr	r3, [r5, #60]	@ 0x3c
2ffc6ee4:	f023 0307 	bic.w	r3, r3, #7
2ffc6ee8:	4313      	orrs	r3, r2
2ffc6eea:	63eb      	str	r3, [r5, #60]	@ 0x3c
    tickstart = HAL_GetTick();
2ffc6eec:	f7fc fb2e 	bl	2ffc354c <HAL_GetTick>
2ffc6ef0:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_APB4DIVRDY) == RESET)
2ffc6ef2:	e005      	b.n	2ffc6f00 <HAL_RCC_ClockConfig+0x88>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
2ffc6ef4:	f7fc fb2a 	bl	2ffc354c <HAL_GetTick>
2ffc6ef8:	1b80      	subs	r0, r0, r6
2ffc6efa:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
2ffc6efe:	d81d      	bhi.n	2ffc6f3c <HAL_RCC_ClockConfig+0xc4>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_APB4DIVRDY) == RESET)
2ffc6f00:	6beb      	ldr	r3, [r5, #60]	@ 0x3c
2ffc6f02:	2b00      	cmp	r3, #0
2ffc6f04:	daf6      	bge.n	2ffc6ef4 <HAL_RCC_ClockConfig+0x7c>
  if ((RCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
2ffc6f06:	6823      	ldr	r3, [r4, #0]
2ffc6f08:	e7c3      	b.n	2ffc6e92 <HAL_RCC_ClockConfig+0x1a>
    __HAL_RCC_APB3_DIV(RCC_ClkInitStruct->APB3_Div);
2ffc6f0a:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
2ffc6f0c:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
2ffc6f10:	f8d4 383c 	ldr.w	r3, [r4, #2108]	@ 0x83c
2ffc6f14:	f023 0307 	bic.w	r3, r3, #7
2ffc6f18:	4313      	orrs	r3, r2
2ffc6f1a:	f8c4 383c 	str.w	r3, [r4, #2108]	@ 0x83c
    tickstart = HAL_GetTick();
2ffc6f1e:	f7fc fb15 	bl	2ffc354c <HAL_GetTick>
2ffc6f22:	4605      	mov	r5, r0
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_APB3DIVRDY) == RESET)
2ffc6f24:	e005      	b.n	2ffc6f32 <HAL_RCC_ClockConfig+0xba>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
2ffc6f26:	f7fc fb11 	bl	2ffc354c <HAL_GetTick>
2ffc6f2a:	1b40      	subs	r0, r0, r5
2ffc6f2c:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
2ffc6f30:	d804      	bhi.n	2ffc6f3c <HAL_RCC_ClockConfig+0xc4>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_APB3DIVRDY) == RESET)
2ffc6f32:	f8d4 383c 	ldr.w	r3, [r4, #2108]	@ 0x83c
2ffc6f36:	2b00      	cmp	r3, #0
2ffc6f38:	daf5      	bge.n	2ffc6f26 <HAL_RCC_ClockConfig+0xae>
2ffc6f3a:	e7b3      	b.n	2ffc6ea4 <HAL_RCC_ClockConfig+0x2c>
        return HAL_TIMEOUT;
2ffc6f3c:	2003      	movs	r0, #3
}
2ffc6f3e:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
2ffc6f40:	2001      	movs	r0, #1
}
2ffc6f42:	4770      	bx	lr
    __HAL_RCC_APB5_DIV(RCC_ClkInitStruct->APB5_Div);
2ffc6f44:	6a22      	ldr	r2, [r4, #32]
2ffc6f46:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc6f4a:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
2ffc6f4c:	f023 0307 	bic.w	r3, r3, #7
2ffc6f50:	4313      	orrs	r3, r2
2ffc6f52:	642b      	str	r3, [r5, #64]	@ 0x40
    tickstart = HAL_GetTick();
2ffc6f54:	f7fc fafa 	bl	2ffc354c <HAL_GetTick>
2ffc6f58:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_APB5DIVRDY) == RESET)
2ffc6f5a:	e005      	b.n	2ffc6f68 <HAL_RCC_ClockConfig+0xf0>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
2ffc6f5c:	f7fc faf6 	bl	2ffc354c <HAL_GetTick>
2ffc6f60:	1b80      	subs	r0, r0, r6
2ffc6f62:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
2ffc6f66:	d8e9      	bhi.n	2ffc6f3c <HAL_RCC_ClockConfig+0xc4>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_APB5DIVRDY) == RESET)
2ffc6f68:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
2ffc6f6a:	2b00      	cmp	r3, #0
2ffc6f6c:	daf6      	bge.n	2ffc6f5c <HAL_RCC_ClockConfig+0xe4>
  if ((RCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
2ffc6f6e:	6823      	ldr	r3, [r4, #0]
2ffc6f70:	e791      	b.n	2ffc6e96 <HAL_RCC_ClockConfig+0x1e>
    __HAL_RCC_APB1_DIV(RCC_ClkInitStruct->APB1_Div);
2ffc6f72:	6a62      	ldr	r2, [r4, #36]	@ 0x24
2ffc6f74:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc6f78:	f8d5 3834 	ldr.w	r3, [r5, #2100]	@ 0x834
2ffc6f7c:	f023 0307 	bic.w	r3, r3, #7
2ffc6f80:	4313      	orrs	r3, r2
2ffc6f82:	f8c5 3834 	str.w	r3, [r5, #2100]	@ 0x834
    tickstart = HAL_GetTick();
2ffc6f86:	f7fc fae1 	bl	2ffc354c <HAL_GetTick>
2ffc6f8a:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_APB1DIVRDY) == RESET)
2ffc6f8c:	e005      	b.n	2ffc6f9a <HAL_RCC_ClockConfig+0x122>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
2ffc6f8e:	f7fc fadd 	bl	2ffc354c <HAL_GetTick>
2ffc6f92:	1b80      	subs	r0, r0, r6
2ffc6f94:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
2ffc6f98:	d8d0      	bhi.n	2ffc6f3c <HAL_RCC_ClockConfig+0xc4>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_APB1DIVRDY) == RESET)
2ffc6f9a:	f8d5 3834 	ldr.w	r3, [r5, #2100]	@ 0x834
2ffc6f9e:	2b00      	cmp	r3, #0
2ffc6fa0:	daf5      	bge.n	2ffc6f8e <HAL_RCC_ClockConfig+0x116>
  if ((RCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
2ffc6fa2:	6823      	ldr	r3, [r4, #0]
2ffc6fa4:	e779      	b.n	2ffc6e9a <HAL_RCC_ClockConfig+0x22>
    __HAL_RCC_APB2_DIV(RCC_ClkInitStruct->APB2_Div);
2ffc6fa6:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
2ffc6fa8:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc6fac:	f8d5 3838 	ldr.w	r3, [r5, #2104]	@ 0x838
2ffc6fb0:	f023 0307 	bic.w	r3, r3, #7
2ffc6fb4:	4313      	orrs	r3, r2
2ffc6fb6:	f8c5 3838 	str.w	r3, [r5, #2104]	@ 0x838
    tickstart = HAL_GetTick();
2ffc6fba:	f7fc fac7 	bl	2ffc354c <HAL_GetTick>
2ffc6fbe:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_APB2DIVRDY) == RESET)
2ffc6fc0:	e005      	b.n	2ffc6fce <HAL_RCC_ClockConfig+0x156>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
2ffc6fc2:	f7fc fac3 	bl	2ffc354c <HAL_GetTick>
2ffc6fc6:	1b80      	subs	r0, r0, r6
2ffc6fc8:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
2ffc6fcc:	d8b6      	bhi.n	2ffc6f3c <HAL_RCC_ClockConfig+0xc4>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_APB2DIVRDY) == RESET)
2ffc6fce:	f8d5 3838 	ldr.w	r3, [r5, #2104]	@ 0x838
2ffc6fd2:	2b00      	cmp	r3, #0
2ffc6fd4:	daf5      	bge.n	2ffc6fc2 <HAL_RCC_ClockConfig+0x14a>
  if ((RCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_PCLK3) == RCC_CLOCKTYPE_PCLK3)
2ffc6fd6:	6823      	ldr	r3, [r4, #0]
2ffc6fd8:	e762      	b.n	2ffc6ea0 <HAL_RCC_ClockConfig+0x28>
2ffc6fda:	bf00      	nop

2ffc6fdc <HAL_RCC_GetAXISSFreq>:
  switch (__HAL_RCC_GET_AXIS_SOURCE())
2ffc6fdc:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc6fe0:	6a53      	ldr	r3, [r2, #36]	@ 0x24
2ffc6fe2:	f003 0307 	and.w	r3, r3, #7
2ffc6fe6:	2b01      	cmp	r3, #1
2ffc6fe8:	d004      	beq.n	2ffc6ff4 <HAL_RCC_GetAXISSFreq+0x18>
2ffc6fea:	2b02      	cmp	r3, #2
2ffc6fec:	d014      	beq.n	2ffc7018 <HAL_RCC_GetAXISSFreq+0x3c>
2ffc6fee:	b133      	cbz	r3, 2ffc6ffe <HAL_RCC_GetAXISSFreq+0x22>
2ffc6ff0:	2000      	movs	r0, #0
2ffc6ff2:	4770      	bx	lr
      axissfreq = HSE_VALUE;
2ffc6ff4:	f44f 5058 	mov.w	r0, #13824	@ 0x3600
2ffc6ff8:	f2c0 106e 	movt	r0, #366	@ 0x16e
2ffc6ffc:	4770      	bx	lr
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIVRDY) != 0U)
2ffc6ffe:	f8d2 3808 	ldr.w	r3, [r2, #2056]	@ 0x808
2ffc7002:	075b      	lsls	r3, r3, #29
2ffc7004:	d511      	bpl.n	2ffc702a <HAL_RCC_GetAXISSFreq+0x4e>
        axissfreq = (HSI_VALUE >> __HAL_RCC_GET_HSI_DIV());
2ffc7006:	6993      	ldr	r3, [r2, #24]
2ffc7008:	f44f 4010 	mov.w	r0, #36864	@ 0x9000
2ffc700c:	f2c0 30d0 	movt	r0, #976	@ 0x3d0
2ffc7010:	f003 0303 	and.w	r3, r3, #3
2ffc7014:	40d8      	lsrs	r0, r3
  return axissfreq;
2ffc7016:	4770      	bx	lr
{
2ffc7018:	b500      	push	{lr}
2ffc701a:	b085      	sub	sp, #20
      HAL_RCC_GetPLL2ClockFreq(&pll2_clocks);
2ffc701c:	a801      	add	r0, sp, #4
2ffc701e:	f7ff fa1f 	bl	2ffc6460 <HAL_RCC_GetPLL2ClockFreq>
      axissfreq = pll2_clocks.PLL2_P_Frequency;
2ffc7022:	9801      	ldr	r0, [sp, #4]
}
2ffc7024:	b005      	add	sp, #20
2ffc7026:	f85d fb04 	ldr.w	pc, [sp], #4
        axissfreq = HSI_VALUE;
2ffc702a:	f44f 4010 	mov.w	r0, #36864	@ 0x9000
2ffc702e:	f2c0 30d0 	movt	r0, #976	@ 0x3d0
}
2ffc7032:	4770      	bx	lr

2ffc7034 <HAL_RCC_GetPCLK5Freq>:
{
2ffc7034:	b538      	push	{r3, r4, r5, lr}
  apb5div = __HAL_RCC_GET_APB5_DIV();
2ffc7036:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc703a:	6c1c      	ldr	r4, [r3, #64]	@ 0x40
  axidiv = __HAL_RCC_GET_AXI_DIV();
2ffc703c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
  apb5div = __HAL_RCC_GET_APB5_DIV();
2ffc703e:	f004 0407 	and.w	r4, r4, #7
  if (apb5div > RCC_APB5_DIV16)
2ffc7042:	2c04      	cmp	r4, #4
2ffc7044:	bf28      	it	cs
2ffc7046:	2404      	movcs	r4, #4
  if (axidiv > RCC_AXI_DIV4)
2ffc7048:	075a      	lsls	r2, r3, #29
  axidiv = __HAL_RCC_GET_AXI_DIV();
2ffc704a:	bf56      	itet	pl
2ffc704c:	f003 0307 	andpl.w	r3, r3, #7
2ffc7050:	2504      	movmi	r5, #4
  axidiv += 1;
2ffc7052:	1c5d      	addpl	r5, r3, #1
  return HAL_RCC_GetAXISSFreq() / axidiv;
2ffc7054:	f7ff ffc2 	bl	2ffc6fdc <HAL_RCC_GetAXISSFreq>
2ffc7058:	fbb0 f0f5 	udiv	r0, r0, r5
}
2ffc705c:	40e0      	lsrs	r0, r4
2ffc705e:	bd38      	pop	{r3, r4, r5, pc}

2ffc7060 <RCCEx_PLL2_Config>:
{
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_RCC_PLL(pll2->PLLState));
  if ((pll2->PLLState) != RCC_PLL_NONE)
2ffc7060:	6803      	ldr	r3, [r0, #0]
2ffc7062:	b90b      	cbnz	r3, 2ffc7068 <RCCEx_PLL2_Config+0x8>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
2ffc7064:	2000      	movs	r0, #0

}
2ffc7066:	4770      	bx	lr
    if (!__IS_PLL2_IN_USE()) /* If not used then */
2ffc7068:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
{
2ffc706c:	b570      	push	{r4, r5, r6, lr}
2ffc706e:	4604      	mov	r4, r0
    if (!__IS_PLL2_IN_USE()) /* If not used then */
2ffc7070:	6a4a      	ldr	r2, [r1, #36]	@ 0x24
2ffc7072:	f002 0207 	and.w	r2, r2, #7
2ffc7076:	2a02      	cmp	r2, #2
2ffc7078:	f000 80c3 	beq.w	2ffc7202 <RCCEx_PLL2_Config+0x1a2>
      if ((pll2->PLLState) == RCC_PLL_ON)
2ffc707c:	2b02      	cmp	r3, #2
2ffc707e:	d10b      	bne.n	2ffc7098 <RCCEx_PLL2_Config+0x38>
        if ((__HAL_RCC_GET_PLL12_SOURCE() != RCC_PLL12SOURCE_HSI) &&
2ffc7080:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc7084:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
2ffc7086:	0790      	lsls	r0, r2, #30
2ffc7088:	d025      	beq.n	2ffc70d6 <RCCEx_PLL2_Config+0x76>
            (__HAL_RCC_GET_PLL12_SOURCE() != RCC_PLL12SOURCE_HSE))
2ffc708a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
2ffc708c:	f003 0303 	and.w	r3, r3, #3
        if ((__HAL_RCC_GET_PLL12_SOURCE() != RCC_PLL12SOURCE_HSI) &&
2ffc7090:	2b01      	cmp	r3, #1
2ffc7092:	d020      	beq.n	2ffc70d6 <RCCEx_PLL2_Config+0x76>
          return HAL_ERROR;
2ffc7094:	2001      	movs	r0, #1
}
2ffc7096:	bd70      	pop	{r4, r5, r6, pc}
        __HAL_RCC_PLL2CLKOUT_DISABLE(RCC_PLL2_DIVP | RCC_PLL2_DIVQ | RCC_PLL2_DIVR);
2ffc7098:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc709c:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
2ffc70a0:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
2ffc70a4:	f8c5 3094 	str.w	r3, [r5, #148]	@ 0x94
        __HAL_RCC_PLL2_DISABLE();
2ffc70a8:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
2ffc70ac:	f023 0301 	bic.w	r3, r3, #1
2ffc70b0:	f8c5 3094 	str.w	r3, [r5, #148]	@ 0x94
        tickstart = HAL_GetTick();
2ffc70b4:	f7fc fa4a 	bl	2ffc354c <HAL_GetTick>
2ffc70b8:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != RESET)
2ffc70ba:	e004      	b.n	2ffc70c6 <RCCEx_PLL2_Config+0x66>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc70bc:	f7fc fa46 	bl	2ffc354c <HAL_GetTick>
2ffc70c0:	1b00      	subs	r0, r0, r4
2ffc70c2:	2864      	cmp	r0, #100	@ 0x64
2ffc70c4:	d805      	bhi.n	2ffc70d2 <RCCEx_PLL2_Config+0x72>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != RESET)
2ffc70c6:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
2ffc70ca:	079b      	lsls	r3, r3, #30
2ffc70cc:	d4f6      	bmi.n	2ffc70bc <RCCEx_PLL2_Config+0x5c>
  return HAL_OK;
2ffc70ce:	2000      	movs	r0, #0
}
2ffc70d0:	bd70      	pop	{r4, r5, r6, pc}
            return HAL_TIMEOUT;
2ffc70d2:	2003      	movs	r0, #3
}
2ffc70d4:	bd70      	pop	{r4, r5, r6, pc}
        __HAL_RCC_PLL2CLKOUT_DISABLE(RCC_PLL2_DIVP | RCC_PLL2_DIVQ | RCC_PLL2_DIVR);
2ffc70d6:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc70da:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
2ffc70de:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
2ffc70e2:	f8c5 3094 	str.w	r3, [r5, #148]	@ 0x94
        __HAL_RCC_PLL2_DISABLE();
2ffc70e6:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
2ffc70ea:	f023 0301 	bic.w	r3, r3, #1
2ffc70ee:	f8c5 3094 	str.w	r3, [r5, #148]	@ 0x94
        tickstart = HAL_GetTick();
2ffc70f2:	f7fc fa2b 	bl	2ffc354c <HAL_GetTick>
2ffc70f6:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != RESET)
2ffc70f8:	e004      	b.n	2ffc7104 <RCCEx_PLL2_Config+0xa4>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc70fa:	f7fc fa27 	bl	2ffc354c <HAL_GetTick>
2ffc70fe:	1b83      	subs	r3, r0, r6
2ffc7100:	2b64      	cmp	r3, #100	@ 0x64
2ffc7102:	d8e6      	bhi.n	2ffc70d2 <RCCEx_PLL2_Config+0x72>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != RESET)
2ffc7104:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
2ffc7108:	0799      	lsls	r1, r3, #30
2ffc710a:	d4f6      	bmi.n	2ffc70fa <RCCEx_PLL2_Config+0x9a>
        if (__IS_PLL1_IN_USE())
2ffc710c:	6a2b      	ldr	r3, [r5, #32]
2ffc710e:	f003 0303 	and.w	r3, r3, #3
2ffc7112:	2b02      	cmp	r3, #2
2ffc7114:	f000 80ae 	beq.w	2ffc7274 <RCCEx_PLL2_Config+0x214>
2ffc7118:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc711c:	6a13      	ldr	r3, [r2, #32]
2ffc711e:	f003 0303 	and.w	r3, r3, #3
2ffc7122:	2b03      	cmp	r3, #3
2ffc7124:	f000 8098 	beq.w	2ffc7258 <RCCEx_PLL2_Config+0x1f8>
          __HAL_RCC_PLL12_SOURCE(pll2->PLLSource);
2ffc7128:	6861      	ldr	r1, [r4, #4]
2ffc712a:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc712e:	6a93      	ldr	r3, [r2, #40]	@ 0x28
2ffc7130:	f023 0303 	bic.w	r3, r3, #3
2ffc7134:	430b      	orrs	r3, r1
2ffc7136:	6293      	str	r3, [r2, #40]	@ 0x28
        __HAL_RCC_PLL2_CONFIG(
2ffc7138:	68e2      	ldr	r2, [r4, #12]
2ffc713a:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc713e:	f44f 417e 	mov.w	r1, #65024	@ 0xfe00
2ffc7142:	f8d3 0098 	ldr.w	r0, [r3, #152]	@ 0x98
2ffc7146:	3a01      	subs	r2, #1
2ffc7148:	f6cf 71c0 	movt	r1, #65472	@ 0xffc0
2ffc714c:	4001      	ands	r1, r0
2ffc714e:	68a0      	ldr	r0, [r4, #8]
2ffc7150:	430a      	orrs	r2, r1
2ffc7152:	3801      	subs	r0, #1
2ffc7154:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
2ffc7158:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
2ffc715c:	f8d3 109c 	ldr.w	r1, [r3, #156]	@ 0x9c
2ffc7160:	e9d4 2004 	ldrd	r2, r0, [r4, #16]
2ffc7164:	f021 117f 	bic.w	r1, r1, #8323199	@ 0x7f007f
2ffc7168:	f421 41fe 	bic.w	r1, r1, #32512	@ 0x7f00
2ffc716c:	3a01      	subs	r2, #1
2ffc716e:	430a      	orrs	r2, r1
2ffc7170:	3801      	subs	r0, #1
2ffc7172:	69a1      	ldr	r1, [r4, #24]
2ffc7174:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
2ffc7178:	3901      	subs	r1, #1
2ffc717a:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
2ffc717e:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
        __HAL_RCC_PLL2FRACV_DISABLE(); //Set FRACLE to 0
2ffc7182:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
2ffc7186:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
2ffc718a:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
        if ((pll2->PLLMODE == RCC_PLL_SPREAD_SPECTRUM) || (pll2->PLLMODE == RCC_PLL_INTEGER))
2ffc718e:	6a61      	ldr	r1, [r4, #36]	@ 0x24
2ffc7190:	f031 0202 	bics.w	r2, r1, #2
          __HAL_RCC_PLL2FRACV_CONFIG(0); //Set FRACV to '0'
2ffc7194:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
        if ((pll2->PLLMODE == RCC_PLL_SPREAD_SPECTRUM) || (pll2->PLLMODE == RCC_PLL_INTEGER))
2ffc7198:	d038      	beq.n	2ffc720c <RCCEx_PLL2_Config+0x1ac>
          __HAL_RCC_PLL2FRACV_CONFIG(pll2->PLLFRACV);
2ffc719a:	6a21      	ldr	r1, [r4, #32]
2ffc719c:	f422 427f 	bic.w	r2, r2, #65280	@ 0xff00
2ffc71a0:	f022 02f8 	bic.w	r2, r2, #248	@ 0xf8
2ffc71a4:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
2ffc71a8:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
        __HAL_RCC_PLL2FRACV_ENABLE(); //Set FRACLE to 1
2ffc71ac:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
2ffc71b0:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
2ffc71b4:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
          __HAL_RCC_PLL2_SSMODE_DISABLE();
2ffc71b8:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc71bc:	f8d2 3094 	ldr.w	r3, [r2, #148]	@ 0x94
2ffc71c0:	f023 0304 	bic.w	r3, r3, #4
2ffc71c4:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
        __HAL_RCC_PLL2_ENABLE();
2ffc71c8:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
2ffc71cc:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94
2ffc71d0:	f043 0301 	orr.w	r3, r3, #1
2ffc71d4:	f8c4 3094 	str.w	r3, [r4, #148]	@ 0x94
        tickstart = HAL_GetTick();
2ffc71d8:	f7fc f9b8 	bl	2ffc354c <HAL_GetTick>
2ffc71dc:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == RESET)
2ffc71de:	e005      	b.n	2ffc71ec <RCCEx_PLL2_Config+0x18c>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc71e0:	f7fc f9b4 	bl	2ffc354c <HAL_GetTick>
2ffc71e4:	1b40      	subs	r0, r0, r5
2ffc71e6:	2864      	cmp	r0, #100	@ 0x64
2ffc71e8:	f63f af73 	bhi.w	2ffc70d2 <RCCEx_PLL2_Config+0x72>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == RESET)
2ffc71ec:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94
2ffc71f0:	079a      	lsls	r2, r3, #30
2ffc71f2:	d5f5      	bpl.n	2ffc71e0 <RCCEx_PLL2_Config+0x180>
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP | RCC_PLL2_DIVQ | RCC_PLL2_DIVR);
2ffc71f4:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94
2ffc71f8:	f043 0370 	orr.w	r3, r3, #112	@ 0x70
2ffc71fc:	f8c4 3094 	str.w	r3, [r4, #148]	@ 0x94
2ffc7200:	e765      	b.n	2ffc70ce <RCCEx_PLL2_Config+0x6e>
    if (!__IS_PLL2_IN_USE()) /* If not used then */
2ffc7202:	6a4a      	ldr	r2, [r1, #36]	@ 0x24
2ffc7204:	2a00      	cmp	r2, #0
2ffc7206:	f6bf af39 	bge.w	2ffc707c <RCCEx_PLL2_Config+0x1c>
2ffc720a:	e743      	b.n	2ffc7094 <RCCEx_PLL2_Config+0x34>
          __HAL_RCC_PLL2FRACV_CONFIG(0); //Set FRACV to '0'
2ffc720c:	f422 427f 	bic.w	r2, r2, #65280	@ 0xff00
        if (pll2->PLLMODE == RCC_PLL_SPREAD_SPECTRUM)
2ffc7210:	2902      	cmp	r1, #2
          __HAL_RCC_PLL2FRACV_CONFIG(0); //Set FRACV to '0'
2ffc7212:	f022 02f8 	bic.w	r2, r2, #248	@ 0xf8
2ffc7216:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
        __HAL_RCC_PLL2FRACV_ENABLE(); //Set FRACLE to 1
2ffc721a:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
2ffc721e:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
2ffc7222:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
        if (pll2->PLLMODE == RCC_PLL_SPREAD_SPECTRUM)
2ffc7226:	d1c7      	bne.n	2ffc71b8 <RCCEx_PLL2_Config+0x158>
          __HAL_RCC_PLL2CSGCONFIG(pll2->MOD_PER, pll2->TPDFN_DIS, pll2->RPDFN_DIS,
2ffc7228:	f8d3 10a4 	ldr.w	r1, [r3, #164]	@ 0xa4
2ffc722c:	6b20      	ldr	r0, [r4, #48]	@ 0x30
2ffc722e:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
2ffc7230:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
2ffc7234:	6ae5      	ldr	r5, [r4, #44]	@ 0x2c
2ffc7236:	4302      	orrs	r2, r0
2ffc7238:	430a      	orrs	r2, r1
2ffc723a:	6b60      	ldr	r0, [r4, #52]	@ 0x34
2ffc723c:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
2ffc723e:	432a      	orrs	r2, r5
2ffc7240:	4302      	orrs	r2, r0
2ffc7242:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
2ffc7246:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
          __HAL_RCC_PLL2_SSMODE_ENABLE();
2ffc724a:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
2ffc724e:	f042 0204 	orr.w	r2, r2, #4
2ffc7252:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
2ffc7256:	e7b7      	b.n	2ffc71c8 <RCCEx_PLL2_Config+0x168>
        if (__IS_PLL1_IN_USE())
2ffc7258:	6a13      	ldr	r3, [r2, #32]
2ffc725a:	2b00      	cmp	r3, #0
2ffc725c:	f6bf af64 	bge.w	2ffc7128 <RCCEx_PLL2_Config+0xc8>
          if (pll2->PLLSource != __HAL_RCC_GET_PLL12_SOURCE())
2ffc7260:	6862      	ldr	r2, [r4, #4]
2ffc7262:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc7266:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
2ffc7268:	f003 0303 	and.w	r3, r3, #3
2ffc726c:	429a      	cmp	r2, r3
2ffc726e:	f47f af11 	bne.w	2ffc7094 <RCCEx_PLL2_Config+0x34>
2ffc7272:	e761      	b.n	2ffc7138 <RCCEx_PLL2_Config+0xd8>
        if (__IS_PLL1_IN_USE())
2ffc7274:	6a2b      	ldr	r3, [r5, #32]
2ffc7276:	2b00      	cmp	r3, #0
2ffc7278:	f6bf af4e 	bge.w	2ffc7118 <RCCEx_PLL2_Config+0xb8>
2ffc727c:	e7f0      	b.n	2ffc7260 <RCCEx_PLL2_Config+0x200>
2ffc727e:	bf00      	nop

2ffc7280 <RCCEx_PLL3_Config>:
  * @param  pll3: pointer to a RCC_PLLInitTypeDef structure
  *
  * @retval HAL status
  */
HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLLInitTypeDef *pll3)
{
2ffc7280:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_RCC_PLL(pll3->PLLState));
  if ((pll3->PLLState) != RCC_PLL_NONE)
2ffc7282:	6803      	ldr	r3, [r0, #0]
2ffc7284:	b90b      	cbnz	r3, 2ffc728a <RCCEx_PLL3_Config+0xa>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
2ffc7286:	2000      	movs	r0, #0
}
2ffc7288:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (!__IS_PLL3_IN_USE()) /* If not used then*/
2ffc728a:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc728e:	4604      	mov	r4, r0
2ffc7290:	6c8a      	ldr	r2, [r1, #72]	@ 0x48
2ffc7292:	f002 0203 	and.w	r2, r2, #3
2ffc7296:	2a03      	cmp	r2, #3
2ffc7298:	d01d      	beq.n	2ffc72d6 <RCCEx_PLL3_Config+0x56>
      if ((pll3->PLLState) == RCC_PLL_ON)
2ffc729a:	2b02      	cmp	r3, #2
2ffc729c:	d022      	beq.n	2ffc72e4 <RCCEx_PLL3_Config+0x64>
        __HAL_RCC_PLL3CLKOUT_DISABLE(RCC_PLL3_DIVP | RCC_PLL3_DIVQ | RCC_PLL3_DIVR);
2ffc729e:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
2ffc72a2:	f8d4 3880 	ldr.w	r3, [r4, #2176]	@ 0x880
2ffc72a6:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
2ffc72aa:	f8c4 3880 	str.w	r3, [r4, #2176]	@ 0x880
        __HAL_RCC_PLL3_DISABLE();
2ffc72ae:	f8d4 3880 	ldr.w	r3, [r4, #2176]	@ 0x880
2ffc72b2:	f023 0301 	bic.w	r3, r3, #1
2ffc72b6:	f8c4 3880 	str.w	r3, [r4, #2176]	@ 0x880
        tickstart = HAL_GetTick();
2ffc72ba:	f7fc f947 	bl	2ffc354c <HAL_GetTick>
2ffc72be:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != RESET)
2ffc72c0:	f8d4 3880 	ldr.w	r3, [r4, #2176]	@ 0x880
2ffc72c4:	079b      	lsls	r3, r3, #30
2ffc72c6:	d5de      	bpl.n	2ffc7286 <RCCEx_PLL3_Config+0x6>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc72c8:	f7fc f940 	bl	2ffc354c <HAL_GetTick>
2ffc72cc:	1b40      	subs	r0, r0, r5
2ffc72ce:	2864      	cmp	r0, #100	@ 0x64
2ffc72d0:	d9f6      	bls.n	2ffc72c0 <RCCEx_PLL3_Config+0x40>
            return HAL_TIMEOUT;
2ffc72d2:	2003      	movs	r0, #3
}
2ffc72d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (!__IS_PLL3_IN_USE()) /* If not used then*/
2ffc72d6:	6c8a      	ldr	r2, [r1, #72]	@ 0x48
2ffc72d8:	2a00      	cmp	r2, #0
      return HAL_ERROR;
2ffc72da:	bfb8      	it	lt
2ffc72dc:	2001      	movlt	r0, #1
    if (!__IS_PLL3_IN_USE()) /* If not used then*/
2ffc72de:	dbd3      	blt.n	2ffc7288 <RCCEx_PLL3_Config+0x8>
      if ((pll3->PLLState) == RCC_PLL_ON)
2ffc72e0:	2b02      	cmp	r3, #2
2ffc72e2:	d1dc      	bne.n	2ffc729e <RCCEx_PLL3_Config+0x1e>
        __HAL_RCC_PLL3CLKOUT_DISABLE(RCC_PLL3_DIVP | RCC_PLL3_DIVQ | RCC_PLL3_DIVR);
2ffc72e4:	f04f 46a0 	mov.w	r6, #1342177280	@ 0x50000000
2ffc72e8:	f8d6 3880 	ldr.w	r3, [r6, #2176]	@ 0x880
2ffc72ec:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
2ffc72f0:	f8c6 3880 	str.w	r3, [r6, #2176]	@ 0x880
        __HAL_RCC_PLL3_DISABLE();
2ffc72f4:	f8d6 3880 	ldr.w	r3, [r6, #2176]	@ 0x880
2ffc72f8:	f023 0301 	bic.w	r3, r3, #1
2ffc72fc:	f8c6 3880 	str.w	r3, [r6, #2176]	@ 0x880
        tickstart = HAL_GetTick();
2ffc7300:	f7fc f924 	bl	2ffc354c <HAL_GetTick>
2ffc7304:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != RESET)
2ffc7306:	e004      	b.n	2ffc7312 <RCCEx_PLL3_Config+0x92>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc7308:	f7fc f920 	bl	2ffc354c <HAL_GetTick>
2ffc730c:	1b43      	subs	r3, r0, r5
2ffc730e:	2b64      	cmp	r3, #100	@ 0x64
2ffc7310:	d8df      	bhi.n	2ffc72d2 <RCCEx_PLL3_Config+0x52>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != RESET)
2ffc7312:	f8d6 3880 	ldr.w	r3, [r6, #2176]	@ 0x880
2ffc7316:	0799      	lsls	r1, r3, #30
2ffc7318:	d4f6      	bmi.n	2ffc7308 <RCCEx_PLL3_Config+0x88>
        __HAL_RCC_PLL3_SOURCE(pll3->PLLSource);
2ffc731a:	f8d6 3820 	ldr.w	r3, [r6, #2080]	@ 0x820
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3SRCRDY) == RESET)
2ffc731e:	f04f 47a0 	mov.w	r7, #1342177280	@ 0x50000000
        __HAL_RCC_PLL3_SOURCE(pll3->PLLSource);
2ffc7322:	6862      	ldr	r2, [r4, #4]
2ffc7324:	f023 0303 	bic.w	r3, r3, #3
2ffc7328:	4313      	orrs	r3, r2
2ffc732a:	f8c6 3820 	str.w	r3, [r6, #2080]	@ 0x820
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3SRCRDY) == RESET)
2ffc732e:	e004      	b.n	2ffc733a <RCCEx_PLL3_Config+0xba>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc7330:	f7fc f90c 	bl	2ffc354c <HAL_GetTick>
2ffc7334:	1b40      	subs	r0, r0, r5
2ffc7336:	2864      	cmp	r0, #100	@ 0x64
2ffc7338:	d8cb      	bhi.n	2ffc72d2 <RCCEx_PLL3_Config+0x52>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3SRCRDY) == RESET)
2ffc733a:	f8d7 3820 	ldr.w	r3, [r7, #2080]	@ 0x820
2ffc733e:	2b00      	cmp	r3, #0
2ffc7340:	daf6      	bge.n	2ffc7330 <RCCEx_PLL3_Config+0xb0>
        __HAL_RCC_PLL3_IFRANGE(pll3->PLLRGE) ;
2ffc7342:	f8d7 3884 	ldr.w	r3, [r7, #2180]	@ 0x884
        __HAL_RCC_PLL3_CONFIG(
2ffc7346:	f44f 427e 	mov.w	r2, #65024	@ 0xfe00
        __HAL_RCC_PLL3_IFRANGE(pll3->PLLRGE) ;
2ffc734a:	69e1      	ldr	r1, [r4, #28]
2ffc734c:	f023 7340 	bic.w	r3, r3, #50331648	@ 0x3000000
2ffc7350:	430b      	orrs	r3, r1
2ffc7352:	f8c7 3884 	str.w	r3, [r7, #2180]	@ 0x884
        __HAL_RCC_PLL3_CONFIG(
2ffc7356:	f8d7 1884 	ldr.w	r1, [r7, #2180]	@ 0x884
2ffc735a:	f6cf 72c0 	movt	r2, #65472	@ 0xffc0
2ffc735e:	68e3      	ldr	r3, [r4, #12]
2ffc7360:	400a      	ands	r2, r1
2ffc7362:	68a1      	ldr	r1, [r4, #8]
2ffc7364:	3b01      	subs	r3, #1
2ffc7366:	4313      	orrs	r3, r2
2ffc7368:	3901      	subs	r1, #1
2ffc736a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
2ffc736e:	f8c7 3884 	str.w	r3, [r7, #2180]	@ 0x884
2ffc7372:	f8d7 2888 	ldr.w	r2, [r7, #2184]	@ 0x888
2ffc7376:	e9d4 3104 	ldrd	r3, r1, [r4, #16]
2ffc737a:	f022 127f 	bic.w	r2, r2, #8323199	@ 0x7f007f
2ffc737e:	f422 42fe 	bic.w	r2, r2, #32512	@ 0x7f00
2ffc7382:	3b01      	subs	r3, #1
2ffc7384:	4313      	orrs	r3, r2
2ffc7386:	3901      	subs	r1, #1
2ffc7388:	69a2      	ldr	r2, [r4, #24]
2ffc738a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
2ffc738e:	3a01      	subs	r2, #1
2ffc7390:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
2ffc7394:	f8c7 3888 	str.w	r3, [r7, #2184]	@ 0x888
        __HAL_RCC_PLL3FRACV_DISABLE(); //Set FRACLE to 0
2ffc7398:	f8d7 388c 	ldr.w	r3, [r7, #2188]	@ 0x88c
2ffc739c:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
2ffc73a0:	f8c7 388c 	str.w	r3, [r7, #2188]	@ 0x88c
        if ((pll3->PLLMODE == RCC_PLL_SPREAD_SPECTRUM) || (pll3->PLLMODE == RCC_PLL_INTEGER))
2ffc73a4:	6a62      	ldr	r2, [r4, #36]	@ 0x24
2ffc73a6:	f032 0302 	bics.w	r3, r2, #2
          __HAL_RCC_PLL3FRACV_CONFIG(0); //Set FRACV to '0'
2ffc73aa:	f8d7 388c 	ldr.w	r3, [r7, #2188]	@ 0x88c
        if ((pll3->PLLMODE == RCC_PLL_SPREAD_SPECTRUM) || (pll3->PLLMODE == RCC_PLL_INTEGER))
2ffc73ae:	d141      	bne.n	2ffc7434 <RCCEx_PLL3_Config+0x1b4>
          __HAL_RCC_PLL3FRACV_CONFIG(0); //Set FRACV to '0'
2ffc73b0:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
        if (pll3->PLLMODE == RCC_PLL_SPREAD_SPECTRUM)
2ffc73b4:	2a02      	cmp	r2, #2
          __HAL_RCC_PLL3FRACV_CONFIG(0); //Set FRACV to '0'
2ffc73b6:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
2ffc73ba:	f8c7 388c 	str.w	r3, [r7, #2188]	@ 0x88c
        __HAL_RCC_PLL3FRACV_ENABLE(); //Set FRACLE to 1
2ffc73be:	f8d7 388c 	ldr.w	r3, [r7, #2188]	@ 0x88c
2ffc73c2:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
2ffc73c6:	f8c7 388c 	str.w	r3, [r7, #2188]	@ 0x88c
        if (pll3->PLLMODE == RCC_PLL_SPREAD_SPECTRUM)
2ffc73ca:	d142      	bne.n	2ffc7452 <RCCEx_PLL3_Config+0x1d2>
          __HAL_RCC_PLL3CSGCONFIG(pll3->MOD_PER, pll3->TPDFN_DIS, pll3->RPDFN_DIS,
2ffc73cc:	f8d7 2890 	ldr.w	r2, [r7, #2192]	@ 0x890
2ffc73d0:	6b21      	ldr	r1, [r4, #48]	@ 0x30
2ffc73d2:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2ffc73d4:	f002 4200 	and.w	r2, r2, #2147483648	@ 0x80000000
2ffc73d8:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
2ffc73da:	430b      	orrs	r3, r1
2ffc73dc:	4313      	orrs	r3, r2
2ffc73de:	6b61      	ldr	r1, [r4, #52]	@ 0x34
2ffc73e0:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
2ffc73e2:	4303      	orrs	r3, r0
2ffc73e4:	430b      	orrs	r3, r1
2ffc73e6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
2ffc73ea:	f8c7 3890 	str.w	r3, [r7, #2192]	@ 0x890
          __HAL_RCC_PLL3_SSMODE_ENABLE();
2ffc73ee:	f8d7 3880 	ldr.w	r3, [r7, #2176]	@ 0x880
2ffc73f2:	f043 0304 	orr.w	r3, r3, #4
2ffc73f6:	f8c7 3880 	str.w	r3, [r7, #2176]	@ 0x880
        __HAL_RCC_PLL3_ENABLE();
2ffc73fa:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
2ffc73fe:	f8d4 3880 	ldr.w	r3, [r4, #2176]	@ 0x880
2ffc7402:	f043 0301 	orr.w	r3, r3, #1
2ffc7406:	f8c4 3880 	str.w	r3, [r4, #2176]	@ 0x880
        tickstart = HAL_GetTick();
2ffc740a:	f7fc f89f 	bl	2ffc354c <HAL_GetTick>
2ffc740e:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == RESET)
2ffc7410:	e005      	b.n	2ffc741e <RCCEx_PLL3_Config+0x19e>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc7412:	f7fc f89b 	bl	2ffc354c <HAL_GetTick>
2ffc7416:	1b40      	subs	r0, r0, r5
2ffc7418:	2864      	cmp	r0, #100	@ 0x64
2ffc741a:	f63f af5a 	bhi.w	2ffc72d2 <RCCEx_PLL3_Config+0x52>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == RESET)
2ffc741e:	f8d4 3880 	ldr.w	r3, [r4, #2176]	@ 0x880
2ffc7422:	079a      	lsls	r2, r3, #30
2ffc7424:	d5f5      	bpl.n	2ffc7412 <RCCEx_PLL3_Config+0x192>
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP | RCC_PLL3_DIVQ | RCC_PLL3_DIVR);
2ffc7426:	f8d4 3880 	ldr.w	r3, [r4, #2176]	@ 0x880
2ffc742a:	f043 0370 	orr.w	r3, r3, #112	@ 0x70
2ffc742e:	f8c4 3880 	str.w	r3, [r4, #2176]	@ 0x880
2ffc7432:	e728      	b.n	2ffc7286 <RCCEx_PLL3_Config+0x6>
          __HAL_RCC_PLL3FRACV_CONFIG(pll3->PLLFRACV);
2ffc7434:	6a22      	ldr	r2, [r4, #32]
2ffc7436:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
2ffc743a:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
2ffc743e:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
2ffc7442:	f8c7 388c 	str.w	r3, [r7, #2188]	@ 0x88c
        __HAL_RCC_PLL3FRACV_ENABLE(); //Set FRACLE to 1
2ffc7446:	f8d7 388c 	ldr.w	r3, [r7, #2188]	@ 0x88c
2ffc744a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
2ffc744e:	f8c7 388c 	str.w	r3, [r7, #2188]	@ 0x88c
          __HAL_RCC_PLL3_SSMODE_DISABLE();
2ffc7452:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc7456:	f8d2 3880 	ldr.w	r3, [r2, #2176]	@ 0x880
2ffc745a:	f023 0304 	bic.w	r3, r3, #4
2ffc745e:	f8c2 3880 	str.w	r3, [r2, #2176]	@ 0x880
2ffc7462:	e7ca      	b.n	2ffc73fa <RCCEx_PLL3_Config+0x17a>

2ffc7464 <RCCEx_PLL4_Config>:
  * @param  pll4: pointer to a RCC_PLLInitTypeDef structure
  *
  * @retval HAL status
  */
HAL_StatusTypeDef RCCEx_PLL4_Config(RCC_PLLInitTypeDef *pll4)
{
2ffc7464:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_RCC_PLL(pll4->PLLState));
  if ((pll4->PLLState) != RCC_PLL_NONE)
2ffc7466:	6803      	ldr	r3, [r0, #0]
2ffc7468:	b90b      	cbnz	r3, 2ffc746e <RCCEx_PLL4_Config+0xa>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
2ffc746a:	2000      	movs	r0, #0
}
2ffc746c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((pll4->PLLState) == RCC_PLL_ON)
2ffc746e:	2b02      	cmp	r3, #2
2ffc7470:	d01b      	beq.n	2ffc74aa <RCCEx_PLL4_Config+0x46>
      __HAL_RCC_PLL4CLKOUT_DISABLE(RCC_PLL4_DIVP | RCC_PLL4_DIVQ | RCC_PLL4_DIVR);
2ffc7472:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
2ffc7476:	f8d4 3894 	ldr.w	r3, [r4, #2196]	@ 0x894
2ffc747a:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
2ffc747e:	f8c4 3894 	str.w	r3, [r4, #2196]	@ 0x894
      __HAL_RCC_PLL4_DISABLE();
2ffc7482:	f8d4 3894 	ldr.w	r3, [r4, #2196]	@ 0x894
2ffc7486:	f023 0301 	bic.w	r3, r3, #1
2ffc748a:	f8c4 3894 	str.w	r3, [r4, #2196]	@ 0x894
      tickstart = HAL_GetTick();
2ffc748e:	f7fc f85d 	bl	2ffc354c <HAL_GetTick>
2ffc7492:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL4RDY) != RESET)
2ffc7494:	f8d4 3894 	ldr.w	r3, [r4, #2196]	@ 0x894
2ffc7498:	079b      	lsls	r3, r3, #30
2ffc749a:	d5e6      	bpl.n	2ffc746a <RCCEx_PLL4_Config+0x6>
        if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc749c:	f7fc f856 	bl	2ffc354c <HAL_GetTick>
2ffc74a0:	1b40      	subs	r0, r0, r5
2ffc74a2:	2864      	cmp	r0, #100	@ 0x64
2ffc74a4:	d9f6      	bls.n	2ffc7494 <RCCEx_PLL4_Config+0x30>
          return HAL_TIMEOUT;
2ffc74a6:	2003      	movs	r0, #3
}
2ffc74a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_RCC_PLL4CLKOUT_DISABLE(RCC_PLL4_DIVP | RCC_PLL4_DIVQ | RCC_PLL4_DIVR);
2ffc74aa:	f04f 46a0 	mov.w	r6, #1342177280	@ 0x50000000
2ffc74ae:	4604      	mov	r4, r0
2ffc74b0:	f8d6 3894 	ldr.w	r3, [r6, #2196]	@ 0x894
2ffc74b4:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
2ffc74b8:	f8c6 3894 	str.w	r3, [r6, #2196]	@ 0x894
      __HAL_RCC_PLL4_DISABLE();
2ffc74bc:	f8d6 3894 	ldr.w	r3, [r6, #2196]	@ 0x894
2ffc74c0:	f023 0301 	bic.w	r3, r3, #1
2ffc74c4:	f8c6 3894 	str.w	r3, [r6, #2196]	@ 0x894
      tickstart = HAL_GetTick();
2ffc74c8:	f7fc f840 	bl	2ffc354c <HAL_GetTick>
2ffc74cc:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL4RDY) != RESET)
2ffc74ce:	e004      	b.n	2ffc74da <RCCEx_PLL4_Config+0x76>
        if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc74d0:	f7fc f83c 	bl	2ffc354c <HAL_GetTick>
2ffc74d4:	1b43      	subs	r3, r0, r5
2ffc74d6:	2b64      	cmp	r3, #100	@ 0x64
2ffc74d8:	d8e5      	bhi.n	2ffc74a6 <RCCEx_PLL4_Config+0x42>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL4RDY) != RESET)
2ffc74da:	f8d6 3894 	ldr.w	r3, [r6, #2196]	@ 0x894
2ffc74de:	0799      	lsls	r1, r3, #30
2ffc74e0:	d4f6      	bmi.n	2ffc74d0 <RCCEx_PLL4_Config+0x6c>
      __HAL_RCC_PLL4_SOURCE(pll4->PLLSource);
2ffc74e2:	f8d6 3824 	ldr.w	r3, [r6, #2084]	@ 0x824
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL4SRCRDY) == RESET)
2ffc74e6:	f04f 47a0 	mov.w	r7, #1342177280	@ 0x50000000
      __HAL_RCC_PLL4_SOURCE(pll4->PLLSource);
2ffc74ea:	6862      	ldr	r2, [r4, #4]
2ffc74ec:	f023 0303 	bic.w	r3, r3, #3
2ffc74f0:	4313      	orrs	r3, r2
2ffc74f2:	f8c6 3824 	str.w	r3, [r6, #2084]	@ 0x824
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL4SRCRDY) == RESET)
2ffc74f6:	e004      	b.n	2ffc7502 <RCCEx_PLL4_Config+0x9e>
        if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc74f8:	f7fc f828 	bl	2ffc354c <HAL_GetTick>
2ffc74fc:	1b40      	subs	r0, r0, r5
2ffc74fe:	2864      	cmp	r0, #100	@ 0x64
2ffc7500:	d8d1      	bhi.n	2ffc74a6 <RCCEx_PLL4_Config+0x42>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL4SRCRDY) == RESET)
2ffc7502:	f8d7 3824 	ldr.w	r3, [r7, #2084]	@ 0x824
2ffc7506:	2b00      	cmp	r3, #0
2ffc7508:	daf6      	bge.n	2ffc74f8 <RCCEx_PLL4_Config+0x94>
      __HAL_RCC_PLL4_IFRANGE(pll4->PLLRGE) ;
2ffc750a:	f8d7 3898 	ldr.w	r3, [r7, #2200]	@ 0x898
      __HAL_RCC_PLL4_CONFIG(
2ffc750e:	f44f 427e 	mov.w	r2, #65024	@ 0xfe00
      __HAL_RCC_PLL4_IFRANGE(pll4->PLLRGE) ;
2ffc7512:	69e1      	ldr	r1, [r4, #28]
2ffc7514:	f023 7340 	bic.w	r3, r3, #50331648	@ 0x3000000
2ffc7518:	430b      	orrs	r3, r1
2ffc751a:	f8c7 3898 	str.w	r3, [r7, #2200]	@ 0x898
      __HAL_RCC_PLL4_CONFIG(
2ffc751e:	f8d7 1898 	ldr.w	r1, [r7, #2200]	@ 0x898
2ffc7522:	f6cf 72c0 	movt	r2, #65472	@ 0xffc0
2ffc7526:	68e3      	ldr	r3, [r4, #12]
2ffc7528:	400a      	ands	r2, r1
2ffc752a:	68a1      	ldr	r1, [r4, #8]
2ffc752c:	3b01      	subs	r3, #1
2ffc752e:	4313      	orrs	r3, r2
2ffc7530:	3901      	subs	r1, #1
2ffc7532:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
2ffc7536:	f8c7 3898 	str.w	r3, [r7, #2200]	@ 0x898
2ffc753a:	f8d7 289c 	ldr.w	r2, [r7, #2204]	@ 0x89c
2ffc753e:	e9d4 3104 	ldrd	r3, r1, [r4, #16]
2ffc7542:	f022 127f 	bic.w	r2, r2, #8323199	@ 0x7f007f
2ffc7546:	f422 42fe 	bic.w	r2, r2, #32512	@ 0x7f00
2ffc754a:	3b01      	subs	r3, #1
2ffc754c:	4313      	orrs	r3, r2
2ffc754e:	3901      	subs	r1, #1
2ffc7550:	69a2      	ldr	r2, [r4, #24]
2ffc7552:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
2ffc7556:	3a01      	subs	r2, #1
2ffc7558:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
2ffc755c:	f8c7 389c 	str.w	r3, [r7, #2204]	@ 0x89c
      __HAL_RCC_PLL4FRACV_DISABLE(); //Set FRACLE to 0
2ffc7560:	f8d7 38a0 	ldr.w	r3, [r7, #2208]	@ 0x8a0
2ffc7564:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
2ffc7568:	f8c7 38a0 	str.w	r3, [r7, #2208]	@ 0x8a0
      if ((pll4->PLLMODE == RCC_PLL_SPREAD_SPECTRUM) || (pll4->PLLMODE == RCC_PLL_INTEGER))
2ffc756c:	6a62      	ldr	r2, [r4, #36]	@ 0x24
2ffc756e:	f032 0302 	bics.w	r3, r2, #2
        __HAL_RCC_PLL4FRACV_CONFIG(0); //Set FRACV to '0'
2ffc7572:	f8d7 38a0 	ldr.w	r3, [r7, #2208]	@ 0x8a0
      if ((pll4->PLLMODE == RCC_PLL_SPREAD_SPECTRUM) || (pll4->PLLMODE == RCC_PLL_INTEGER))
2ffc7576:	d141      	bne.n	2ffc75fc <RCCEx_PLL4_Config+0x198>
        __HAL_RCC_PLL4FRACV_CONFIG(0); //Set FRACV to '0'
2ffc7578:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
      if (pll4->PLLMODE == RCC_PLL_SPREAD_SPECTRUM)
2ffc757c:	2a02      	cmp	r2, #2
        __HAL_RCC_PLL4FRACV_CONFIG(0); //Set FRACV to '0'
2ffc757e:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
2ffc7582:	f8c7 38a0 	str.w	r3, [r7, #2208]	@ 0x8a0
      __HAL_RCC_PLL4FRACV_ENABLE(); //Set FRACLE to 1
2ffc7586:	f8d7 38a0 	ldr.w	r3, [r7, #2208]	@ 0x8a0
2ffc758a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
2ffc758e:	f8c7 38a0 	str.w	r3, [r7, #2208]	@ 0x8a0
      if (pll4->PLLMODE == RCC_PLL_SPREAD_SPECTRUM)
2ffc7592:	d142      	bne.n	2ffc761a <RCCEx_PLL4_Config+0x1b6>
        __HAL_RCC_PLL4CSGCONFIG(pll4->MOD_PER, pll4->TPDFN_DIS, pll4->RPDFN_DIS,
2ffc7594:	f8d7 28a4 	ldr.w	r2, [r7, #2212]	@ 0x8a4
2ffc7598:	6b21      	ldr	r1, [r4, #48]	@ 0x30
2ffc759a:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2ffc759c:	f002 4200 	and.w	r2, r2, #2147483648	@ 0x80000000
2ffc75a0:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
2ffc75a2:	430b      	orrs	r3, r1
2ffc75a4:	4313      	orrs	r3, r2
2ffc75a6:	6b61      	ldr	r1, [r4, #52]	@ 0x34
2ffc75a8:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
2ffc75aa:	4303      	orrs	r3, r0
2ffc75ac:	430b      	orrs	r3, r1
2ffc75ae:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
2ffc75b2:	f8c7 38a4 	str.w	r3, [r7, #2212]	@ 0x8a4
        __HAL_RCC_PLL4_SSMODE_ENABLE();
2ffc75b6:	f8d7 3894 	ldr.w	r3, [r7, #2196]	@ 0x894
2ffc75ba:	f043 0304 	orr.w	r3, r3, #4
2ffc75be:	f8c7 3894 	str.w	r3, [r7, #2196]	@ 0x894
      __HAL_RCC_PLL4_ENABLE();
2ffc75c2:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
2ffc75c6:	f8d4 3894 	ldr.w	r3, [r4, #2196]	@ 0x894
2ffc75ca:	f043 0301 	orr.w	r3, r3, #1
2ffc75ce:	f8c4 3894 	str.w	r3, [r4, #2196]	@ 0x894
      tickstart = HAL_GetTick();
2ffc75d2:	f7fb ffbb 	bl	2ffc354c <HAL_GetTick>
2ffc75d6:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL4RDY) == RESET)
2ffc75d8:	e005      	b.n	2ffc75e6 <RCCEx_PLL4_Config+0x182>
        if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffc75da:	f7fb ffb7 	bl	2ffc354c <HAL_GetTick>
2ffc75de:	1b40      	subs	r0, r0, r5
2ffc75e0:	2864      	cmp	r0, #100	@ 0x64
2ffc75e2:	f63f af60 	bhi.w	2ffc74a6 <RCCEx_PLL4_Config+0x42>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL4RDY) == RESET)
2ffc75e6:	f8d4 3894 	ldr.w	r3, [r4, #2196]	@ 0x894
2ffc75ea:	079a      	lsls	r2, r3, #30
2ffc75ec:	d5f5      	bpl.n	2ffc75da <RCCEx_PLL4_Config+0x176>
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP | RCC_PLL4_DIVQ | RCC_PLL4_DIVR);
2ffc75ee:	f8d4 3894 	ldr.w	r3, [r4, #2196]	@ 0x894
2ffc75f2:	f043 0370 	orr.w	r3, r3, #112	@ 0x70
2ffc75f6:	f8c4 3894 	str.w	r3, [r4, #2196]	@ 0x894
2ffc75fa:	e736      	b.n	2ffc746a <RCCEx_PLL4_Config+0x6>
        __HAL_RCC_PLL4FRACV_CONFIG(pll4->PLLFRACV);
2ffc75fc:	6a22      	ldr	r2, [r4, #32]
2ffc75fe:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
2ffc7602:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
2ffc7606:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
2ffc760a:	f8c7 38a0 	str.w	r3, [r7, #2208]	@ 0x8a0
      __HAL_RCC_PLL4FRACV_ENABLE(); //Set FRACLE to 1
2ffc760e:	f8d7 38a0 	ldr.w	r3, [r7, #2208]	@ 0x8a0
2ffc7612:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
2ffc7616:	f8c7 38a0 	str.w	r3, [r7, #2208]	@ 0x8a0
        __HAL_RCC_PLL4_SSMODE_DISABLE();
2ffc761a:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffc761e:	f8d2 3894 	ldr.w	r3, [r2, #2196]	@ 0x894
2ffc7622:	f023 0304 	bic.w	r3, r3, #4
2ffc7626:	f8c2 3894 	str.w	r3, [r2, #2196]	@ 0x894
2ffc762a:	e7ca      	b.n	2ffc75c2 <RCCEx_PLL4_Config+0x15e>

2ffc762c <HAL_RCCEx_PeriphCLKConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- CKPER configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) ==
2ffc762c:	e9d0 3200 	ldrd	r3, r2, [r0]
{
2ffc7630:	b5f0      	push	{r4, r5, r6, r7, lr}
2ffc7632:	4604      	mov	r4, r0
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) ==
2ffc7634:	021f      	lsls	r7, r3, #8
{
2ffc7636:	b0c7      	sub	sp, #284	@ 0x11c
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) ==
2ffc7638:	d50a      	bpl.n	2ffc7650 <HAL_RCCEx_PeriphCLKConfig+0x24>
      RCC_PERIPHCLK_CKPER)
  {
    /* Check the parameters */
    assert_param(IS_RCC_CKPERCLKSOURCE(PeriphClkInit->CkperClockSelection));

    __HAL_RCC_CKPER_CONFIG(PeriphClkInit->CkperClockSelection);
2ffc763a:	f8d0 5114 	ldr.w	r5, [r0, #276]	@ 0x114
2ffc763e:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
2ffc7642:	f8d0 10d0 	ldr.w	r1, [r0, #208]	@ 0xd0
2ffc7646:	f021 0103 	bic.w	r1, r1, #3
2ffc764a:	4329      	orrs	r1, r5
2ffc764c:	f8c0 10d0 	str.w	r1, [r0, #208]	@ 0xd0
  }

  /*------------------------------ I2C12 Configuration -----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) &  RCC_PERIPHCLK_I2C12) ==
2ffc7650:	06de      	lsls	r6, r3, #27
2ffc7652:	d50d      	bpl.n	2ffc7670 <HAL_RCCEx_PeriphCLKConfig+0x44>
      RCC_PERIPHCLK_I2C12)
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C12CLKSOURCE(PeriphClkInit->I2c12ClockSelection));

    if ((PeriphClkInit->I2c12ClockSelection) == RCC_I2C12CLKSOURCE_PLL4)
2ffc7654:	f8d4 00bc 	ldr.w	r0, [r4, #188]	@ 0xbc
2ffc7658:	2801      	cmp	r0, #1
2ffc765a:	f000 830f 	beq.w	2ffc7c7c <HAL_RCCEx_PeriphCLKConfig+0x650>
        return status;
      }
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
    }

    __HAL_RCC_I2C12_CONFIG(PeriphClkInit->I2c12ClockSelection);
2ffc765e:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7662:	f8d5 18c0 	ldr.w	r1, [r5, #2240]	@ 0x8c0
2ffc7666:	f021 0107 	bic.w	r1, r1, #7
2ffc766a:	4301      	orrs	r1, r0
2ffc766c:	f8c5 18c0 	str.w	r1, [r5, #2240]	@ 0x8c0
  }

  /*------------------------------ I2C35 Configuration -----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) &  RCC_PERIPHCLK_I2C35) ==
2ffc7670:	069d      	lsls	r5, r3, #26
2ffc7672:	d50d      	bpl.n	2ffc7690 <HAL_RCCEx_PeriphCLKConfig+0x64>
      RCC_PERIPHCLK_I2C35)
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C35CLKSOURCE(PeriphClkInit->I2c35ClockSelection));

    if ((PeriphClkInit->I2c35ClockSelection) == RCC_I2C35CLKSOURCE_PLL4)
2ffc7674:	f8d4 00c0 	ldr.w	r0, [r4, #192]	@ 0xc0
2ffc7678:	2801      	cmp	r0, #1
2ffc767a:	f000 8435 	beq.w	2ffc7ee8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>
        return status;
      }
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
    }

    __HAL_RCC_I2C35_CONFIG(PeriphClkInit->I2c35ClockSelection);
2ffc767e:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7682:	f8d5 18c4 	ldr.w	r1, [r5, #2244]	@ 0x8c4
2ffc7686:	f021 0107 	bic.w	r1, r1, #7
2ffc768a:	4301      	orrs	r1, r0
2ffc768c:	f8c5 18c4 	str.w	r1, [r5, #2244]	@ 0x8c4
  }

  /*------------------------------ I2C46 Configuration -----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C46) ==
2ffc7690:	0690      	lsls	r0, r2, #26
2ffc7692:	d50d      	bpl.n	2ffc76b0 <HAL_RCCEx_PeriphCLKConfig+0x84>
      RCC_PERIPHCLK_I2C46)
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C46CLKSOURCE(PeriphClkInit->I2c46ClockSelection));

    if ((PeriphClkInit->I2c46ClockSelection) == RCC_I2C46CLKSOURCE_PLL3)
2ffc7694:	f8d4 00c4 	ldr.w	r0, [r4, #196]	@ 0xc4
2ffc7698:	2801      	cmp	r0, #1
2ffc769a:	f000 843b 	beq.w	2ffc7f14 <HAL_RCCEx_PeriphCLKConfig+0x8e8>
        return status;
      }
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
    }

    __HAL_RCC_I2C46_CONFIG(PeriphClkInit->I2c46ClockSelection);
2ffc769e:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc76a2:	f8d5 10c0 	ldr.w	r1, [r5, #192]	@ 0xc0
2ffc76a6:	f021 0107 	bic.w	r1, r1, #7
2ffc76aa:	4301      	orrs	r1, r0
2ffc76ac:	f8c5 10c0 	str.w	r1, [r5, #192]	@ 0xc0
  }

  /*---------------------------- SAI1 configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) ==
2ffc76b0:	0619      	lsls	r1, r3, #24
2ffc76b2:	d513      	bpl.n	2ffc76dc <HAL_RCCEx_PeriphCLKConfig+0xb0>
      RCC_PERIPHCLK_SAI1)
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    switch (PeriphClkInit->Sai1ClockSelection)
2ffc76b4:	f8d4 10c8 	ldr.w	r1, [r4, #200]	@ 0xc8
2ffc76b8:	2901      	cmp	r1, #1
2ffc76ba:	f000 83c1 	beq.w	2ffc7e40 <HAL_RCCEx_PeriphCLKConfig+0x814>
2ffc76be:	2904      	cmp	r1, #4
2ffc76c0:	f000 83a9 	beq.w	2ffc7e16 <HAL_RCCEx_PeriphCLKConfig+0x7ea>
2ffc76c4:	2900      	cmp	r1, #0
2ffc76c6:	f000 8391 	beq.w	2ffc7dec <HAL_RCCEx_PeriphCLKConfig+0x7c0>

        break;
    }

    /* Set the source of SAI1 clock*/
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
2ffc76ca:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc76ce:	f8d5 08c8 	ldr.w	r0, [r5, #2248]	@ 0x8c8
2ffc76d2:	f020 0007 	bic.w	r0, r0, #7
2ffc76d6:	4301      	orrs	r1, r0
2ffc76d8:	f8c5 18c8 	str.w	r1, [r5, #2248]	@ 0x8c8
  }

  /*---------------------------- SAI2 configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) ==
2ffc76dc:	05df      	lsls	r7, r3, #23
2ffc76de:	d513      	bpl.n	2ffc7708 <HAL_RCCEx_PeriphCLKConfig+0xdc>
      RCC_PERIPHCLK_SAI2)
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    switch (PeriphClkInit->Sai2ClockSelection)
2ffc76e0:	f8d4 10cc 	ldr.w	r1, [r4, #204]	@ 0xcc
2ffc76e4:	2901      	cmp	r1, #1
2ffc76e6:	f000 83ea 	beq.w	2ffc7ebe <HAL_RCCEx_PeriphCLKConfig+0x892>
2ffc76ea:	2905      	cmp	r1, #5
2ffc76ec:	f000 83d2 	beq.w	2ffc7e94 <HAL_RCCEx_PeriphCLKConfig+0x868>
2ffc76f0:	2900      	cmp	r1, #0
2ffc76f2:	f000 83ba 	beq.w	2ffc7e6a <HAL_RCCEx_PeriphCLKConfig+0x83e>

        break;
    }

    /* Set the source of SAI2 clock*/
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
2ffc76f6:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc76fa:	f8d5 08cc 	ldr.w	r0, [r5, #2252]	@ 0x8cc
2ffc76fe:	f020 0007 	bic.w	r0, r0, #7
2ffc7702:	4301      	orrs	r1, r0
2ffc7704:	f8c5 18cc 	str.w	r1, [r5, #2252]	@ 0x8cc
  }

  /*---------------------------- SAI3 configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI3) ==
2ffc7708:	035e      	lsls	r6, r3, #13
2ffc770a:	d513      	bpl.n	2ffc7734 <HAL_RCCEx_PeriphCLKConfig+0x108>
      RCC_PERIPHCLK_SAI3)
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI3CLKSOURCE(PeriphClkInit->Sai3ClockSelection));

    switch (PeriphClkInit->Sai3ClockSelection)
2ffc770c:	f8d4 10d0 	ldr.w	r1, [r4, #208]	@ 0xd0
2ffc7710:	2901      	cmp	r1, #1
2ffc7712:	f000 842b 	beq.w	2ffc7f6c <HAL_RCCEx_PeriphCLKConfig+0x940>
2ffc7716:	2904      	cmp	r1, #4
2ffc7718:	f000 8412 	beq.w	2ffc7f40 <HAL_RCCEx_PeriphCLKConfig+0x914>
2ffc771c:	2900      	cmp	r1, #0
2ffc771e:	f000 843b 	beq.w	2ffc7f98 <HAL_RCCEx_PeriphCLKConfig+0x96c>

        break;
    }

    /* Set the source of SAI3 clock*/
    __HAL_RCC_SAI3_CONFIG(PeriphClkInit->Sai3ClockSelection);
2ffc7722:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7726:	f8d5 08d0 	ldr.w	r0, [r5, #2256]	@ 0x8d0
2ffc772a:	f020 0007 	bic.w	r0, r0, #7
2ffc772e:	4301      	orrs	r1, r0
2ffc7730:	f8c5 18d0 	str.w	r1, [r5, #2256]	@ 0x8d0
  }

  /*---------------------------- SAI4 configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4) ==
2ffc7734:	005d      	lsls	r5, r3, #1
2ffc7736:	d513      	bpl.n	2ffc7760 <HAL_RCCEx_PeriphCLKConfig+0x134>
      RCC_PERIPHCLK_SAI4)
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI4CLKSOURCE(PeriphClkInit->Sai4ClockSelection));

    switch (PeriphClkInit->Sai4ClockSelection)
2ffc7738:	f8d4 10d4 	ldr.w	r1, [r4, #212]	@ 0xd4
2ffc773c:	2901      	cmp	r1, #1
2ffc773e:	f000 8441 	beq.w	2ffc7fc4 <HAL_RCCEx_PeriphCLKConfig+0x998>
2ffc7742:	2904      	cmp	r1, #4
2ffc7744:	f000 82c2 	beq.w	2ffc7ccc <HAL_RCCEx_PeriphCLKConfig+0x6a0>
2ffc7748:	2900      	cmp	r1, #0
2ffc774a:	f000 82ab 	beq.w	2ffc7ca4 <HAL_RCCEx_PeriphCLKConfig+0x678>

        break;
    }

    /* Set the source of SAI4 clock*/
    __HAL_RCC_SAI4_CONFIG(PeriphClkInit->Sai4ClockSelection);
2ffc774e:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7752:	f8d5 08d4 	ldr.w	r0, [r5, #2260]	@ 0x8d4
2ffc7756:	f020 0007 	bic.w	r0, r0, #7
2ffc775a:	4301      	orrs	r1, r0
2ffc775c:	f8c5 18d4 	str.w	r1, [r5, #2260]	@ 0x8d4
  }

  /*---------------------------- SPI1 configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI1) ==
2ffc7760:	0158      	lsls	r0, r3, #5
2ffc7762:	f100 8278 	bmi.w	2ffc7c56 <HAL_RCCEx_PeriphCLKConfig+0x62a>
    /* Set the source of SPI1 clock*/
    __HAL_RCC_SPI1_CONFIG(PeriphClkInit->Spi1ClockSelection);
  }

  /*---------------------------- SPI23 configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI23) ==
2ffc7766:	0119      	lsls	r1, r3, #4
2ffc7768:	d513      	bpl.n	2ffc7792 <HAL_RCCEx_PeriphCLKConfig+0x166>
      RCC_PERIPHCLK_SPI23)
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI23CLKSOURCE(PeriphClkInit->Spi23ClockSelection));

    switch (PeriphClkInit->Spi23ClockSelection)
2ffc776a:	f8d4 10dc 	ldr.w	r1, [r4, #220]	@ 0xdc
2ffc776e:	2901      	cmp	r1, #1
2ffc7770:	f000 8327 	beq.w	2ffc7dc2 <HAL_RCCEx_PeriphCLKConfig+0x796>
2ffc7774:	2904      	cmp	r1, #4
2ffc7776:	f000 82e5 	beq.w	2ffc7d44 <HAL_RCCEx_PeriphCLKConfig+0x718>
2ffc777a:	2900      	cmp	r1, #0
2ffc777c:	f000 82f7 	beq.w	2ffc7d6e <HAL_RCCEx_PeriphCLKConfig+0x742>

        break;
    }

    /* Set the source of SPI2 clock*/
    __HAL_RCC_SPI23_CONFIG(PeriphClkInit->Spi23ClockSelection);
2ffc7780:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7784:	f8d5 08dc 	ldr.w	r0, [r5, #2268]	@ 0x8dc
2ffc7788:	f020 0007 	bic.w	r0, r0, #7
2ffc778c:	4301      	orrs	r1, r0
2ffc778e:	f8c5 18dc 	str.w	r1, [r5, #2268]	@ 0x8dc
  }

  /*---------------------------- SPI45 configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) ==
2ffc7792:	00df      	lsls	r7, r3, #3
2ffc7794:	d50d      	bpl.n	2ffc77b2 <HAL_RCCEx_PeriphCLKConfig+0x186>
      RCC_PERIPHCLK_SPI45)
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI45CLKSOURCE(PeriphClkInit->Spi45ClockSelection));

    if (PeriphClkInit->Spi45ClockSelection == RCC_SPI45CLKSOURCE_PLL4)
2ffc7796:	f8d4 00e0 	ldr.w	r0, [r4, #224]	@ 0xe0
2ffc779a:	2801      	cmp	r0, #1
2ffc779c:	f000 8560 	beq.w	2ffc8260 <HAL_RCCEx_PeriphCLKConfig+0xc34>
      /* Enable SPI Clock output generated on PLL4 . */
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
    }

    /* Set the source of SPI45 clock*/
    __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
2ffc77a0:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc77a4:	f8d5 18e0 	ldr.w	r1, [r5, #2272]	@ 0x8e0
2ffc77a8:	f021 0107 	bic.w	r1, r1, #7
2ffc77ac:	4301      	orrs	r1, r0
2ffc77ae:	f8c5 18e0 	str.w	r1, [r5, #2272]	@ 0x8e0
  }

  /*---------------------------- SPI6 configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) ==
2ffc77b2:	009e      	lsls	r6, r3, #2
2ffc77b4:	d523      	bpl.n	2ffc77fe <HAL_RCCEx_PeriphCLKConfig+0x1d2>
      RCC_PERIPHCLK_SPI6)
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI6CLKSOURCE(PeriphClkInit->Spi6ClockSelection));

    switch (PeriphClkInit->Spi6ClockSelection)
2ffc77b6:	f8d4 00e4 	ldr.w	r0, [r4, #228]	@ 0xe4
2ffc77ba:	2801      	cmp	r0, #1
2ffc77bc:	f000 8418 	beq.w	2ffc7ff0 <HAL_RCCEx_PeriphCLKConfig+0x9c4>
2ffc77c0:	2805      	cmp	r0, #5
2ffc77c2:	d113      	bne.n	2ffc77ec <HAL_RCCEx_PeriphCLKConfig+0x1c0>

        break;

      case RCC_SPI6CLKSOURCE_PLL3: /* PLL3 is used as clock source for SPI6 */

        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc77c4:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc77c8:	f7ff fd5a 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc77cc:	4605      	mov	r5, r0
2ffc77ce:	2800      	cmp	r0, #0
2ffc77d0:	f040 823e 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
    /* Set the source of SPI6 clock*/
    __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
  }

  /*---------------------------- USART6 configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) ==
2ffc77d4:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc77d6:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) ==
2ffc77da:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc77dc:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc77e0:	f041 0120 	orr.w	r1, r1, #32
2ffc77e4:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
2ffc77e8:	f8d4 00e4 	ldr.w	r0, [r4, #228]	@ 0xe4
2ffc77ec:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc77f0:	f8d5 10c4 	ldr.w	r1, [r5, #196]	@ 0xc4
2ffc77f4:	f021 0107 	bic.w	r1, r1, #7
2ffc77f8:	4301      	orrs	r1, r0
2ffc77fa:	f8c5 10c4 	str.w	r1, [r5, #196]	@ 0xc4
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) ==
2ffc77fe:	045d      	lsls	r5, r3, #17
2ffc7800:	d50d      	bpl.n	2ffc781e <HAL_RCCEx_PeriphCLKConfig+0x1f2>
      RCC_PERIPHCLK_USART6)
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_PLL4)
2ffc7802:	f8d4 00f4 	ldr.w	r0, [r4, #244]	@ 0xf4
2ffc7806:	2801      	cmp	r0, #1
2ffc7808:	f000 8556 	beq.w	2ffc82b8 <HAL_RCCEx_PeriphCLKConfig+0xc8c>
      /* Enable USART Clock output generated on PLL4 */
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
    }

    /* Set the source of USART6 clock*/
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
2ffc780c:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7810:	f8d5 18e4 	ldr.w	r1, [r5, #2276]	@ 0x8e4
2ffc7814:	f021 0107 	bic.w	r1, r1, #7
2ffc7818:	4301      	orrs	r1, r0
2ffc781a:	f8c5 18e4 	str.w	r1, [r5, #2276]	@ 0x8e4
  }

  /*---------------------------- UART24 configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART24) ==
2ffc781e:	0798      	lsls	r0, r3, #30
2ffc7820:	d50d      	bpl.n	2ffc783e <HAL_RCCEx_PeriphCLKConfig+0x212>
      RCC_PERIPHCLK_UART24)
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART24CLKSOURCE(PeriphClkInit->Uart24ClockSelection));

    if (PeriphClkInit->Uart24ClockSelection == RCC_UART24CLKSOURCE_PLL4)
2ffc7822:	f8d4 00ec 	ldr.w	r0, [r4, #236]	@ 0xec
2ffc7826:	2801      	cmp	r0, #1
2ffc7828:	f000 8572 	beq.w	2ffc8310 <HAL_RCCEx_PeriphCLKConfig+0xce4>
      /* Enable UART Clock output generated on PLL4 */
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
    }

    /* Set the source of UART24 clock*/
    __HAL_RCC_UART24_CONFIG(PeriphClkInit->Uart24ClockSelection);
2ffc782c:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7830:	f8d5 18e8 	ldr.w	r1, [r5, #2280]	@ 0x8e8
2ffc7834:	f021 0107 	bic.w	r1, r1, #7
2ffc7838:	4301      	orrs	r1, r0
2ffc783a:	f8c5 18e8 	str.w	r1, [r5, #2280]	@ 0x8e8
  }

  /*---------------------------- UART35 configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART35) ==
2ffc783e:	0759      	lsls	r1, r3, #29
2ffc7840:	d50d      	bpl.n	2ffc785e <HAL_RCCEx_PeriphCLKConfig+0x232>
      RCC_PERIPHCLK_UART35)
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART35CLKSOURCE(PeriphClkInit->Uart35ClockSelection));

    if (PeriphClkInit->Uart35ClockSelection == RCC_UART35CLKSOURCE_PLL4)
2ffc7842:	f8d4 00f0 	ldr.w	r0, [r4, #240]	@ 0xf0
2ffc7846:	2801      	cmp	r0, #1
2ffc7848:	f000 8578 	beq.w	2ffc833c <HAL_RCCEx_PeriphCLKConfig+0xd10>
      /* Enable UART Clock output generated on PLL4 */
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
    }

    /* Set the source of UART35 clock*/
    __HAL_RCC_UART35_CONFIG(PeriphClkInit->Uart35ClockSelection);
2ffc784c:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7850:	f8d5 18ec 	ldr.w	r1, [r5, #2284]	@ 0x8ec
2ffc7854:	f021 0107 	bic.w	r1, r1, #7
2ffc7858:	4301      	orrs	r1, r0
2ffc785a:	f8c5 18ec 	str.w	r1, [r5, #2284]	@ 0x8ec
  }

  /*---------------------------- UAUART78 configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART78) ==
2ffc785e:	041f      	lsls	r7, r3, #16
2ffc7860:	d50d      	bpl.n	2ffc787e <HAL_RCCEx_PeriphCLKConfig+0x252>
      RCC_PERIPHCLK_UART78)
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART78CLKSOURCE(PeriphClkInit->Uart78ClockSelection));

    if (PeriphClkInit->Uart78ClockSelection == RCC_UART78CLKSOURCE_PLL4)
2ffc7862:	f8d4 00f8 	ldr.w	r0, [r4, #248]	@ 0xf8
2ffc7866:	2801      	cmp	r0, #1
2ffc7868:	f000 857e 	beq.w	2ffc8368 <HAL_RCCEx_PeriphCLKConfig+0xd3c>
      /* Enable UART Clock output generated on PLL4 */
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
    }

    /* Set the source of UART78 clock*/
    __HAL_RCC_UART78_CONFIG(PeriphClkInit->Uart78ClockSelection);
2ffc786c:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7870:	f8d5 18f0 	ldr.w	r1, [r5, #2288]	@ 0x8f0
2ffc7874:	f021 0107 	bic.w	r1, r1, #7
2ffc7878:	4301      	orrs	r1, r0
2ffc787a:	f8c5 18f0 	str.w	r1, [r5, #2288]	@ 0x8f0
  }

  /*---------------------------- USART1 configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) ==
2ffc787e:	07de      	lsls	r6, r3, #31
2ffc7880:	d523      	bpl.n	2ffc78ca <HAL_RCCEx_PeriphCLKConfig+0x29e>
      RCC_PERIPHCLK_USART1)
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    switch (PeriphClkInit->Usart1ClockSelection)
2ffc7882:	f8d4 00e8 	ldr.w	r0, [r4, #232]	@ 0xe8
2ffc7886:	2801      	cmp	r0, #1
2ffc7888:	f000 84be 	beq.w	2ffc8208 <HAL_RCCEx_PeriphCLKConfig+0xbdc>
2ffc788c:	2804      	cmp	r0, #4
2ffc788e:	d113      	bne.n	2ffc78b8 <HAL_RCCEx_PeriphCLKConfig+0x28c>

        break;

      case RCC_USART1CLKSOURCE_PLL4: /* PLL4 is used as clock source for USART1 */

        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc7890:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc7894:	f7ff fde6 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc7898:	4605      	mov	r5, r0
2ffc789a:	2800      	cmp	r0, #0
2ffc789c:	f040 81d8 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
    /* Set the source of USART1 clock*/
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
  }

  /*---------------------------- SDMMC12 configuration -----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC12) ==
2ffc78a0:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc78a2:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC12) ==
2ffc78a6:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc78a8:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc78ac:	f041 0120 	orr.w	r1, r1, #32
2ffc78b0:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
2ffc78b4:	f8d4 00e8 	ldr.w	r0, [r4, #232]	@ 0xe8
2ffc78b8:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc78bc:	f8d5 10c8 	ldr.w	r1, [r5, #200]	@ 0xc8
2ffc78c0:	f021 0107 	bic.w	r1, r1, #7
2ffc78c4:	4301      	orrs	r1, r0
2ffc78c6:	f8c5 10c8 	str.w	r1, [r5, #200]	@ 0xc8
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC12) ==
2ffc78ca:	2b00      	cmp	r3, #0
2ffc78cc:	da23      	bge.n	2ffc7916 <HAL_RCCEx_PeriphCLKConfig+0x2ea>
      RCC_PERIPHCLK_SDMMC12)
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC12CLKSOURCE(PeriphClkInit->Sdmmc12ClockSelection));

    switch (PeriphClkInit->Sdmmc12ClockSelection)
2ffc78ce:	f8d4 00fc 	ldr.w	r0, [r4, #252]	@ 0xfc
2ffc78d2:	2801      	cmp	r0, #1
2ffc78d4:	f000 84ae 	beq.w	2ffc8234 <HAL_RCCEx_PeriphCLKConfig+0xc08>
2ffc78d8:	2802      	cmp	r0, #2
2ffc78da:	d113      	bne.n	2ffc7904 <HAL_RCCEx_PeriphCLKConfig+0x2d8>

        break;

      case RCC_SDMMC12CLKSOURCE_PLL4: /* PLL4 is used as clock source for SDMMC12 */

        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc78dc:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc78e0:	f7ff fdc0 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc78e4:	4605      	mov	r5, r0
2ffc78e6:	2800      	cmp	r0, #0
2ffc78e8:	f040 81b2 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
    /* Set the source of SDMMC12 clock*/
    __HAL_RCC_SDMMC12_CONFIG(PeriphClkInit->Sdmmc12ClockSelection);
  }

  /*---------------------------- SDMMC3 configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC3) ==
2ffc78ec:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc78ee:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC3) ==
2ffc78f2:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc78f4:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc78f8:	f041 0110 	orr.w	r1, r1, #16
2ffc78fc:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_SDMMC12_CONFIG(PeriphClkInit->Sdmmc12ClockSelection);
2ffc7900:	f8d4 00fc 	ldr.w	r0, [r4, #252]	@ 0xfc
2ffc7904:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7908:	f8d5 18f4 	ldr.w	r1, [r5, #2292]	@ 0x8f4
2ffc790c:	f021 0107 	bic.w	r1, r1, #7
2ffc7910:	4301      	orrs	r1, r0
2ffc7912:	f8c5 18f4 	str.w	r1, [r5, #2292]	@ 0x8f4
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC3) ==
2ffc7916:	07d5      	lsls	r5, r2, #31
2ffc7918:	d523      	bpl.n	2ffc7962 <HAL_RCCEx_PeriphCLKConfig+0x336>
      RCC_PERIPHCLK_SDMMC3)
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC3CLKSOURCE(PeriphClkInit->Sdmmc3ClockSelection));

    switch (PeriphClkInit->Sdmmc3ClockSelection)
2ffc791a:	f8d4 0100 	ldr.w	r0, [r4, #256]	@ 0x100
2ffc791e:	2801      	cmp	r0, #1
2ffc7920:	f000 84b4 	beq.w	2ffc828c <HAL_RCCEx_PeriphCLKConfig+0xc60>
2ffc7924:	2802      	cmp	r0, #2
2ffc7926:	d113      	bne.n	2ffc7950 <HAL_RCCEx_PeriphCLKConfig+0x324>

        break;

      case RCC_SDMMC3CLKSOURCE_PLL4:  /* PLL4 is used as clock source for SDMMC3 */

        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc7928:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc792c:	f7ff fd9a 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc7930:	4605      	mov	r5, r0
2ffc7932:	2800      	cmp	r0, #0
2ffc7934:	f040 818c 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
    /* Set the source of SDMMC3 clock*/
    __HAL_RCC_SDMMC3_CONFIG(PeriphClkInit->Sdmmc3ClockSelection);
  }

  /*---------------------------- ETH configuration ---------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ETH) ==
2ffc7938:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc793a:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ETH) ==
2ffc793e:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc7940:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc7944:	f041 0110 	orr.w	r1, r1, #16
2ffc7948:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_SDMMC3_CONFIG(PeriphClkInit->Sdmmc3ClockSelection);
2ffc794c:	f8d4 0100 	ldr.w	r0, [r4, #256]	@ 0x100
2ffc7950:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7954:	f8d5 18f8 	ldr.w	r1, [r5, #2296]	@ 0x8f8
2ffc7958:	f021 0107 	bic.w	r1, r1, #7
2ffc795c:	4301      	orrs	r1, r0
2ffc795e:	f8c5 18f8 	str.w	r1, [r5, #2296]	@ 0x8f8
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ETH) ==
2ffc7962:	0790      	lsls	r0, r2, #30
2ffc7964:	d523      	bpl.n	2ffc79ae <HAL_RCCEx_PeriphCLKConfig+0x382>
      RCC_PERIPHCLK_ETH)
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETHCLKSOURCE(PeriphClkInit->EthClockSelection));

    switch (PeriphClkInit->EthClockSelection)
2ffc7966:	f8d4 0104 	ldr.w	r0, [r4, #260]	@ 0x104
2ffc796a:	2800      	cmp	r0, #0
2ffc796c:	f000 84ba 	beq.w	2ffc82e4 <HAL_RCCEx_PeriphCLKConfig+0xcb8>
2ffc7970:	2801      	cmp	r0, #1
2ffc7972:	d113      	bne.n	2ffc799c <HAL_RCCEx_PeriphCLKConfig+0x370>

        break;

      case RCC_ETHCLKSOURCE_PLL3:     /* PLL3 is used as clock source for ETH */

        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7974:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7978:	f7ff fc82 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc797c:	4605      	mov	r5, r0
2ffc797e:	2800      	cmp	r0, #0
2ffc7980:	f040 8166 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
    /* Set the source of ETH clock*/
    __HAL_RCC_ETH_CONFIG(PeriphClkInit->EthClockSelection);
  }

  /*---------------------------- QSPI configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) ==
2ffc7984:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7986:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) ==
2ffc798a:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc798c:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc7990:	f041 0120 	orr.w	r1, r1, #32
2ffc7994:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_ETH_CONFIG(PeriphClkInit->EthClockSelection);
2ffc7998:	f8d4 0104 	ldr.w	r0, [r4, #260]	@ 0x104
2ffc799c:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc79a0:	f8d5 18fc 	ldr.w	r1, [r5, #2300]	@ 0x8fc
2ffc79a4:	f021 0103 	bic.w	r1, r1, #3
2ffc79a8:	4301      	orrs	r1, r0
2ffc79aa:	f8c5 18fc 	str.w	r1, [r5, #2300]	@ 0x8fc
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) ==
2ffc79ae:	0299      	lsls	r1, r3, #10
2ffc79b0:	d510      	bpl.n	2ffc79d4 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
      RCC_PERIPHCLK_QSPI)
  {
    /* Check the parameters */
    assert_param(IS_RCC_QSPICLKSOURCE(PeriphClkInit->QspiClockSelection));

    switch (PeriphClkInit->QspiClockSelection)
2ffc79b2:	f8d4 010c 	ldr.w	r0, [r4, #268]	@ 0x10c
2ffc79b6:	2801      	cmp	r0, #1
2ffc79b8:	f000 84ec 	beq.w	2ffc8394 <HAL_RCCEx_PeriphCLKConfig+0xd68>
2ffc79bc:	2802      	cmp	r0, #2
2ffc79be:	f000 832d 	beq.w	2ffc801c <HAL_RCCEx_PeriphCLKConfig+0x9f0>

        break;
    }

    /* Set the source of QSPI clock*/
    __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
2ffc79c2:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc79c6:	f8d5 1900 	ldr.w	r1, [r5, #2304]	@ 0x900
2ffc79ca:	f021 0103 	bic.w	r1, r1, #3
2ffc79ce:	4301      	orrs	r1, r0
2ffc79d0:	f8c5 1900 	str.w	r1, [r5, #2304]	@ 0x900
  }

  /*---------------------------- FMC configuration ---------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) ==
2ffc79d4:	02df      	lsls	r7, r3, #11
2ffc79d6:	d510      	bpl.n	2ffc79fa <HAL_RCCEx_PeriphCLKConfig+0x3ce>
      RCC_PERIPHCLK_FMC)
  {
    /* Check the parameters */
    assert_param(IS_RCC_FMCCLKSOURCE(PeriphClkInit->FmcClockSelection));

    switch (PeriphClkInit->FmcClockSelection)
2ffc79d8:	f8d4 0108 	ldr.w	r0, [r4, #264]	@ 0x108
2ffc79dc:	2801      	cmp	r0, #1
2ffc79de:	f000 84ef 	beq.w	2ffc83c0 <HAL_RCCEx_PeriphCLKConfig+0xd94>
2ffc79e2:	2802      	cmp	r0, #2
2ffc79e4:	f000 832f 	beq.w	2ffc8046 <HAL_RCCEx_PeriphCLKConfig+0xa1a>

        break;
    }

    /* Set the source of FMC clock*/
    __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
2ffc79e8:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc79ec:	f8d5 1904 	ldr.w	r1, [r5, #2308]	@ 0x904
2ffc79f0:	f021 0103 	bic.w	r1, r1, #3
2ffc79f4:	4301      	orrs	r1, r0
2ffc79f6:	f8c5 1904 	str.w	r1, [r5, #2308]	@ 0x904
  }

#if defined(FDCAN1)
  /*---------------------------- FDCAN configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) ==
2ffc79fa:	019e      	lsls	r6, r3, #6
2ffc79fc:	d513      	bpl.n	2ffc7a26 <HAL_RCCEx_PeriphCLKConfig+0x3fa>
      RCC_PERIPHCLK_FDCAN)
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    switch (PeriphClkInit->FdcanClockSelection)
2ffc79fe:	f8d4 111c 	ldr.w	r1, [r4, #284]	@ 0x11c
2ffc7a02:	2902      	cmp	r1, #2
2ffc7a04:	f000 84f2 	beq.w	2ffc83ec <HAL_RCCEx_PeriphCLKConfig+0xdc0>
2ffc7a08:	2903      	cmp	r1, #3
2ffc7a0a:	f000 8346 	beq.w	2ffc809a <HAL_RCCEx_PeriphCLKConfig+0xa6e>
2ffc7a0e:	2901      	cmp	r1, #1
2ffc7a10:	f000 832e 	beq.w	2ffc8070 <HAL_RCCEx_PeriphCLKConfig+0xa44>

        break;
    }

    /* Set the source of FDCAN clock*/
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
2ffc7a14:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7a18:	f8d5 090c 	ldr.w	r0, [r5, #2316]	@ 0x90c
2ffc7a1c:	f020 0003 	bic.w	r0, r0, #3
2ffc7a20:	4301      	orrs	r1, r0
2ffc7a22:	f8c5 190c 	str.w	r1, [r5, #2316]	@ 0x90c
  }
#endif /*FDCAN1*/

  /*---------------------------- SPDIFRX configuration -----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) ==
2ffc7a26:	01dd      	lsls	r5, r3, #7
2ffc7a28:	d523      	bpl.n	2ffc7a72 <HAL_RCCEx_PeriphCLKConfig+0x446>
      RCC_PERIPHCLK_SPDIFRX)
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPDIFRXCLKSOURCE(PeriphClkInit->SpdifrxClockSelection));

    switch (PeriphClkInit->SpdifrxClockSelection)
2ffc7a2a:	f8d4 0118 	ldr.w	r0, [r4, #280]	@ 0x118
2ffc7a2e:	2800      	cmp	r0, #0
2ffc7a30:	f000 8348 	beq.w	2ffc80c4 <HAL_RCCEx_PeriphCLKConfig+0xa98>
2ffc7a34:	2801      	cmp	r0, #1
2ffc7a36:	d113      	bne.n	2ffc7a60 <HAL_RCCEx_PeriphCLKConfig+0x434>

        break;

      case RCC_SPDIFRXCLKSOURCE_PLL3: /* PLL3 is used as clock source for SPDIF */

        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7a38:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7a3c:	f7ff fc20 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc7a40:	4605      	mov	r5, r0
2ffc7a42:	2800      	cmp	r0, #0
2ffc7a44:	f040 8104 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
    /* Set the source of SPDIF clock*/
    __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
  }

  /*---------------------------- CEC configuration ---------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) ==
2ffc7a48:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7a4a:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) ==
2ffc7a4e:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7a50:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc7a54:	f041 0120 	orr.w	r1, r1, #32
2ffc7a58:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
2ffc7a5c:	f8d4 0118 	ldr.w	r0, [r4, #280]	@ 0x118
2ffc7a60:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7a64:	f8d5 1914 	ldr.w	r1, [r5, #2324]	@ 0x914
2ffc7a68:	f021 0103 	bic.w	r1, r1, #3
2ffc7a6c:	4301      	orrs	r1, r0
2ffc7a6e:	f8c5 1914 	str.w	r1, [r5, #2324]	@ 0x914
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) ==
2ffc7a72:	0498      	lsls	r0, r3, #18
2ffc7a74:	d50a      	bpl.n	2ffc7a8c <HAL_RCCEx_PeriphCLKConfig+0x460>
      RCC_PERIPHCLK_CEC)
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
2ffc7a76:	f8d4 5134 	ldr.w	r5, [r4, #308]	@ 0x134
2ffc7a7a:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
2ffc7a7e:	f8d0 1918 	ldr.w	r1, [r0, #2328]	@ 0x918
2ffc7a82:	f021 0103 	bic.w	r1, r1, #3
2ffc7a86:	4329      	orrs	r1, r5
2ffc7a88:	f8c0 1918 	str.w	r1, [r0, #2328]	@ 0x918
  }

  /*---------------------------- USBPHY configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USBPHY) ==
2ffc7a8c:	0599      	lsls	r1, r3, #22
2ffc7a8e:	d50d      	bpl.n	2ffc7aac <HAL_RCCEx_PeriphCLKConfig+0x480>
      RCC_PERIPHCLK_USBPHY)
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHYCLKSOURCE(PeriphClkInit->UsbphyClockSelection));

    if (PeriphClkInit->UsbphyClockSelection == RCC_USBPHYCLKSOURCE_PLL4)
2ffc7a90:	f8d4 012c 	ldr.w	r0, [r4, #300]	@ 0x12c
2ffc7a94:	2801      	cmp	r0, #1
2ffc7a96:	f000 838d 	beq.w	2ffc81b4 <HAL_RCCEx_PeriphCLKConfig+0xb88>
      }
      /* Enable USB PHY Clock output generated on PLL4 . */
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
    }

    __HAL_RCC_USBPHY_CONFIG(PeriphClkInit->UsbphyClockSelection);
2ffc7a9a:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7a9e:	f8d5 191c 	ldr.w	r1, [r5, #2332]	@ 0x91c
2ffc7aa2:	f021 0103 	bic.w	r1, r1, #3
2ffc7aa6:	4301      	orrs	r1, r0
2ffc7aa8:	f8c5 191c 	str.w	r1, [r5, #2332]	@ 0x91c
  }

  /*---------------------------- USBO configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USBO) ==
2ffc7aac:	031f      	lsls	r7, r3, #12
2ffc7aae:	d50d      	bpl.n	2ffc7acc <HAL_RCCEx_PeriphCLKConfig+0x4a0>
      RCC_PERIPHCLK_USBO)
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOCLKSOURCE(PeriphClkInit->UsboClockSelection));

    if (PeriphClkInit->UsboClockSelection == RCC_USBOCLKSOURCE_PLL4)
2ffc7ab0:	f8d4 0130 	ldr.w	r0, [r4, #304]	@ 0x130
2ffc7ab4:	2800      	cmp	r0, #0
2ffc7ab6:	f000 834c 	beq.w	2ffc8152 <HAL_RCCEx_PeriphCLKConfig+0xb26>
      }
      /* Enable USB OTG Clock output generated on PLL4 . */
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
    }

    __HAL_RCC_USBO_CONFIG(PeriphClkInit->UsboClockSelection);
2ffc7aba:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7abe:	f8d5 191c 	ldr.w	r1, [r5, #2332]	@ 0x91c
2ffc7ac2:	f021 0110 	bic.w	r1, r1, #16
2ffc7ac6:	4301      	orrs	r1, r0
2ffc7ac8:	f8c5 191c 	str.w	r1, [r5, #2332]	@ 0x91c
  }

  /*---------------------------- RNG1 configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG1) ==
2ffc7acc:	0756      	lsls	r6, r2, #29
2ffc7ace:	d50d      	bpl.n	2ffc7aec <HAL_RCCEx_PeriphCLKConfig+0x4c0>
      RCC_PERIPHCLK_RNG1)
  {
    /* Check the parameters */
    assert_param(IS_RCC_RNG1CLKSOURCE(PeriphClkInit->Rng1ClockSelection));

    if (PeriphClkInit->Rng1ClockSelection == RCC_RNG1CLKSOURCE_PLL4)
2ffc7ad0:	f8d4 0120 	ldr.w	r0, [r4, #288]	@ 0x120
2ffc7ad4:	2801      	cmp	r0, #1
2ffc7ad6:	f000 8382 	beq.w	2ffc81de <HAL_RCCEx_PeriphCLKConfig+0xbb2>
      /* Enable RNG1 Clock output generated on PLL4 . */
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
    }

    /* Set the source of RNG1 clock*/
    __HAL_RCC_RNG1_CONFIG(PeriphClkInit->Rng1ClockSelection);
2ffc7ada:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7ade:	f8d5 10cc 	ldr.w	r1, [r5, #204]	@ 0xcc
2ffc7ae2:	f021 0103 	bic.w	r1, r1, #3
2ffc7ae6:	4301      	orrs	r1, r0
2ffc7ae8:	f8c5 10cc 	str.w	r1, [r5, #204]	@ 0xcc
  }

  /*---------------------------- RNG2 configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG2) ==
2ffc7aec:	0715      	lsls	r5, r2, #28
2ffc7aee:	d50d      	bpl.n	2ffc7b0c <HAL_RCCEx_PeriphCLKConfig+0x4e0>
      RCC_PERIPHCLK_RNG2)
  {
    /* Check the parameters */
    assert_param(IS_RCC_RNG2CLKSOURCE(PeriphClkInit->Rng2ClockSelection));

    if (PeriphClkInit->Rng2ClockSelection == RCC_RNG2CLKSOURCE_PLL4)
2ffc7af0:	f8d4 0124 	ldr.w	r0, [r4, #292]	@ 0x124
2ffc7af4:	2801      	cmp	r0, #1
2ffc7af6:	f000 84e9 	beq.w	2ffc84cc <HAL_RCCEx_PeriphCLKConfig+0xea0>
      /* Enable RNG2 Clock output generated on PLL4 . */
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
    }

    /* Set the source of RNG2 clock*/
    __HAL_RCC_RNG2_CONFIG(PeriphClkInit->Rng2ClockSelection);
2ffc7afa:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7afe:	f8d5 1920 	ldr.w	r1, [r5, #2336]	@ 0x920
2ffc7b02:	f021 0103 	bic.w	r1, r1, #3
2ffc7b06:	4301      	orrs	r1, r0
2ffc7b08:	f8c5 1920 	str.w	r1, [r5, #2336]	@ 0x920
  }

  /*---------------------------- STGEN configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_STGEN) ==
2ffc7b0c:	06d0      	lsls	r0, r2, #27
2ffc7b0e:	d50a      	bpl.n	2ffc7b26 <HAL_RCCEx_PeriphCLKConfig+0x4fa>
      RCC_PERIPHCLK_STGEN)
  {
    /* Check the parameters */
    assert_param(IS_RCC_STGENCLKSOURCE(PeriphClkInit->StgenClockSelection));

    __HAL_RCC_STGEN_CONFIG(PeriphClkInit->StgenClockSelection);
2ffc7b10:	f8d4 0128 	ldr.w	r0, [r4, #296]	@ 0x128
2ffc7b14:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc7b18:	f8d1 20d4 	ldr.w	r2, [r1, #212]	@ 0xd4
2ffc7b1c:	f022 0203 	bic.w	r2, r2, #3
2ffc7b20:	4302      	orrs	r2, r0
2ffc7b22:	f8c1 20d4 	str.w	r2, [r1, #212]	@ 0xd4
  }

#if defined(DSI)
  /*---------------------------- DSI configuration ---------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DSI) ==
2ffc7b26:	0259      	lsls	r1, r3, #9
2ffc7b28:	d50d      	bpl.n	2ffc7b46 <HAL_RCCEx_PeriphCLKConfig+0x51a>
      RCC_PERIPHCLK_DSI)
  {
    /* Check the parameters */
    assert_param(IS_RCC_DSICLKSOURCE(PeriphClkInit->DsiClockSelection));

    if (PeriphClkInit->DsiClockSelection == RCC_DSICLKSOURCE_PLL4)
2ffc7b2a:	f8d4 1110 	ldr.w	r1, [r4, #272]	@ 0x110
2ffc7b2e:	2901      	cmp	r1, #1
2ffc7b30:	f000 84e2 	beq.w	2ffc84f8 <HAL_RCCEx_PeriphCLKConfig+0xecc>
      }
      /* Enable DSI Clock output generated on PLL4 . */
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
    }

    __HAL_RCC_DSI_CONFIG(PeriphClkInit->DsiClockSelection);
2ffc7b34:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
2ffc7b38:	f8d0 2924 	ldr.w	r2, [r0, #2340]	@ 0x924
2ffc7b3c:	f022 0201 	bic.w	r2, r2, #1
2ffc7b40:	430a      	orrs	r2, r1
2ffc7b42:	f8c0 2924 	str.w	r2, [r0, #2340]	@ 0x924
  }
#endif /*DSI*/

  /*---------------------------- ADC configuration ---------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) ==
2ffc7b46:	071a      	lsls	r2, r3, #28
2ffc7b48:	d521      	bpl.n	2ffc7b8e <HAL_RCCEx_PeriphCLKConfig+0x562>
      RCC_PERIPHCLK_ADC)
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    switch (PeriphClkInit->AdcClockSelection)
2ffc7b4a:	f8d4 1144 	ldr.w	r1, [r4, #324]	@ 0x144
2ffc7b4e:	2900      	cmp	r1, #0
2ffc7b50:	f000 847d 	beq.w	2ffc844e <HAL_RCCEx_PeriphCLKConfig+0xe22>
2ffc7b54:	2902      	cmp	r1, #2
2ffc7b56:	d111      	bne.n	2ffc7b7c <HAL_RCCEx_PeriphCLKConfig+0x550>
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
        break;

      case RCC_ADCCLKSOURCE_PLL3: /* PLL3 is used as clock source for ADC */

        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7b58:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7b5c:	f7ff fb90 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc7b60:	4605      	mov	r5, r0
2ffc7b62:	2800      	cmp	r0, #0
2ffc7b64:	d174      	bne.n	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
    /* Set the source of ADC clock*/
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
  }

  /*---------------------------- LPTIM45 configuration -----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM45) ==
2ffc7b66:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7b68:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc7b6c:	f8d1 2880 	ldr.w	r2, [r1, #2176]	@ 0x880
2ffc7b70:	f042 0220 	orr.w	r2, r2, #32
2ffc7b74:	f8c1 2880 	str.w	r2, [r1, #2176]	@ 0x880
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
2ffc7b78:	f8d4 1144 	ldr.w	r1, [r4, #324]	@ 0x144
2ffc7b7c:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
2ffc7b80:	f8d0 2928 	ldr.w	r2, [r0, #2344]	@ 0x928
2ffc7b84:	f022 0203 	bic.w	r2, r2, #3
2ffc7b88:	430a      	orrs	r2, r1
2ffc7b8a:	f8c0 2928 	str.w	r2, [r0, #2344]	@ 0x928
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM45) ==
2ffc7b8e:	039f      	lsls	r7, r3, #14
2ffc7b90:	d521      	bpl.n	2ffc7bd6 <HAL_RCCEx_PeriphCLKConfig+0x5aa>
      RCC_PERIPHCLK_LPTIM45)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM45CLKSOURCE(PeriphClkInit->Lptim45ClockSelection));

    switch (PeriphClkInit->Lptim45ClockSelection)
2ffc7b92:	f8d4 1140 	ldr.w	r1, [r4, #320]	@ 0x140
2ffc7b96:	2901      	cmp	r1, #1
2ffc7b98:	f000 846e 	beq.w	2ffc8478 <HAL_RCCEx_PeriphCLKConfig+0xe4c>
2ffc7b9c:	2902      	cmp	r1, #2
2ffc7b9e:	d111      	bne.n	2ffc7bc4 <HAL_RCCEx_PeriphCLKConfig+0x598>
    {
      case RCC_LPTIM45CLKSOURCE_PLL3: /* PLL3 is used as clock source for LPTIM45 */

        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7ba0:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7ba4:	f7ff fb6c 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc7ba8:	4605      	mov	r5, r0
2ffc7baa:	2800      	cmp	r0, #0
2ffc7bac:	d150      	bne.n	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
    /* Set the source of LPTIM45 clock*/
    __HAL_RCC_LPTIM45_CONFIG(PeriphClkInit->Lptim45ClockSelection);
  }

  /*---------------------------- LPTIM23 configuration -----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM23) ==
2ffc7bae:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7bb0:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc7bb4:	f8d1 2880 	ldr.w	r2, [r1, #2176]	@ 0x880
2ffc7bb8:	f042 0220 	orr.w	r2, r2, #32
2ffc7bbc:	f8c1 2880 	str.w	r2, [r1, #2176]	@ 0x880
    __HAL_RCC_LPTIM45_CONFIG(PeriphClkInit->Lptim45ClockSelection);
2ffc7bc0:	f8d4 1140 	ldr.w	r1, [r4, #320]	@ 0x140
2ffc7bc4:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
2ffc7bc8:	f8d0 292c 	ldr.w	r2, [r0, #2348]	@ 0x92c
2ffc7bcc:	f022 0207 	bic.w	r2, r2, #7
2ffc7bd0:	430a      	orrs	r2, r1
2ffc7bd2:	f8c0 292c 	str.w	r2, [r0, #2348]	@ 0x92c
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM23) ==
2ffc7bd6:	03de      	lsls	r6, r3, #15
2ffc7bd8:	d50d      	bpl.n	2ffc7bf6 <HAL_RCCEx_PeriphCLKConfig+0x5ca>
      RCC_PERIPHCLK_LPTIM23)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM23CLKSOURCE(PeriphClkInit->Lptim23ClockSelection));

    if (PeriphClkInit->Lptim23ClockSelection == RCC_LPTIM23CLKSOURCE_PLL4)
2ffc7bda:	f8d4 113c 	ldr.w	r1, [r4, #316]	@ 0x13c
2ffc7bde:	2901      	cmp	r1, #1
2ffc7be0:	f000 849f 	beq.w	2ffc8522 <HAL_RCCEx_PeriphCLKConfig+0xef6>
      /* Enable clock output generated on PLL4 . */
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
    }

    /* Set the source of LPTIM23 clock*/
    __HAL_RCC_LPTIM23_CONFIG(PeriphClkInit->Lptim23ClockSelection);
2ffc7be4:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
2ffc7be8:	f8d0 2930 	ldr.w	r2, [r0, #2352]	@ 0x930
2ffc7bec:	f022 0207 	bic.w	r2, r2, #7
2ffc7bf0:	430a      	orrs	r2, r1
2ffc7bf2:	f8c0 2930 	str.w	r2, [r0, #2352]	@ 0x930
  }

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) ==
2ffc7bf6:	065d      	lsls	r5, r3, #25
2ffc7bf8:	d520      	bpl.n	2ffc7c3c <HAL_RCCEx_PeriphCLKConfig+0x610>
      RCC_PERIPHCLK_LPTIM1)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    switch (PeriphClkInit->Lptim1ClockSelection)
2ffc7bfa:	f8d4 1138 	ldr.w	r1, [r4, #312]	@ 0x138
2ffc7bfe:	2901      	cmp	r1, #1
2ffc7c00:	f000 844f 	beq.w	2ffc84a2 <HAL_RCCEx_PeriphCLKConfig+0xe76>
2ffc7c04:	2902      	cmp	r1, #2
2ffc7c06:	d110      	bne.n	2ffc7c2a <HAL_RCCEx_PeriphCLKConfig+0x5fe>
    {
      case RCC_LPTIM1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM1 */

        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7c08:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7c0c:	f7ff fb38 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc7c10:	4605      	mov	r5, r0
2ffc7c12:	b9e8      	cbnz	r0, 2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
    /* Set the source of LPTIM1 clock*/
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
  }

  /*---------------------------- RTC configuration ---------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) ==
2ffc7c14:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7c16:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc7c1a:	f8d1 2880 	ldr.w	r2, [r1, #2176]	@ 0x880
2ffc7c1e:	f042 0220 	orr.w	r2, r2, #32
2ffc7c22:	f8c1 2880 	str.w	r2, [r1, #2176]	@ 0x880
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
2ffc7c26:	f8d4 1138 	ldr.w	r1, [r4, #312]	@ 0x138
2ffc7c2a:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
2ffc7c2e:	f8d0 2934 	ldr.w	r2, [r0, #2356]	@ 0x934
2ffc7c32:	f022 0207 	bic.w	r2, r2, #7
2ffc7c36:	430a      	orrs	r2, r1
2ffc7c38:	f8c0 2934 	str.w	r2, [r0, #2356]	@ 0x934
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) ==
2ffc7c3c:	04d8      	lsls	r0, r3, #19
2ffc7c3e:	f100 8256 	bmi.w	2ffc80ee <HAL_RCCEx_PeriphCLKConfig+0xac2>
      return ret;
    }
  }

  /*---------------------------- TIMG1 configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIMG1) ==
2ffc7c42:	055a      	lsls	r2, r3, #21
2ffc7c44:	f100 829a 	bmi.w	2ffc817c <HAL_RCCEx_PeriphCLKConfig+0xb50>
      }
    }
  }

  /*---------------------------- TIMG2 configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIMG2) ==
2ffc7c48:	051b      	lsls	r3, r3, #20
2ffc7c4a:	f100 83e5 	bmi.w	2ffc8418 <HAL_RCCEx_PeriphCLKConfig+0xdec>
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
2ffc7c4e:	2500      	movs	r5, #0
}
2ffc7c50:	4628      	mov	r0, r5
2ffc7c52:	b047      	add	sp, #284	@ 0x11c
2ffc7c54:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch (PeriphClkInit->Spi1ClockSelection)
2ffc7c56:	f8d4 10d8 	ldr.w	r1, [r4, #216]	@ 0xd8
2ffc7c5a:	2901      	cmp	r1, #1
2ffc7c5c:	f000 809c 	beq.w	2ffc7d98 <HAL_RCCEx_PeriphCLKConfig+0x76c>
2ffc7c60:	2904      	cmp	r1, #4
2ffc7c62:	d05b      	beq.n	2ffc7d1c <HAL_RCCEx_PeriphCLKConfig+0x6f0>
2ffc7c64:	2900      	cmp	r1, #0
2ffc7c66:	d045      	beq.n	2ffc7cf4 <HAL_RCCEx_PeriphCLKConfig+0x6c8>
    __HAL_RCC_SPI1_CONFIG(PeriphClkInit->Spi1ClockSelection);
2ffc7c68:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc7c6c:	f8d5 08d8 	ldr.w	r0, [r5, #2264]	@ 0x8d8
2ffc7c70:	f020 0007 	bic.w	r0, r0, #7
2ffc7c74:	4301      	orrs	r1, r0
2ffc7c76:	f8c5 18d8 	str.w	r1, [r5, #2264]	@ 0x8d8
2ffc7c7a:	e574      	b.n	2ffc7766 <HAL_RCCEx_PeriphCLKConfig+0x13a>
      status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc7c7c:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc7c80:	f7ff fbf0 	bl	2ffc7464 <RCCEx_PLL4_Config>
      if (status != HAL_OK)
2ffc7c84:	4605      	mov	r5, r0
2ffc7c86:	2800      	cmp	r0, #0
2ffc7c88:	d1e2      	bne.n	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) &  RCC_PERIPHCLK_I2C35) ==
2ffc7c8a:	6823      	ldr	r3, [r4, #0]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
2ffc7c8c:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) &  RCC_PERIPHCLK_I2C35) ==
2ffc7c90:	6862      	ldr	r2, [r4, #4]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
2ffc7c92:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc7c96:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
2ffc7c9a:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_I2C12_CONFIG(PeriphClkInit->I2c12ClockSelection);
2ffc7c9e:	f8d4 00bc 	ldr.w	r0, [r4, #188]	@ 0xbc
2ffc7ca2:	e4dc      	b.n	2ffc765e <HAL_RCCEx_PeriphCLKConfig+0x32>
        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc7ca4:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc7ca8:	f7ff fbdc 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc7cac:	4605      	mov	r5, r0
2ffc7cae:	2800      	cmp	r0, #0
2ffc7cb0:	d1ce      	bne.n	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI1) ==
2ffc7cb2:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc7cb4:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI1) ==
2ffc7cb8:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc7cba:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc7cbe:	f041 0120 	orr.w	r1, r1, #32
2ffc7cc2:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_SAI4_CONFIG(PeriphClkInit->Sai4ClockSelection);
2ffc7cc6:	f8d4 10d4 	ldr.w	r1, [r4, #212]	@ 0xd4
        break;
2ffc7cca:	e540      	b.n	2ffc774e <HAL_RCCEx_PeriphCLKConfig+0x122>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7ccc:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7cd0:	f7ff fad6 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc7cd4:	4605      	mov	r5, r0
2ffc7cd6:	2800      	cmp	r0, #0
2ffc7cd8:	d1ba      	bne.n	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI1) ==
2ffc7cda:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc7cdc:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI1) ==
2ffc7ce0:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc7ce2:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc7ce6:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
2ffc7cea:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_SAI4_CONFIG(PeriphClkInit->Sai4ClockSelection);
2ffc7cee:	f8d4 10d4 	ldr.w	r1, [r4, #212]	@ 0xd4
        break;
2ffc7cf2:	e52c      	b.n	2ffc774e <HAL_RCCEx_PeriphCLKConfig+0x122>
        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc7cf4:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc7cf8:	f7ff fbb4 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc7cfc:	4605      	mov	r5, r0
2ffc7cfe:	2800      	cmp	r0, #0
2ffc7d00:	d1a6      	bne.n	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI23) ==
2ffc7d02:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc7d04:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI23) ==
2ffc7d08:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc7d0a:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc7d0e:	f041 0110 	orr.w	r1, r1, #16
2ffc7d12:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_SPI1_CONFIG(PeriphClkInit->Spi1ClockSelection);
2ffc7d16:	f8d4 10d8 	ldr.w	r1, [r4, #216]	@ 0xd8
        break;
2ffc7d1a:	e7a5      	b.n	2ffc7c68 <HAL_RCCEx_PeriphCLKConfig+0x63c>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7d1c:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7d20:	f7ff faae 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc7d24:	4605      	mov	r5, r0
2ffc7d26:	2800      	cmp	r0, #0
2ffc7d28:	d192      	bne.n	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI23) ==
2ffc7d2a:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc7d2c:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI23) ==
2ffc7d30:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc7d32:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc7d36:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
2ffc7d3a:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_SPI1_CONFIG(PeriphClkInit->Spi1ClockSelection);
2ffc7d3e:	f8d4 10d8 	ldr.w	r1, [r4, #216]	@ 0xd8
        break;
2ffc7d42:	e791      	b.n	2ffc7c68 <HAL_RCCEx_PeriphCLKConfig+0x63c>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7d44:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7d48:	f7ff fa9a 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc7d4c:	4605      	mov	r5, r0
2ffc7d4e:	2800      	cmp	r0, #0
2ffc7d50:	f47f af7e 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) ==
2ffc7d54:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc7d56:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) ==
2ffc7d5a:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc7d5c:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc7d60:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
2ffc7d64:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_SPI23_CONFIG(PeriphClkInit->Spi23ClockSelection);
2ffc7d68:	f8d4 10dc 	ldr.w	r1, [r4, #220]	@ 0xdc
        break;
2ffc7d6c:	e508      	b.n	2ffc7780 <HAL_RCCEx_PeriphCLKConfig+0x154>
        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc7d6e:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc7d72:	f7ff fb77 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc7d76:	4605      	mov	r5, r0
2ffc7d78:	2800      	cmp	r0, #0
2ffc7d7a:	f47f af69 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) ==
2ffc7d7e:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc7d80:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) ==
2ffc7d84:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc7d86:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc7d8a:	f041 0110 	orr.w	r1, r1, #16
2ffc7d8e:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_SPI23_CONFIG(PeriphClkInit->Spi23ClockSelection);
2ffc7d92:	f8d4 10dc 	ldr.w	r1, [r4, #220]	@ 0xdc
        break;
2ffc7d96:	e4f3      	b.n	2ffc7780 <HAL_RCCEx_PeriphCLKConfig+0x154>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7d98:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7d9c:	f7ff fa70 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc7da0:	4605      	mov	r5, r0
2ffc7da2:	2800      	cmp	r0, #0
2ffc7da4:	f47f af54 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI23) ==
2ffc7da8:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7daa:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI23) ==
2ffc7dae:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7db0:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc7db4:	f041 0120 	orr.w	r1, r1, #32
2ffc7db8:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_SPI1_CONFIG(PeriphClkInit->Spi1ClockSelection);
2ffc7dbc:	f8d4 10d8 	ldr.w	r1, [r4, #216]	@ 0xd8
        break;
2ffc7dc0:	e752      	b.n	2ffc7c68 <HAL_RCCEx_PeriphCLKConfig+0x63c>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7dc2:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7dc6:	f7ff fa5b 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc7dca:	4605      	mov	r5, r0
2ffc7dcc:	2800      	cmp	r0, #0
2ffc7dce:	f47f af3f 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) ==
2ffc7dd2:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7dd4:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) ==
2ffc7dd8:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7dda:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc7dde:	f041 0120 	orr.w	r1, r1, #32
2ffc7de2:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_SPI23_CONFIG(PeriphClkInit->Spi23ClockSelection);
2ffc7de6:	f8d4 10dc 	ldr.w	r1, [r4, #220]	@ 0xdc
        break;
2ffc7dea:	e4c9      	b.n	2ffc7780 <HAL_RCCEx_PeriphCLKConfig+0x154>
        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc7dec:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc7df0:	f7ff fb38 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc7df4:	4605      	mov	r5, r0
2ffc7df6:	2800      	cmp	r0, #0
2ffc7df8:	f47f af2a 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) ==
2ffc7dfc:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc7dfe:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) ==
2ffc7e02:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc7e04:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc7e08:	f041 0120 	orr.w	r1, r1, #32
2ffc7e0c:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
2ffc7e10:	f8d4 10c8 	ldr.w	r1, [r4, #200]	@ 0xc8
        break;
2ffc7e14:	e459      	b.n	2ffc76ca <HAL_RCCEx_PeriphCLKConfig+0x9e>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7e16:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7e1a:	f7ff fa31 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc7e1e:	4605      	mov	r5, r0
2ffc7e20:	2800      	cmp	r0, #0
2ffc7e22:	f47f af15 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) ==
2ffc7e26:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc7e28:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) ==
2ffc7e2c:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc7e2e:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc7e32:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
2ffc7e36:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
2ffc7e3a:	f8d4 10c8 	ldr.w	r1, [r4, #200]	@ 0xc8
        break;
2ffc7e3e:	e444      	b.n	2ffc76ca <HAL_RCCEx_PeriphCLKConfig+0x9e>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7e40:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7e44:	f7ff fa1c 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc7e48:	4605      	mov	r5, r0
2ffc7e4a:	2800      	cmp	r0, #0
2ffc7e4c:	f47f af00 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) ==
2ffc7e50:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7e52:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) ==
2ffc7e56:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7e58:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc7e5c:	f041 0120 	orr.w	r1, r1, #32
2ffc7e60:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
2ffc7e64:	f8d4 10c8 	ldr.w	r1, [r4, #200]	@ 0xc8
        break;
2ffc7e68:	e42f      	b.n	2ffc76ca <HAL_RCCEx_PeriphCLKConfig+0x9e>
        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc7e6a:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc7e6e:	f7ff faf9 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc7e72:	4605      	mov	r5, r0
2ffc7e74:	2800      	cmp	r0, #0
2ffc7e76:	f47f aeeb 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI3) ==
2ffc7e7a:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc7e7c:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI3) ==
2ffc7e80:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc7e82:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc7e86:	f041 0120 	orr.w	r1, r1, #32
2ffc7e8a:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
2ffc7e8e:	f8d4 10cc 	ldr.w	r1, [r4, #204]	@ 0xcc
        break;
2ffc7e92:	e430      	b.n	2ffc76f6 <HAL_RCCEx_PeriphCLKConfig+0xca>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7e94:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7e98:	f7ff f9f2 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc7e9c:	4605      	mov	r5, r0
2ffc7e9e:	2800      	cmp	r0, #0
2ffc7ea0:	f47f aed6 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI3) ==
2ffc7ea4:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc7ea6:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI3) ==
2ffc7eaa:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc7eac:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc7eb0:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
2ffc7eb4:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
2ffc7eb8:	f8d4 10cc 	ldr.w	r1, [r4, #204]	@ 0xcc
        break;
2ffc7ebc:	e41b      	b.n	2ffc76f6 <HAL_RCCEx_PeriphCLKConfig+0xca>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7ebe:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7ec2:	f7ff f9dd 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc7ec6:	4605      	mov	r5, r0
2ffc7ec8:	2800      	cmp	r0, #0
2ffc7eca:	f47f aec1 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI3) ==
2ffc7ece:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7ed0:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI3) ==
2ffc7ed4:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7ed6:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc7eda:	f041 0120 	orr.w	r1, r1, #32
2ffc7ede:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
2ffc7ee2:	f8d4 10cc 	ldr.w	r1, [r4, #204]	@ 0xcc
        break;
2ffc7ee6:	e406      	b.n	2ffc76f6 <HAL_RCCEx_PeriphCLKConfig+0xca>
      status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc7ee8:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc7eec:	f7ff faba 	bl	2ffc7464 <RCCEx_PLL4_Config>
      if (status != HAL_OK)
2ffc7ef0:	4605      	mov	r5, r0
2ffc7ef2:	2800      	cmp	r0, #0
2ffc7ef4:	f47f aeac 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C46) ==
2ffc7ef8:	6823      	ldr	r3, [r4, #0]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
2ffc7efa:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C46) ==
2ffc7efe:	6862      	ldr	r2, [r4, #4]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
2ffc7f00:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc7f04:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
2ffc7f08:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_I2C35_CONFIG(PeriphClkInit->I2c35ClockSelection);
2ffc7f0c:	f8d4 00c0 	ldr.w	r0, [r4, #192]	@ 0xc0
2ffc7f10:	f7ff bbb5 	b.w	2ffc767e <HAL_RCCEx_PeriphCLKConfig+0x52>
      status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7f14:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7f18:	f7ff f9b2 	bl	2ffc7280 <RCCEx_PLL3_Config>
      if (status != HAL_OK)
2ffc7f1c:	4605      	mov	r5, r0
2ffc7f1e:	2800      	cmp	r0, #0
2ffc7f20:	f47f ae96 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) ==
2ffc7f24:	6823      	ldr	r3, [r4, #0]
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7f26:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) ==
2ffc7f2a:	6862      	ldr	r2, [r4, #4]
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7f2c:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc7f30:	f041 0120 	orr.w	r1, r1, #32
2ffc7f34:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_I2C46_CONFIG(PeriphClkInit->I2c46ClockSelection);
2ffc7f38:	f8d4 00c4 	ldr.w	r0, [r4, #196]	@ 0xc4
2ffc7f3c:	f7ff bbaf 	b.w	2ffc769e <HAL_RCCEx_PeriphCLKConfig+0x72>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7f40:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7f44:	f7ff f99c 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc7f48:	4605      	mov	r5, r0
2ffc7f4a:	2800      	cmp	r0, #0
2ffc7f4c:	f47f ae80 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4) ==
2ffc7f50:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc7f52:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4) ==
2ffc7f56:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc7f58:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc7f5c:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
2ffc7f60:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_SAI3_CONFIG(PeriphClkInit->Sai3ClockSelection);
2ffc7f64:	f8d4 10d0 	ldr.w	r1, [r4, #208]	@ 0xd0
        break;
2ffc7f68:	f7ff bbdb 	b.w	2ffc7722 <HAL_RCCEx_PeriphCLKConfig+0xf6>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7f6c:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7f70:	f7ff f986 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc7f74:	4605      	mov	r5, r0
2ffc7f76:	2800      	cmp	r0, #0
2ffc7f78:	f47f ae6a 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4) ==
2ffc7f7c:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7f7e:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4) ==
2ffc7f82:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7f84:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc7f88:	f041 0120 	orr.w	r1, r1, #32
2ffc7f8c:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_SAI3_CONFIG(PeriphClkInit->Sai3ClockSelection);
2ffc7f90:	f8d4 10d0 	ldr.w	r1, [r4, #208]	@ 0xd0
        break;
2ffc7f94:	f7ff bbc5 	b.w	2ffc7722 <HAL_RCCEx_PeriphCLKConfig+0xf6>
        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc7f98:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc7f9c:	f7ff fa62 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc7fa0:	4605      	mov	r5, r0
2ffc7fa2:	2800      	cmp	r0, #0
2ffc7fa4:	f47f ae54 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4) ==
2ffc7fa8:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc7faa:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4) ==
2ffc7fae:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc7fb0:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc7fb4:	f041 0120 	orr.w	r1, r1, #32
2ffc7fb8:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_SAI3_CONFIG(PeriphClkInit->Sai3ClockSelection);
2ffc7fbc:	f8d4 10d0 	ldr.w	r1, [r4, #208]	@ 0xd0
        break;
2ffc7fc0:	f7ff bbaf 	b.w	2ffc7722 <HAL_RCCEx_PeriphCLKConfig+0xf6>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc7fc4:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc7fc8:	f7ff f95a 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc7fcc:	4605      	mov	r5, r0
2ffc7fce:	2800      	cmp	r0, #0
2ffc7fd0:	f47f ae3e 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI1) ==
2ffc7fd4:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7fd6:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI1) ==
2ffc7fda:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc7fdc:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc7fe0:	f041 0120 	orr.w	r1, r1, #32
2ffc7fe4:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_SAI4_CONFIG(PeriphClkInit->Sai4ClockSelection);
2ffc7fe8:	f8d4 10d4 	ldr.w	r1, [r4, #212]	@ 0xd4
        break;
2ffc7fec:	f7ff bbaf 	b.w	2ffc774e <HAL_RCCEx_PeriphCLKConfig+0x122>
        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc7ff0:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc7ff4:	f7ff fa36 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc7ff8:	4605      	mov	r5, r0
2ffc7ffa:	2800      	cmp	r0, #0
2ffc7ffc:	f47f ae28 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) ==
2ffc8000:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc8002:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) ==
2ffc8006:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc8008:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc800c:	f041 0120 	orr.w	r1, r1, #32
2ffc8010:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
2ffc8014:	f8d4 00e4 	ldr.w	r0, [r4, #228]	@ 0xe4
        break;
2ffc8018:	f7ff bbe8 	b.w	2ffc77ec <HAL_RCCEx_PeriphCLKConfig+0x1c0>
        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc801c:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc8020:	f7ff fa20 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc8024:	4605      	mov	r5, r0
2ffc8026:	2800      	cmp	r0, #0
2ffc8028:	f47f ae12 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) ==
2ffc802c:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc802e:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) ==
2ffc8032:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc8034:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc8038:	f041 0110 	orr.w	r1, r1, #16
2ffc803c:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
2ffc8040:	f8d4 010c 	ldr.w	r0, [r4, #268]	@ 0x10c
        break;
2ffc8044:	e4bd      	b.n	2ffc79c2 <HAL_RCCEx_PeriphCLKConfig+0x396>
        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc8046:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc804a:	f7ff fa0b 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc804e:	4605      	mov	r5, r0
2ffc8050:	2800      	cmp	r0, #0
2ffc8052:	f47f adfd 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) ==
2ffc8056:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc8058:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) ==
2ffc805c:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc805e:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc8062:	f041 0110 	orr.w	r1, r1, #16
2ffc8066:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
2ffc806a:	f8d4 0108 	ldr.w	r0, [r4, #264]	@ 0x108
        break;
2ffc806e:	e4bb      	b.n	2ffc79e8 <HAL_RCCEx_PeriphCLKConfig+0x3bc>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc8070:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc8074:	f7ff f904 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc8078:	4605      	mov	r5, r0
2ffc807a:	2800      	cmp	r0, #0
2ffc807c:	f47f ade8 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) ==
2ffc8080:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc8082:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) ==
2ffc8086:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc8088:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc808c:	f041 0120 	orr.w	r1, r1, #32
2ffc8090:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
2ffc8094:	f8d4 111c 	ldr.w	r1, [r4, #284]	@ 0x11c
        break;
2ffc8098:	e4bc      	b.n	2ffc7a14 <HAL_RCCEx_PeriphCLKConfig+0x3e8>
        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc809a:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc809e:	f7ff f9e1 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc80a2:	4605      	mov	r5, r0
2ffc80a4:	2800      	cmp	r0, #0
2ffc80a6:	f47f add3 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) ==
2ffc80aa:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
2ffc80ac:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) ==
2ffc80b0:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
2ffc80b2:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc80b6:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
2ffc80ba:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
2ffc80be:	f8d4 111c 	ldr.w	r1, [r4, #284]	@ 0x11c
        break;
2ffc80c2:	e4a7      	b.n	2ffc7a14 <HAL_RCCEx_PeriphCLKConfig+0x3e8>
        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc80c4:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc80c8:	f7ff f9cc 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc80cc:	4605      	mov	r5, r0
2ffc80ce:	2800      	cmp	r0, #0
2ffc80d0:	f47f adbe 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) ==
2ffc80d4:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc80d6:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) ==
2ffc80da:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc80dc:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc80e0:	f041 0110 	orr.w	r1, r1, #16
2ffc80e4:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
2ffc80e8:	f8d4 0118 	ldr.w	r0, [r4, #280]	@ 0x118
        break;
2ffc80ec:	e4b8      	b.n	2ffc7a60 <HAL_RCCEx_PeriphCLKConfig+0x434>
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
2ffc80ee:	f44f 5680 	mov.w	r6, #4096	@ 0x1000
2ffc80f2:	f2c5 0600 	movt	r6, #20480	@ 0x5000
2ffc80f6:	6833      	ldr	r3, [r6, #0]
2ffc80f8:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
2ffc80fc:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
2ffc80fe:	f7fb fa25 	bl	2ffc354c <HAL_GetTick>
    while ((PWR->CR1 & PWR_CR1_DBP) == RESET)
2ffc8102:	6835      	ldr	r5, [r6, #0]
    tickstart = HAL_GetTick();
2ffc8104:	4607      	mov	r7, r0
    while ((PWR->CR1 & PWR_CR1_DBP) == RESET)
2ffc8106:	f415 7080 	ands.w	r0, r5, #256	@ 0x100
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
2ffc810a:	bf08      	it	eq
2ffc810c:	4605      	moveq	r5, r0
    while ((PWR->CR1 & PWR_CR1_DBP) == RESET)
2ffc810e:	d10b      	bne.n	2ffc8128 <HAL_RCCEx_PeriphCLKConfig+0xafc>
      if ((HAL_GetTick() - tickstart) > DBP_TIMEOUT_VALUE)
2ffc8110:	f7fb fa1c 	bl	2ffc354c <HAL_GetTick>
2ffc8114:	1bc0      	subs	r0, r0, r7
    while ((PWR->CR1 & PWR_CR1_DBP) == RESET)
2ffc8116:	6833      	ldr	r3, [r6, #0]
        ret = HAL_TIMEOUT;
2ffc8118:	2865      	cmp	r0, #101	@ 0x65
2ffc811a:	bf28      	it	cs
2ffc811c:	2503      	movcs	r5, #3
    while ((PWR->CR1 & PWR_CR1_DBP) == RESET)
2ffc811e:	05d9      	lsls	r1, r3, #23
2ffc8120:	d5f6      	bpl.n	2ffc8110 <HAL_RCCEx_PeriphCLKConfig+0xae4>
    if (ret == HAL_OK)
2ffc8122:	2d00      	cmp	r5, #0
2ffc8124:	f47f ad94 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
      if ((RCC->BDCR & RCC_BDCR_RTCSRC) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSRC))
2ffc8128:	f8d4 2148 	ldr.w	r2, [r4, #328]	@ 0x148
2ffc812c:	f04f 46a0 	mov.w	r6, #1342177280	@ 0x50000000
2ffc8130:	f8d6 3140 	ldr.w	r3, [r6, #320]	@ 0x140
2ffc8134:	4053      	eors	r3, r2
2ffc8136:	f413 3f40 	tst.w	r3, #196608	@ 0x30000
2ffc813a:	f040 8207 	bne.w	2ffc854c <HAL_RCCEx_PeriphCLKConfig+0xf20>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIMG1) ==
2ffc813e:	6823      	ldr	r3, [r4, #0]
      __HAL_RCC_RTC_ENABLE();
2ffc8140:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc8144:	f8d1 2140 	ldr.w	r2, [r1, #320]	@ 0x140
2ffc8148:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
2ffc814c:	f8c1 2140 	str.w	r2, [r1, #320]	@ 0x140
2ffc8150:	e577      	b.n	2ffc7c42 <HAL_RCCEx_PeriphCLKConfig+0x616>
      status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc8152:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc8156:	f7ff f985 	bl	2ffc7464 <RCCEx_PLL4_Config>
      if (status != HAL_OK)
2ffc815a:	4605      	mov	r5, r0
2ffc815c:	2800      	cmp	r0, #0
2ffc815e:	f47f ad77 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG1) ==
2ffc8162:	6823      	ldr	r3, [r4, #0]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
2ffc8164:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG1) ==
2ffc8168:	6862      	ldr	r2, [r4, #4]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
2ffc816a:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc816e:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
2ffc8172:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_USBO_CONFIG(PeriphClkInit->UsboClockSelection);
2ffc8176:	f8d4 0130 	ldr.w	r0, [r4, #304]	@ 0x130
2ffc817a:	e49e      	b.n	2ffc7aba <HAL_RCCEx_PeriphCLKConfig+0x48e>
    __HAL_RCC_TIMG1PRES(PeriphClkInit->TIMG1PresSelection);
2ffc817c:	f8d4 214c 	ldr.w	r2, [r4, #332]	@ 0x14c
2ffc8180:	f04f 45a0 	mov.w	r5, #1342177280	@ 0x50000000
2ffc8184:	f8d5 3828 	ldr.w	r3, [r5, #2088]	@ 0x828
2ffc8188:	f023 0301 	bic.w	r3, r3, #1
2ffc818c:	4313      	orrs	r3, r2
2ffc818e:	f8c5 3828 	str.w	r3, [r5, #2088]	@ 0x828
    tickstart = HAL_GetTick();
2ffc8192:	f7fb f9db 	bl	2ffc354c <HAL_GetTick>
2ffc8196:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_TIMG1PRERDY) == RESET)
2ffc8198:	e006      	b.n	2ffc81a8 <HAL_RCCEx_PeriphCLKConfig+0xb7c>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
2ffc819a:	f7fb f9d7 	bl	2ffc354c <HAL_GetTick>
2ffc819e:	1b80      	subs	r0, r0, r6
2ffc81a0:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
2ffc81a4:	f200 8151 	bhi.w	2ffc844a <HAL_RCCEx_PeriphCLKConfig+0xe1e>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_TIMG1PRERDY) == RESET)
2ffc81a8:	f8d5 3828 	ldr.w	r3, [r5, #2088]	@ 0x828
2ffc81ac:	2b00      	cmp	r3, #0
2ffc81ae:	daf4      	bge.n	2ffc819a <HAL_RCCEx_PeriphCLKConfig+0xb6e>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIMG2) ==
2ffc81b0:	6823      	ldr	r3, [r4, #0]
2ffc81b2:	e549      	b.n	2ffc7c48 <HAL_RCCEx_PeriphCLKConfig+0x61c>
      status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc81b4:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc81b8:	f7ff f954 	bl	2ffc7464 <RCCEx_PLL4_Config>
      if (status != HAL_OK)
2ffc81bc:	4605      	mov	r5, r0
2ffc81be:	2800      	cmp	r0, #0
2ffc81c0:	f47f ad46 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USBO) ==
2ffc81c4:	6823      	ldr	r3, [r4, #0]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
2ffc81c6:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USBO) ==
2ffc81ca:	6862      	ldr	r2, [r4, #4]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
2ffc81cc:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc81d0:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
2ffc81d4:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_USBPHY_CONFIG(PeriphClkInit->UsbphyClockSelection);
2ffc81d8:	f8d4 012c 	ldr.w	r0, [r4, #300]	@ 0x12c
2ffc81dc:	e45d      	b.n	2ffc7a9a <HAL_RCCEx_PeriphCLKConfig+0x46e>
      status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc81de:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc81e2:	f7ff f93f 	bl	2ffc7464 <RCCEx_PLL4_Config>
      if (status != HAL_OK)
2ffc81e6:	4605      	mov	r5, r0
2ffc81e8:	2800      	cmp	r0, #0
2ffc81ea:	f47f ad31 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG2) ==
2ffc81ee:	6823      	ldr	r3, [r4, #0]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
2ffc81f0:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG2) ==
2ffc81f4:	6862      	ldr	r2, [r4, #4]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
2ffc81f6:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc81fa:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
2ffc81fe:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_RNG1_CONFIG(PeriphClkInit->Rng1ClockSelection);
2ffc8202:	f8d4 0120 	ldr.w	r0, [r4, #288]	@ 0x120
2ffc8206:	e468      	b.n	2ffc7ada <HAL_RCCEx_PeriphCLKConfig+0x4ae>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc8208:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc820c:	f7ff f838 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc8210:	4605      	mov	r5, r0
2ffc8212:	2800      	cmp	r0, #0
2ffc8214:	f47f ad1c 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC12) ==
2ffc8218:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc821a:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC12) ==
2ffc821e:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2ffc8220:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc8224:	f041 0120 	orr.w	r1, r1, #32
2ffc8228:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
2ffc822c:	f8d4 00e8 	ldr.w	r0, [r4, #232]	@ 0xe8
        break;
2ffc8230:	f7ff bb42 	b.w	2ffc78b8 <HAL_RCCEx_PeriphCLKConfig+0x28c>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc8234:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc8238:	f7ff f822 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc823c:	4605      	mov	r5, r0
2ffc823e:	2800      	cmp	r0, #0
2ffc8240:	f47f ad06 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC3) ==
2ffc8244:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc8246:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC3) ==
2ffc824a:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc824c:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc8250:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
2ffc8254:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_SDMMC12_CONFIG(PeriphClkInit->Sdmmc12ClockSelection);
2ffc8258:	f8d4 00fc 	ldr.w	r0, [r4, #252]	@ 0xfc
        break;
2ffc825c:	f7ff bb52 	b.w	2ffc7904 <HAL_RCCEx_PeriphCLKConfig+0x2d8>
      status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc8260:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc8264:	f7ff f8fe 	bl	2ffc7464 <RCCEx_PLL4_Config>
      if (status != HAL_OK)
2ffc8268:	4605      	mov	r5, r0
2ffc826a:	2800      	cmp	r0, #0
2ffc826c:	f47f acf0 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) ==
2ffc8270:	6823      	ldr	r3, [r4, #0]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc8272:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) ==
2ffc8276:	6862      	ldr	r2, [r4, #4]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc8278:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc827c:	f041 0120 	orr.w	r1, r1, #32
2ffc8280:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
2ffc8284:	f8d4 00e0 	ldr.w	r0, [r4, #224]	@ 0xe0
2ffc8288:	f7ff ba8a 	b.w	2ffc77a0 <HAL_RCCEx_PeriphCLKConfig+0x174>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc828c:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc8290:	f7fe fff6 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc8294:	4605      	mov	r5, r0
2ffc8296:	2800      	cmp	r0, #0
2ffc8298:	f47f acda 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ETH) ==
2ffc829c:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc829e:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ETH) ==
2ffc82a2:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc82a4:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc82a8:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
2ffc82ac:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_SDMMC3_CONFIG(PeriphClkInit->Sdmmc3ClockSelection);
2ffc82b0:	f8d4 0100 	ldr.w	r0, [r4, #256]	@ 0x100
        break;
2ffc82b4:	f7ff bb4c 	b.w	2ffc7950 <HAL_RCCEx_PeriphCLKConfig+0x324>
      status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc82b8:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc82bc:	f7ff f8d2 	bl	2ffc7464 <RCCEx_PLL4_Config>
      if (status != HAL_OK)
2ffc82c0:	4605      	mov	r5, r0
2ffc82c2:	2800      	cmp	r0, #0
2ffc82c4:	f47f acc4 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART24) ==
2ffc82c8:	6823      	ldr	r3, [r4, #0]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc82ca:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART24) ==
2ffc82ce:	6862      	ldr	r2, [r4, #4]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc82d0:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc82d4:	f041 0120 	orr.w	r1, r1, #32
2ffc82d8:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
2ffc82dc:	f8d4 00f4 	ldr.w	r0, [r4, #244]	@ 0xf4
2ffc82e0:	f7ff ba94 	b.w	2ffc780c <HAL_RCCEx_PeriphCLKConfig+0x1e0>
        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc82e4:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc82e8:	f7ff f8bc 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc82ec:	4605      	mov	r5, r0
2ffc82ee:	2800      	cmp	r0, #0
2ffc82f0:	f47f acae 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) ==
2ffc82f4:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc82f6:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) ==
2ffc82fa:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc82fc:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc8300:	f041 0110 	orr.w	r1, r1, #16
2ffc8304:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_ETH_CONFIG(PeriphClkInit->EthClockSelection);
2ffc8308:	f8d4 0104 	ldr.w	r0, [r4, #260]	@ 0x104
        break;
2ffc830c:	f7ff bb46 	b.w	2ffc799c <HAL_RCCEx_PeriphCLKConfig+0x370>
      status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc8310:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc8314:	f7ff f8a6 	bl	2ffc7464 <RCCEx_PLL4_Config>
      if (status != HAL_OK)
2ffc8318:	4605      	mov	r5, r0
2ffc831a:	2800      	cmp	r0, #0
2ffc831c:	f47f ac98 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART35) ==
2ffc8320:	6823      	ldr	r3, [r4, #0]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc8322:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART35) ==
2ffc8326:	6862      	ldr	r2, [r4, #4]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc8328:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc832c:	f041 0120 	orr.w	r1, r1, #32
2ffc8330:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_UART24_CONFIG(PeriphClkInit->Uart24ClockSelection);
2ffc8334:	f8d4 00ec 	ldr.w	r0, [r4, #236]	@ 0xec
2ffc8338:	f7ff ba78 	b.w	2ffc782c <HAL_RCCEx_PeriphCLKConfig+0x200>
      status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc833c:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc8340:	f7ff f890 	bl	2ffc7464 <RCCEx_PLL4_Config>
      if (status != HAL_OK)
2ffc8344:	4605      	mov	r5, r0
2ffc8346:	2800      	cmp	r0, #0
2ffc8348:	f47f ac82 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART78) ==
2ffc834c:	6823      	ldr	r3, [r4, #0]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc834e:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART78) ==
2ffc8352:	6862      	ldr	r2, [r4, #4]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc8354:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc8358:	f041 0120 	orr.w	r1, r1, #32
2ffc835c:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_UART35_CONFIG(PeriphClkInit->Uart35ClockSelection);
2ffc8360:	f8d4 00f0 	ldr.w	r0, [r4, #240]	@ 0xf0
2ffc8364:	f7ff ba72 	b.w	2ffc784c <HAL_RCCEx_PeriphCLKConfig+0x220>
      status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc8368:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc836c:	f7ff f87a 	bl	2ffc7464 <RCCEx_PLL4_Config>
      if (status != HAL_OK)
2ffc8370:	4605      	mov	r5, r0
2ffc8372:	2800      	cmp	r0, #0
2ffc8374:	f47f ac6c 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) ==
2ffc8378:	6823      	ldr	r3, [r4, #0]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc837a:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) ==
2ffc837e:	6862      	ldr	r2, [r4, #4]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc8380:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc8384:	f041 0120 	orr.w	r1, r1, #32
2ffc8388:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_UART78_CONFIG(PeriphClkInit->Uart78ClockSelection);
2ffc838c:	f8d4 00f8 	ldr.w	r0, [r4, #248]	@ 0xf8
2ffc8390:	f7ff ba6c 	b.w	2ffc786c <HAL_RCCEx_PeriphCLKConfig+0x240>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc8394:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc8398:	f7fe ff72 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc839c:	4605      	mov	r5, r0
2ffc839e:	2800      	cmp	r0, #0
2ffc83a0:	f47f ac56 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) ==
2ffc83a4:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc83a6:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) ==
2ffc83aa:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc83ac:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc83b0:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
2ffc83b4:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
2ffc83b8:	f8d4 010c 	ldr.w	r0, [r4, #268]	@ 0x10c
        break;
2ffc83bc:	f7ff bb01 	b.w	2ffc79c2 <HAL_RCCEx_PeriphCLKConfig+0x396>
        status = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3));
2ffc83c0:	f104 0044 	add.w	r0, r4, #68	@ 0x44
2ffc83c4:	f7fe ff5c 	bl	2ffc7280 <RCCEx_PLL3_Config>
        if (status != HAL_OK)
2ffc83c8:	4605      	mov	r5, r0
2ffc83ca:	2800      	cmp	r0, #0
2ffc83cc:	f47f ac40 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) ==
2ffc83d0:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc83d2:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) ==
2ffc83d6:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2ffc83d8:	f8d0 1880 	ldr.w	r1, [r0, #2176]	@ 0x880
2ffc83dc:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
2ffc83e0:	f8c0 1880 	str.w	r1, [r0, #2176]	@ 0x880
    __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
2ffc83e4:	f8d4 0108 	ldr.w	r0, [r4, #264]	@ 0x108
        break;
2ffc83e8:	f7ff bafe 	b.w	2ffc79e8 <HAL_RCCEx_PeriphCLKConfig+0x3bc>
        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc83ec:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc83f0:	f7ff f838 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc83f4:	4605      	mov	r5, r0
2ffc83f6:	2800      	cmp	r0, #0
2ffc83f8:	f47f ac2a 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) ==
2ffc83fc:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc83fe:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) ==
2ffc8402:	6862      	ldr	r2, [r4, #4]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc8404:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc8408:	f041 0120 	orr.w	r1, r1, #32
2ffc840c:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
2ffc8410:	f8d4 111c 	ldr.w	r1, [r4, #284]	@ 0x11c
        break;
2ffc8414:	f7ff bafe 	b.w	2ffc7a14 <HAL_RCCEx_PeriphCLKConfig+0x3e8>
    __HAL_RCC_TIMG2PRES(PeriphClkInit->TIMG2PresSelection);
2ffc8418:	f8d4 2150 	ldr.w	r2, [r4, #336]	@ 0x150
2ffc841c:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
2ffc8420:	f8d4 382c 	ldr.w	r3, [r4, #2092]	@ 0x82c
2ffc8424:	f023 0301 	bic.w	r3, r3, #1
2ffc8428:	4313      	orrs	r3, r2
2ffc842a:	f8c4 382c 	str.w	r3, [r4, #2092]	@ 0x82c
    tickstart = HAL_GetTick();
2ffc842e:	f7fb f88d 	bl	2ffc354c <HAL_GetTick>
2ffc8432:	4605      	mov	r5, r0
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_TIMG2PRERDY) == RESET)
2ffc8434:	f8d4 382c 	ldr.w	r3, [r4, #2092]	@ 0x82c
2ffc8438:	2b00      	cmp	r3, #0
2ffc843a:	f6ff ac08 	blt.w	2ffc7c4e <HAL_RCCEx_PeriphCLKConfig+0x622>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
2ffc843e:	f7fb f885 	bl	2ffc354c <HAL_GetTick>
2ffc8442:	1b40      	subs	r0, r0, r5
2ffc8444:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
2ffc8448:	d9f4      	bls.n	2ffc8434 <HAL_RCCEx_PeriphCLKConfig+0xe08>
        return HAL_TIMEOUT;
2ffc844a:	2503      	movs	r5, #3
2ffc844c:	e400      	b.n	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc844e:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc8452:	f7ff f807 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc8456:	4605      	mov	r5, r0
2ffc8458:	2800      	cmp	r0, #0
2ffc845a:	f47f abf9 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM45) ==
2ffc845e:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
2ffc8460:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc8464:	f8d1 2894 	ldr.w	r2, [r1, #2196]	@ 0x894
2ffc8468:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
2ffc846c:	f8c1 2894 	str.w	r2, [r1, #2196]	@ 0x894
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
2ffc8470:	f8d4 1144 	ldr.w	r1, [r4, #324]	@ 0x144
        break;
2ffc8474:	f7ff bb82 	b.w	2ffc7b7c <HAL_RCCEx_PeriphCLKConfig+0x550>
        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc8478:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc847c:	f7fe fff2 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc8480:	4605      	mov	r5, r0
2ffc8482:	2800      	cmp	r0, #0
2ffc8484:	f47f abe4 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM23) ==
2ffc8488:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc848a:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc848e:	f8d1 2894 	ldr.w	r2, [r1, #2196]	@ 0x894
2ffc8492:	f042 0210 	orr.w	r2, r2, #16
2ffc8496:	f8c1 2894 	str.w	r2, [r1, #2196]	@ 0x894
    __HAL_RCC_LPTIM45_CONFIG(PeriphClkInit->Lptim45ClockSelection);
2ffc849a:	f8d4 1140 	ldr.w	r1, [r4, #320]	@ 0x140
        break;
2ffc849e:	f7ff bb91 	b.w	2ffc7bc4 <HAL_RCCEx_PeriphCLKConfig+0x598>
        status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc84a2:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc84a6:	f7fe ffdd 	bl	2ffc7464 <RCCEx_PLL4_Config>
        if (status != HAL_OK)
2ffc84aa:	4605      	mov	r5, r0
2ffc84ac:	2800      	cmp	r0, #0
2ffc84ae:	f47f abcf 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) ==
2ffc84b2:	6823      	ldr	r3, [r4, #0]
        __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc84b4:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc84b8:	f8d1 2894 	ldr.w	r2, [r1, #2196]	@ 0x894
2ffc84bc:	f042 0210 	orr.w	r2, r2, #16
2ffc84c0:	f8c1 2894 	str.w	r2, [r1, #2196]	@ 0x894
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
2ffc84c4:	f8d4 1138 	ldr.w	r1, [r4, #312]	@ 0x138
        break;
2ffc84c8:	f7ff bbaf 	b.w	2ffc7c2a <HAL_RCCEx_PeriphCLKConfig+0x5fe>
      status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc84cc:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc84d0:	f7fe ffc8 	bl	2ffc7464 <RCCEx_PLL4_Config>
      if (status != HAL_OK)
2ffc84d4:	4605      	mov	r5, r0
2ffc84d6:	2800      	cmp	r0, #0
2ffc84d8:	f47f abba 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_STGEN) ==
2ffc84dc:	6823      	ldr	r3, [r4, #0]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
2ffc84de:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_STGEN) ==
2ffc84e2:	6862      	ldr	r2, [r4, #4]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVR);
2ffc84e4:	f8d0 1894 	ldr.w	r1, [r0, #2196]	@ 0x894
2ffc84e8:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
2ffc84ec:	f8c0 1894 	str.w	r1, [r0, #2196]	@ 0x894
    __HAL_RCC_RNG2_CONFIG(PeriphClkInit->Rng2ClockSelection);
2ffc84f0:	f8d4 0124 	ldr.w	r0, [r4, #292]	@ 0x124
2ffc84f4:	f7ff bb01 	b.w	2ffc7afa <HAL_RCCEx_PeriphCLKConfig+0x4ce>
      status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc84f8:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc84fc:	f7fe ffb2 	bl	2ffc7464 <RCCEx_PLL4_Config>
      if (status != HAL_OK)
2ffc8500:	4605      	mov	r5, r0
2ffc8502:	2800      	cmp	r0, #0
2ffc8504:	f47f aba4 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) ==
2ffc8508:	6823      	ldr	r3, [r4, #0]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVP);
2ffc850a:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc850e:	f8d1 2894 	ldr.w	r2, [r1, #2196]	@ 0x894
2ffc8512:	f042 0210 	orr.w	r2, r2, #16
2ffc8516:	f8c1 2894 	str.w	r2, [r1, #2196]	@ 0x894
    __HAL_RCC_DSI_CONFIG(PeriphClkInit->DsiClockSelection);
2ffc851a:	f8d4 1110 	ldr.w	r1, [r4, #272]	@ 0x110
2ffc851e:	f7ff bb09 	b.w	2ffc7b34 <HAL_RCCEx_PeriphCLKConfig+0x508>
      status = RCCEx_PLL4_Config(&(PeriphClkInit->PLL4));
2ffc8522:	f104 0080 	add.w	r0, r4, #128	@ 0x80
2ffc8526:	f7fe ff9d 	bl	2ffc7464 <RCCEx_PLL4_Config>
      if (status != HAL_OK)
2ffc852a:	4605      	mov	r5, r0
2ffc852c:	2800      	cmp	r0, #0
2ffc852e:	f47f ab8f 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) ==
2ffc8532:	6823      	ldr	r3, [r4, #0]
      __HAL_RCC_PLL4CLKOUT_ENABLE(RCC_PLL4_DIVQ);
2ffc8534:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
2ffc8538:	f8d1 2894 	ldr.w	r2, [r1, #2196]	@ 0x894
2ffc853c:	f042 0220 	orr.w	r2, r2, #32
2ffc8540:	f8c1 2894 	str.w	r2, [r1, #2196]	@ 0x894
    __HAL_RCC_LPTIM23_CONFIG(PeriphClkInit->Lptim23ClockSelection);
2ffc8544:	f8d4 113c 	ldr.w	r1, [r4, #316]	@ 0x13c
2ffc8548:	f7ff bb4c 	b.w	2ffc7be4 <HAL_RCCEx_PeriphCLKConfig+0x5b8>
        tmpreg = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSRC));
2ffc854c:	f8d6 7140 	ldr.w	r7, [r6, #320]	@ 0x140
        ret = HAL_RCC_OscConfig(&RCC_OscInitStructure);
2ffc8550:	a801      	add	r0, sp, #4
        __HAL_RCC_BACKUPRESET_FORCE();
2ffc8552:	f8d6 3140 	ldr.w	r3, [r6, #320]	@ 0x140
        __HAL_RCC_LSEDRIVE_CONFIG(tmpreg & RCC_BDCR_LSEDRV);
2ffc8556:	f007 0230 	and.w	r2, r7, #48	@ 0x30
        __HAL_RCC_BACKUPRESET_FORCE();
2ffc855a:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
2ffc855e:	f8c6 3140 	str.w	r3, [r6, #320]	@ 0x140
        __HAL_RCC_BACKUPRESET_RELEASE();
2ffc8562:	f8d6 3140 	ldr.w	r3, [r6, #320]	@ 0x140
2ffc8566:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
2ffc856a:	f8c6 3140 	str.w	r3, [r6, #320]	@ 0x140
        __HAL_RCC_LSEDRIVE_CONFIG(tmpreg & RCC_BDCR_LSEDRV);
2ffc856e:	f8d6 3140 	ldr.w	r3, [r6, #320]	@ 0x140
2ffc8572:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
2ffc8576:	4313      	orrs	r3, r2
2ffc8578:	f8c6 3140 	str.w	r3, [r6, #320]	@ 0x140
        RCC_OscInitStructure.PLL.PLLState = RCC_PLL_NONE;
2ffc857c:	2300      	movs	r3, #0
2ffc857e:	930a      	str	r3, [sp, #40]	@ 0x28
        RCC_OscInitStructure.PLL2.PLLState = RCC_PLL_NONE;
2ffc8580:	9319      	str	r3, [sp, #100]	@ 0x64
        RCC_OscInitStructure.PLL3.PLLState = RCC_PLL_NONE;
2ffc8582:	9328      	str	r3, [sp, #160]	@ 0xa0
        RCC_OscInitStructure.PLL4.PLLState = RCC_PLL_NONE;
2ffc8584:	9337      	str	r3, [sp, #220]	@ 0xdc
        RCC_OscInitStructure.OscillatorType = RCC_OSCILLATORTYPE_LSE;
2ffc8586:	2304      	movs	r3, #4
2ffc8588:	9301      	str	r3, [sp, #4]
        RCC_OscInitStructure.LSEState = (tmpreg & LSE_MASK);
2ffc858a:	f007 030b 	and.w	r3, r7, #11
2ffc858e:	9303      	str	r3, [sp, #12]
        ret = HAL_RCC_OscConfig(&RCC_OscInitStructure);
2ffc8590:	f7fe f9f2 	bl	2ffc6978 <HAL_RCC_OscConfig>
        if (ret != HAL_OK)
2ffc8594:	4605      	mov	r5, r0
2ffc8596:	2800      	cmp	r0, #0
2ffc8598:	f47f ab5a 	bne.w	2ffc7c50 <HAL_RCCEx_PeriphCLKConfig+0x624>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
2ffc859c:	f8d6 2140 	ldr.w	r2, [r6, #320]	@ 0x140
2ffc85a0:	f8d4 3148 	ldr.w	r3, [r4, #328]	@ 0x148
2ffc85a4:	f422 3240 	bic.w	r2, r2, #196608	@ 0x30000
2ffc85a8:	431a      	orrs	r2, r3
        WRITE_REG(RCC->BDCR, (READ_REG(RCC->BDCR) | (tmpreg & RESERVED_BDCR_MASK)));
2ffc85aa:	f64f 53c0 	movw	r3, #64960	@ 0xfdc0
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
2ffc85ae:	f8c6 2140 	str.w	r2, [r6, #320]	@ 0x140
        WRITE_REG(RCC->BDCR, (READ_REG(RCC->BDCR) | (tmpreg & RESERVED_BDCR_MASK)));
2ffc85b2:	f6c7 73ec 	movt	r3, #32748	@ 0x7fec
2ffc85b6:	f8d6 2140 	ldr.w	r2, [r6, #320]	@ 0x140
2ffc85ba:	403b      	ands	r3, r7
2ffc85bc:	4313      	orrs	r3, r2
2ffc85be:	f8c6 3140 	str.w	r3, [r6, #320]	@ 0x140
2ffc85c2:	e5bc      	b.n	2ffc813e <HAL_RCCEx_PeriphCLKConfig+0xb12>

2ffc85c4 <HAL_UART_DeInit>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
{
  /* Check the UART handle allocation */
  if (huart == NULL)
2ffc85c4:	b1c8      	cbz	r0, 2ffc85fa <HAL_UART_DeInit+0x36>
{
2ffc85c6:	b538      	push	{r3, r4, r5, lr}
  }

  /* Check the parameters */
  assert_param(IS_UART_INSTANCE(huart->Instance));

  huart->gState = HAL_UART_STATE_BUSY;
2ffc85c8:	2224      	movs	r2, #36	@ 0x24

  __HAL_UART_DISABLE(huart);
2ffc85ca:	6803      	ldr	r3, [r0, #0]

  huart->Instance->CR1 = 0x0U;
2ffc85cc:	2400      	movs	r4, #0
  huart->gState = HAL_UART_STATE_BUSY;
2ffc85ce:	f8c0 2080 	str.w	r2, [r0, #128]	@ 0x80
2ffc85d2:	4605      	mov	r5, r0
  __HAL_UART_DISABLE(huart);
2ffc85d4:	681a      	ldr	r2, [r3, #0]
2ffc85d6:	f022 0201 	bic.w	r2, r2, #1
2ffc85da:	601a      	str	r2, [r3, #0]
  huart->Instance->CR1 = 0x0U;
2ffc85dc:	601c      	str	r4, [r3, #0]
  huart->Instance->CR2 = 0x0U;
2ffc85de:	605c      	str	r4, [r3, #4]
  huart->Instance->CR3 = 0x0U;
2ffc85e0:	609c      	str	r4, [r3, #8]
  }
  /* DeInit the low level hardware */
  huart->MspDeInitCallback(huart);
#else
  /* DeInit the low level hardware */
  HAL_UART_MspDeInit(huart);
2ffc85e2:	f002 fe81 	bl	2ffcb2e8 <HAL_UART_MspDeInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */

  huart->ErrorCode = HAL_UART_ERROR_NONE;
2ffc85e6:	f8c5 4088 	str.w	r4, [r5, #136]	@ 0x88
  huart->gState = HAL_UART_STATE_RESET;
  huart->RxState = HAL_UART_STATE_RESET;

  __HAL_UNLOCK(huart);

  return HAL_OK;
2ffc85ea:	4620      	mov	r0, r4
  huart->gState = HAL_UART_STATE_RESET;
2ffc85ec:	f8c5 4080 	str.w	r4, [r5, #128]	@ 0x80
  __HAL_UNLOCK(huart);
2ffc85f0:	f885 407c 	strb.w	r4, [r5, #124]	@ 0x7c
  huart->RxState = HAL_UART_STATE_RESET;
2ffc85f4:	f8c5 4084 	str.w	r4, [r5, #132]	@ 0x84
}
2ffc85f8:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
2ffc85fa:	2001      	movs	r0, #1
}
2ffc85fc:	4770      	bx	lr
2ffc85fe:	bf00      	nop

2ffc8600 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
2ffc8600:	b530      	push	{r4, r5, lr}
2ffc8602:	4604      	mov	r4, r0
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
2ffc8604:	6905      	ldr	r5, [r0, #16]
{
2ffc8606:	b087      	sub	sp, #28
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
2ffc8608:	6882      	ldr	r2, [r0, #8]
  tmpreg |= (uint32_t)huart->FifoMode;
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
2ffc860a:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
2ffc860c:	6940      	ldr	r0, [r0, #20]
2ffc860e:	69e1      	ldr	r1, [r4, #28]
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
2ffc8610:	f1b3 4fb8 	cmp.w	r3, #1543503872	@ 0x5c000000
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
2ffc8614:	ea42 0205 	orr.w	r2, r2, r5
2ffc8618:	ea42 0200 	orr.w	r2, r2, r0
  tmpreg |= (uint32_t)huart->FifoMode;
2ffc861c:	6e60      	ldr	r0, [r4, #100]	@ 0x64
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
2ffc861e:	ea42 0201 	orr.w	r2, r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
2ffc8622:	681d      	ldr	r5, [r3, #0]
  tmpreg |= (uint32_t)huart->FifoMode;
2ffc8624:	ea42 0200 	orr.w	r2, r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
2ffc8628:	f646 10f3 	movw	r0, #27123	@ 0x69f3
2ffc862c:	f6cc 70ff 	movt	r0, #53247	@ 0xcfff
2ffc8630:	ea00 0005 	and.w	r0, r0, r5
2ffc8634:	ea42 0200 	orr.w	r2, r2, r0
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
2ffc8638:	68e5      	ldr	r5, [r4, #12]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
2ffc863a:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
2ffc863c:	6858      	ldr	r0, [r3, #4]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
2ffc863e:	69a2      	ldr	r2, [r4, #24]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
2ffc8640:	f420 5040 	bic.w	r0, r0, #12288	@ 0x3000
2ffc8644:	ea40 0005 	orr.w	r0, r0, r5
2ffc8648:	6058      	str	r0, [r3, #4]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
2ffc864a:	6898      	ldr	r0, [r3, #8]
  tmpreg |= huart->Init.OneBitSampling;
2ffc864c:	6a25      	ldr	r5, [r4, #32]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
2ffc864e:	f020 406e 	bic.w	r0, r0, #3992977408	@ 0xee000000
2ffc8652:	f420 6030 	bic.w	r0, r0, #2816	@ 0xb00
  tmpreg |= huart->Init.OneBitSampling;
2ffc8656:	ea42 0205 	orr.w	r2, r2, r5
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
2ffc865a:	ea42 0200 	orr.w	r2, r2, r0
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
2ffc865e:	6a60      	ldr	r0, [r4, #36]	@ 0x24
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
2ffc8660:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
2ffc8662:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
2ffc8664:	f022 020f 	bic.w	r2, r2, #15
2ffc8668:	ea42 0200 	orr.w	r2, r2, r0
2ffc866c:	62da      	str	r2, [r3, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
2ffc866e:	d047      	beq.n	2ffc8700 <UART_SetConfig+0x100>
2ffc8670:	f44f 4260 	mov.w	r2, #57344	@ 0xe000
2ffc8674:	f2c4 0200 	movt	r2, #16384	@ 0x4000
2ffc8678:	4293      	cmp	r3, r2
2ffc867a:	d027      	beq.n	2ffc86cc <UART_SetConfig+0xcc>
2ffc867c:	f44f 4270 	mov.w	r2, #61440	@ 0xf000
2ffc8680:	f2c4 0200 	movt	r2, #16384	@ 0x4000
2ffc8684:	4293      	cmp	r3, r2
2ffc8686:	d02e      	beq.n	2ffc86e6 <UART_SetConfig+0xe6>
2ffc8688:	2200      	movs	r2, #0
2ffc868a:	f2c4 0201 	movt	r2, #16385	@ 0x4001
2ffc868e:	4293      	cmp	r3, r2
2ffc8690:	d01c      	beq.n	2ffc86cc <UART_SetConfig+0xcc>
2ffc8692:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
2ffc8696:	f2c4 0201 	movt	r2, #16385	@ 0x4001
2ffc869a:	4293      	cmp	r3, r2
2ffc869c:	d023      	beq.n	2ffc86e6 <UART_SetConfig+0xe6>
2ffc869e:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
2ffc86a2:	f2c4 4200 	movt	r2, #17408	@ 0x4400
2ffc86a6:	4293      	cmp	r3, r2
2ffc86a8:	f000 80ea 	beq.w	2ffc8880 <UART_SetConfig+0x280>
2ffc86ac:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
2ffc86b0:	f2c4 0201 	movt	r2, #16385	@ 0x4001
2ffc86b4:	4293      	cmp	r3, r2
2ffc86b6:	f000 80cd 	beq.w	2ffc8854 <UART_SetConfig+0x254>
2ffc86ba:	f44f 4210 	mov.w	r2, #36864	@ 0x9000
2ffc86be:	f2c4 0201 	movt	r2, #16385	@ 0x4001
2ffc86c2:	4293      	cmp	r3, r2
2ffc86c4:	f000 80c6 	beq.w	2ffc8854 <UART_SetConfig+0x254>
        break;
      case UART_CLOCKSOURCE_CSI:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(CSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
        break;
      case UART_CLOCKSOURCE_HSE:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc86c8:	2001      	movs	r0, #1
2ffc86ca:	e04c      	b.n	2ffc8766 <UART_SetConfig+0x166>
  UART_GETCLOCKSOURCE(huart, clocksource);
2ffc86cc:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc86d0:	f8d3 38e8 	ldr.w	r3, [r3, #2280]	@ 0x8e8
2ffc86d4:	f003 0307 	and.w	r3, r3, #7
2ffc86d8:	2b04      	cmp	r3, #4
2ffc86da:	d8f5      	bhi.n	2ffc86c8 <UART_SetConfig+0xc8>
2ffc86dc:	e8df f003 	tbb	[pc, r3]
2ffc86e0:	644e7a91 	.word	0x644e7a91
2ffc86e4:	1d          	.byte	0x1d
2ffc86e5:	00          	.byte	0x00
2ffc86e6:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc86ea:	f8d3 38ec 	ldr.w	r3, [r3, #2284]	@ 0x8ec
2ffc86ee:	f003 0307 	and.w	r3, r3, #7
2ffc86f2:	2b04      	cmp	r3, #4
2ffc86f4:	d8e8      	bhi.n	2ffc86c8 <UART_SetConfig+0xc8>
2ffc86f6:	e8df f003 	tbb	[pc, r3]
2ffc86fa:	6d84      	.short	0x6d84
2ffc86fc:	5741      	.short	0x5741
2ffc86fe:	10          	.byte	0x10
2ffc86ff:	00          	.byte	0x00
2ffc8700:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc8704:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
2ffc8708:	f003 0307 	and.w	r3, r3, #7
2ffc870c:	2b05      	cmp	r3, #5
2ffc870e:	d8db      	bhi.n	2ffc86c8 <UART_SetConfig+0xc8>
2ffc8710:	e8df f003 	tbb	[pc, r3]
2ffc8714:	4a34cce4 	.word	0x4a34cce4
2ffc8718:	0360      	.short	0x0360
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
2ffc871a:	f5b1 4f00 	cmp.w	r1, #32768	@ 0x8000
2ffc871e:	f000 815e 	beq.w	2ffc89de <UART_SetConfig+0x3de>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc8722:	2800      	cmp	r0, #0
2ffc8724:	f000 808c 	beq.w	2ffc8840 <UART_SetConfig+0x240>
2ffc8728:	3801      	subs	r0, #1
2ffc872a:	280a      	cmp	r0, #10
2ffc872c:	f200 8088 	bhi.w	2ffc8840 <UART_SetConfig+0x240>
2ffc8730:	f64e 2220 	movw	r2, #59936	@ 0xea20
2ffc8734:	f44f 5358 	mov.w	r3, #13824	@ 0x3600
2ffc8738:	f6c2 72fc 	movt	r2, #12284	@ 0x2ffc
2ffc873c:	f2c0 136e 	movt	r3, #366	@ 0x16e
2ffc8740:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
2ffc8744:	fbb3 f3f2 	udiv	r3, r3, r2
2ffc8748:	6862      	ldr	r2, [r4, #4]
2ffc874a:	eb03 0352 	add.w	r3, r3, r2, lsr #1
2ffc874e:	fbb3 f3f2 	udiv	r3, r3, r2
2ffc8752:	b29b      	uxth	r3, r3
        ret = HAL_ERROR;
        break;
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
2ffc8754:	f1a3 0110 	sub.w	r1, r3, #16
2ffc8758:	f64f 72ef 	movw	r2, #65519	@ 0xffef
2ffc875c:	4291      	cmp	r1, r2
2ffc875e:	d8b3      	bhi.n	2ffc86c8 <UART_SetConfig+0xc8>
    {
      huart->Instance->BRR = usartdiv;
2ffc8760:	6822      	ldr	r2, [r4, #0]
2ffc8762:	60d3      	str	r3, [r2, #12]
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc8764:	2000      	movs	r0, #0
  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
  huart->NbRxDataToProcess = 1;

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
2ffc8766:	efc0 0010 	vmov.i32	d16, #0	@ 0x00000000
2ffc876a:	f104 036c 	add.w	r3, r4, #108	@ 0x6c
  huart->NbRxDataToProcess = 1;
2ffc876e:	f04f 1201 	mov.w	r2, #65537	@ 0x10001
2ffc8772:	66a2      	str	r2, [r4, #104]	@ 0x68
  huart->RxISR = NULL;
2ffc8774:	f943 078f 	vst1.32	{d16}, [r3]
  huart->TxISR = NULL;

  return ret;
}
2ffc8778:	b007      	add	sp, #28
2ffc877a:	bd30      	pop	{r4, r5, pc}
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
2ffc877c:	f5b1 4f00 	cmp.w	r1, #32768	@ 0x8000
2ffc8780:	f000 8151 	beq.w	2ffc8a26 <UART_SetConfig+0x426>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc8784:	2800      	cmp	r0, #0
2ffc8786:	d056      	beq.n	2ffc8836 <UART_SetConfig+0x236>
2ffc8788:	3801      	subs	r0, #1
2ffc878a:	280a      	cmp	r0, #10
2ffc878c:	d853      	bhi.n	2ffc8836 <UART_SetConfig+0x236>
2ffc878e:	f64e 2220 	movw	r2, #59936	@ 0xea20
2ffc8792:	f44f 4310 	mov.w	r3, #36864	@ 0x9000
2ffc8796:	f6c2 72fc 	movt	r2, #12284	@ 0x2ffc
2ffc879a:	f2c0 33d0 	movt	r3, #976	@ 0x3d0
2ffc879e:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
2ffc87a2:	fbb3 f3f2 	udiv	r3, r3, r2
2ffc87a6:	e7cf      	b.n	2ffc8748 <UART_SetConfig+0x148>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
2ffc87a8:	f5b1 4f00 	cmp.w	r1, #32768	@ 0x8000
2ffc87ac:	f000 80fe 	beq.w	2ffc89ac <UART_SetConfig+0x3ac>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(CSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc87b0:	2800      	cmp	r0, #0
2ffc87b2:	d04a      	beq.n	2ffc884a <UART_SetConfig+0x24a>
2ffc87b4:	3801      	subs	r0, #1
2ffc87b6:	280a      	cmp	r0, #10
2ffc87b8:	d847      	bhi.n	2ffc884a <UART_SetConfig+0x24a>
2ffc87ba:	f64e 2220 	movw	r2, #59936	@ 0xea20
2ffc87be:	f44f 6310 	mov.w	r3, #2304	@ 0x900
2ffc87c2:	f6c2 72fc 	movt	r2, #12284	@ 0x2ffc
2ffc87c6:	f2c0 033d 	movt	r3, #61	@ 0x3d
2ffc87ca:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
2ffc87ce:	fbb3 f3f2 	udiv	r3, r3, r2
2ffc87d2:	e7b9      	b.n	2ffc8748 <UART_SetConfig+0x148>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
2ffc87d4:	f5b1 4f00 	cmp.w	r1, #32768	@ 0x8000
2ffc87d8:	f000 8138 	beq.w	2ffc8a4c <UART_SetConfig+0x44c>
        HAL_RCC_GetPLL4ClockFreq(&pll4_clocks);
2ffc87dc:	a803      	add	r0, sp, #12
2ffc87de:	f7fd ff63 	bl	2ffc66a8 <HAL_RCC_GetPLL4ClockFreq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pll4_clocks.PLL4_Q_Frequency, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc87e2:	6a62      	ldr	r2, [r4, #36]	@ 0x24
2ffc87e4:	9b04      	ldr	r3, [sp, #16]
2ffc87e6:	2a00      	cmp	r2, #0
2ffc87e8:	d0ae      	beq.n	2ffc8748 <UART_SetConfig+0x148>
2ffc87ea:	3a01      	subs	r2, #1
2ffc87ec:	2a0a      	cmp	r2, #10
2ffc87ee:	d8ab      	bhi.n	2ffc8748 <UART_SetConfig+0x148>
2ffc87f0:	f64e 2120 	movw	r1, #59936	@ 0xea20
2ffc87f4:	f6c2 71fc 	movt	r1, #12284	@ 0x2ffc
2ffc87f8:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
2ffc87fc:	fbb3 f3f2 	udiv	r3, r3, r2
2ffc8800:	e7a2      	b.n	2ffc8748 <UART_SetConfig+0x148>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
2ffc8802:	f5b1 4f00 	cmp.w	r1, #32768	@ 0x8000
2ffc8806:	f000 80fd 	beq.w	2ffc8a04 <UART_SetConfig+0x404>
        pclk = HAL_RCC_GetPCLK1Freq();
2ffc880a:	f7fd fff1 	bl	2ffc67f0 <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc880e:	6a63      	ldr	r3, [r4, #36]	@ 0x24
2ffc8810:	b153      	cbz	r3, 2ffc8828 <UART_SetConfig+0x228>
2ffc8812:	3b01      	subs	r3, #1
2ffc8814:	2b0a      	cmp	r3, #10
2ffc8816:	d807      	bhi.n	2ffc8828 <UART_SetConfig+0x228>
2ffc8818:	f64e 2220 	movw	r2, #59936	@ 0xea20
2ffc881c:	f6c2 72fc 	movt	r2, #12284	@ 0x2ffc
2ffc8820:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2ffc8824:	fbb0 f0f3 	udiv	r0, r0, r3
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc8828:	6862      	ldr	r2, [r4, #4]
2ffc882a:	eb00 0352 	add.w	r3, r0, r2, lsr #1
2ffc882e:	fbb3 f3f2 	udiv	r3, r3, r2
2ffc8832:	b29b      	uxth	r3, r3
        break;
2ffc8834:	e78e      	b.n	2ffc8754 <UART_SetConfig+0x154>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc8836:	f44f 4310 	mov.w	r3, #36864	@ 0x9000
2ffc883a:	f2c0 33d0 	movt	r3, #976	@ 0x3d0
2ffc883e:	e783      	b.n	2ffc8748 <UART_SetConfig+0x148>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc8840:	f44f 5358 	mov.w	r3, #13824	@ 0x3600
2ffc8844:	f2c0 136e 	movt	r3, #366	@ 0x16e
2ffc8848:	e77e      	b.n	2ffc8748 <UART_SetConfig+0x148>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(CSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc884a:	f44f 6310 	mov.w	r3, #2304	@ 0x900
2ffc884e:	f2c0 033d 	movt	r3, #61	@ 0x3d
2ffc8852:	e779      	b.n	2ffc8748 <UART_SetConfig+0x148>
  UART_GETCLOCKSOURCE(huart, clocksource);
2ffc8854:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc8858:	f8d3 38f0 	ldr.w	r3, [r3, #2288]	@ 0x8f0
2ffc885c:	f003 0307 	and.w	r3, r3, #7
2ffc8860:	2b04      	cmp	r3, #4
2ffc8862:	f63f af31 	bhi.w	2ffc86c8 <UART_SetConfig+0xc8>
2ffc8866:	a201      	add	r2, pc, #4	@ (adr r2, 2ffc886c <UART_SetConfig+0x26c>)
2ffc8868:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2ffc886c:	2ffc8803 	.word	0x2ffc8803
2ffc8870:	2ffc87d5 	.word	0x2ffc87d5
2ffc8874:	2ffc877d 	.word	0x2ffc877d
2ffc8878:	2ffc87a9 	.word	0x2ffc87a9
2ffc887c:	2ffc871b 	.word	0x2ffc871b
2ffc8880:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffc8884:	f8d3 38e4 	ldr.w	r3, [r3, #2276]	@ 0x8e4
2ffc8888:	f003 0307 	and.w	r3, r3, #7
2ffc888c:	2b04      	cmp	r3, #4
2ffc888e:	f63f af1b 	bhi.w	2ffc86c8 <UART_SetConfig+0xc8>
2ffc8892:	a201      	add	r2, pc, #4	@ (adr r2, 2ffc8898 <UART_SetConfig+0x298>)
2ffc8894:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2ffc8898:	2ffc8907 	.word	0x2ffc8907
2ffc889c:	2ffc87d5 	.word	0x2ffc87d5
2ffc88a0:	2ffc877d 	.word	0x2ffc877d
2ffc88a4:	2ffc87a9 	.word	0x2ffc87a9
2ffc88a8:	2ffc871b 	.word	0x2ffc871b
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
2ffc88ac:	f5b1 4f00 	cmp.w	r1, #32768	@ 0x8000
2ffc88b0:	d03d      	beq.n	2ffc892e <UART_SetConfig+0x32e>
        HAL_RCC_GetPLL3ClockFreq(&pll3_clocks);
2ffc88b2:	4668      	mov	r0, sp
2ffc88b4:	f7fd fe5c 	bl	2ffc6570 <HAL_RCC_GetPLL3ClockFreq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pll3_clocks.PLL3_Q_Frequency, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc88b8:	6a62      	ldr	r2, [r4, #36]	@ 0x24
2ffc88ba:	9b01      	ldr	r3, [sp, #4]
2ffc88bc:	2a00      	cmp	r2, #0
2ffc88be:	f43f af43 	beq.w	2ffc8748 <UART_SetConfig+0x148>
2ffc88c2:	3a01      	subs	r2, #1
2ffc88c4:	2a0a      	cmp	r2, #10
2ffc88c6:	f63f af3f 	bhi.w	2ffc8748 <UART_SetConfig+0x148>
2ffc88ca:	f64e 2120 	movw	r1, #59936	@ 0xea20
2ffc88ce:	f6c2 71fc 	movt	r1, #12284	@ 0x2ffc
2ffc88d2:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
2ffc88d6:	fbb3 f3f2 	udiv	r3, r3, r2
2ffc88da:	e735      	b.n	2ffc8748 <UART_SetConfig+0x148>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
2ffc88dc:	f5b1 4f00 	cmp.w	r1, #32768	@ 0x8000
2ffc88e0:	f000 80c8 	beq.w	2ffc8a74 <UART_SetConfig+0x474>
        pclk = HAL_RCC_GetPCLK5Freq();
2ffc88e4:	f7fe fba6 	bl	2ffc7034 <HAL_RCC_GetPCLK5Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc88e8:	6a63      	ldr	r3, [r4, #36]	@ 0x24
2ffc88ea:	2b00      	cmp	r3, #0
2ffc88ec:	d09c      	beq.n	2ffc8828 <UART_SetConfig+0x228>
2ffc88ee:	3b01      	subs	r3, #1
2ffc88f0:	2b0a      	cmp	r3, #10
2ffc88f2:	bf9f      	itttt	ls
2ffc88f4:	f64e 2220 	movwls	r2, #59936	@ 0xea20
2ffc88f8:	f6c2 72fc 	movtls	r2, #12284	@ 0x2ffc
2ffc88fc:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
2ffc8900:	fbb0 f0f3 	udivls	r0, r0, r3
2ffc8904:	e790      	b.n	2ffc8828 <UART_SetConfig+0x228>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
2ffc8906:	f5b1 4f00 	cmp.w	r1, #32768	@ 0x8000
2ffc890a:	d038      	beq.n	2ffc897e <UART_SetConfig+0x37e>
        pclk = HAL_RCC_GetPCLK2Freq();
2ffc890c:	f7fd ffb0 	bl	2ffc6870 <HAL_RCC_GetPCLK2Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc8910:	6a63      	ldr	r3, [r4, #36]	@ 0x24
2ffc8912:	2b00      	cmp	r3, #0
2ffc8914:	d088      	beq.n	2ffc8828 <UART_SetConfig+0x228>
2ffc8916:	3b01      	subs	r3, #1
2ffc8918:	2b0a      	cmp	r3, #10
2ffc891a:	d885      	bhi.n	2ffc8828 <UART_SetConfig+0x228>
2ffc891c:	f64e 2220 	movw	r2, #59936	@ 0xea20
2ffc8920:	f6c2 72fc 	movt	r2, #12284	@ 0x2ffc
2ffc8924:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2ffc8928:	fbb0 f0f3 	udiv	r0, r0, r3
2ffc892c:	e77c      	b.n	2ffc8828 <UART_SetConfig+0x228>
        HAL_RCC_GetPLL3ClockFreq(&pll3_clocks);
2ffc892e:	4668      	mov	r0, sp
2ffc8930:	f7fd fe1e 	bl	2ffc6570 <HAL_RCC_GetPLL3ClockFreq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pll3_clocks.PLL3_Q_Frequency, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc8934:	6a63      	ldr	r3, [r4, #36]	@ 0x24
2ffc8936:	9901      	ldr	r1, [sp, #4]
2ffc8938:	b153      	cbz	r3, 2ffc8950 <UART_SetConfig+0x350>
2ffc893a:	3b01      	subs	r3, #1
2ffc893c:	2b0a      	cmp	r3, #10
2ffc893e:	d807      	bhi.n	2ffc8950 <UART_SetConfig+0x350>
2ffc8940:	f64e 2220 	movw	r2, #59936	@ 0xea20
2ffc8944:	f6c2 72fc 	movt	r2, #12284	@ 0x2ffc
2ffc8948:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2ffc894c:	fbb1 f1f3 	udiv	r1, r1, r3
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pll4_clocks.PLL4_Q_Frequency, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc8950:	6862      	ldr	r2, [r4, #4]
2ffc8952:	0853      	lsrs	r3, r2, #1
2ffc8954:	eb03 0341 	add.w	r3, r3, r1, lsl #1
2ffc8958:	fbb3 f3f2 	udiv	r3, r3, r2
2ffc895c:	b29b      	uxth	r3, r3
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
2ffc895e:	f1a3 0110 	sub.w	r1, r3, #16
2ffc8962:	f64f 72ef 	movw	r2, #65519	@ 0xffef
2ffc8966:	4291      	cmp	r1, r2
2ffc8968:	f63f aeae 	bhi.w	2ffc86c8 <UART_SetConfig+0xc8>
      huart->Instance->BRR = brrtemp;
2ffc896c:	6821      	ldr	r1, [r4, #0]
      brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
2ffc896e:	f64f 72f0 	movw	r2, #65520	@ 0xfff0
2ffc8972:	401a      	ands	r2, r3
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
2ffc8974:	f3c3 0342 	ubfx	r3, r3, #1, #3
      huart->Instance->BRR = brrtemp;
2ffc8978:	431a      	orrs	r2, r3
2ffc897a:	60ca      	str	r2, [r1, #12]
2ffc897c:	e6f2      	b.n	2ffc8764 <UART_SetConfig+0x164>
        pclk = HAL_RCC_GetPCLK2Freq();
2ffc897e:	f7fd ff77 	bl	2ffc6870 <HAL_RCC_GetPCLK2Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc8982:	6a63      	ldr	r3, [r4, #36]	@ 0x24
2ffc8984:	b153      	cbz	r3, 2ffc899c <UART_SetConfig+0x39c>
2ffc8986:	3b01      	subs	r3, #1
2ffc8988:	2b0a      	cmp	r3, #10
2ffc898a:	d807      	bhi.n	2ffc899c <UART_SetConfig+0x39c>
2ffc898c:	f64e 2220 	movw	r2, #59936	@ 0xea20
2ffc8990:	f6c2 72fc 	movt	r2, #12284	@ 0x2ffc
2ffc8994:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2ffc8998:	fbb0 f0f3 	udiv	r0, r0, r3
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc899c:	6862      	ldr	r2, [r4, #4]
2ffc899e:	0853      	lsrs	r3, r2, #1
2ffc89a0:	eb03 0340 	add.w	r3, r3, r0, lsl #1
2ffc89a4:	fbb3 f3f2 	udiv	r3, r3, r2
2ffc89a8:	b29b      	uxth	r3, r3
        break;
2ffc89aa:	e7d8      	b.n	2ffc895e <UART_SetConfig+0x35e>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(CSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc89ac:	2800      	cmp	r0, #0
2ffc89ae:	d077      	beq.n	2ffc8aa0 <UART_SetConfig+0x4a0>
2ffc89b0:	3801      	subs	r0, #1
2ffc89b2:	280a      	cmp	r0, #10
2ffc89b4:	d874      	bhi.n	2ffc8aa0 <UART_SetConfig+0x4a0>
2ffc89b6:	f64e 2220 	movw	r2, #59936	@ 0xea20
2ffc89ba:	f44f 6310 	mov.w	r3, #2304	@ 0x900
2ffc89be:	f6c2 72fc 	movt	r2, #12284	@ 0x2ffc
2ffc89c2:	f2c0 033d 	movt	r3, #61	@ 0x3d
2ffc89c6:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
2ffc89ca:	fbb3 f3f2 	udiv	r3, r3, r2
2ffc89ce:	005b      	lsls	r3, r3, #1
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc89d0:	6862      	ldr	r2, [r4, #4]
2ffc89d2:	eb03 0352 	add.w	r3, r3, r2, lsr #1
2ffc89d6:	fbb3 f3f2 	udiv	r3, r3, r2
2ffc89da:	b29b      	uxth	r3, r3
        break;
2ffc89dc:	e7bf      	b.n	2ffc895e <UART_SetConfig+0x35e>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc89de:	2800      	cmp	r0, #0
2ffc89e0:	d059      	beq.n	2ffc8a96 <UART_SetConfig+0x496>
2ffc89e2:	3801      	subs	r0, #1
2ffc89e4:	280a      	cmp	r0, #10
2ffc89e6:	d856      	bhi.n	2ffc8a96 <UART_SetConfig+0x496>
2ffc89e8:	f64e 2220 	movw	r2, #59936	@ 0xea20
2ffc89ec:	f44f 5358 	mov.w	r3, #13824	@ 0x3600
2ffc89f0:	f6c2 72fc 	movt	r2, #12284	@ 0x2ffc
2ffc89f4:	f2c0 136e 	movt	r3, #366	@ 0x16e
2ffc89f8:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
2ffc89fc:	fbb3 f3f2 	udiv	r3, r3, r2
2ffc8a00:	005b      	lsls	r3, r3, #1
2ffc8a02:	e7e5      	b.n	2ffc89d0 <UART_SetConfig+0x3d0>
        pclk = HAL_RCC_GetPCLK1Freq();
2ffc8a04:	f7fd fef4 	bl	2ffc67f0 <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc8a08:	6a63      	ldr	r3, [r4, #36]	@ 0x24
2ffc8a0a:	2b00      	cmp	r3, #0
2ffc8a0c:	d0c6      	beq.n	2ffc899c <UART_SetConfig+0x39c>
2ffc8a0e:	3b01      	subs	r3, #1
2ffc8a10:	2b0a      	cmp	r3, #10
2ffc8a12:	d8c3      	bhi.n	2ffc899c <UART_SetConfig+0x39c>
2ffc8a14:	f64e 2220 	movw	r2, #59936	@ 0xea20
2ffc8a18:	f6c2 72fc 	movt	r2, #12284	@ 0x2ffc
2ffc8a1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2ffc8a20:	fbb0 f0f3 	udiv	r0, r0, r3
2ffc8a24:	e7ba      	b.n	2ffc899c <UART_SetConfig+0x39c>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc8a26:	2800      	cmp	r0, #0
2ffc8a28:	d03f      	beq.n	2ffc8aaa <UART_SetConfig+0x4aa>
2ffc8a2a:	3801      	subs	r0, #1
2ffc8a2c:	280a      	cmp	r0, #10
2ffc8a2e:	d83c      	bhi.n	2ffc8aaa <UART_SetConfig+0x4aa>
2ffc8a30:	f64e 2220 	movw	r2, #59936	@ 0xea20
2ffc8a34:	f44f 4310 	mov.w	r3, #36864	@ 0x9000
2ffc8a38:	f6c2 72fc 	movt	r2, #12284	@ 0x2ffc
2ffc8a3c:	f2c0 33d0 	movt	r3, #976	@ 0x3d0
2ffc8a40:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
2ffc8a44:	fbb3 f3f2 	udiv	r3, r3, r2
2ffc8a48:	005b      	lsls	r3, r3, #1
2ffc8a4a:	e7c1      	b.n	2ffc89d0 <UART_SetConfig+0x3d0>
        HAL_RCC_GetPLL4ClockFreq(&pll4_clocks);
2ffc8a4c:	a803      	add	r0, sp, #12
2ffc8a4e:	f7fd fe2b 	bl	2ffc66a8 <HAL_RCC_GetPLL4ClockFreq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pll4_clocks.PLL4_Q_Frequency, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc8a52:	6a63      	ldr	r3, [r4, #36]	@ 0x24
2ffc8a54:	9904      	ldr	r1, [sp, #16]
2ffc8a56:	2b00      	cmp	r3, #0
2ffc8a58:	f43f af7a 	beq.w	2ffc8950 <UART_SetConfig+0x350>
2ffc8a5c:	3b01      	subs	r3, #1
2ffc8a5e:	2b0a      	cmp	r3, #10
2ffc8a60:	bf9f      	itttt	ls
2ffc8a62:	f64e 2220 	movwls	r2, #59936	@ 0xea20
2ffc8a66:	f6c2 72fc 	movtls	r2, #12284	@ 0x2ffc
2ffc8a6a:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
2ffc8a6e:	fbb1 f1f3 	udivls	r1, r1, r3
2ffc8a72:	e76d      	b.n	2ffc8950 <UART_SetConfig+0x350>
        pclk = HAL_RCC_GetPCLK5Freq();
2ffc8a74:	f7fe fade 	bl	2ffc7034 <HAL_RCC_GetPCLK5Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc8a78:	6a63      	ldr	r3, [r4, #36]	@ 0x24
2ffc8a7a:	2b00      	cmp	r3, #0
2ffc8a7c:	d08e      	beq.n	2ffc899c <UART_SetConfig+0x39c>
2ffc8a7e:	3b01      	subs	r3, #1
2ffc8a80:	2b0a      	cmp	r3, #10
2ffc8a82:	bf9f      	itttt	ls
2ffc8a84:	f64e 2220 	movwls	r2, #59936	@ 0xea20
2ffc8a88:	f6c2 72fc 	movtls	r2, #12284	@ 0x2ffc
2ffc8a8c:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
2ffc8a90:	fbb0 f0f3 	udivls	r0, r0, r3
2ffc8a94:	e782      	b.n	2ffc899c <UART_SetConfig+0x39c>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc8a96:	f44f 43d8 	mov.w	r3, #27648	@ 0x6c00
2ffc8a9a:	f2c0 23dc 	movt	r3, #732	@ 0x2dc
2ffc8a9e:	e797      	b.n	2ffc89d0 <UART_SetConfig+0x3d0>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(CSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc8aa0:	f44f 5390 	mov.w	r3, #4608	@ 0x1200
2ffc8aa4:	f2c0 037a 	movt	r3, #122	@ 0x7a
2ffc8aa8:	e792      	b.n	2ffc89d0 <UART_SetConfig+0x3d0>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2ffc8aaa:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
2ffc8aae:	f2c0 73a1 	movt	r3, #1953	@ 0x7a1
2ffc8ab2:	e78d      	b.n	2ffc89d0 <UART_SetConfig+0x3d0>

2ffc8ab4 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
2ffc8ab4:	6a83      	ldr	r3, [r0, #40]	@ 0x28
{
2ffc8ab6:	b410      	push	{r4}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
2ffc8ab8:	07da      	lsls	r2, r3, #31
2ffc8aba:	d506      	bpl.n	2ffc8aca <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
2ffc8abc:	6801      	ldr	r1, [r0, #0]
2ffc8abe:	6ac4      	ldr	r4, [r0, #44]	@ 0x2c
2ffc8ac0:	684a      	ldr	r2, [r1, #4]
2ffc8ac2:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
2ffc8ac6:	4322      	orrs	r2, r4
2ffc8ac8:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
2ffc8aca:	079c      	lsls	r4, r3, #30
2ffc8acc:	d506      	bpl.n	2ffc8adc <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
2ffc8ace:	6801      	ldr	r1, [r0, #0]
2ffc8ad0:	6b04      	ldr	r4, [r0, #48]	@ 0x30
2ffc8ad2:	684a      	ldr	r2, [r1, #4]
2ffc8ad4:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
2ffc8ad8:	4322      	orrs	r2, r4
2ffc8ada:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
2ffc8adc:	0759      	lsls	r1, r3, #29
2ffc8ade:	d506      	bpl.n	2ffc8aee <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
2ffc8ae0:	6801      	ldr	r1, [r0, #0]
2ffc8ae2:	6b44      	ldr	r4, [r0, #52]	@ 0x34
2ffc8ae4:	684a      	ldr	r2, [r1, #4]
2ffc8ae6:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
2ffc8aea:	4322      	orrs	r2, r4
2ffc8aec:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
2ffc8aee:	071a      	lsls	r2, r3, #28
2ffc8af0:	d506      	bpl.n	2ffc8b00 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
2ffc8af2:	6801      	ldr	r1, [r0, #0]
2ffc8af4:	6b84      	ldr	r4, [r0, #56]	@ 0x38
2ffc8af6:	684a      	ldr	r2, [r1, #4]
2ffc8af8:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
2ffc8afc:	4322      	orrs	r2, r4
2ffc8afe:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
2ffc8b00:	06dc      	lsls	r4, r3, #27
2ffc8b02:	d506      	bpl.n	2ffc8b12 <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
2ffc8b04:	6801      	ldr	r1, [r0, #0]
2ffc8b06:	6bc4      	ldr	r4, [r0, #60]	@ 0x3c
2ffc8b08:	688a      	ldr	r2, [r1, #8]
2ffc8b0a:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
2ffc8b0e:	4322      	orrs	r2, r4
2ffc8b10:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
2ffc8b12:	0699      	lsls	r1, r3, #26
2ffc8b14:	d506      	bpl.n	2ffc8b24 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
2ffc8b16:	6801      	ldr	r1, [r0, #0]
2ffc8b18:	6c04      	ldr	r4, [r0, #64]	@ 0x40
2ffc8b1a:	688a      	ldr	r2, [r1, #8]
2ffc8b1c:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
2ffc8b20:	4322      	orrs	r2, r4
2ffc8b22:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
2ffc8b24:	065a      	lsls	r2, r3, #25
2ffc8b26:	d50a      	bpl.n	2ffc8b3e <UART_AdvFeatureConfig+0x8a>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
2ffc8b28:	6801      	ldr	r1, [r0, #0]
2ffc8b2a:	6c44      	ldr	r4, [r0, #68]	@ 0x44
2ffc8b2c:	684a      	ldr	r2, [r1, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
2ffc8b2e:	f5b4 1f80 	cmp.w	r4, #1048576	@ 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
2ffc8b32:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
2ffc8b36:	ea42 0204 	orr.w	r2, r2, r4
2ffc8b3a:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
2ffc8b3c:	d00b      	beq.n	2ffc8b56 <UART_AdvFeatureConfig+0xa2>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
2ffc8b3e:	061b      	lsls	r3, r3, #24
2ffc8b40:	d506      	bpl.n	2ffc8b50 <UART_AdvFeatureConfig+0x9c>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
2ffc8b42:	6802      	ldr	r2, [r0, #0]
2ffc8b44:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
2ffc8b46:	6853      	ldr	r3, [r2, #4]
2ffc8b48:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
2ffc8b4c:	430b      	orrs	r3, r1
2ffc8b4e:	6053      	str	r3, [r2, #4]
  }
}
2ffc8b50:	f85d 4b04 	ldr.w	r4, [sp], #4
2ffc8b54:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
2ffc8b56:	684a      	ldr	r2, [r1, #4]
2ffc8b58:	6c84      	ldr	r4, [r0, #72]	@ 0x48
2ffc8b5a:	f422 02c0 	bic.w	r2, r2, #6291456	@ 0x600000
2ffc8b5e:	4322      	orrs	r2, r4
2ffc8b60:	604a      	str	r2, [r1, #4]
2ffc8b62:	e7ec      	b.n	2ffc8b3e <UART_AdvFeatureConfig+0x8a>

2ffc8b64 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
2ffc8b64:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
2ffc8b68:	4681      	mov	r9, r0
2ffc8b6a:	f8dd 8020 	ldr.w	r8, [sp, #32]
2ffc8b6e:	460f      	mov	r7, r1
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
2ffc8b70:	6805      	ldr	r5, [r0, #0]
{
2ffc8b72:	4616      	mov	r6, r2
2ffc8b74:	469a      	mov	sl, r3
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
2ffc8b76:	e002      	b.n	2ffc8b7e <UART_WaitOnFlagUntilTimeout+0x1a>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
2ffc8b78:	f1b8 3fff 	cmp.w	r8, #4294967295	@ 0xffffffff
2ffc8b7c:	d10a      	bne.n	2ffc8b94 <UART_WaitOnFlagUntilTimeout+0x30>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
2ffc8b7e:	69ec      	ldr	r4, [r5, #28]
2ffc8b80:	ea37 0404 	bics.w	r4, r7, r4
2ffc8b84:	bf0c      	ite	eq
2ffc8b86:	2401      	moveq	r4, #1
2ffc8b88:	2400      	movne	r4, #0
2ffc8b8a:	42b4      	cmp	r4, r6
2ffc8b8c:	d0f4      	beq.n	2ffc8b78 <UART_WaitOnFlagUntilTimeout+0x14>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
2ffc8b8e:	2000      	movs	r0, #0
}
2ffc8b90:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2ffc8b94:	f7fa fcda 	bl	2ffc354c <HAL_GetTick>
2ffc8b98:	fab8 f288 	clz	r2, r8
2ffc8b9c:	eba0 000a 	sub.w	r0, r0, sl
2ffc8ba0:	0952      	lsrs	r2, r2, #5
2ffc8ba2:	4540      	cmp	r0, r8
2ffc8ba4:	bf88      	it	hi
2ffc8ba6:	f042 0201 	orrhi.w	r2, r2, #1
2ffc8baa:	b9f2      	cbnz	r2, 2ffc8bea <UART_WaitOnFlagUntilTimeout+0x86>
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
2ffc8bac:	f8d9 5000 	ldr.w	r5, [r9]
2ffc8bb0:	682b      	ldr	r3, [r5, #0]
2ffc8bb2:	075a      	lsls	r2, r3, #29
2ffc8bb4:	d5e3      	bpl.n	2ffc8b7e <UART_WaitOnFlagUntilTimeout+0x1a>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
2ffc8bb6:	69eb      	ldr	r3, [r5, #28]
2ffc8bb8:	051b      	lsls	r3, r3, #20
2ffc8bba:	d5e0      	bpl.n	2ffc8b7e <UART_WaitOnFlagUntilTimeout+0x1a>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
2ffc8bbc:	f44f 6200 	mov.w	r2, #2048	@ 0x800
          huart->gState = HAL_UART_STATE_READY;
2ffc8bc0:	2320      	movs	r3, #32
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
2ffc8bc2:	622a      	str	r2, [r5, #32]
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
2ffc8bc4:	682a      	ldr	r2, [r5, #0]
2ffc8bc6:	f422 72d0 	bic.w	r2, r2, #416	@ 0x1a0
2ffc8bca:	602a      	str	r2, [r5, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
2ffc8bcc:	68aa      	ldr	r2, [r5, #8]
2ffc8bce:	f022 0201 	bic.w	r2, r2, #1
2ffc8bd2:	60aa      	str	r2, [r5, #8]
          huart->gState = HAL_UART_STATE_READY;
2ffc8bd4:	f8c9 3080 	str.w	r3, [r9, #128]	@ 0x80
          huart->RxState = HAL_UART_STATE_READY;
2ffc8bd8:	f8c9 3084 	str.w	r3, [r9, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
2ffc8bdc:	f8c9 3088 	str.w	r3, [r9, #136]	@ 0x88
          __HAL_UNLOCK(huart);
2ffc8be0:	2300      	movs	r3, #0
        return HAL_TIMEOUT;
2ffc8be2:	2003      	movs	r0, #3
          __HAL_UNLOCK(huart);
2ffc8be4:	f889 307c 	strb.w	r3, [r9, #124]	@ 0x7c
2ffc8be8:	e7d2      	b.n	2ffc8b90 <UART_WaitOnFlagUntilTimeout+0x2c>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
2ffc8bea:	f8d9 3000 	ldr.w	r3, [r9]
        huart->gState = HAL_UART_STATE_READY;
2ffc8bee:	2120      	movs	r1, #32
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
2ffc8bf0:	681a      	ldr	r2, [r3, #0]
2ffc8bf2:	f422 72d0 	bic.w	r2, r2, #416	@ 0x1a0
2ffc8bf6:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
2ffc8bf8:	689a      	ldr	r2, [r3, #8]
2ffc8bfa:	f022 0201 	bic.w	r2, r2, #1
2ffc8bfe:	609a      	str	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
2ffc8c00:	f8c9 1080 	str.w	r1, [r9, #128]	@ 0x80
        huart->RxState = HAL_UART_STATE_READY;
2ffc8c04:	f8c9 1084 	str.w	r1, [r9, #132]	@ 0x84
        return HAL_TIMEOUT;
2ffc8c08:	e7ea      	b.n	2ffc8be0 <UART_WaitOnFlagUntilTimeout+0x7c>
2ffc8c0a:	bf00      	nop

2ffc8c0c <HAL_UART_Transmit>:
{
2ffc8c0c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
2ffc8c10:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_READY)
2ffc8c12:	f8d0 0080 	ldr.w	r0, [r0, #128]	@ 0x80
{
2ffc8c16:	b083      	sub	sp, #12
  if (huart->gState == HAL_UART_STATE_READY)
2ffc8c18:	2820      	cmp	r0, #32
2ffc8c1a:	d149      	bne.n	2ffc8cb0 <HAL_UART_Transmit+0xa4>
    if ((pData == NULL) || (Size == 0U))
2ffc8c1c:	2a00      	cmp	r2, #0
2ffc8c1e:	bf18      	it	ne
2ffc8c20:	2900      	cmpne	r1, #0
2ffc8c22:	460d      	mov	r5, r1
2ffc8c24:	4691      	mov	r9, r2
2ffc8c26:	bf0a      	itet	eq
2ffc8c28:	f04f 0801 	moveq.w	r8, #1
2ffc8c2c:	f04f 0800 	movne.w	r8, #0
      return  HAL_ERROR;
2ffc8c30:	2001      	moveq	r0, #1
    if ((pData == NULL) || (Size == 0U))
2ffc8c32:	d03e      	beq.n	2ffc8cb2 <HAL_UART_Transmit+0xa6>
2ffc8c34:	461e      	mov	r6, r3
    __HAL_LOCK(huart);
2ffc8c36:	f894 307c 	ldrb.w	r3, [r4, #124]	@ 0x7c
2ffc8c3a:	2b01      	cmp	r3, #1
2ffc8c3c:	d038      	beq.n	2ffc8cb0 <HAL_UART_Transmit+0xa4>
    huart->ErrorCode = HAL_UART_ERROR_NONE;
2ffc8c3e:	f8c4 8088 	str.w	r8, [r4, #136]	@ 0x88
    __HAL_LOCK(huart);
2ffc8c42:	2301      	movs	r3, #1
2ffc8c44:	f884 307c 	strb.w	r3, [r4, #124]	@ 0x7c
    huart->gState = HAL_UART_STATE_BUSY_TX;
2ffc8c48:	2321      	movs	r3, #33	@ 0x21
2ffc8c4a:	f8c4 3080 	str.w	r3, [r4, #128]	@ 0x80
    tickstart = HAL_GetTick();
2ffc8c4e:	f7fa fc7d 	bl	2ffc354c <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
2ffc8c52:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
2ffc8c54:	4607      	mov	r7, r0
    huart->TxXferSize  = Size;
2ffc8c56:	f8a4 9054 	strh.w	r9, [r4, #84]	@ 0x54
    huart->TxXferCount = Size;
2ffc8c5a:	f8a4 9056 	strh.w	r9, [r4, #86]	@ 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
2ffc8c5e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
2ffc8c62:	d03c      	beq.n	2ffc8cde <HAL_UART_Transmit+0xd2>
    while (huart->TxXferCount > 0U)
2ffc8c64:	f8b4 3056 	ldrh.w	r3, [r4, #86]	@ 0x56
    __HAL_UNLOCK(huart);
2ffc8c68:	2200      	movs	r2, #0
2ffc8c6a:	f884 207c 	strb.w	r2, [r4, #124]	@ 0x7c
    while (huart->TxXferCount > 0U)
2ffc8c6e:	b29b      	uxth	r3, r3
2ffc8c70:	b96b      	cbnz	r3, 2ffc8c8e <HAL_UART_Transmit+0x82>
2ffc8c72:	e025      	b.n	2ffc8cc0 <HAL_UART_Transmit+0xb4>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
2ffc8c74:	f815 2b01 	ldrb.w	r2, [r5], #1
2ffc8c78:	629a      	str	r2, [r3, #40]	@ 0x28
      huart->TxXferCount--;
2ffc8c7a:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
2ffc8c7e:	3a01      	subs	r2, #1
2ffc8c80:	b292      	uxth	r2, r2
2ffc8c82:	f8a4 2056 	strh.w	r2, [r4, #86]	@ 0x56
    while (huart->TxXferCount > 0U)
2ffc8c86:	f8b4 3056 	ldrh.w	r3, [r4, #86]	@ 0x56
2ffc8c8a:	b29b      	uxth	r3, r3
2ffc8c8c:	b1c3      	cbz	r3, 2ffc8cc0 <HAL_UART_Transmit+0xb4>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
2ffc8c8e:	9600      	str	r6, [sp, #0]
2ffc8c90:	463b      	mov	r3, r7
2ffc8c92:	2200      	movs	r2, #0
2ffc8c94:	2180      	movs	r1, #128	@ 0x80
2ffc8c96:	4620      	mov	r0, r4
2ffc8c98:	f7ff ff64 	bl	2ffc8b64 <UART_WaitOnFlagUntilTimeout>
2ffc8c9c:	b960      	cbnz	r0, 2ffc8cb8 <HAL_UART_Transmit+0xac>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
2ffc8c9e:	6823      	ldr	r3, [r4, #0]
      if (pdata8bits == NULL)
2ffc8ca0:	2d00      	cmp	r5, #0
2ffc8ca2:	d1e7      	bne.n	2ffc8c74 <HAL_UART_Transmit+0x68>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
2ffc8ca4:	f838 2b02 	ldrh.w	r2, [r8], #2
2ffc8ca8:	f3c2 0208 	ubfx	r2, r2, #0, #9
2ffc8cac:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata16bits++;
2ffc8cae:	e7e4      	b.n	2ffc8c7a <HAL_UART_Transmit+0x6e>
    __HAL_LOCK(huart);
2ffc8cb0:	2002      	movs	r0, #2
}
2ffc8cb2:	b003      	add	sp, #12
2ffc8cb4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return HAL_TIMEOUT;
2ffc8cb8:	2003      	movs	r0, #3
}
2ffc8cba:	b003      	add	sp, #12
2ffc8cbc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
2ffc8cc0:	9600      	str	r6, [sp, #0]
2ffc8cc2:	463b      	mov	r3, r7
2ffc8cc4:	2200      	movs	r2, #0
2ffc8cc6:	2140      	movs	r1, #64	@ 0x40
2ffc8cc8:	4620      	mov	r0, r4
2ffc8cca:	f7ff ff4b 	bl	2ffc8b64 <UART_WaitOnFlagUntilTimeout>
2ffc8cce:	2800      	cmp	r0, #0
2ffc8cd0:	d1f2      	bne.n	2ffc8cb8 <HAL_UART_Transmit+0xac>
    huart->gState = HAL_UART_STATE_READY;
2ffc8cd2:	2320      	movs	r3, #32
2ffc8cd4:	f8c4 3080 	str.w	r3, [r4, #128]	@ 0x80
}
2ffc8cd8:	b003      	add	sp, #12
2ffc8cda:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
2ffc8cde:	6923      	ldr	r3, [r4, #16]
2ffc8ce0:	2b00      	cmp	r3, #0
2ffc8ce2:	d1bf      	bne.n	2ffc8c64 <HAL_UART_Transmit+0x58>
2ffc8ce4:	46a8      	mov	r8, r5
      pdata8bits  = NULL;
2ffc8ce6:	461d      	mov	r5, r3
2ffc8ce8:	e7bc      	b.n	2ffc8c64 <HAL_UART_Transmit+0x58>
2ffc8cea:	bf00      	nop

2ffc8cec <HAL_UART_Receive>:
{
2ffc8cec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
2ffc8cf0:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_READY)
2ffc8cf2:	f8d0 0084 	ldr.w	r0, [r0, #132]	@ 0x84
{
2ffc8cf6:	b083      	sub	sp, #12
  if (huart->RxState == HAL_UART_STATE_READY)
2ffc8cf8:	2820      	cmp	r0, #32
2ffc8cfa:	d14e      	bne.n	2ffc8d9a <HAL_UART_Receive+0xae>
    if ((pData == NULL) || (Size == 0U))
2ffc8cfc:	2a00      	cmp	r2, #0
2ffc8cfe:	bf18      	it	ne
2ffc8d00:	2900      	cmpne	r1, #0
2ffc8d02:	460d      	mov	r5, r1
2ffc8d04:	4691      	mov	r9, r2
2ffc8d06:	bf0a      	itet	eq
2ffc8d08:	2701      	moveq	r7, #1
2ffc8d0a:	2700      	movne	r7, #0
      return  HAL_ERROR;
2ffc8d0c:	2001      	moveq	r0, #1
    if ((pData == NULL) || (Size == 0U))
2ffc8d0e:	d045      	beq.n	2ffc8d9c <HAL_UART_Receive+0xb0>
2ffc8d10:	461e      	mov	r6, r3
    __HAL_LOCK(huart);
2ffc8d12:	f894 307c 	ldrb.w	r3, [r4, #124]	@ 0x7c
2ffc8d16:	2b01      	cmp	r3, #1
2ffc8d18:	d03f      	beq.n	2ffc8d9a <HAL_UART_Receive+0xae>
    huart->ErrorCode = HAL_UART_ERROR_NONE;
2ffc8d1a:	f8c4 7088 	str.w	r7, [r4, #136]	@ 0x88
    __HAL_LOCK(huart);
2ffc8d1e:	2301      	movs	r3, #1
2ffc8d20:	f884 307c 	strb.w	r3, [r4, #124]	@ 0x7c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
2ffc8d24:	2322      	movs	r3, #34	@ 0x22
2ffc8d26:	f8c4 3084 	str.w	r3, [r4, #132]	@ 0x84
    tickstart = HAL_GetTick();
2ffc8d2a:	f7fa fc0f 	bl	2ffc354c <HAL_GetTick>
    UART_MASK_COMPUTATION(huart);
2ffc8d2e:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
2ffc8d30:	4680      	mov	r8, r0
    huart->RxXferSize  = Size;
2ffc8d32:	f8a4 905c 	strh.w	r9, [r4, #92]	@ 0x5c
    huart->RxXferCount = Size;
2ffc8d36:	f8a4 905e 	strh.w	r9, [r4, #94]	@ 0x5e
    UART_MASK_COMPUTATION(huart);
2ffc8d3a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
2ffc8d3e:	d047      	beq.n	2ffc8dd0 <HAL_UART_Receive+0xe4>
2ffc8d40:	bb7b      	cbnz	r3, 2ffc8da2 <HAL_UART_Receive+0xb6>
2ffc8d42:	6922      	ldr	r2, [r4, #16]
    uhMask = huart->Mask;
2ffc8d44:	4699      	mov	r9, r3
2ffc8d46:	2a00      	cmp	r2, #0
2ffc8d48:	bf0c      	ite	eq
2ffc8d4a:	27ff      	moveq	r7, #255	@ 0xff
2ffc8d4c:	277f      	movne	r7, #127	@ 0x7f
    while (huart->RxXferCount > 0U)
2ffc8d4e:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
    __HAL_UNLOCK(huart);
2ffc8d52:	2200      	movs	r2, #0
    UART_MASK_COMPUTATION(huart);
2ffc8d54:	f8a4 7060 	strh.w	r7, [r4, #96]	@ 0x60
    __HAL_UNLOCK(huart);
2ffc8d58:	f884 207c 	strb.w	r2, [r4, #124]	@ 0x7c
    while (huart->RxXferCount > 0U)
2ffc8d5c:	b29b      	uxth	r3, r3
2ffc8d5e:	b963      	cbnz	r3, 2ffc8d7a <HAL_UART_Receive+0x8e>
2ffc8d60:	e02b      	b.n	2ffc8dba <HAL_UART_Receive+0xce>
        *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
2ffc8d62:	f805 3b01 	strb.w	r3, [r5], #1
      huart->RxXferCount--;
2ffc8d66:	f8b4 205e 	ldrh.w	r2, [r4, #94]	@ 0x5e
2ffc8d6a:	3a01      	subs	r2, #1
2ffc8d6c:	b292      	uxth	r2, r2
2ffc8d6e:	f8a4 205e 	strh.w	r2, [r4, #94]	@ 0x5e
    while (huart->RxXferCount > 0U)
2ffc8d72:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
2ffc8d76:	b29b      	uxth	r3, r3
2ffc8d78:	b1fb      	cbz	r3, 2ffc8dba <HAL_UART_Receive+0xce>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
2ffc8d7a:	9600      	str	r6, [sp, #0]
2ffc8d7c:	4643      	mov	r3, r8
2ffc8d7e:	2200      	movs	r2, #0
2ffc8d80:	2120      	movs	r1, #32
2ffc8d82:	4620      	mov	r0, r4
2ffc8d84:	f7ff feee 	bl	2ffc8b64 <UART_WaitOnFlagUntilTimeout>
2ffc8d88:	b9f0      	cbnz	r0, 2ffc8dc8 <HAL_UART_Receive+0xdc>
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
2ffc8d8a:	6823      	ldr	r3, [r4, #0]
2ffc8d8c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
2ffc8d8e:	403b      	ands	r3, r7
      if (pdata8bits == NULL)
2ffc8d90:	2d00      	cmp	r5, #0
2ffc8d92:	d1e6      	bne.n	2ffc8d62 <HAL_UART_Receive+0x76>
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
2ffc8d94:	f829 3b02 	strh.w	r3, [r9], #2
        pdata16bits++;
2ffc8d98:	e7e5      	b.n	2ffc8d66 <HAL_UART_Receive+0x7a>
    __HAL_LOCK(huart);
2ffc8d9a:	2002      	movs	r0, #2
}
2ffc8d9c:	b003      	add	sp, #12
2ffc8d9e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    UART_MASK_COMPUTATION(huart);
2ffc8da2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
      pdata16bits = NULL;
2ffc8da6:	bf18      	it	ne
2ffc8da8:	46b9      	movne	r9, r7
    UART_MASK_COMPUTATION(huart);
2ffc8daa:	d1d0      	bne.n	2ffc8d4e <HAL_UART_Receive+0x62>
2ffc8dac:	6923      	ldr	r3, [r4, #16]
    uhMask = huart->Mask;
2ffc8dae:	46b9      	mov	r9, r7
2ffc8db0:	2b00      	cmp	r3, #0
2ffc8db2:	bf14      	ite	ne
2ffc8db4:	273f      	movne	r7, #63	@ 0x3f
2ffc8db6:	277f      	moveq	r7, #127	@ 0x7f
2ffc8db8:	e7c9      	b.n	2ffc8d4e <HAL_UART_Receive+0x62>
    huart->RxState = HAL_UART_STATE_READY;
2ffc8dba:	2320      	movs	r3, #32
    return HAL_OK;
2ffc8dbc:	2000      	movs	r0, #0
    huart->RxState = HAL_UART_STATE_READY;
2ffc8dbe:	f8c4 3084 	str.w	r3, [r4, #132]	@ 0x84
}
2ffc8dc2:	b003      	add	sp, #12
2ffc8dc4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return HAL_TIMEOUT;
2ffc8dc8:	2003      	movs	r0, #3
}
2ffc8dca:	b003      	add	sp, #12
2ffc8dcc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    UART_MASK_COMPUTATION(huart);
2ffc8dd0:	6923      	ldr	r3, [r4, #16]
      pdata16bits = NULL;
2ffc8dd2:	46b9      	mov	r9, r7
    uhMask = huart->Mask;
2ffc8dd4:	27ff      	movs	r7, #255	@ 0xff
    UART_MASK_COMPUTATION(huart);
2ffc8dd6:	2b00      	cmp	r3, #0
2ffc8dd8:	d1b9      	bne.n	2ffc8d4e <HAL_UART_Receive+0x62>
2ffc8dda:	46a9      	mov	r9, r5
    uhMask = huart->Mask;
2ffc8ddc:	f240 17ff 	movw	r7, #511	@ 0x1ff
      pdata8bits  = NULL;
2ffc8de0:	461d      	mov	r5, r3
2ffc8de2:	e7b4      	b.n	2ffc8d4e <HAL_UART_Receive+0x62>

2ffc8de4 <UART_CheckIdleState>:
{
2ffc8de4:	b570      	push	{r4, r5, r6, lr}
2ffc8de6:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
2ffc8de8:	2600      	movs	r6, #0
{
2ffc8dea:	b082      	sub	sp, #8
  huart->ErrorCode = HAL_UART_ERROR_NONE;
2ffc8dec:	f8c0 6088 	str.w	r6, [r0, #136]	@ 0x88
  tickstart = HAL_GetTick();
2ffc8df0:	f7fa fbac 	bl	2ffc354c <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
2ffc8df4:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
2ffc8df6:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
2ffc8df8:	681a      	ldr	r2, [r3, #0]
2ffc8dfa:	0712      	lsls	r2, r2, #28
2ffc8dfc:	d40d      	bmi.n	2ffc8e1a <UART_CheckIdleState+0x36>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
2ffc8dfe:	681b      	ldr	r3, [r3, #0]
2ffc8e00:	075b      	lsls	r3, r3, #29
2ffc8e02:	d419      	bmi.n	2ffc8e38 <UART_CheckIdleState+0x54>
  huart->gState = HAL_UART_STATE_READY;
2ffc8e04:	2220      	movs	r2, #32
  __HAL_UNLOCK(huart);
2ffc8e06:	2300      	movs	r3, #0
  huart->gState = HAL_UART_STATE_READY;
2ffc8e08:	f8c4 2080 	str.w	r2, [r4, #128]	@ 0x80
  return HAL_OK;
2ffc8e0c:	4618      	mov	r0, r3
  huart->RxState = HAL_UART_STATE_READY;
2ffc8e0e:	f8c4 2084 	str.w	r2, [r4, #132]	@ 0x84
  __HAL_UNLOCK(huart);
2ffc8e12:	f884 307c 	strb.w	r3, [r4, #124]	@ 0x7c
}
2ffc8e16:	b002      	add	sp, #8
2ffc8e18:	bd70      	pop	{r4, r5, r6, pc}
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
2ffc8e1a:	f06f 427e 	mvn.w	r2, #4261412864	@ 0xfe000000
2ffc8e1e:	4603      	mov	r3, r0
2ffc8e20:	9200      	str	r2, [sp, #0]
2ffc8e22:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
2ffc8e26:	4632      	mov	r2, r6
2ffc8e28:	4620      	mov	r0, r4
2ffc8e2a:	f7ff fe9b 	bl	2ffc8b64 <UART_WaitOnFlagUntilTimeout>
2ffc8e2e:	b978      	cbnz	r0, 2ffc8e50 <UART_CheckIdleState+0x6c>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
2ffc8e30:	6823      	ldr	r3, [r4, #0]
2ffc8e32:	681b      	ldr	r3, [r3, #0]
2ffc8e34:	075b      	lsls	r3, r3, #29
2ffc8e36:	d5e5      	bpl.n	2ffc8e04 <UART_CheckIdleState+0x20>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
2ffc8e38:	f06f 427e 	mvn.w	r2, #4261412864	@ 0xfe000000
2ffc8e3c:	462b      	mov	r3, r5
2ffc8e3e:	9200      	str	r2, [sp, #0]
2ffc8e40:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
2ffc8e44:	2200      	movs	r2, #0
2ffc8e46:	4620      	mov	r0, r4
2ffc8e48:	f7ff fe8c 	bl	2ffc8b64 <UART_WaitOnFlagUntilTimeout>
2ffc8e4c:	2800      	cmp	r0, #0
2ffc8e4e:	d0d9      	beq.n	2ffc8e04 <UART_CheckIdleState+0x20>
      return HAL_TIMEOUT;
2ffc8e50:	2003      	movs	r0, #3
}
2ffc8e52:	b002      	add	sp, #8
2ffc8e54:	bd70      	pop	{r4, r5, r6, pc}
2ffc8e56:	bf00      	nop

2ffc8e58 <HAL_UART_Init>:
  if (huart == NULL)
2ffc8e58:	b380      	cbz	r0, 2ffc8ebc <HAL_UART_Init+0x64>
  if (huart->gState == HAL_UART_STATE_RESET)
2ffc8e5a:	f8d0 3080 	ldr.w	r3, [r0, #128]	@ 0x80
{
2ffc8e5e:	b510      	push	{r4, lr}
2ffc8e60:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
2ffc8e62:	b333      	cbz	r3, 2ffc8eb2 <HAL_UART_Init+0x5a>
  __HAL_UART_DISABLE(huart);
2ffc8e64:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
2ffc8e66:	2324      	movs	r3, #36	@ 0x24
2ffc8e68:	f8c4 3080 	str.w	r3, [r4, #128]	@ 0x80
  if (UART_SetConfig(huart) == HAL_ERROR)
2ffc8e6c:	4620      	mov	r0, r4
  __HAL_UART_DISABLE(huart);
2ffc8e6e:	6813      	ldr	r3, [r2, #0]
2ffc8e70:	f023 0301 	bic.w	r3, r3, #1
2ffc8e74:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
2ffc8e76:	f7ff fbc3 	bl	2ffc8600 <UART_SetConfig>
2ffc8e7a:	2801      	cmp	r0, #1
2ffc8e7c:	d017      	beq.n	2ffc8eae <HAL_UART_Init+0x56>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
2ffc8e7e:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2ffc8e80:	b98b      	cbnz	r3, 2ffc8ea6 <HAL_UART_Init+0x4e>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
2ffc8e82:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
2ffc8e84:	4620      	mov	r0, r4
}
2ffc8e86:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
2ffc8e8a:	685a      	ldr	r2, [r3, #4]
2ffc8e8c:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
2ffc8e90:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
2ffc8e92:	689a      	ldr	r2, [r3, #8]
2ffc8e94:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
2ffc8e98:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
2ffc8e9a:	681a      	ldr	r2, [r3, #0]
2ffc8e9c:	f042 0201 	orr.w	r2, r2, #1
2ffc8ea0:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
2ffc8ea2:	f7ff bf9f 	b.w	2ffc8de4 <UART_CheckIdleState>
    UART_AdvFeatureConfig(huart);
2ffc8ea6:	4620      	mov	r0, r4
2ffc8ea8:	f7ff fe04 	bl	2ffc8ab4 <UART_AdvFeatureConfig>
2ffc8eac:	e7e9      	b.n	2ffc8e82 <HAL_UART_Init+0x2a>
}
2ffc8eae:	2001      	movs	r0, #1
2ffc8eb0:	bd10      	pop	{r4, pc}
    huart->Lock = HAL_UNLOCKED;
2ffc8eb2:	f880 307c 	strb.w	r3, [r0, #124]	@ 0x7c
    HAL_UART_MspInit(huart);
2ffc8eb6:	f002 f9db 	bl	2ffcb270 <HAL_UART_MspInit>
2ffc8eba:	e7d3      	b.n	2ffc8e64 <HAL_UART_Init+0xc>
}
2ffc8ebc:	2001      	movs	r0, #1
2ffc8ebe:	4770      	bx	lr

2ffc8ec0 <UARTEx_SetNbDataToProcess>:
{
  uint8_t rx_fifo_depth;
  uint8_t tx_fifo_depth;
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
2ffc8ec0:	f64e 2158 	movw	r1, #59992	@ 0xea58
{
2ffc8ec4:	b084      	sub	sp, #16
  uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
2ffc8ec6:	f6c2 71fc 	movt	r1, #12284	@ 0x2ffc
  uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};
2ffc8eca:	f64e 224c 	movw	r2, #59980	@ 0xea4c
2ffc8ece:	f6c2 72fc 	movt	r2, #12284	@ 0x2ffc
{
2ffc8ed2:	4603      	mov	r3, r0
  uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
2ffc8ed4:	46ec      	mov	ip, sp
2ffc8ed6:	c903      	ldmia	r1, {r0, r1}
2ffc8ed8:	e88c 0003 	stmia.w	ip, {r0, r1}
  uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};
2ffc8edc:	e892 0003 	ldmia.w	r2, {r0, r1}
2ffc8ee0:	aa04      	add	r2, sp, #16
2ffc8ee2:	e902 0003 	stmdb	r2, {r0, r1}

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
2ffc8ee6:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
2ffc8ee8:	b1fa      	cbz	r2, 2ffc8f2a <UARTEx_SetNbDataToProcess+0x6a>
  }
  else
  {
    rx_fifo_depth = RX_FIFO_DEPTH;
    tx_fifo_depth = TX_FIFO_DEPTH;
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
2ffc8eea:	681a      	ldr	r2, [r3, #0]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) / (uint16_t)denominator[tx_fifo_threshold];
2ffc8eec:	a904      	add	r1, sp, #16
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
2ffc8eee:	6890      	ldr	r0, [r2, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
2ffc8ef0:	6892      	ldr	r2, [r2, #8]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) / (uint16_t)denominator[rx_fifo_threshold];
2ffc8ef2:	f3c0 6042 	ubfx	r0, r0, #25, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) / (uint16_t)denominator[tx_fifo_threshold];
2ffc8ef6:	eb01 7252 	add.w	r2, r1, r2, lsr #29
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) / (uint16_t)denominator[rx_fifo_threshold];
2ffc8efa:	f100 0110 	add.w	r1, r0, #16
2ffc8efe:	eb0d 0001 	add.w	r0, sp, r1
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) / (uint16_t)denominator[tx_fifo_threshold];
2ffc8f02:	f812 1c10 	ldrb.w	r1, [r2, #-16]
2ffc8f06:	f812 2c08 	ldrb.w	r2, [r2, #-8]
2ffc8f0a:	00c9      	lsls	r1, r1, #3
2ffc8f0c:	fbb1 f1f2 	udiv	r1, r1, r2
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) / (uint16_t)denominator[rx_fifo_threshold];
2ffc8f10:	f810 2c10 	ldrb.w	r2, [r0, #-16]
2ffc8f14:	f810 0c08 	ldrb.w	r0, [r0, #-8]
2ffc8f18:	00d2      	lsls	r2, r2, #3
2ffc8f1a:	f8a3 106a 	strh.w	r1, [r3, #106]	@ 0x6a
2ffc8f1e:	fbb2 f2f0 	udiv	r2, r2, r0
2ffc8f22:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
  }
}
2ffc8f26:	b004      	add	sp, #16
2ffc8f28:	4770      	bx	lr
    huart->NbRxDataToProcess = 1U;
2ffc8f2a:	2201      	movs	r2, #1
2ffc8f2c:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
    huart->NbTxDataToProcess = 1U;
2ffc8f30:	4611      	mov	r1, r2
2ffc8f32:	f8a3 106a 	strh.w	r1, [r3, #106]	@ 0x6a
}
2ffc8f36:	b004      	add	sp, #16
2ffc8f38:	4770      	bx	lr
2ffc8f3a:	bf00      	nop

2ffc8f3c <HAL_UARTEx_EnableFifoMode>:
  __HAL_LOCK(huart);
2ffc8f3c:	f890 307c 	ldrb.w	r3, [r0, #124]	@ 0x7c
2ffc8f40:	2b01      	cmp	r3, #1
2ffc8f42:	d019      	beq.n	2ffc8f78 <HAL_UARTEx_EnableFifoMode+0x3c>
  tmpcr1 = READ_REG(huart->Instance->CR1);
2ffc8f44:	6803      	ldr	r3, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
2ffc8f46:	2224      	movs	r2, #36	@ 0x24
{
2ffc8f48:	b510      	push	{r4, lr}
2ffc8f4a:	4604      	mov	r4, r0
  huart->gState = HAL_UART_STATE_BUSY;
2ffc8f4c:	f8c0 2080 	str.w	r2, [r0, #128]	@ 0x80
  tmpcr1 = READ_REG(huart->Instance->CR1);
2ffc8f50:	681a      	ldr	r2, [r3, #0]
  __HAL_UART_DISABLE(huart);
2ffc8f52:	6819      	ldr	r1, [r3, #0]
  SET_BIT(tmpcr1, USART_CR1_FIFOEN);
2ffc8f54:	f042 5200 	orr.w	r2, r2, #536870912	@ 0x20000000
  __HAL_UART_DISABLE(huart);
2ffc8f58:	f021 0101 	bic.w	r1, r1, #1
2ffc8f5c:	6019      	str	r1, [r3, #0]
  huart->FifoMode = UART_FIFOMODE_ENABLE;
2ffc8f5e:	f04f 5100 	mov.w	r1, #536870912	@ 0x20000000
2ffc8f62:	6641      	str	r1, [r0, #100]	@ 0x64
  WRITE_REG(huart->Instance->CR1, tmpcr1);
2ffc8f64:	601a      	str	r2, [r3, #0]
  UARTEx_SetNbDataToProcess(huart);
2ffc8f66:	f7ff ffab 	bl	2ffc8ec0 <UARTEx_SetNbDataToProcess>
  __HAL_UNLOCK(huart);
2ffc8f6a:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
2ffc8f6c:	2320      	movs	r3, #32
  __HAL_UNLOCK(huart);
2ffc8f6e:	f884 007c 	strb.w	r0, [r4, #124]	@ 0x7c
  huart->gState = HAL_UART_STATE_READY;
2ffc8f72:	f8c4 3080 	str.w	r3, [r4, #128]	@ 0x80
}
2ffc8f76:	bd10      	pop	{r4, pc}
  __HAL_LOCK(huart);
2ffc8f78:	2002      	movs	r0, #2
}
2ffc8f7a:	4770      	bx	lr

2ffc8f7c <HAL_UARTEx_SetTxFifoThreshold>:
  __HAL_LOCK(huart);
2ffc8f7c:	f890 307c 	ldrb.w	r3, [r0, #124]	@ 0x7c
2ffc8f80:	2b01      	cmp	r3, #1
2ffc8f82:	d01a      	beq.n	2ffc8fba <HAL_UARTEx_SetTxFifoThreshold+0x3e>
{
2ffc8f84:	b570      	push	{r4, r5, r6, lr}
  huart->gState = HAL_UART_STATE_BUSY;
2ffc8f86:	2324      	movs	r3, #36	@ 0x24
  tmpcr1 = READ_REG(huart->Instance->CR1);
2ffc8f88:	6805      	ldr	r5, [r0, #0]
2ffc8f8a:	4604      	mov	r4, r0
  huart->gState = HAL_UART_STATE_BUSY;
2ffc8f8c:	f8c0 3080 	str.w	r3, [r0, #128]	@ 0x80
  tmpcr1 = READ_REG(huart->Instance->CR1);
2ffc8f90:	682e      	ldr	r6, [r5, #0]
  __HAL_UART_DISABLE(huart);
2ffc8f92:	682b      	ldr	r3, [r5, #0]
2ffc8f94:	f023 0301 	bic.w	r3, r3, #1
2ffc8f98:	602b      	str	r3, [r5, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
2ffc8f9a:	68ab      	ldr	r3, [r5, #8]
2ffc8f9c:	f023 4360 	bic.w	r3, r3, #3758096384	@ 0xe0000000
2ffc8fa0:	4319      	orrs	r1, r3
2ffc8fa2:	60a9      	str	r1, [r5, #8]
  UARTEx_SetNbDataToProcess(huart);
2ffc8fa4:	f7ff ff8c 	bl	2ffc8ec0 <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
2ffc8fa8:	602e      	str	r6, [r5, #0]
  __HAL_UNLOCK(huart);
2ffc8faa:	2300      	movs	r3, #0
2ffc8fac:	f884 307c 	strb.w	r3, [r4, #124]	@ 0x7c
  huart->gState = HAL_UART_STATE_READY;
2ffc8fb0:	2220      	movs	r2, #32
2ffc8fb2:	f8c4 2080 	str.w	r2, [r4, #128]	@ 0x80
  return HAL_OK;
2ffc8fb6:	4618      	mov	r0, r3
}
2ffc8fb8:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(huart);
2ffc8fba:	2002      	movs	r0, #2
}
2ffc8fbc:	4770      	bx	lr
2ffc8fbe:	bf00      	nop

2ffc8fc0 <HAL_UARTEx_SetRxFifoThreshold>:
  __HAL_LOCK(huart);
2ffc8fc0:	f890 307c 	ldrb.w	r3, [r0, #124]	@ 0x7c
2ffc8fc4:	2b01      	cmp	r3, #1
2ffc8fc6:	d01a      	beq.n	2ffc8ffe <HAL_UARTEx_SetRxFifoThreshold+0x3e>
{
2ffc8fc8:	b570      	push	{r4, r5, r6, lr}
  huart->gState = HAL_UART_STATE_BUSY;
2ffc8fca:	2324      	movs	r3, #36	@ 0x24
  tmpcr1 = READ_REG(huart->Instance->CR1);
2ffc8fcc:	6805      	ldr	r5, [r0, #0]
2ffc8fce:	4604      	mov	r4, r0
  huart->gState = HAL_UART_STATE_BUSY;
2ffc8fd0:	f8c0 3080 	str.w	r3, [r0, #128]	@ 0x80
  tmpcr1 = READ_REG(huart->Instance->CR1);
2ffc8fd4:	682e      	ldr	r6, [r5, #0]
  __HAL_UART_DISABLE(huart);
2ffc8fd6:	682b      	ldr	r3, [r5, #0]
2ffc8fd8:	f023 0301 	bic.w	r3, r3, #1
2ffc8fdc:	602b      	str	r3, [r5, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
2ffc8fde:	68ab      	ldr	r3, [r5, #8]
2ffc8fe0:	f023 6360 	bic.w	r3, r3, #234881024	@ 0xe000000
2ffc8fe4:	4319      	orrs	r1, r3
2ffc8fe6:	60a9      	str	r1, [r5, #8]
  UARTEx_SetNbDataToProcess(huart);
2ffc8fe8:	f7ff ff6a 	bl	2ffc8ec0 <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
2ffc8fec:	602e      	str	r6, [r5, #0]
  __HAL_UNLOCK(huart);
2ffc8fee:	2300      	movs	r3, #0
2ffc8ff0:	f884 307c 	strb.w	r3, [r4, #124]	@ 0x7c
  huart->gState = HAL_UART_STATE_READY;
2ffc8ff4:	2220      	movs	r2, #32
2ffc8ff6:	f8c4 2080 	str.w	r2, [r4, #128]	@ 0x80
  return HAL_OK;
2ffc8ffa:	4618      	mov	r0, r3
}
2ffc8ffc:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(huart);
2ffc8ffe:	2002      	movs	r0, #2
}
2ffc9000:	4770      	bx	lr
2ffc9002:	bf00      	nop

2ffc9004 <get_buf_size>:
}

static int get_buf_size(uint32_t size_in, uint32_t *size,
                        uint32_t default_size, uint32_t min_size)
{
  if (size_in != 0)
2ffc9004:	b910      	cbnz	r0, 2ffc900c <get_buf_size+0x8>
    {
      printf("Unaligned size: 0x%lx (min=%ld)\n\r", size_in, min_size);
      return -1;
    }

    *size = size_in;
2ffc9006:	600a      	str	r2, [r1, #0]
  else
  {
    *size = default_size;
  }

  return 0;
2ffc9008:	2000      	movs	r0, #0
}
2ffc900a:	4770      	bx	lr
    if ((size_in < min_size) || (size_in > DDR_MEM_SIZE))
2ffc900c:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
2ffc9010:	4684      	mov	ip, r0
2ffc9012:	bf94      	ite	ls
2ffc9014:	2200      	movls	r2, #0
2ffc9016:	2201      	movhi	r2, #1
{
2ffc9018:	b500      	push	{lr}
2ffc901a:	b083      	sub	sp, #12
    if ((size_in < min_size) || (size_in > DDR_MEM_SIZE))
2ffc901c:	4298      	cmp	r0, r3
2ffc901e:	bf38      	it	cc
2ffc9020:	f042 0201 	orrcc.w	r2, r2, #1
2ffc9024:	b94a      	cbnz	r2, 2ffc903a <get_buf_size+0x36>
    if ((size_in & (min_size - 1)) != 0)
2ffc9026:	1e5a      	subs	r2, r3, #1
2ffc9028:	4202      	tst	r2, r0
2ffc902a:	bf02      	ittt	eq
2ffc902c:	4602      	moveq	r2, r0
  return 0;
2ffc902e:	2000      	moveq	r0, #0
    *size = size_in;
2ffc9030:	600a      	streq	r2, [r1, #0]
    if ((size_in & (min_size - 1)) != 0)
2ffc9032:	d117      	bne.n	2ffc9064 <get_buf_size+0x60>
}
2ffc9034:	b003      	add	sp, #12
2ffc9036:	f85d fb04 	ldr.w	pc, [sp], #4
2ffc903a:	9301      	str	r3, [sp, #4]
      printf("Invalid size: 0x%lx\n\r", size_in);
2ffc903c:	f64e 2060 	movw	r0, #60000	@ 0xea60
2ffc9040:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9044:	4661      	mov	r1, ip
2ffc9046:	f002 fc9f 	bl	2ffcb988 <iprintf>
      printf("  (range = 0x%lx..0x%x)\n\r", min_size, DDR_MEM_SIZE);
2ffc904a:	9b01      	ldr	r3, [sp, #4]
2ffc904c:	f64e 2078 	movw	r0, #60024	@ 0xea78
2ffc9050:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9054:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
2ffc9058:	4619      	mov	r1, r3
2ffc905a:	f002 fc95 	bl	2ffcb988 <iprintf>
      return -1;
2ffc905e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
2ffc9062:	e7e7      	b.n	2ffc9034 <get_buf_size+0x30>
      printf("Unaligned size: 0x%lx (min=%ld)\n\r", size_in, min_size);
2ffc9064:	f64e 2094 	movw	r0, #60052	@ 0xea94
2ffc9068:	461a      	mov	r2, r3
2ffc906a:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc906e:	4661      	mov	r1, ip
2ffc9070:	f002 fc8a 	bl	2ffcb988 <iprintf>
      return -1;
2ffc9074:	e7f3      	b.n	2ffc905e <get_buf_size+0x5a>
2ffc9076:	bf00      	nop

2ffc9078 <test_databuswalk>:

  return 0;
}

static int test_databuswalk(uint8_t mode, uint32_t loop_in, uint32_t addr_in)
{
2ffc9078:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
2ffc907c:	4606      	mov	r6, r0
2ffc907e:	b085      	sub	sp, #20
2ffc9080:	4692      	mov	sl, r2
    *nb_loop = default_nb_loop;
2ffc9082:	f04f 0b64 	mov.w	fp, #100	@ 0x64
  if (loop_in != 0)
2ffc9086:	b119      	cbz	r1, 2ffc9090 <test_databuswalk+0x18>
    if (loop_in == 0xFFFFFFFF)
2ffc9088:	f1b1 3fff 	cmp.w	r1, #4294967295	@ 0xffffffff
2ffc908c:	468b      	mov	fp, r1
2ffc908e:	d070      	beq.n	2ffc9172 <test_databuswalk+0xfa>
  if (addr_in != 0)
2ffc9090:	f1ba 0f00 	cmp.w	sl, #0
2ffc9094:	d00e      	beq.n	2ffc90b4 <test_databuswalk+0x3c>
    if (addr_in < DDR_BASE_ADDR)
2ffc9096:	f1ba 4f40 	cmp.w	sl, #3221225472	@ 0xc0000000
2ffc909a:	d371      	bcc.n	2ffc9180 <test_databuswalk+0x108>
    if ((addr_in & 0x3) != 0)
2ffc909c:	f01a 0f03 	tst.w	sl, #3
2ffc90a0:	d00a      	beq.n	2ffc90b8 <test_databuswalk+0x40>
      printf("Unaligned address: 0x%lx\n\r", addr_in);
2ffc90a2:	f64e 20f8 	movw	r0, #60152	@ 0xeaf8
2ffc90a6:	4651      	mov	r1, sl
2ffc90a8:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc90ac:	f002 fc6c 	bl	2ffcb988 <iprintf>

  get_nb_loop(loop_in, &nb_loop, 100);

  if (get_addr(addr_in, &addr) != 0)
  {
    return 1;
2ffc90b0:	2001      	movs	r0, #1
2ffc90b2:	e05b      	b.n	2ffc916c <test_databuswalk+0xf4>
    *addr = DDR_BASE_ADDR;
2ffc90b4:	f04f 4a40 	mov.w	sl, #3221225472	@ 0xc0000000
  }

  while (error == 0U)
2ffc90b8:	f8cd b00c 	str.w	fp, [sp, #12]
2ffc90bc:	f10a 0180 	add.w	r1, sl, #128	@ 0x80
2ffc90c0:	460b      	mov	r3, r1
  uint32_t loop = 0;
2ffc90c2:	2000      	movs	r0, #0

      data = READ_REG(*(volatile uint32_t*)(addr + sizeof(uint32_t) * i));
      if (pattern !=  data)
      {
        error |= 1 << i;
        printf("  %lx: error %lx expected %lx => error:%lx\n\r",
2ffc90c4:	f64e 3814 	movw	r8, #60180	@ 0xeb14
2ffc90c8:	4651      	mov	r1, sl
2ffc90ca:	f6c2 78fc 	movt	r8, #12284	@ 0x2ffc
      uint32_t pattern = mode ? (1 << i) : ~(1 << i);
2ffc90ce:	2701      	movs	r7, #1
2ffc90d0:	4683      	mov	fp, r0
2ffc90d2:	469a      	mov	sl, r3
    *addr = DDR_BASE_ADDR;
2ffc90d4:	460c      	mov	r4, r1
    for (i = 0; i < 32; i++)
2ffc90d6:	2300      	movs	r3, #0
      uint32_t pattern = mode ? (1 << i) : ~(1 << i);
2ffc90d8:	fa07 f203 	lsl.w	r2, r7, r3
2ffc90dc:	b906      	cbnz	r6, 2ffc90e0 <test_databuswalk+0x68>
2ffc90de:	43d2      	mvns	r2, r2
      WRITE_REG(*(volatile uint32_t*)(addr + sizeof(uint32_t) * i), pattern);
2ffc90e0:	f844 2b04 	str.w	r2, [r4], #4
    for (i = 0; i < 32; i++)
2ffc90e4:	3301      	adds	r3, #1
2ffc90e6:	2b20      	cmp	r3, #32
2ffc90e8:	d1f6      	bne.n	2ffc90d8 <test_databuswalk+0x60>
    for (i = 0; i < 32; i++)
2ffc90ea:	f8cd b008 	str.w	fp, [sp, #8]
    for (i = 0; i < 32; i++)
2ffc90ee:	f04f 0900 	mov.w	r9, #0
    for (i = 0; i < 32; i++)
2ffc90f2:	4633      	mov	r3, r6
2ffc90f4:	464c      	mov	r4, r9
2ffc90f6:	464e      	mov	r6, r9
    for (i = 0; i < 32; i++)
2ffc90f8:	460d      	mov	r5, r1
    for (i = 0; i < 32; i++)
2ffc90fa:	468b      	mov	fp, r1
2ffc90fc:	4699      	mov	r9, r3
      uint32_t pattern = mode ? (1 << i) : ~(1 << i);
2ffc90fe:	fa07 fc04 	lsl.w	ip, r7, r4
2ffc9102:	4663      	mov	r3, ip
2ffc9104:	f1b9 0f00 	cmp.w	r9, #0
2ffc9108:	d101      	bne.n	2ffc910e <test_databuswalk+0x96>
2ffc910a:	ea6f 030c 	mvn.w	r3, ip
      data = READ_REG(*(volatile uint32_t*)(addr + sizeof(uint32_t) * i));
2ffc910e:	682a      	ldr	r2, [r5, #0]
        printf("  %lx: error %lx expected %lx => error:%lx\n\r",
2ffc9110:	4629      	mov	r1, r5
    for (i = 0; i < 32; i++)
2ffc9112:	3401      	adds	r4, #1
2ffc9114:	3504      	adds	r5, #4
      if (pattern !=  data)
2ffc9116:	4293      	cmp	r3, r2
        printf("  %lx: error %lx expected %lx => error:%lx\n\r",
2ffc9118:	4640      	mov	r0, r8
      if (pattern !=  data)
2ffc911a:	d004      	beq.n	2ffc9126 <test_databuswalk+0xae>
        error |= 1 << i;
2ffc911c:	ea46 060c 	orr.w	r6, r6, ip
        printf("  %lx: error %lx expected %lx => error:%lx\n\r",
2ffc9120:	9600      	str	r6, [sp, #0]
2ffc9122:	f002 fc31 	bl	2ffcb988 <iprintf>
    for (i = 0; i < 32; i++)
2ffc9126:	2c20      	cmp	r4, #32
2ffc9128:	d1e9      	bne.n	2ffc90fe <test_databuswalk+0x86>
  (*loop)++;
2ffc912a:	464b      	mov	r3, r9
2ffc912c:	4659      	mov	r1, fp
2ffc912e:	f8dd b008 	ldr.w	fp, [sp, #8]
2ffc9132:	46b1      	mov	r9, r6
2ffc9134:	461e      	mov	r6, r3
  if (nb_loop && *loop >= nb_loop)
2ffc9136:	9b03      	ldr	r3, [sp, #12]
  (*loop)++;
2ffc9138:	f10b 0b01 	add.w	fp, fp, #1
  if (nb_loop && *loop >= nb_loop)
2ffc913c:	459b      	cmp	fp, r3
2ffc913e:	d011      	beq.n	2ffc9164 <test_databuswalk+0xec>
2ffc9140:	460b      	mov	r3, r1
      break;
    }

    for (i = 0; i < 32; i++)
    {
      WRITE_REG(*(volatile uint32_t*)(addr + sizeof(uint32_t) * i), 0);
2ffc9142:	2200      	movs	r2, #0
2ffc9144:	f843 2b04 	str.w	r2, [r3], #4
    for (i = 0; i < 32; i++)
2ffc9148:	459a      	cmp	sl, r3
2ffc914a:	d1fb      	bne.n	2ffc9144 <test_databuswalk+0xcc>
  while (error == 0U)
2ffc914c:	f1b9 0f00 	cmp.w	r9, #0
2ffc9150:	d0c0      	beq.n	2ffc90d4 <test_databuswalk+0x5c>
    }
  }

  if (error != 0U)
  {
    printf("  test_databuswalk%d KO\n\r", mode);
2ffc9152:	f64e 3044 	movw	r0, #60228	@ 0xeb44
2ffc9156:	4631      	mov	r1, r6
2ffc9158:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc915c:	f002 fc14 	bl	2ffcb988 <iprintf>
    return 2;
2ffc9160:	2002      	movs	r0, #2
2ffc9162:	e003      	b.n	2ffc916c <test_databuswalk+0xf4>
  }

  return 0;
2ffc9164:	4648      	mov	r0, r9
  if (error != 0U)
2ffc9166:	f1b9 0f00 	cmp.w	r9, #0
2ffc916a:	d1f2      	bne.n	2ffc9152 <test_databuswalk+0xda>
}
2ffc916c:	b005      	add	sp, #20
2ffc916e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      printf("Warning: infinite loop requested\n\r");
2ffc9172:	f64e 20b8 	movw	r0, #60088	@ 0xeab8
2ffc9176:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc917a:	f002 fc05 	bl	2ffcb988 <iprintf>
2ffc917e:	e787      	b.n	2ffc9090 <test_databuswalk+0x18>
      printf("Address too low: 0x%lx\n\r", addr_in);
2ffc9180:	f64e 20dc 	movw	r0, #60124	@ 0xeadc
2ffc9184:	4651      	mov	r1, sl
2ffc9186:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc918a:	f002 fbfd 	bl	2ffcb988 <iprintf>
      return -1;
2ffc918e:	e78f      	b.n	2ffc90b0 <test_databuswalk+0x38>

2ffc9190 <DDR_Test_Databus>:
{
2ffc9190:	b510      	push	{r4, lr}
  if (addr_in != 0)
2ffc9192:	b138      	cbz	r0, 2ffc91a4 <DDR_Test_Databus+0x14>
    if (addr_in < DDR_BASE_ADDR)
2ffc9194:	f1b0 4f40 	cmp.w	r0, #3221225472	@ 0xc0000000
2ffc9198:	4601      	mov	r1, r0
2ffc919a:	d319      	bcc.n	2ffc91d0 <DDR_Test_Databus+0x40>
    if ((addr_in & 0x3) != 0)
2ffc919c:	0783      	lsls	r3, r0, #30
2ffc919e:	d11f      	bne.n	2ffc91e0 <DDR_Test_Databus+0x50>
    WRITE_REG(*(volatile uint32_t*)addr, pattern);
2ffc91a0:	4602      	mov	r2, r0
2ffc91a2:	e002      	b.n	2ffc91aa <DDR_Test_Databus+0x1a>
2ffc91a4:	f04f 4240 	mov.w	r2, #3221225472	@ 0xc0000000
    *addr = DDR_BASE_ADDR;
2ffc91a8:	4611      	mov	r1, r2
2ffc91aa:	2020      	movs	r0, #32
  for (pattern = 1U; pattern != 0U; pattern <<= 1)
2ffc91ac:	2301      	movs	r3, #1
2ffc91ae:	e001      	b.n	2ffc91b4 <DDR_Test_Databus+0x24>
2ffc91b0:	3801      	subs	r0, #1
2ffc91b2:	d00c      	beq.n	2ffc91ce <DDR_Test_Databus+0x3e>
    WRITE_REG(*(volatile uint32_t*)addr, pattern);
2ffc91b4:	6013      	str	r3, [r2, #0]
    if (READ_REG(*(volatile uint32_t*)addr) != pattern)
2ffc91b6:	6814      	ldr	r4, [r2, #0]
2ffc91b8:	429c      	cmp	r4, r3
  for (pattern = 1U; pattern != 0U; pattern <<= 1)
2ffc91ba:	ea4f 0343 	mov.w	r3, r3, lsl #1
    if (READ_REG(*(volatile uint32_t*)addr) != pattern)
2ffc91be:	d0f7      	beq.n	2ffc91b0 <DDR_Test_Databus+0x20>
      printf("  test_databus KO @ 0x%lx \n\r", addr);
2ffc91c0:	f64e 3060 	movw	r0, #60256	@ 0xeb60
2ffc91c4:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc91c8:	f002 fbde 	bl	2ffcb988 <iprintf>
      return 2;
2ffc91cc:	2002      	movs	r0, #2
}
2ffc91ce:	bd10      	pop	{r4, pc}
      printf("Address too low: 0x%lx\n\r", addr_in);
2ffc91d0:	f64e 20dc 	movw	r0, #60124	@ 0xeadc
2ffc91d4:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc91d8:	f002 fbd6 	bl	2ffcb988 <iprintf>
    return 1;
2ffc91dc:	2001      	movs	r0, #1
}
2ffc91de:	bd10      	pop	{r4, pc}
      printf("Unaligned address: 0x%lx\n\r", addr_in);
2ffc91e0:	f64e 20f8 	movw	r0, #60152	@ 0xeaf8
2ffc91e4:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc91e8:	f002 fbce 	bl	2ffcb988 <iprintf>
      return -1;
2ffc91ec:	e7f6      	b.n	2ffc91dc <DDR_Test_Databus+0x4c>
2ffc91ee:	bf00      	nop

2ffc91f0 <DDR_Test_DatabusWalk0>:
*  0: Test passed
*  Value different from 0: Test failed
*  None(0xFF): if the result is deduced by the user: waveform, event...
*/
uint32_t DDR_Test_DatabusWalk0(uint32_t loop, uint32_t addr)
{
2ffc91f0:	460a      	mov	r2, r1
  return test_databuswalk(0, loop, addr);
2ffc91f2:	4601      	mov	r1, r0
2ffc91f4:	2000      	movs	r0, #0
2ffc91f6:	f7ff bf3f 	b.w	2ffc9078 <test_databuswalk>
2ffc91fa:	bf00      	nop

2ffc91fc <DDR_Test_DatabusWalk1>:
*  0: Test passed
*  Value different from 0: Test failed
*  None(0xFF): if the result is deduced by the user: waveform, event...
*/
uint32_t DDR_Test_DatabusWalk1(uint32_t loop, uint32_t addr)
{
2ffc91fc:	460a      	mov	r2, r1
  return test_databuswalk(1, loop, addr);
2ffc91fe:	4601      	mov	r1, r0
2ffc9200:	2001      	movs	r0, #1
2ffc9202:	f7ff bf39 	b.w	2ffc9078 <test_databuswalk>
2ffc9206:	bf00      	nop

2ffc9208 <DDR_Test_AddressBus>:
*  0: Test passed
*  Value different from 0: Test failed
*  None(0xFF): if the result is deduced by the user: waveform, event...
*/
uint32_t DDR_Test_AddressBus(uint32_t size_in, uint32_t addr_in)
{
2ffc9208:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
2ffc920c:	b085      	sub	sp, #20
2ffc920e:	460c      	mov	r4, r1
  uint64_t offset;
  uint64_t testoffset = 0;
  uint32_t pattern     = 0xAAAAAAAA;
  uint32_t antipattern = 0x55555555;

  if (get_buf_size(size_in, &size, DDR_MEM_SIZE, 4) != 0)
2ffc9210:	2304      	movs	r3, #4
2ffc9212:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
2ffc9216:	a903      	add	r1, sp, #12
  {
    return 1;
2ffc9218:	2501      	movs	r5, #1
  if (get_buf_size(size_in, &size, DDR_MEM_SIZE, 4) != 0)
2ffc921a:	f7ff fef3 	bl	2ffc9004 <get_buf_size>
2ffc921e:	2800      	cmp	r0, #0
2ffc9220:	f040 8091 	bne.w	2ffc9346 <DDR_Test_AddressBus+0x13e>
  }

  if (!is_power_of_2(size))
2ffc9224:	9903      	ldr	r1, [sp, #12]
  return ((n != 0) && ((n & (n - 1)) == 0));
2ffc9226:	2900      	cmp	r1, #0
2ffc9228:	f000 8091 	beq.w	2ffc934e <DDR_Test_AddressBus+0x146>
2ffc922c:	1e4e      	subs	r6, r1, #1
2ffc922e:	ea11 0506 	ands.w	r5, r1, r6
2ffc9232:	f040 808c 	bne.w	2ffc934e <DDR_Test_AddressBus+0x146>
  if (addr_in != 0)
2ffc9236:	2c00      	cmp	r4, #0
2ffc9238:	f040 8094 	bne.w	2ffc9364 <DDR_Test_AddressBus+0x15c>
2ffc923c:	f04f 4840 	mov.w	r8, #3221225472	@ 0xc0000000
    *addr = DDR_BASE_ADDR;
2ffc9240:	4644      	mov	r4, r8
  }

  addressmask = size - 1;

  /* Write the default pattern at each of the power-of-two offsets. */
  for (offset = sizeof(uint32_t); (offset & addressmask) != 0U; offset <<= 1)
2ffc9242:	0773      	lsls	r3, r6, #29
2ffc9244:	f140 80ab 	bpl.w	2ffc939e <DDR_Test_AddressBus+0x196>
2ffc9248:	2304      	movs	r3, #4
  {
    WRITE_REG(*(volatile uint32_t*)(addr + (uint32_t)offset), pattern);
2ffc924a:	f04f 31aa 	mov.w	r1, #2863311530	@ 0xaaaaaaaa
2ffc924e:	50e1      	str	r1, [r4, r3]
  for (offset = sizeof(uint32_t); (offset & addressmask) != 0U; offset <<= 1)
2ffc9250:	18db      	adds	r3, r3, r3
2ffc9252:	ea16 0203 	ands.w	r2, r6, r3
2ffc9256:	d1fa      	bne.n	2ffc924e <DDR_Test_AddressBus+0x46>
  }

  /* Check for address bits stuck high. */
  WRITE_REG(*(volatile uint32_t*)(addr + (uint32_t)testoffset), antipattern);

  for (offset = sizeof(uint32_t);
2ffc9258:	2304      	movs	r3, #4
  WRITE_REG(*(volatile uint32_t*)(addr + (uint32_t)testoffset), antipattern);
2ffc925a:	f04f 3155 	mov.w	r1, #1431655765	@ 0x55555555
2ffc925e:	f8c8 1000 	str.w	r1, [r8]
       ((offset & addressmask) != 0U) && (offset != DDR_MEM_SIZE);
       offset <<= 1)
  {
    if (READ_REG(*(volatile uint32_t*)(addr + (uint32_t)offset)) != pattern)
2ffc9262:	58e0      	ldr	r0, [r4, r3]
2ffc9264:	18e1      	adds	r1, r4, r3
2ffc9266:	f1b0 3faa 	cmp.w	r0, #2863311530	@ 0xaaaaaaaa
2ffc926a:	f040 808d 	bne.w	2ffc9388 <DDR_Test_AddressBus+0x180>
       offset <<= 1)
2ffc926e:	18db      	adds	r3, r3, r3
2ffc9270:	4152      	adcs	r2, r2
       ((offset & addressmask) != 0U) && (offset != DDR_MEM_SIZE);
2ffc9272:	f103 4760 	add.w	r7, r3, #3758096384	@ 0xe0000000
2ffc9276:	421e      	tst	r6, r3
2ffc9278:	bf14      	ite	ne
2ffc927a:	2101      	movne	r1, #1
2ffc927c:	2100      	moveq	r1, #0
2ffc927e:	4317      	orrs	r7, r2
2ffc9280:	f001 0101 	and.w	r1, r1, #1
2ffc9284:	bf08      	it	eq
2ffc9286:	2100      	moveq	r1, #0
2ffc9288:	2900      	cmp	r1, #0
2ffc928a:	d1ea      	bne.n	2ffc9262 <DDR_Test_AddressBus+0x5a>
      printf("  test_addrbus KO @ 0x%lx \n\r", addr + (uint32_t)offset);
      return 4;
    }
  }

  WRITE_REG(*(volatile uint32_t*)(addr + (uint32_t)testoffset), pattern);
2ffc928c:	f8c8 0000 	str.w	r0, [r8]

  /* Check for address bits stuck low or shorted. */
  for (testoffset = sizeof(uint32_t);
2ffc9290:	468c      	mov	ip, r1
       ((testoffset & addressmask) != 0U)  && (testoffset != DDR_MEM_SIZE);
       testoffset <<= 1)
  {
    WRITE_REG(*(volatile uint32_t*)(addr + (uint32_t)testoffset), antipattern);
2ffc9292:	9001      	str	r0, [sp, #4]
  for (testoffset = sizeof(uint32_t);
2ffc9294:	2704      	movs	r7, #4
    WRITE_REG(*(volatile uint32_t*)(addr + (uint32_t)testoffset), antipattern);
2ffc9296:	f04f 3a55 	mov.w	sl, #1431655765	@ 0x55555555
2ffc929a:	f844 a007 	str.w	sl, [r4, r7]

    if (READ_REG(*(volatile uint32_t*)addr) != pattern)
2ffc929e:	f8d8 3000 	ldr.w	r3, [r8]
    WRITE_REG(*(volatile uint32_t*)(addr + (uint32_t)testoffset), antipattern);
2ffc92a2:	eb04 0e07 	add.w	lr, r4, r7
    if (READ_REG(*(volatile uint32_t*)addr) != pattern)
2ffc92a6:	f1b3 3faa 	cmp.w	r3, #2863311530	@ 0xaaaaaaaa
2ffc92aa:	f040 8081 	bne.w	2ffc93b0 <DDR_Test_AddressBus+0x1a8>

    for (offset = sizeof(uint32_t);
         ((offset & addressmask) != 0U) && (offset != DDR_MEM_SIZE);
         offset <<= 1)
    {
      if ((READ_REG(*(volatile uint32_t*)(addr + (uint32_t)offset)) != pattern)
2ffc92ae:	6862      	ldr	r2, [r4, #4]
          && (offset != testoffset))
2ffc92b0:	1f3b      	subs	r3, r7, #4
2ffc92b2:	ea43 030c 	orr.w	r3, r3, ip
      if ((READ_REG(*(volatile uint32_t*)(addr + (uint32_t)offset)) != pattern)
2ffc92b6:	1d21      	adds	r1, r4, #4
          && (offset != testoffset))
2ffc92b8:	f1b2 3faa 	cmp.w	r2, #2863311530	@ 0xaaaaaaaa
2ffc92bc:	bf18      	it	ne
2ffc92be:	2b00      	cmpne	r3, #0
2ffc92c0:	bf14      	ite	ne
2ffc92c2:	2201      	movne	r2, #1
2ffc92c4:	2200      	moveq	r2, #0
2ffc92c6:	d154      	bne.n	2ffc9372 <DDR_Test_AddressBus+0x16a>
    for (offset = sizeof(uint32_t);
2ffc92c8:	2304      	movs	r3, #4
2ffc92ca:	e00b      	b.n	2ffc92e4 <DDR_Test_AddressBus+0xdc>
      if ((READ_REG(*(volatile uint32_t*)(addr + (uint32_t)offset)) != pattern)
2ffc92cc:	f854 0009 	ldr.w	r0, [r4, r9]
          && (offset != testoffset))
2ffc92d0:	f1b0 3faa 	cmp.w	r0, #2863311530	@ 0xaaaaaaaa
2ffc92d4:	bf0c      	ite	eq
2ffc92d6:	f04f 0b00 	moveq.w	fp, #0
2ffc92da:	f00b 0b01 	andne.w	fp, fp, #1
2ffc92de:	f1bb 0f00 	cmp.w	fp, #0
2ffc92e2:	d146      	bne.n	2ffc9372 <DDR_Test_AddressBus+0x16a>
         offset <<= 1)
2ffc92e4:	eb13 0903 	adds.w	r9, r3, r3
2ffc92e8:	4152      	adcs	r2, r2
         ((offset & addressmask) != 0U) && (offset != DDR_MEM_SIZE);
2ffc92ea:	f109 4b60 	add.w	fp, r9, #3758096384	@ 0xe0000000
2ffc92ee:	ea16 0f09 	tst.w	r6, r9
         offset <<= 1)
2ffc92f2:	464b      	mov	r3, r9
      if ((READ_REG(*(volatile uint32_t*)(addr + (uint32_t)offset)) != pattern)
2ffc92f4:	eb04 0103 	add.w	r1, r4, r3
         ((offset & addressmask) != 0U) && (offset != DDR_MEM_SIZE);
2ffc92f8:	bf14      	ite	ne
2ffc92fa:	2001      	movne	r0, #1
2ffc92fc:	2000      	moveq	r0, #0
2ffc92fe:	ea5b 0b02 	orrs.w	fp, fp, r2
2ffc9302:	f000 0001 	and.w	r0, r0, #1
2ffc9306:	bf08      	it	eq
2ffc9308:	2000      	moveq	r0, #0
          && (offset != testoffset))
2ffc930a:	4562      	cmp	r2, ip
2ffc930c:	bf08      	it	eq
2ffc930e:	42bb      	cmpeq	r3, r7
2ffc9310:	bf14      	ite	ne
2ffc9312:	f04f 0b01 	movne.w	fp, #1
2ffc9316:	f04f 0b00 	moveq.w	fp, #0
         ((offset & addressmask) != 0U) && (offset != DDR_MEM_SIZE);
2ffc931a:	2800      	cmp	r0, #0
2ffc931c:	d1d6      	bne.n	2ffc92cc <DDR_Test_AddressBus+0xc4>
        printf("  test_addrbus KO @ 0x%lx \n\r", addr + (uint32_t)offset);
        return 6;
      }
    }

    WRITE_REG(*(volatile uint32_t*)(addr + (uint32_t)testoffset), pattern);
2ffc931e:	9b01      	ldr	r3, [sp, #4]
       testoffset <<= 1)
2ffc9320:	19ff      	adds	r7, r7, r7
2ffc9322:	eb4c 0c0c 	adc.w	ip, ip, ip
       ((testoffset & addressmask) != 0U)  && (testoffset != DDR_MEM_SIZE);
2ffc9326:	f107 4260 	add.w	r2, r7, #3758096384	@ 0xe0000000
2ffc932a:	423e      	tst	r6, r7
    WRITE_REG(*(volatile uint32_t*)(addr + (uint32_t)testoffset), pattern);
2ffc932c:	f8ce 3000 	str.w	r3, [lr]
       ((testoffset & addressmask) != 0U)  && (testoffset != DDR_MEM_SIZE);
2ffc9330:	bf14      	ite	ne
2ffc9332:	2301      	movne	r3, #1
2ffc9334:	2300      	moveq	r3, #0
2ffc9336:	ea52 020c 	orrs.w	r2, r2, ip
2ffc933a:	f003 0301 	and.w	r3, r3, #1
2ffc933e:	bf08      	it	eq
2ffc9340:	2300      	moveq	r3, #0
2ffc9342:	2b00      	cmp	r3, #0
2ffc9344:	d1a9      	bne.n	2ffc929a <DDR_Test_AddressBus+0x92>
  }

  return 0;
}
2ffc9346:	4628      	mov	r0, r5
2ffc9348:	b005      	add	sp, #20
2ffc934a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    printf("size 0x%lx is not a power of 2\n\r", size);
2ffc934e:	f64e 3080 	movw	r0, #60288	@ 0xeb80
    return 2;
2ffc9352:	2502      	movs	r5, #2
    printf("size 0x%lx is not a power of 2\n\r", size);
2ffc9354:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9358:	f002 fb16 	bl	2ffcb988 <iprintf>
}
2ffc935c:	4628      	mov	r0, r5
2ffc935e:	b005      	add	sp, #20
2ffc9360:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (addr_in < DDR_BASE_ADDR)
2ffc9364:	f1b4 4f40 	cmp.w	r4, #3221225472	@ 0xc0000000
2ffc9368:	d32b      	bcc.n	2ffc93c2 <DDR_Test_AddressBus+0x1ba>
    if ((addr_in & 0x3) != 0)
2ffc936a:	07a2      	lsls	r2, r4, #30
2ffc936c:	d132      	bne.n	2ffc93d4 <DDR_Test_AddressBus+0x1cc>
  WRITE_REG(*(volatile uint32_t*)(addr + (uint32_t)testoffset), antipattern);
2ffc936e:	46a0      	mov	r8, r4
2ffc9370:	e767      	b.n	2ffc9242 <DDR_Test_AddressBus+0x3a>
        printf("  test_addrbus KO @ 0x%lx \n\r", addr + (uint32_t)offset);
2ffc9372:	f64e 30a4 	movw	r0, #60324	@ 0xeba4
        return 6;
2ffc9376:	2506      	movs	r5, #6
        printf("  test_addrbus KO @ 0x%lx \n\r", addr + (uint32_t)offset);
2ffc9378:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc937c:	f002 fb04 	bl	2ffcb988 <iprintf>
}
2ffc9380:	4628      	mov	r0, r5
2ffc9382:	b005      	add	sp, #20
2ffc9384:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      printf("  test_addrbus KO @ 0x%lx \n\r", addr + (uint32_t)offset);
2ffc9388:	f64e 30a4 	movw	r0, #60324	@ 0xeba4
      return 4;
2ffc938c:	2504      	movs	r5, #4
      printf("  test_addrbus KO @ 0x%lx \n\r", addr + (uint32_t)offset);
2ffc938e:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9392:	f002 faf9 	bl	2ffcb988 <iprintf>
}
2ffc9396:	4628      	mov	r0, r5
2ffc9398:	b005      	add	sp, #20
2ffc939a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  WRITE_REG(*(volatile uint32_t*)(addr + (uint32_t)testoffset), antipattern);
2ffc939e:	f04f 3255 	mov.w	r2, #1431655765	@ 0x55555555
  WRITE_REG(*(volatile uint32_t*)(addr + (uint32_t)testoffset), pattern);
2ffc93a2:	f04f 33aa 	mov.w	r3, #2863311530	@ 0xaaaaaaaa
  WRITE_REG(*(volatile uint32_t*)(addr + (uint32_t)testoffset), antipattern);
2ffc93a6:	f8c8 2000 	str.w	r2, [r8]
  WRITE_REG(*(volatile uint32_t*)(addr + (uint32_t)testoffset), pattern);
2ffc93aa:	f8c8 3000 	str.w	r3, [r8]
       ((testoffset & addressmask) != 0U)  && (testoffset != DDR_MEM_SIZE);
2ffc93ae:	e7ca      	b.n	2ffc9346 <DDR_Test_AddressBus+0x13e>
      printf("  test_addrbus KO @ 0x%lx \n\r", addr + (uint32_t)testoffset);
2ffc93b0:	f64e 30a4 	movw	r0, #60324	@ 0xeba4
2ffc93b4:	4671      	mov	r1, lr
2ffc93b6:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
      return 5;
2ffc93ba:	2505      	movs	r5, #5
      printf("  test_addrbus KO @ 0x%lx \n\r", addr + (uint32_t)testoffset);
2ffc93bc:	f002 fae4 	bl	2ffcb988 <iprintf>
      return 5;
2ffc93c0:	e7c1      	b.n	2ffc9346 <DDR_Test_AddressBus+0x13e>
      printf("Address too low: 0x%lx\n\r", addr_in);
2ffc93c2:	f64e 20dc 	movw	r0, #60124	@ 0xeadc
2ffc93c6:	4621      	mov	r1, r4
2ffc93c8:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc93cc:	f002 fadc 	bl	2ffcb988 <iprintf>
    return 3;
2ffc93d0:	2503      	movs	r5, #3
2ffc93d2:	e7b8      	b.n	2ffc9346 <DDR_Test_AddressBus+0x13e>
      printf("Unaligned address: 0x%lx\n\r", addr_in);
2ffc93d4:	f64e 20f8 	movw	r0, #60152	@ 0xeaf8
2ffc93d8:	4621      	mov	r1, r4
2ffc93da:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc93de:	f002 fad3 	bl	2ffcb988 <iprintf>
      return -1;
2ffc93e2:	e7f5      	b.n	2ffc93d0 <DDR_Test_AddressBus+0x1c8>

2ffc93e4 <DDR_Test_MemDevice>:
*  0: Test passed
*  Value different from 0: Test failed
*  None(0xFF): if the result is deduced by the user: waveform, event...
*/
uint32_t DDR_Test_MemDevice(uint32_t size_in, uint32_t addr_in)
{
2ffc93e4:	b570      	push	{r4, r5, r6, lr}
  uint64_t nb_words;
  uint32_t offset;
  uint32_t pattern;
  uint32_t antipattern;

  if (get_buf_size(size_in, &size, 4 * 1024, 4) != 0)
2ffc93e6:	2304      	movs	r3, #4
{
2ffc93e8:	b082      	sub	sp, #8
2ffc93ea:	460c      	mov	r4, r1
  if (get_buf_size(size_in, &size, 4 * 1024, 4) != 0)
2ffc93ec:	eb0d 0103 	add.w	r1, sp, r3
2ffc93f0:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
2ffc93f4:	f7ff fe06 	bl	2ffc9004 <get_buf_size>
2ffc93f8:	b110      	cbz	r0, 2ffc9400 <DDR_Test_MemDevice+0x1c>
  {
    return 1;
2ffc93fa:	2001      	movs	r0, #1
      return 4;
    }
  }

  return 0;
}
2ffc93fc:	b002      	add	sp, #8
2ffc93fe:	bd70      	pop	{r4, r5, r6, pc}
  if (addr_in != 0)
2ffc9400:	b344      	cbz	r4, 2ffc9454 <DDR_Test_MemDevice+0x70>
    if (addr_in < DDR_BASE_ADDR)
2ffc9402:	f1b4 4f40 	cmp.w	r4, #3221225472	@ 0xc0000000
2ffc9406:	d342      	bcc.n	2ffc948e <DDR_Test_MemDevice+0xaa>
    if ((addr_in & 0x3) != 0)
2ffc9408:	07a3      	lsls	r3, r4, #30
2ffc940a:	d149      	bne.n	2ffc94a0 <DDR_Test_MemDevice+0xbc>
  nb_words = size / sizeof(uint32_t);
2ffc940c:	9801      	ldr	r0, [sp, #4]
  for (pattern = 1, offset = 0; offset < nb_words;
2ffc940e:	0880      	lsrs	r0, r0, #2
2ffc9410:	bf1c      	itt	ne
2ffc9412:	2201      	movne	r2, #1
2ffc9414:	2300      	movne	r3, #0
2ffc9416:	d037      	beq.n	2ffc9488 <DDR_Test_MemDevice+0xa4>
    WRITE_REG(*(volatile uint32_t*)(addr + offset), pattern);
2ffc9418:	511a      	str	r2, [r3, r4]
       pattern++, offset += sizeof(uint32_t))
2ffc941a:	3304      	adds	r3, #4
  for (pattern = 1, offset = 0; offset < nb_words;
2ffc941c:	4298      	cmp	r0, r3
       pattern++, offset += sizeof(uint32_t))
2ffc941e:	f102 0201 	add.w	r2, r2, #1
  for (pattern = 1, offset = 0; offset < nb_words;
2ffc9422:	d8f9      	bhi.n	2ffc9418 <DDR_Test_MemDevice+0x34>
2ffc9424:	4621      	mov	r1, r4
  for (pattern = 1, offset = 0; offset < nb_words;
2ffc9426:	2301      	movs	r3, #1
2ffc9428:	2200      	movs	r2, #0
2ffc942a:	e003      	b.n	2ffc9434 <DDR_Test_MemDevice+0x50>
2ffc942c:	4290      	cmp	r0, r2
    WRITE_REG(*(volatile uint32_t*)(addr + offset), antipattern);
2ffc942e:	f841 6b04 	str.w	r6, [r1], #4
  for (pattern = 1, offset = 0; offset < nb_words;
2ffc9432:	d912      	bls.n	2ffc945a <DDR_Test_MemDevice+0x76>
    if (READ_REG(*(volatile uint32_t*)(addr + offset)) != pattern)
2ffc9434:	680d      	ldr	r5, [r1, #0]
       pattern++, offset += sizeof(uint32_t))
2ffc9436:	3204      	adds	r2, #4
2ffc9438:	43de      	mvns	r6, r3
    if (READ_REG(*(volatile uint32_t*)(addr + offset)) != pattern)
2ffc943a:	429d      	cmp	r5, r3
       pattern++, offset += sizeof(uint32_t))
2ffc943c:	f103 0301 	add.w	r3, r3, #1
    if (READ_REG(*(volatile uint32_t*)(addr + offset)) != pattern)
2ffc9440:	d0f4      	beq.n	2ffc942c <DDR_Test_MemDevice+0x48>
      printf("  test_memdevice KO @ 0x%lx \n\r", addr + offset);
2ffc9442:	f64e 30c4 	movw	r0, #60356	@ 0xebc4
2ffc9446:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc944a:	f002 fa9d 	bl	2ffcb988 <iprintf>
      return 3;
2ffc944e:	2003      	movs	r0, #3
}
2ffc9450:	b002      	add	sp, #8
2ffc9452:	bd70      	pop	{r4, r5, r6, pc}
    *addr = DDR_BASE_ADDR;
2ffc9454:	f04f 4440 	mov.w	r4, #3221225472	@ 0xc0000000
2ffc9458:	e7d8      	b.n	2ffc940c <DDR_Test_MemDevice+0x28>
2ffc945a:	f06f 0301 	mvn.w	r3, #1
  for (pattern = 1, offset = 0; offset < nb_words;
2ffc945e:	2200      	movs	r2, #0
2ffc9460:	e003      	b.n	2ffc946a <DDR_Test_MemDevice+0x86>
2ffc9462:	4290      	cmp	r0, r2
2ffc9464:	f104 0404 	add.w	r4, r4, #4
2ffc9468:	d90e      	bls.n	2ffc9488 <DDR_Test_MemDevice+0xa4>
    if (READ_REG(*(volatile uint32_t*)(addr + offset)) != antipattern)
2ffc946a:	6821      	ldr	r1, [r4, #0]
       pattern++, offset += sizeof(uint32_t))
2ffc946c:	3204      	adds	r2, #4
    if (READ_REG(*(volatile uint32_t*)(addr + offset)) != antipattern)
2ffc946e:	4299      	cmp	r1, r3
  for (pattern = 1, offset = 0; offset < nb_words;
2ffc9470:	f103 33ff 	add.w	r3, r3, #4294967295	@ 0xffffffff
    if (READ_REG(*(volatile uint32_t*)(addr + offset)) != antipattern)
2ffc9474:	d0f5      	beq.n	2ffc9462 <DDR_Test_MemDevice+0x7e>
      printf("  test_memdevice KO @ 0x%lx \n\r", addr + offset);
2ffc9476:	f64e 30c4 	movw	r0, #60356	@ 0xebc4
2ffc947a:	4621      	mov	r1, r4
2ffc947c:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9480:	f002 fa82 	bl	2ffcb988 <iprintf>
      return 4;
2ffc9484:	2004      	movs	r0, #4
2ffc9486:	e7b9      	b.n	2ffc93fc <DDR_Test_MemDevice+0x18>
  return 0;
2ffc9488:	2000      	movs	r0, #0
}
2ffc948a:	b002      	add	sp, #8
2ffc948c:	bd70      	pop	{r4, r5, r6, pc}
      printf("Address too low: 0x%lx\n\r", addr_in);
2ffc948e:	f64e 20dc 	movw	r0, #60124	@ 0xeadc
2ffc9492:	4621      	mov	r1, r4
2ffc9494:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9498:	f002 fa76 	bl	2ffcb988 <iprintf>
    return 2;
2ffc949c:	2002      	movs	r0, #2
2ffc949e:	e7ad      	b.n	2ffc93fc <DDR_Test_MemDevice+0x18>
      printf("Unaligned address: 0x%lx\n\r", addr_in);
2ffc94a0:	f64e 20f8 	movw	r0, #60152	@ 0xeaf8
2ffc94a4:	4621      	mov	r1, r4
2ffc94a6:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc94aa:	f002 fa6d 	bl	2ffcb988 <iprintf>
      return -1;
2ffc94ae:	e7f5      	b.n	2ffc949c <DDR_Test_MemDevice+0xb8>

2ffc94b0 <DDR_Test_SimultaneousSwitchingOutput>:
*  Value different from 0: Test failed
*  None(0xFF): if the result is deduced by the user: waveform, event...
*/
uint32_t DDR_Test_SimultaneousSwitchingOutput(uint32_t size_in,
                                                  uint32_t addr_in)
{
2ffc94b0:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t size;
  uint32_t remaining;
  uint32_t offset;
  uint32_t data = 0;

  if (get_buf_size(size_in, &size, 4 * 1024, 4) != 0)
2ffc94b2:	2304      	movs	r3, #4
{
2ffc94b4:	b083      	sub	sp, #12
2ffc94b6:	460d      	mov	r5, r1
  if (get_buf_size(size_in, &size, 4 * 1024, 4) != 0)
2ffc94b8:	eb0d 0103 	add.w	r1, sp, r3
2ffc94bc:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
2ffc94c0:	f7ff fda0 	bl	2ffc9004 <get_buf_size>
2ffc94c4:	b110      	cbz	r0, 2ffc94cc <DDR_Test_SimultaneousSwitchingOutput+0x1c>
  {
    return 1;
2ffc94c6:	2001      	movs	r0, #1
    offset += sizeof(uint32_t);
    remaining -= sizeof(uint32_t);
  }

  return 0;
}
2ffc94c8:	b003      	add	sp, #12
2ffc94ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (addr_in != 0)
2ffc94cc:	2d00      	cmp	r5, #0
2ffc94ce:	d03d      	beq.n	2ffc954c <DDR_Test_SimultaneousSwitchingOutput+0x9c>
    if (addr_in < DDR_BASE_ADDR)
2ffc94d0:	f1b5 4f40 	cmp.w	r5, #3221225472	@ 0xc0000000
2ffc94d4:	d33d      	bcc.n	2ffc9552 <DDR_Test_SimultaneousSwitchingOutput+0xa2>
    if ((addr_in & 0x3) != 0)
2ffc94d6:	07ab      	lsls	r3, r5, #30
2ffc94d8:	d144      	bne.n	2ffc9564 <DDR_Test_SimultaneousSwitchingOutput+0xb4>
  remaining = size;
2ffc94da:	f8dd e004 	ldr.w	lr, [sp, #4]
  while (remaining) {
2ffc94de:	4629      	mov	r1, r5
            data = ~(1 << i);
2ffc94e0:	f04f 0c01 	mov.w	ip, #1
        WRITE_REG(*(volatile uint32_t*)offset, data);
2ffc94e4:	f04f 36ff 	mov.w	r6, #4294967295	@ 0xffffffff
2ffc94e8:	2700      	movs	r7, #0
  while (remaining) {
2ffc94ea:	f1be 0f00 	cmp.w	lr, #0
2ffc94ee:	d022      	beq.n	2ffc9536 <DDR_Test_SimultaneousSwitchingOutput+0x86>
    for (i = 0; i < 32; i++) {
2ffc94f0:	2000      	movs	r0, #0
            data = ~(1 << i);
2ffc94f2:	fa0c f300 	lsl.w	r3, ip, r0
        WRITE_REG(*(volatile uint32_t*)offset, data);
2ffc94f6:	3001      	adds	r0, #1
2ffc94f8:	600b      	str	r3, [r1, #0]
        if (READ_REG(*(volatile uint32_t*)offset) != data)
2ffc94fa:	680c      	ldr	r4, [r1, #0]
            data = ~(1 << i);
2ffc94fc:	43da      	mvns	r2, r3
        if (READ_REG(*(volatile uint32_t*)offset) != data)
2ffc94fe:	429c      	cmp	r4, r3
2ffc9500:	d11b      	bne.n	2ffc953a <DDR_Test_SimultaneousSwitchingOutput+0x8a>
        WRITE_REG(*(volatile uint32_t*)offset, data);
2ffc9502:	600e      	str	r6, [r1, #0]
        if (READ_REG(*(volatile uint32_t*)offset) != data)
2ffc9504:	680b      	ldr	r3, [r1, #0]
2ffc9506:	3301      	adds	r3, #1
2ffc9508:	d117      	bne.n	2ffc953a <DDR_Test_SimultaneousSwitchingOutput+0x8a>
        WRITE_REG(*(volatile uint32_t*)offset, data);
2ffc950a:	600c      	str	r4, [r1, #0]
        if (READ_REG(*(volatile uint32_t*)offset) != data)
2ffc950c:	680b      	ldr	r3, [r1, #0]
2ffc950e:	429c      	cmp	r4, r3
2ffc9510:	d113      	bne.n	2ffc953a <DDR_Test_SimultaneousSwitchingOutput+0x8a>
        WRITE_REG(*(volatile uint32_t*)offset, data);
2ffc9512:	600a      	str	r2, [r1, #0]
        if (READ_REG(*(volatile uint32_t*)offset) != data)
2ffc9514:	680b      	ldr	r3, [r1, #0]
2ffc9516:	429a      	cmp	r2, r3
2ffc9518:	d10f      	bne.n	2ffc953a <DDR_Test_SimultaneousSwitchingOutput+0x8a>
        WRITE_REG(*(volatile uint32_t*)offset, data);
2ffc951a:	600f      	str	r7, [r1, #0]
        if (READ_REG(*(volatile uint32_t*)offset) != data)
2ffc951c:	680b      	ldr	r3, [r1, #0]
2ffc951e:	b963      	cbnz	r3, 2ffc953a <DDR_Test_SimultaneousSwitchingOutput+0x8a>
        WRITE_REG(*(volatile uint32_t*)offset, data);
2ffc9520:	600a      	str	r2, [r1, #0]
        if (READ_REG(*(volatile uint32_t*)offset) != data)
2ffc9522:	680b      	ldr	r3, [r1, #0]
2ffc9524:	4293      	cmp	r3, r2
2ffc9526:	d108      	bne.n	2ffc953a <DDR_Test_SimultaneousSwitchingOutput+0x8a>
    for (i = 0; i < 32; i++) {
2ffc9528:	2820      	cmp	r0, #32
2ffc952a:	d1e2      	bne.n	2ffc94f2 <DDR_Test_SimultaneousSwitchingOutput+0x42>
  while (remaining) {
2ffc952c:	eb0e 0305 	add.w	r3, lr, r5
    offset += sizeof(uint32_t);
2ffc9530:	3104      	adds	r1, #4
  while (remaining) {
2ffc9532:	4299      	cmp	r1, r3
2ffc9534:	d1dc      	bne.n	2ffc94f0 <DDR_Test_SimultaneousSwitchingOutput+0x40>
  return 0;
2ffc9536:	2000      	movs	r0, #0
2ffc9538:	e7c6      	b.n	2ffc94c8 <DDR_Test_SimultaneousSwitchingOutput+0x18>
          printf("  test_sso KO @ 0x%lx \n\r", offset);
2ffc953a:	f64e 30e4 	movw	r0, #60388	@ 0xebe4
2ffc953e:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9542:	f002 fa21 	bl	2ffcb988 <iprintf>
          return 3;
2ffc9546:	2003      	movs	r0, #3
}
2ffc9548:	b003      	add	sp, #12
2ffc954a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    *addr = DDR_BASE_ADDR;
2ffc954c:	f04f 4540 	mov.w	r5, #3221225472	@ 0xc0000000
2ffc9550:	e7c3      	b.n	2ffc94da <DDR_Test_SimultaneousSwitchingOutput+0x2a>
      printf("Address too low: 0x%lx\n\r", addr_in);
2ffc9552:	f64e 20dc 	movw	r0, #60124	@ 0xeadc
2ffc9556:	4629      	mov	r1, r5
2ffc9558:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc955c:	f002 fa14 	bl	2ffcb988 <iprintf>
    return 2;
2ffc9560:	2002      	movs	r0, #2
2ffc9562:	e7b1      	b.n	2ffc94c8 <DDR_Test_SimultaneousSwitchingOutput+0x18>
      printf("Unaligned address: 0x%lx\n\r", addr_in);
2ffc9564:	f64e 20f8 	movw	r0, #60152	@ 0xeaf8
2ffc9568:	4629      	mov	r1, r5
2ffc956a:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc956e:	f002 fa0b 	bl	2ffcb988 <iprintf>
      return -1;
2ffc9572:	e7f5      	b.n	2ffc9560 <DDR_Test_SimultaneousSwitchingOutput+0xb0>

2ffc9574 <DDR_Test_Noise>:
*/
uint32_t DDR_Test_Noise(uint32_t pattern_in, uint32_t addr_in)
{
  uint32_t pattern;
  uint32_t addr;
  uint32_t result[8] = {0,0,0,0,0,0,0,0};
2ffc9574:	efc0 0050 	vmov.i32	q8, #0	@ 0x00000000
{
2ffc9578:	e92d 4800 	stmdb	sp!, {fp, lr}
2ffc957c:	b088      	sub	sp, #32
  uint32_t result[8] = {0,0,0,0,0,0,0,0};
2ffc957e:	46ec      	mov	ip, sp
    *pattern = default_pattern;
2ffc9580:	1e03      	subs	r3, r0, #0
2ffc9582:	bf08      	it	eq
2ffc9584:	f04f 33ff 	moveq.w	r3, #4294967295	@ 0xffffffff
  uint32_t result[8] = {0,0,0,0,0,0,0,0};
2ffc9588:	f94c 0a1f 	vst1.8	{d16-d17}, [ip :64]
2ffc958c:	edcc 0b04 	vstr	d16, [ip, #16]
2ffc9590:	edcc 0b06 	vstr	d16, [ip, #24]
  if (addr_in != 0)
2ffc9594:	b169      	cbz	r1, 2ffc95b2 <DDR_Test_Noise+0x3e>
    if (addr_in < DDR_BASE_ADDR)
2ffc9596:	f1b1 4f40 	cmp.w	r1, #3221225472	@ 0xc0000000
2ffc959a:	460a      	mov	r2, r1
2ffc959c:	d355      	bcc.n	2ffc964a <DDR_Test_Noise+0xd6>
    if ((addr_in & 0x3) != 0)
2ffc959e:	0788      	lsls	r0, r1, #30
2ffc95a0:	d009      	beq.n	2ffc95b6 <DDR_Test_Noise+0x42>
      printf("Unaligned address: 0x%lx\n\r", addr_in);
2ffc95a2:	f64e 20f8 	movw	r0, #60152	@ 0xeaf8
2ffc95a6:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc95aa:	f002 f9ed 	bl	2ffcb988 <iprintf>

  get_pattern(pattern_in, &pattern, 0xFFFFFFFF);

  if (get_addr(addr_in, &addr) != 0)
  {
    return 1;
2ffc95ae:	2001      	movs	r0, #1
2ffc95b0:	e036      	b.n	2ffc9620 <DDR_Test_Noise+0xac>
    *addr = DDR_BASE_ADDR;
2ffc95b2:	f04f 4240 	mov.w	r2, #3221225472	@ 0xc0000000
  __asm volatile ("PUSH {r2-r10}         \n"
2ffc95b6:	e92d 07fc 	stmdb	sp!, {r2, r3, r4, r5, r6, r7, r8, r9, sl}
2ffc95ba:	4610      	mov	r0, r2
2ffc95bc:	4619      	mov	r1, r3
2ffc95be:	46e3      	mov	fp, ip
2ffc95c0:	ea6f 0201 	mvn.w	r2, r1
2ffc95c4:	6001      	str	r1, [r0, #0]
2ffc95c6:	6803      	ldr	r3, [r0, #0]
2ffc95c8:	6002      	str	r2, [r0, #0]
2ffc95ca:	6804      	ldr	r4, [r0, #0]
2ffc95cc:	6001      	str	r1, [r0, #0]
2ffc95ce:	6805      	ldr	r5, [r0, #0]
2ffc95d0:	6002      	str	r2, [r0, #0]
2ffc95d2:	6806      	ldr	r6, [r0, #0]
2ffc95d4:	6001      	str	r1, [r0, #0]
2ffc95d6:	6807      	ldr	r7, [r0, #0]
2ffc95d8:	6002      	str	r2, [r0, #0]
2ffc95da:	f8d0 8000 	ldr.w	r8, [r0]
2ffc95de:	6001      	str	r1, [r0, #0]
2ffc95e0:	f8d0 9000 	ldr.w	r9, [r0]
2ffc95e4:	6002      	str	r2, [r0, #0]
2ffc95e6:	f8d0 a000 	ldr.w	sl, [r0]
2ffc95ea:	e8ab 07f8 	stmia.w	fp!, {r3, r4, r5, r6, r7, r8, r9, sl}
2ffc95ee:	e8bd 07fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, r9, sl}
    {
      printf("  test_noise KO @ 0x%lx \n\r", result[i - 1]);
      return 2;
    }

    if (READ_REG(*(volatile uint32_t*)(&result[i++])) != ~pattern)
2ffc95f2:	ea6f 0c03 	mvn.w	ip, r3
  for (i = 0; i < 8;)
2ffc95f6:	2200      	movs	r2, #0
    if (READ_REG(*(volatile uint32_t*)(&result[i++])) != pattern)
2ffc95f8:	a908      	add	r1, sp, #32
    if (READ_REG(*(volatile uint32_t*)(&result[i++])) != ~pattern)
2ffc95fa:	f10d 0e20 	add.w	lr, sp, #32
    if (READ_REG(*(volatile uint32_t*)(&result[i++])) != pattern)
2ffc95fe:	eb01 0082 	add.w	r0, r1, r2, lsl #2
2ffc9602:	1c51      	adds	r1, r2, #1
    if (READ_REG(*(volatile uint32_t*)(&result[i++])) != ~pattern)
2ffc9604:	3202      	adds	r2, #2
    if (READ_REG(*(volatile uint32_t*)(&result[i++])) != pattern)
2ffc9606:	f850 0c20 	ldr.w	r0, [r0, #-32]
    if (READ_REG(*(volatile uint32_t*)(&result[i++])) != ~pattern)
2ffc960a:	eb0e 0181 	add.w	r1, lr, r1, lsl #2
    if (READ_REG(*(volatile uint32_t*)(&result[i++])) != pattern)
2ffc960e:	4298      	cmp	r0, r3
2ffc9610:	d109      	bne.n	2ffc9626 <DDR_Test_Noise+0xb2>
    if (READ_REG(*(volatile uint32_t*)(&result[i++])) != ~pattern)
2ffc9612:	f851 1c20 	ldr.w	r1, [r1, #-32]
2ffc9616:	4561      	cmp	r1, ip
2ffc9618:	d10e      	bne.n	2ffc9638 <DDR_Test_Noise+0xc4>
  for (i = 0; i < 8;)
2ffc961a:	2a08      	cmp	r2, #8
2ffc961c:	d1ec      	bne.n	2ffc95f8 <DDR_Test_Noise+0x84>
      printf("  test_noise KO @ 0x%lx \n\r", result[i - 1]);
      return 3;
    }
  }

  return 0;
2ffc961e:	2000      	movs	r0, #0
}
2ffc9620:	b008      	add	sp, #32
2ffc9622:	e8bd 8800 	ldmia.w	sp!, {fp, pc}
      printf("  test_noise KO @ 0x%lx \n\r", result[i - 1]);
2ffc9626:	f64e 4000 	movw	r0, #60416	@ 0xec00
2ffc962a:	2100      	movs	r1, #0
2ffc962c:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9630:	f002 f9aa 	bl	2ffcb988 <iprintf>
      return 2;
2ffc9634:	2002      	movs	r0, #2
2ffc9636:	e7f3      	b.n	2ffc9620 <DDR_Test_Noise+0xac>
      printf("  test_noise KO @ 0x%lx \n\r", result[i - 1]);
2ffc9638:	f64e 4000 	movw	r0, #60416	@ 0xec00
2ffc963c:	2100      	movs	r1, #0
2ffc963e:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9642:	f002 f9a1 	bl	2ffcb988 <iprintf>
      return 3;
2ffc9646:	2003      	movs	r0, #3
2ffc9648:	e7ea      	b.n	2ffc9620 <DDR_Test_Noise+0xac>
      printf("Address too low: 0x%lx\n\r", addr_in);
2ffc964a:	f64e 20dc 	movw	r0, #60124	@ 0xeadc
2ffc964e:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9652:	f002 f999 	bl	2ffcb988 <iprintf>
      return -1;
2ffc9656:	e7aa      	b.n	2ffc95ae <DDR_Test_Noise+0x3a>

2ffc9658 <DDR_Test_NoiseBurst>:
*  Value different from 0: Test failed
*  None(0xFF): if the result is deduced by the user: waveform, event...
*/
uint32_t DDR_Test_NoiseBurst(uint32_t size_in, uint32_t pattern_in,
                                 uint32_t addr_in)
{
2ffc9658:	e92d 4270 	stmdb	sp!, {r4, r5, r6, r9, lr}
2ffc965c:	b083      	sub	sp, #12
2ffc965e:	4614      	mov	r4, r2
  uint32_t bufsize;
  size_t remaining;
  size_t size;
  int i;

  if (get_buf_size(size_in, &bufsize, 4 * 1024, 128) != 0)
2ffc9660:	2380      	movs	r3, #128	@ 0x80
2ffc9662:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
{
2ffc9666:	460d      	mov	r5, r1
  if (get_buf_size(size_in, &bufsize, 4 * 1024, 128) != 0)
2ffc9668:	a901      	add	r1, sp, #4
2ffc966a:	f7ff fccb 	bl	2ffc9004 <get_buf_size>
  {
    return 1;
2ffc966e:	f04f 0c01 	mov.w	ip, #1
  if (get_buf_size(size_in, &bufsize, 4 * 1024, 128) != 0)
2ffc9672:	2800      	cmp	r0, #0
2ffc9674:	d14a      	bne.n	2ffc970c <loop1+0x58>
    *pattern = default_pattern;
2ffc9676:	2d00      	cmp	r5, #0
2ffc9678:	bf08      	it	eq
2ffc967a:	f04f 35ff 	moveq.w	r5, #4294967295	@ 0xffffffff
  if (addr_in != 0)
2ffc967e:	2c00      	cmp	r4, #0
2ffc9680:	d148      	bne.n	2ffc9714 <loop1+0x60>
    *addr = DDR_BASE_ADDR;
2ffc9682:	f04f 4440 	mov.w	r4, #3221225472	@ 0xc0000000
  {
    return 2;
  }

  offset = addr;
  remaining = (size_t)bufsize;
2ffc9686:	9e01      	ldr	r6, [sp, #4]
2ffc9688:	46b4      	mov	ip, r6
  size = DDR_CHUNK_SIZE;

  while (remaining)
2ffc968a:	2e00      	cmp	r6, #0
2ffc968c:	d03e      	beq.n	2ffc970c <loop1+0x58>
2ffc968e:	4622      	mov	r2, r4
  size = DDR_CHUNK_SIZE;
2ffc9690:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
  {
    if (remaining < size)
2ffc9694:	4563      	cmp	r3, ip
2ffc9696:	bf28      	it	cs
2ffc9698:	4663      	movcs	r3, ip
  __asm volatile ("PUSH {r2-r8}          \n"
2ffc969a:	e92d 01fc 	stmdb	sp!, {r2, r3, r4, r5, r6, r7, r8}
2ffc969e:	4610      	mov	r0, r2
2ffc96a0:	4629      	mov	r1, r5
2ffc96a2:	4699      	mov	r9, r3
2ffc96a4:	ea6f 0201 	mvn.w	r2, r1
2ffc96a8:	460b      	mov	r3, r1
2ffc96aa:	4614      	mov	r4, r2
2ffc96ac:	460d      	mov	r5, r1
2ffc96ae:	4616      	mov	r6, r2
2ffc96b0:	460f      	mov	r7, r1
2ffc96b2:	4690      	mov	r8, r2

2ffc96b4 <loop1>:
2ffc96b4:	e8a0 01fe 	stmia.w	r0!, {r1, r2, r3, r4, r5, r6, r7, r8}
2ffc96b8:	e8a0 01fe 	stmia.w	r0!, {r1, r2, r3, r4, r5, r6, r7, r8}
2ffc96bc:	e8a0 01fe 	stmia.w	r0!, {r1, r2, r3, r4, r5, r6, r7, r8}
2ffc96c0:	e8a0 01fe 	stmia.w	r0!, {r1, r2, r3, r4, r5, r6, r7, r8}
2ffc96c4:	f1b9 0980 	subs.w	r9, r9, #128	@ 0x80
2ffc96c8:	daf4      	bge.n	2ffc96b4 <loop1>
2ffc96ca:	e8bd 01fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8}
  while (remaining)
2ffc96ce:	ebbc 0c03 	subs.w	ip, ip, r3
      size = remaining;
    }

    do_noiseburst(offset, pattern, size);
    remaining -= size;
    offset += size;
2ffc96d2:	441a      	add	r2, r3
  while (remaining)
2ffc96d4:	d1de      	bne.n	2ffc9694 <DDR_Test_NoiseBurst+0x3c>
  }

  for (i = 0; i < bufsize;)
2ffc96d6:	f06f 0003 	mvn.w	r0, #3
2ffc96da:	1d21      	adds	r1, r4, #4
      return 3;
    }

    i += sizeof(uint32_t);

    if (READ_REG(*(volatile uint32_t*)(addr + i)) != ~pattern)
2ffc96dc:	ea6f 0e05 	mvn.w	lr, r5
  for (i = 0; i < bufsize;)
2ffc96e0:	1b00      	subs	r0, r0, r4
2ffc96e2:	e007      	b.n	2ffc96f4 <loop1+0x40>
    if (READ_REG(*(volatile uint32_t*)(addr + i)) != ~pattern)
2ffc96e4:	680b      	ldr	r3, [r1, #0]
  for (i = 0; i < bufsize;)
2ffc96e6:	3408      	adds	r4, #8
    if (READ_REG(*(volatile uint32_t*)(addr + i)) != ~pattern)
2ffc96e8:	4573      	cmp	r3, lr
2ffc96ea:	d122      	bne.n	2ffc9732 <loop1+0x7e>
  for (i = 0; i < bufsize;)
2ffc96ec:	3108      	adds	r1, #8
2ffc96ee:	1843      	adds	r3, r0, r1
2ffc96f0:	42b3      	cmp	r3, r6
2ffc96f2:	d20b      	bcs.n	2ffc970c <loop1+0x58>
    if (READ_REG(*(volatile uint32_t*)(addr + i)) != pattern)
2ffc96f4:	6823      	ldr	r3, [r4, #0]
2ffc96f6:	42ab      	cmp	r3, r5
2ffc96f8:	d0f4      	beq.n	2ffc96e4 <loop1+0x30>
      printf("  test_noiseburst KO @ 0x%lx\n\r", addr + i);
2ffc96fa:	f64e 401c 	movw	r0, #60444	@ 0xec1c
2ffc96fe:	4621      	mov	r1, r4
2ffc9700:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9704:	f002 f940 	bl	2ffcb988 <iprintf>
      return 3;
2ffc9708:	f04f 0c03 	mov.w	ip, #3

    i += sizeof(uint32_t);
  }

  return 0;
}
2ffc970c:	4660      	mov	r0, ip
2ffc970e:	b003      	add	sp, #12
2ffc9710:	e8bd 8270 	ldmia.w	sp!, {r4, r5, r6, r9, pc}
    if (addr_in < DDR_BASE_ADDR)
2ffc9714:	f1b4 4f40 	cmp.w	r4, #3221225472	@ 0xc0000000
2ffc9718:	d317      	bcc.n	2ffc974a <loop1+0x96>
    if ((addr_in & 0x3) != 0)
2ffc971a:	07a3      	lsls	r3, r4, #30
2ffc971c:	d0b3      	beq.n	2ffc9686 <DDR_Test_NoiseBurst+0x2e>
      printf("Unaligned address: 0x%lx\n\r", addr_in);
2ffc971e:	f64e 20f8 	movw	r0, #60152	@ 0xeaf8
2ffc9722:	4621      	mov	r1, r4
2ffc9724:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9728:	f002 f92e 	bl	2ffcb988 <iprintf>
    return 2;
2ffc972c:	f04f 0c02 	mov.w	ip, #2
2ffc9730:	e7ec      	b.n	2ffc970c <loop1+0x58>
      printf("  test_noiseburst KO @ 0x%lx\n\r", addr + i);
2ffc9732:	f64e 401c 	movw	r0, #60444	@ 0xec1c
2ffc9736:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc973a:	f002 f925 	bl	2ffcb988 <iprintf>
      return 4;
2ffc973e:	f04f 0c04 	mov.w	ip, #4
}
2ffc9742:	4660      	mov	r0, ip
2ffc9744:	b003      	add	sp, #12
2ffc9746:	e8bd 8270 	ldmia.w	sp!, {r4, r5, r6, r9, pc}
      printf("Address too low: 0x%lx\n\r", addr_in);
2ffc974a:	f64e 20dc 	movw	r0, #60124	@ 0xeadc
2ffc974e:	4621      	mov	r1, r4
2ffc9750:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9754:	f002 f918 	bl	2ffcb988 <iprintf>
      return -1;
2ffc9758:	e7e8      	b.n	2ffc972c <loop1+0x78>
2ffc975a:	bf00      	nop

2ffc975c <DDR_Test_Random>:
*  Value different from 0: Test failed
*  None(0xFF): if the result is deduced by the user: waveform, event...
*/
uint32_t DDR_Test_Random(uint32_t size_in, uint32_t loop_in,
                                            uint32_t addr_in)
{
2ffc975c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
2ffc9760:	b087      	sub	sp, #28
2ffc9762:	4616      	mov	r6, r2
2ffc9764:	468b      	mov	fp, r1
  uint32_t loop = 0;
  uint32_t nb_loop;
  uint32_t bufsize;
  unsigned int seed;

  if (get_buf_size(size_in, &bufsize, 4 * 1024, 8) != 0)
2ffc9766:	2308      	movs	r3, #8
2ffc9768:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
2ffc976c:	a905      	add	r1, sp, #20
2ffc976e:	f7ff fc49 	bl	2ffc9004 <get_buf_size>
2ffc9772:	2800      	cmp	r0, #0
2ffc9774:	d16a      	bne.n	2ffc984c <DDR_Test_Random+0xf0>
  if (loop_in != 0)
2ffc9776:	f1bb 0f00 	cmp.w	fp, #0
2ffc977a:	d052      	beq.n	2ffc9822 <DDR_Test_Random+0xc6>
    if (loop_in == 0xFFFFFFFF)
2ffc977c:	f1bb 3fff 	cmp.w	fp, #4294967295	@ 0xffffffff
2ffc9780:	d068      	beq.n	2ffc9854 <DDR_Test_Random+0xf8>
  if (addr_in != 0)
2ffc9782:	2e00      	cmp	r6, #0
2ffc9784:	d051      	beq.n	2ffc982a <DDR_Test_Random+0xce>
    if (addr_in < DDR_BASE_ADDR)
2ffc9786:	f1b6 4f40 	cmp.w	r6, #3221225472	@ 0xc0000000
2ffc978a:	d373      	bcc.n	2ffc9874 <DDR_Test_Random+0x118>
    if ((addr_in & 0x3) != 0)
2ffc978c:	07b3      	lsls	r3, r6, #30
2ffc978e:	d168      	bne.n	2ffc9862 <DDR_Test_Random+0x106>
  if (get_addr(addr_in, &addr) != 0)
  {
    return 2;
  }

  bufsize /= 2;
2ffc9790:	9f05      	ldr	r7, [sp, #20]
2ffc9792:	f04f 0a01 	mov.w	sl, #1
2ffc9796:	f04f 0900 	mov.w	r9, #0
2ffc979a:	fa27 f50a 	lsr.w	r5, r7, sl

    memcpy((void *)(addr + bufsize), (void *)addr, bufsize);

    srand(seed);

    for (offset = 0; offset < (2 * bufsize); offset += sizeof(uint32_t))
2ffc979e:	f027 0701 	bic.w	r7, r7, #1
    memcpy((void *)(addr + bufsize), (void *)addr, bufsize);
2ffc97a2:	19ab      	adds	r3, r5, r6
  bufsize /= 2;
2ffc97a4:	9505      	str	r5, [sp, #20]
    memcpy((void *)(addr + bufsize), (void *)addr, bufsize);
2ffc97a6:	9303      	str	r3, [sp, #12]
    seed = rand();
2ffc97a8:	f001 fed0 	bl	2ffcb54c <rand>
2ffc97ac:	4680      	mov	r8, r0
    srand(seed);
2ffc97ae:	f001 fe9f 	bl	2ffcb4f0 <srand>
    for (offset = 0; offset < bufsize; offset += sizeof(uint32_t))
2ffc97b2:	2d00      	cmp	r5, #0
2ffc97b4:	d03c      	beq.n	2ffc9830 <DDR_Test_Random+0xd4>
2ffc97b6:	2400      	movs	r4, #0
      WRITE_REG(*(volatile uint32_t*)(addr + offset), rand());
2ffc97b8:	f001 fec8 	bl	2ffcb54c <rand>
2ffc97bc:	51a0      	str	r0, [r4, r6]
    for (offset = 0; offset < bufsize; offset += sizeof(uint32_t))
2ffc97be:	3404      	adds	r4, #4
2ffc97c0:	42a5      	cmp	r5, r4
2ffc97c2:	d8f9      	bhi.n	2ffc97b8 <DDR_Test_Random+0x5c>
    memcpy((void *)(addr + bufsize), (void *)addr, bufsize);
2ffc97c4:	9803      	ldr	r0, [sp, #12]
2ffc97c6:	462a      	mov	r2, r5
2ffc97c8:	4631      	mov	r1, r6
    for (offset = 0; offset < (2 * bufsize); offset += sizeof(uint32_t))
2ffc97ca:	2400      	movs	r4, #0
    memcpy((void *)(addr + bufsize), (void *)addr, bufsize);
2ffc97cc:	f002 fb0c 	bl	2ffcbde8 <memcpy>
    srand(seed);
2ffc97d0:	4640      	mov	r0, r8
2ffc97d2:	f001 fe8d 	bl	2ffcb4f0 <srand>
    for (offset = 0; offset < (2 * bufsize); offset += sizeof(uint32_t))
2ffc97d6:	e007      	b.n	2ffc97e8 <DDR_Test_Random+0x8c>
      if (offset == bufsize)
      {
        srand(seed);
      }

      value = rand();
2ffc97d8:	f001 feb8 	bl	2ffcb54c <rand>
      data = READ_REG(*(volatile uint32_t*)(addr + offset));
2ffc97dc:	5933      	ldr	r3, [r6, r4]
      if (data != value)
2ffc97de:	4298      	cmp	r0, r3
2ffc97e0:	d10c      	bne.n	2ffc97fc <DDR_Test_Random+0xa0>
    for (offset = 0; offset < (2 * bufsize); offset += sizeof(uint32_t))
2ffc97e2:	3404      	adds	r4, #4
2ffc97e4:	42bc      	cmp	r4, r7
2ffc97e6:	d226      	bcs.n	2ffc9836 <DDR_Test_Random+0xda>
      if (offset == bufsize)
2ffc97e8:	42a5      	cmp	r5, r4
2ffc97ea:	d1f5      	bne.n	2ffc97d8 <DDR_Test_Random+0x7c>
        srand(seed);
2ffc97ec:	4640      	mov	r0, r8
2ffc97ee:	f001 fe7f 	bl	2ffcb4f0 <srand>
      value = rand();
2ffc97f2:	f001 feab 	bl	2ffcb54c <rand>
      data = READ_REG(*(volatile uint32_t*)(addr + offset));
2ffc97f6:	5933      	ldr	r3, [r6, r4]
      if (data != value)
2ffc97f8:	4298      	cmp	r0, r3
2ffc97fa:	d0f2      	beq.n	2ffc97e2 <DDR_Test_Random+0x86>
      {
        error++;
        printf("  loop %ld: error @ 0x%lx: 0x%lx expected 0x%lx\n\r",
2ffc97fc:	9000      	str	r0, [sp, #0]
2ffc97fe:	f64e 403c 	movw	r0, #60476	@ 0xec3c
2ffc9802:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9806:	4622      	mov	r2, r4
2ffc9808:	4649      	mov	r1, r9
2ffc980a:	f002 f8bd 	bl	2ffcb988 <iprintf>
    }
  }

  if (error != 0U)
  {
    printf("  test_random KO\n\r");
2ffc980e:	f64e 4070 	movw	r0, #60528	@ 0xec70
2ffc9812:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9816:	f002 f8b7 	bl	2ffcb988 <iprintf>
    return 3;
2ffc981a:	2003      	movs	r0, #3
  }

  return 0;
}
2ffc981c:	b007      	add	sp, #28
2ffc981e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    *nb_loop = default_nb_loop;
2ffc9822:	f04f 0b0a 	mov.w	fp, #10
  if (addr_in != 0)
2ffc9826:	2e00      	cmp	r6, #0
2ffc9828:	d1ad      	bne.n	2ffc9786 <DDR_Test_Random+0x2a>
    *addr = DDR_BASE_ADDR;
2ffc982a:	f04f 4640 	mov.w	r6, #3221225472	@ 0xc0000000
2ffc982e:	e7af      	b.n	2ffc9790 <DDR_Test_Random+0x34>
    srand(seed);
2ffc9830:	4640      	mov	r0, r8
2ffc9832:	f001 fe5d 	bl	2ffcb4f0 <srand>
  if (nb_loop && *loop >= nb_loop)
2ffc9836:	45da      	cmp	sl, fp
2ffc9838:	f10a 0301 	add.w	r3, sl, #1
2ffc983c:	46d1      	mov	r9, sl
2ffc983e:	d201      	bcs.n	2ffc9844 <DDR_Test_Random+0xe8>
2ffc9840:	469a      	mov	sl, r3
2ffc9842:	e7b1      	b.n	2ffc97a8 <DDR_Test_Random+0x4c>
  return 0;
2ffc9844:	2000      	movs	r0, #0
}
2ffc9846:	b007      	add	sp, #28
2ffc9848:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return 1;
2ffc984c:	2001      	movs	r0, #1
}
2ffc984e:	b007      	add	sp, #28
2ffc9850:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      printf("Warning: infinite loop requested\n\r");
2ffc9854:	f64e 20b8 	movw	r0, #60088	@ 0xeab8
2ffc9858:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc985c:	f002 f894 	bl	2ffcb988 <iprintf>
2ffc9860:	e78f      	b.n	2ffc9782 <DDR_Test_Random+0x26>
      printf("Unaligned address: 0x%lx\n\r", addr_in);
2ffc9862:	f64e 20f8 	movw	r0, #60152	@ 0xeaf8
2ffc9866:	4631      	mov	r1, r6
2ffc9868:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc986c:	f002 f88c 	bl	2ffcb988 <iprintf>
    return 2;
2ffc9870:	2002      	movs	r0, #2
2ffc9872:	e7d3      	b.n	2ffc981c <DDR_Test_Random+0xc0>
      printf("Address too low: 0x%lx\n\r", addr_in);
2ffc9874:	f64e 20dc 	movw	r0, #60124	@ 0xeadc
2ffc9878:	4631      	mov	r1, r6
2ffc987a:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc987e:	f002 f883 	bl	2ffcb988 <iprintf>
      return -1;
2ffc9882:	e7f5      	b.n	2ffc9870 <DDR_Test_Random+0x114>

2ffc9884 <DDR_Test_FrequencySelectivePattern>:
*  Value different from 0: Test failed
*  None(0xFF): if the result is deduced by the user: waveform, event...
*/
uint32_t DDR_Test_FrequencySelectivePattern(uint32_t size,
                                                uint32_t addr_in)
{
2ffc9884:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  const uint32_t * const patterns_x16[DDR_NB_PATTERN] = {
2ffc9888:	f64e 545c 	movw	r4, #60764	@ 0xed5c
2ffc988c:	f6c2 74fc 	movt	r4, #12284	@ 0x2ffc
{
2ffc9890:	b08d      	sub	sp, #52	@ 0x34
2ffc9892:	4686      	mov	lr, r0
  const uint32_t * const patterns_x16[DDR_NB_PATTERN] = {
2ffc9894:	ae02      	add	r6, sp, #8
{
2ffc9896:	460d      	mov	r5, r1
  const uint32_t * const patterns_x16[DDR_NB_PATTERN] = {
2ffc9898:	46b4      	mov	ip, r6
2ffc989a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    pattern_div2_x16,
    pattern_div4_x16,
    pattern_mostly_zero_x16,
    pattern_mostly_one_x16,
  };
  const uint32_t * const patterns_x32[DDR_NB_PATTERN] = {
2ffc989c:	f10d 081c 	add.w	r8, sp, #28
  const uint32_t * const patterns_x16[DDR_NB_PATTERN] = {
2ffc98a0:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
  const uint32_t * const patterns_x32[DDR_NB_PATTERN] = {
2ffc98a4:	4647      	mov	r7, r8
  const uint32_t * const patterns_x16[DDR_NB_PATTERN] = {
2ffc98a6:	f854 3b04 	ldr.w	r3, [r4], #4
2ffc98aa:	f8cc 3000 	str.w	r3, [ip]
  const uint32_t * const patterns_x32[DDR_NB_PATTERN] = {
2ffc98ae:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
2ffc98b0:	c70f      	stmia	r7!, {r0, r1, r2, r3}
  int ret = 0;
  const uint32_t **patterns;
  uint32_t bufsize;
  uint32_t addr;

  if (get_buf_size(size, &bufsize, 4 * 1024, 128) != 0)
2ffc98b2:	4670      	mov	r0, lr
  const uint32_t * const patterns_x32[DDR_NB_PATTERN] = {
2ffc98b4:	6823      	ldr	r3, [r4, #0]
  if (get_buf_size(size, &bufsize, 4 * 1024, 128) != 0)
2ffc98b6:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
2ffc98ba:	a901      	add	r1, sp, #4
  {
    return 1;
2ffc98bc:	2401      	movs	r4, #1
  const uint32_t * const patterns_x32[DDR_NB_PATTERN] = {
2ffc98be:	603b      	str	r3, [r7, #0]
  if (get_buf_size(size, &bufsize, 4 * 1024, 128) != 0)
2ffc98c0:	2380      	movs	r3, #128	@ 0x80
2ffc98c2:	f7ff fb9f 	bl	2ffc9004 <get_buf_size>
2ffc98c6:	b118      	cbz	r0, 2ffc98d0 <DDR_Test_FrequencySelectivePattern+0x4c>
      return 3;
    }
  }

  return 0;
}
2ffc98c8:	4620      	mov	r0, r4
2ffc98ca:	b00d      	add	sp, #52	@ 0x34
2ffc98cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (addr_in != 0)
2ffc98d0:	2d00      	cmp	r5, #0
2ffc98d2:	d069      	beq.n	2ffc99a8 <loop2+0x78>
    if (addr_in < DDR_BASE_ADDR)
2ffc98d4:	f1b5 4f40 	cmp.w	r5, #3221225472	@ 0xc0000000
2ffc98d8:	d36c      	bcc.n	2ffc99b4 <loop2+0x84>
    if ((addr_in & 0x3) != 0)
2ffc98da:	07ab      	lsls	r3, r5, #30
2ffc98dc:	d173      	bne.n	2ffc99c6 <loop2+0x96>
    ret = test_loop(patterns[i], (uint32_t *)addr, bufsize);
2ffc98de:	462f      	mov	r7, r5
2ffc98e0:	9c01      	ldr	r4, [sp, #4]
  switch (READ_REG(DDRCTRL->MSTR) & DDRCTRL_MSTR_DATA_BUS_WIDTH_Msk)
2ffc98e2:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
2ffc98e6:	f6c5 2300 	movt	r3, #23040	@ 0x5a00
2ffc98ea:	681b      	ldr	r3, [r3, #0]
2ffc98ec:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
2ffc98f0:	f5a3 5380 	sub.w	r3, r3, #4096	@ 0x1000
2ffc98f4:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
2ffc98f8:	2b00      	cmp	r3, #0
2ffc98fa:	bf18      	it	ne
2ffc98fc:	4646      	movne	r6, r8
  for (i = 0; i < DDR_NB_PATTERN; i++)
2ffc98fe:	f1a6 0e04 	sub.w	lr, r6, #4
2ffc9902:	f106 0b10 	add.w	fp, r6, #16
    ret = test_loop(patterns[i], (uint32_t *)addr, bufsize);
2ffc9906:	f10e 0e04 	add.w	lr, lr, #4
  while (remaining)
2ffc990a:	2c00      	cmp	r4, #0
2ffc990c:	d049      	beq.n	2ffc99a2 <loop2+0x72>
    ret = test_loop(patterns[i], (uint32_t *)addr, bufsize);
2ffc990e:	f8de a000 	ldr.w	sl, [lr]
    testsize = bufsize > 0x1000000 ? 0x1000000 : bufsize;
2ffc9912:	f1b4 7f80 	cmp.w	r4, #16777216	@ 0x1000000
2ffc9916:	46a4      	mov	ip, r4
2ffc9918:	bf28      	it	cs
2ffc991a:	f04f 7c80 	movcs.w	ip, #16777216	@ 0x1000000
  remaining = bufsize;
2ffc991e:	4623      	mov	r3, r4
    testsize = bufsize > 0x1000000 ? 0x1000000 : bufsize;
2ffc9920:	46a8      	mov	r8, r5
    __asm volatile ("PUSH {r3-r10}          \n"
2ffc9922:	e92d 07f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl}
2ffc9926:	4650      	mov	r0, sl
2ffc9928:	4641      	mov	r1, r8
2ffc992a:	4662      	mov	r2, ip
2ffc992c:	e8b0 07f8 	ldmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl}

2ffc9930 <loop2>:
2ffc9930:	e8a1 07f8 	stmia.w	r1!, {r3, r4, r5, r6, r7, r8, r9, sl}
2ffc9934:	e8a1 07f8 	stmia.w	r1!, {r3, r4, r5, r6, r7, r8, r9, sl}
2ffc9938:	e8a1 07f8 	stmia.w	r1!, {r3, r4, r5, r6, r7, r8, r9, sl}
2ffc993c:	e8a1 07f8 	stmia.w	r1!, {r3, r4, r5, r6, r7, r8, r9, sl}
2ffc9940:	3a80      	subs	r2, #128	@ 0x80
2ffc9942:	daf5      	bge.n	2ffc9930 <loop2>
2ffc9944:	e8bd 07f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl}
  while (remaining)
2ffc9948:	ebb3 030c 	subs.w	r3, r3, ip
    offset += testsize;
2ffc994c:	44e0      	add	r8, ip
  while (remaining)
2ffc994e:	d1e8      	bne.n	2ffc9922 <DDR_Test_FrequencySelectivePattern+0x9e>
2ffc9950:	4618      	mov	r0, r3
2ffc9952:	f1aa 0a04 	sub.w	sl, sl, #4
2ffc9956:	463b      	mov	r3, r7
    for (j = 0; j < DDR_PATTERN_SIZE; j++, address++)
2ffc9958:	4652      	mov	r2, sl
2ffc995a:	f103 0920 	add.w	r9, r3, #32
      if (READ_REG(*(volatile uint32_t*)address) != pattern[j])
2ffc995e:	681e      	ldr	r6, [r3, #0]
2ffc9960:	f852 1f04 	ldr.w	r1, [r2, #4]!
2ffc9964:	428e      	cmp	r6, r1
2ffc9966:	d10a      	bne.n	2ffc997e <loop2+0x4e>
    for (j = 0; j < DDR_PATTERN_SIZE; j++, address++)
2ffc9968:	3304      	adds	r3, #4
2ffc996a:	4599      	cmp	r9, r3
2ffc996c:	d1f7      	bne.n	2ffc995e <loop2+0x2e>
  for (i = 0; i < bufsize; i += DDR_PATTERN_SIZE * sizeof(uint32_t))
2ffc996e:	3020      	adds	r0, #32
2ffc9970:	4284      	cmp	r4, r0
2ffc9972:	d8f1      	bhi.n	2ffc9958 <loop2+0x28>
  for (i = 0; i < DDR_NB_PATTERN; i++)
2ffc9974:	45de      	cmp	lr, fp
2ffc9976:	d01b      	beq.n	2ffc99b0 <loop2+0x80>
    ret = test_loop(patterns[i], (uint32_t *)addr, bufsize);
2ffc9978:	f85e af04 	ldr.w	sl, [lr, #4]!
  while (remaining)
2ffc997c:	e7cf      	b.n	2ffc991e <DDR_Test_FrequencySelectivePattern+0x9a>
        printf("  test_freqpattern KO @ 0x%lx\n\r", *address);
2ffc997e:	6819      	ldr	r1, [r3, #0]
2ffc9980:	f64e 4084 	movw	r0, #60548	@ 0xec84
2ffc9984:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
      return 3;
2ffc9988:	2403      	movs	r4, #3
        printf("  test_freqpattern KO @ 0x%lx\n\r", *address);
2ffc998a:	f001 fffd 	bl	2ffcb988 <iprintf>
      printf("  test_freqpattern KO\n\r");
2ffc998e:	f64e 40a4 	movw	r0, #60580	@ 0xeca4
2ffc9992:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9996:	f001 fff7 	bl	2ffcb988 <iprintf>
}
2ffc999a:	4620      	mov	r0, r4
2ffc999c:	b00d      	add	sp, #52	@ 0x34
2ffc999e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  for (i = 0; i < DDR_NB_PATTERN; i++)
2ffc99a2:	45f3      	cmp	fp, lr
2ffc99a4:	d1af      	bne.n	2ffc9906 <DDR_Test_FrequencySelectivePattern+0x82>
2ffc99a6:	e78f      	b.n	2ffc98c8 <DDR_Test_FrequencySelectivePattern+0x44>
2ffc99a8:	f04f 4740 	mov.w	r7, #3221225472	@ 0xc0000000
    *addr = DDR_BASE_ADDR;
2ffc99ac:	463d      	mov	r5, r7
2ffc99ae:	e797      	b.n	2ffc98e0 <DDR_Test_FrequencySelectivePattern+0x5c>
  return 0;
2ffc99b0:	2400      	movs	r4, #0
2ffc99b2:	e789      	b.n	2ffc98c8 <DDR_Test_FrequencySelectivePattern+0x44>
      printf("Address too low: 0x%lx\n\r", addr_in);
2ffc99b4:	f64e 20dc 	movw	r0, #60124	@ 0xeadc
2ffc99b8:	4629      	mov	r1, r5
2ffc99ba:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc99be:	f001 ffe3 	bl	2ffcb988 <iprintf>
    return 2;
2ffc99c2:	2402      	movs	r4, #2
2ffc99c4:	e780      	b.n	2ffc98c8 <DDR_Test_FrequencySelectivePattern+0x44>
      printf("Unaligned address: 0x%lx\n\r", addr_in);
2ffc99c6:	f64e 20f8 	movw	r0, #60152	@ 0xeaf8
2ffc99ca:	4629      	mov	r1, r5
2ffc99cc:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc99d0:	f001 ffda 	bl	2ffcb988 <iprintf>
      return -1;
2ffc99d4:	e7f5      	b.n	2ffc99c2 <loop2+0x92>
2ffc99d6:	bf00      	nop

2ffc99d8 <DDR_Test_BlockSequential>:
*  Value different from 0: Test failed
*  None(0xFF): if the result is deduced by the user: waveform, event...
*/
uint32_t DDR_Test_BlockSequential(uint32_t size, uint32_t loop_in,
                                      uint32_t addr_in)
{
2ffc99d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t addr;
  uint32_t value;
  int i;
  int ret;

  if (get_buf_size(size, &bufsize, 4 * 1024, 4) != 0)
2ffc99dc:	2304      	movs	r3, #4
{
2ffc99de:	b082      	sub	sp, #8
2ffc99e0:	4614      	mov	r4, r2
2ffc99e2:	460d      	mov	r5, r1
  if (get_buf_size(size, &bufsize, 4 * 1024, 4) != 0)
2ffc99e4:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
2ffc99e8:	eb0d 0103 	add.w	r1, sp, r3
2ffc99ec:	f7ff fb0a 	bl	2ffc9004 <get_buf_size>
2ffc99f0:	2800      	cmp	r0, #0
2ffc99f2:	d150      	bne.n	2ffc9a96 <DDR_Test_BlockSequential+0xbe>
  if (loop_in != 0)
2ffc99f4:	b3c5      	cbz	r5, 2ffc9a68 <DDR_Test_BlockSequential+0x90>
    if (loop_in == 0xFFFFFFFF)
2ffc99f6:	1c6a      	adds	r2, r5, #1
2ffc99f8:	d051      	beq.n	2ffc9a9e <DDR_Test_BlockSequential+0xc6>
  if (addr_in != 0)
2ffc99fa:	b3c4      	cbz	r4, 2ffc9a6e <DDR_Test_BlockSequential+0x96>
    if (addr_in < DDR_BASE_ADDR)
2ffc99fc:	f1b4 4f40 	cmp.w	r4, #3221225472	@ 0xc0000000
2ffc9a00:	d354      	bcc.n	2ffc9aac <DDR_Test_BlockSequential+0xd4>
    if ((addr_in & 0x3) != 0)
2ffc9a02:	07a3      	lsls	r3, r4, #30
2ffc9a04:	d15b      	bne.n	2ffc9abe <DDR_Test_BlockSequential+0xe6>
  while (1)
  {
    for (i = 0; i < 256; i++)
    {
      value = i | i << 8 | i << 16 | i << 24;
      ret = test_loop_size(&value, 1, (uint32_t *)addr, bufsize);
2ffc9a06:	4620      	mov	r0, r4
2ffc9a08:	f8dd c004 	ldr.w	ip, [sp, #4]
    for (i = 0; i < 256; i++)
2ffc9a0c:	f44f 7680 	mov.w	r6, #256	@ 0x100
2ffc9a10:	f2c0 0601 	movt	r6, #1
  uint32_t loop = 0;
2ffc9a14:	f04f 0800 	mov.w	r8, #0
2ffc9a18:	1f07      	subs	r7, r0, #4
2ffc9a1a:	f04f 0e00 	mov.w	lr, #0
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9a1e:	f1bc 0f00 	cmp.w	ip, #0
2ffc9a22:	d027      	beq.n	2ffc9a74 <DDR_Test_BlockSequential+0x9c>
2ffc9a24:	4674      	mov	r4, lr
2ffc9a26:	463a      	mov	r2, r7
      *p = pattern[j];
2ffc9a28:	4613      	mov	r3, r2
2ffc9a2a:	f842 4f04 	str.w	r4, [r2, #4]!
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9a2e:	3308      	adds	r3, #8
2ffc9a30:	1a1b      	subs	r3, r3, r0
2ffc9a32:	4563      	cmp	r3, ip
2ffc9a34:	d3f8      	bcc.n	2ffc9a28 <DDR_Test_BlockSequential+0x50>
  for (i = 0; i < bufsize; i += size * sizeof(uint32_t))
2ffc9a36:	2300      	movs	r3, #0
2ffc9a38:	e001      	b.n	2ffc9a3e <DDR_Test_BlockSequential+0x66>
2ffc9a3a:	459c      	cmp	ip, r3
2ffc9a3c:	d924      	bls.n	2ffc9a88 <DDR_Test_BlockSequential+0xb0>
      if (READ_REG(*(volatile uint32_t*)p) != pattern[j])
2ffc9a3e:	58c2      	ldr	r2, [r0, r3]
2ffc9a40:	18c1      	adds	r1, r0, r3
  for (i = 0; i < bufsize; i += size * sizeof(uint32_t))
2ffc9a42:	3304      	adds	r3, #4
      if (READ_REG(*(volatile uint32_t*)p) != pattern[j])
2ffc9a44:	4294      	cmp	r4, r2
2ffc9a46:	d0f8      	beq.n	2ffc9a3a <DDR_Test_BlockSequential+0x62>
        printf("  test KO @ 0x%ln\n\r", p);
2ffc9a48:	f64e 40bc 	movw	r0, #60604	@ 0xecbc
2ffc9a4c:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9a50:	f001 ff9a 	bl	2ffcb988 <iprintf>
      if (ret != 0)
      {
        printf("  test_blockseq KO\n\r");
2ffc9a54:	f64e 40d0 	movw	r0, #60624	@ 0xecd0
2ffc9a58:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9a5c:	f001 ff94 	bl	2ffcb988 <iprintf>
        return 3;
2ffc9a60:	2003      	movs	r0, #3
      break;
    }
  }

  return 0;
}
2ffc9a62:	b002      	add	sp, #8
2ffc9a64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    *nb_loop = default_nb_loop;
2ffc9a68:	2501      	movs	r5, #1
  if (addr_in != 0)
2ffc9a6a:	2c00      	cmp	r4, #0
2ffc9a6c:	d1c6      	bne.n	2ffc99fc <DDR_Test_BlockSequential+0x24>
2ffc9a6e:	f04f 4040 	mov.w	r0, #3221225472	@ 0xc0000000
2ffc9a72:	e7c9      	b.n	2ffc9a08 <DDR_Test_BlockSequential+0x30>
    for (i = 0; i < 256; i++)
2ffc9a74:	f20e 1e01 	addw	lr, lr, #257	@ 0x101
2ffc9a78:	45b6      	cmp	lr, r6
2ffc9a7a:	d1fb      	bne.n	2ffc9a74 <DDR_Test_BlockSequential+0x9c>
  (*loop)++;
2ffc9a7c:	f108 0801 	add.w	r8, r8, #1
  if (nb_loop && *loop >= nb_loop)
2ffc9a80:	45a8      	cmp	r8, r5
2ffc9a82:	d1ca      	bne.n	2ffc9a1a <DDR_Test_BlockSequential+0x42>
  return 0;
2ffc9a84:	2000      	movs	r0, #0
2ffc9a86:	e7ec      	b.n	2ffc9a62 <DDR_Test_BlockSequential+0x8a>
    for (i = 0; i < 256; i++)
2ffc9a88:	f20e 1e01 	addw	lr, lr, #257	@ 0x101
2ffc9a8c:	45b6      	cmp	lr, r6
2ffc9a8e:	d0f5      	beq.n	2ffc9a7c <DDR_Test_BlockSequential+0xa4>
      value = i | i << 8 | i << 16 | i << 24;
2ffc9a90:	ea4e 440e 	orr.w	r4, lr, lr, lsl #16
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9a94:	e7c7      	b.n	2ffc9a26 <DDR_Test_BlockSequential+0x4e>
    return 1;
2ffc9a96:	2001      	movs	r0, #1
}
2ffc9a98:	b002      	add	sp, #8
2ffc9a9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      printf("Warning: infinite loop requested\n\r");
2ffc9a9e:	f64e 20b8 	movw	r0, #60088	@ 0xeab8
2ffc9aa2:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9aa6:	f001 ff6f 	bl	2ffcb988 <iprintf>
2ffc9aaa:	e7a6      	b.n	2ffc99fa <DDR_Test_BlockSequential+0x22>
      printf("Address too low: 0x%lx\n\r", addr_in);
2ffc9aac:	f64e 20dc 	movw	r0, #60124	@ 0xeadc
2ffc9ab0:	4621      	mov	r1, r4
2ffc9ab2:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9ab6:	f001 ff67 	bl	2ffcb988 <iprintf>
    return 2;
2ffc9aba:	2002      	movs	r0, #2
2ffc9abc:	e7d1      	b.n	2ffc9a62 <DDR_Test_BlockSequential+0x8a>
      printf("Unaligned address: 0x%lx\n\r", addr_in);
2ffc9abe:	f64e 20f8 	movw	r0, #60152	@ 0xeaf8
2ffc9ac2:	4621      	mov	r1, r4
2ffc9ac4:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9ac8:	f001 ff5e 	bl	2ffcb988 <iprintf>
      return -1;
2ffc9acc:	e7f5      	b.n	2ffc9aba <DDR_Test_BlockSequential+0xe2>
2ffc9ace:	bf00      	nop

2ffc9ad0 <DDR_Test_Checkerboard>:
*  Value different from 0: Test failed
*  None(0xFF): if the result is deduced by the user: waveform, event...
*/
uint32_t DDR_Test_Checkerboard(uint32_t size, uint32_t loop_in,
                                   uint32_t addr_in)
{
2ffc9ad0:	b5f0      	push	{r4, r5, r6, r7, lr}
2ffc9ad2:	b083      	sub	sp, #12
2ffc9ad4:	4614      	mov	r4, r2
2ffc9ad6:	460d      	mov	r5, r1
  uint32_t addr;
  uint32_t checkboard[2] = {0x55555555, 0xAAAAAAAA};
  int i;
  int ret;

  if (get_buf_size(size, &bufsize, 4 * 1024, 8) != 0)
2ffc9ad8:	2308      	movs	r3, #8
2ffc9ada:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
2ffc9ade:	a901      	add	r1, sp, #4
2ffc9ae0:	f7ff fa90 	bl	2ffc9004 <get_buf_size>
2ffc9ae4:	2800      	cmp	r0, #0
2ffc9ae6:	d14b      	bne.n	2ffc9b80 <DDR_Test_Checkerboard+0xb0>
  if (loop_in != 0)
2ffc9ae8:	b3c5      	cbz	r5, 2ffc9b5c <DDR_Test_Checkerboard+0x8c>
    if (loop_in == 0xFFFFFFFF)
2ffc9aea:	1c6a      	adds	r2, r5, #1
2ffc9aec:	d04a      	beq.n	2ffc9b84 <DDR_Test_Checkerboard+0xb4>
  if (addr_in != 0)
2ffc9aee:	b3c4      	cbz	r4, 2ffc9b62 <DDR_Test_Checkerboard+0x92>
    if (addr_in < DDR_BASE_ADDR)
2ffc9af0:	f1b4 4f40 	cmp.w	r4, #3221225472	@ 0xc0000000
2ffc9af4:	d356      	bcc.n	2ffc9ba4 <DDR_Test_Checkerboard+0xd4>
    if ((addr_in & 0x3) != 0)
2ffc9af6:	07a3      	lsls	r3, r4, #30
2ffc9af8:	d14b      	bne.n	2ffc9b92 <DDR_Test_Checkerboard+0xc2>

  while (1)
  {
    for (i = 0; i < 2; i++)
    {
      ret = test_loop_size(checkboard, 2, (uint32_t *)addr, bufsize);
2ffc9afa:	4620      	mov	r0, r4
2ffc9afc:	eddf 0b2e 	vldr	d16, [pc, #184]	@ 2ffc9bb8 <DDR_Test_Checkerboard+0xe8>
2ffc9b00:	9c01      	ldr	r4, [sp, #4]
  uint32_t loop = 0;
2ffc9b02:	2700      	movs	r7, #0
    for (i = 0; i < 2; i++)
2ffc9b04:	2602      	movs	r6, #2
2ffc9b06:	ef20 71b0 	vorr	d7, d16, d16
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9b0a:	2300      	movs	r3, #0
      {
        printf("  test_checkboard KO\n\r");
        return 3;
      }

      checkboard[0] = ~checkboard[0];
2ffc9b0c:	fff0 05a0 	vmvn	d16, d16
2ffc9b10:	ee37 eb10 	vmov.32	lr, d7[1]
2ffc9b14:	ee17 ca10 	vmov	ip, s14
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9b18:	b334      	cbz	r4, 2ffc9b68 <DDR_Test_Checkerboard+0x98>
      *p = pattern[j];
2ffc9b1a:	18c2      	adds	r2, r0, r3
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9b1c:	3308      	adds	r3, #8
2ffc9b1e:	429c      	cmp	r4, r3
      *p = pattern[j];
2ffc9b20:	f902 778f 	vst1.32	{d7}, [r2]
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9b24:	d8f9      	bhi.n	2ffc9b1a <DDR_Test_Checkerboard+0x4a>
  for (i = 0; i < bufsize; i += size * sizeof(uint32_t))
2ffc9b26:	2300      	movs	r3, #0
2ffc9b28:	e004      	b.n	2ffc9b34 <DDR_Test_Checkerboard+0x64>
      if (READ_REG(*(volatile uint32_t*)p) != pattern[j])
2ffc9b2a:	684a      	ldr	r2, [r1, #4]
2ffc9b2c:	4572      	cmp	r2, lr
2ffc9b2e:	d125      	bne.n	2ffc9b7c <DDR_Test_Checkerboard+0xac>
  for (i = 0; i < bufsize; i += size * sizeof(uint32_t))
2ffc9b30:	429c      	cmp	r4, r3
2ffc9b32:	d919      	bls.n	2ffc9b68 <DDR_Test_Checkerboard+0x98>
      if (READ_REG(*(volatile uint32_t*)p) != pattern[j])
2ffc9b34:	58c2      	ldr	r2, [r0, r3]
2ffc9b36:	18c1      	adds	r1, r0, r3
  for (i = 0; i < bufsize; i += size * sizeof(uint32_t))
2ffc9b38:	3308      	adds	r3, #8
      if (READ_REG(*(volatile uint32_t*)p) != pattern[j])
2ffc9b3a:	4562      	cmp	r2, ip
2ffc9b3c:	d0f5      	beq.n	2ffc9b2a <DDR_Test_Checkerboard+0x5a>
        printf("  test KO @ 0x%ln\n\r", p);
2ffc9b3e:	f64e 40bc 	movw	r0, #60604	@ 0xecbc
2ffc9b42:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9b46:	f001 ff1f 	bl	2ffcb988 <iprintf>
        printf("  test_checkboard KO\n\r");
2ffc9b4a:	f64e 40e8 	movw	r0, #60648	@ 0xece8
2ffc9b4e:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9b52:	f001 ff19 	bl	2ffcb988 <iprintf>
        return 3;
2ffc9b56:	2003      	movs	r0, #3
      break;
    }
  }

  return 0;
}
2ffc9b58:	b003      	add	sp, #12
2ffc9b5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    *nb_loop = default_nb_loop;
2ffc9b5c:	2501      	movs	r5, #1
  if (addr_in != 0)
2ffc9b5e:	2c00      	cmp	r4, #0
2ffc9b60:	d1c6      	bne.n	2ffc9af0 <DDR_Test_Checkerboard+0x20>
2ffc9b62:	f04f 4040 	mov.w	r0, #3221225472	@ 0xc0000000
2ffc9b66:	e7c9      	b.n	2ffc9afc <DDR_Test_Checkerboard+0x2c>
    for (i = 0; i < 2; i++)
2ffc9b68:	2e01      	cmp	r6, #1
2ffc9b6a:	d001      	beq.n	2ffc9b70 <DDR_Test_Checkerboard+0xa0>
2ffc9b6c:	2601      	movs	r6, #1
2ffc9b6e:	e7ca      	b.n	2ffc9b06 <DDR_Test_Checkerboard+0x36>
  (*loop)++;
2ffc9b70:	3701      	adds	r7, #1
  if (nb_loop && *loop >= nb_loop)
2ffc9b72:	42af      	cmp	r7, r5
2ffc9b74:	d1c6      	bne.n	2ffc9b04 <DDR_Test_Checkerboard+0x34>
  return 0;
2ffc9b76:	2000      	movs	r0, #0
}
2ffc9b78:	b003      	add	sp, #12
2ffc9b7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (j = 0; j < size; j++, p++)
2ffc9b7c:	3104      	adds	r1, #4
2ffc9b7e:	e7de      	b.n	2ffc9b3e <DDR_Test_Checkerboard+0x6e>
    return 1;
2ffc9b80:	2001      	movs	r0, #1
2ffc9b82:	e7e9      	b.n	2ffc9b58 <DDR_Test_Checkerboard+0x88>
      printf("Warning: infinite loop requested\n\r");
2ffc9b84:	f64e 20b8 	movw	r0, #60088	@ 0xeab8
2ffc9b88:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9b8c:	f001 fefc 	bl	2ffcb988 <iprintf>
2ffc9b90:	e7ad      	b.n	2ffc9aee <DDR_Test_Checkerboard+0x1e>
      printf("Unaligned address: 0x%lx\n\r", addr_in);
2ffc9b92:	f64e 20f8 	movw	r0, #60152	@ 0xeaf8
2ffc9b96:	4621      	mov	r1, r4
2ffc9b98:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9b9c:	f001 fef4 	bl	2ffcb988 <iprintf>
    return 2;
2ffc9ba0:	2002      	movs	r0, #2
2ffc9ba2:	e7d9      	b.n	2ffc9b58 <DDR_Test_Checkerboard+0x88>
      printf("Address too low: 0x%lx\n\r", addr_in);
2ffc9ba4:	f64e 20dc 	movw	r0, #60124	@ 0xeadc
2ffc9ba8:	4621      	mov	r1, r4
2ffc9baa:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9bae:	f001 feeb 	bl	2ffcb988 <iprintf>
      return -1;
2ffc9bb2:	e7f5      	b.n	2ffc9ba0 <DDR_Test_Checkerboard+0xd0>
2ffc9bb4:	f3af 8000 	nop.w
2ffc9bb8:	55555555 	.word	0x55555555
2ffc9bbc:	aaaaaaaa 	.word	0xaaaaaaaa

2ffc9bc0 <DDR_Test_BitSpread>:
*  Value different from 0: Test failed
*  None(0xFF): if the result is deduced by the user: waveform, event...
*/
uint32_t DDR_Test_BitSpread(uint32_t size, uint32_t loop_in,
                                uint32_t addr_in)
{
2ffc9bc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
2ffc9bc4:	b08d      	sub	sp, #52	@ 0x34
2ffc9bc6:	4615      	mov	r5, r2
2ffc9bc8:	460c      	mov	r4, r1
  uint32_t bitspread[4];
  int i;
  int j;
  int ret;

  if (get_buf_size(size, &bufsize, 4 * 1024, 32) != 0)
2ffc9bca:	2320      	movs	r3, #32
2ffc9bcc:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
2ffc9bd0:	a907      	add	r1, sp, #28
2ffc9bd2:	f7ff fa17 	bl	2ffc9004 <get_buf_size>
2ffc9bd6:	2800      	cmp	r0, #0
2ffc9bd8:	d178      	bne.n	2ffc9ccc <DDR_Test_BitSpread+0x10c>
  if (loop_in != 0)
2ffc9bda:	2c00      	cmp	r4, #0
2ffc9bdc:	d05d      	beq.n	2ffc9c9a <DDR_Test_BitSpread+0xda>
    if (loop_in == 0xFFFFFFFF)
2ffc9bde:	1c62      	adds	r2, r4, #1
2ffc9be0:	d078      	beq.n	2ffc9cd4 <DDR_Test_BitSpread+0x114>
  if (addr_in != 0)
2ffc9be2:	2d00      	cmp	r5, #0
2ffc9be4:	d05c      	beq.n	2ffc9ca0 <DDR_Test_BitSpread+0xe0>
    if (addr_in < DDR_BASE_ADDR)
2ffc9be6:	f1b5 4f40 	cmp.w	r5, #3221225472	@ 0xc0000000
2ffc9bea:	f0c0 8083 	bcc.w	2ffc9cf4 <DDR_Test_BitSpread+0x134>
    if ((addr_in & 0x3) != 0)
2ffc9bee:	07ab      	lsls	r3, r5, #30
2ffc9bf0:	d177      	bne.n	2ffc9ce2 <DDR_Test_BitSpread+0x122>

        bitspread[1] = bitspread[0];
        bitspread[2] = ~bitspread[0];
        bitspread[3] = ~bitspread[0];

        ret = test_loop_size(bitspread, 4, (uint32_t *)addr, bufsize);
2ffc9bf2:	9f07      	ldr	r7, [sp, #28]
  uint32_t loop = 0;
2ffc9bf4:	f04f 0c00 	mov.w	ip, #0
    for (i = 1; i < 32; i++)
2ffc9bf8:	2601      	movs	r6, #1
2ffc9bfa:	46a6      	mov	lr, r4
2ffc9bfc:	2401      	movs	r4, #1
2ffc9bfe:	46e2      	mov	sl, ip
2ffc9c00:	46a4      	mov	ip, r4
          bitspread[0] = (1 << i) | (1 << j);
2ffc9c02:	fa06 f80c 	lsl.w	r8, r6, ip
      for (j = 0; j < i; j++)
2ffc9c06:	2400      	movs	r4, #0
2ffc9c08:	46a1      	mov	r9, r4
          bitspread[0] = (1 << i) | (1 << j);
2ffc9c0a:	fa06 f309 	lsl.w	r3, r6, r9
2ffc9c0e:	ea43 0308 	orr.w	r3, r3, r8
        bitspread[2] = ~bitspread[0];
2ffc9c12:	43da      	mvns	r2, r3
          bitspread[0] = (1 << i) | (1 << j);
2ffc9c14:	e9cd 3302 	strd	r3, r3, [sp, #8]
2ffc9c18:	e9cd 2204 	strd	r2, r2, [sp, #16]
2ffc9c1c:	eddd 0b02 	vldr	d16, [sp, #8]
2ffc9c20:	eddd 1b04 	vldr	d17, [sp, #16]
2ffc9c24:	edcd 0b08 	vstr	d16, [sp, #32]
2ffc9c28:	edcd 1b0a 	vstr	d17, [sp, #40]	@ 0x28
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9c2c:	2f00      	cmp	r7, #0
2ffc9c2e:	d03e      	beq.n	2ffc9cae <DDR_Test_BitSpread+0xee>
2ffc9c30:	f8cd 8004 	str.w	r8, [sp, #4]
2ffc9c34:	f04f 0b00 	mov.w	fp, #0
      *p = pattern[j];
2ffc9c38:	eb05 080b 	add.w	r8, r5, fp
2ffc9c3c:	ac08      	add	r4, sp, #32
2ffc9c3e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
2ffc9c40:	f845 000b 	str.w	r0, [r5, fp]
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9c44:	f10b 0b10 	add.w	fp, fp, #16
2ffc9c48:	455f      	cmp	r7, fp
      *p = pattern[j];
2ffc9c4a:	f8c8 1004 	str.w	r1, [r8, #4]
2ffc9c4e:	f8c8 2008 	str.w	r2, [r8, #8]
2ffc9c52:	f8c8 300c 	str.w	r3, [r8, #12]
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9c56:	d8ef      	bhi.n	2ffc9c38 <DDR_Test_BitSpread+0x78>
  p = address;
2ffc9c58:	f8dd 8004 	ldr.w	r8, [sp, #4]
2ffc9c5c:	4629      	mov	r1, r5
2ffc9c5e:	f04f 0b00 	mov.w	fp, #0
    for (j = 0; j < size; j++, p++)
2ffc9c62:	ab08      	add	r3, sp, #32
2ffc9c64:	f101 0410 	add.w	r4, r1, #16
2ffc9c68:	e002      	b.n	2ffc9c70 <DDR_Test_BitSpread+0xb0>
2ffc9c6a:	3104      	adds	r1, #4
2ffc9c6c:	42a1      	cmp	r1, r4
2ffc9c6e:	d01a      	beq.n	2ffc9ca6 <DDR_Test_BitSpread+0xe6>
      if (READ_REG(*(volatile uint32_t*)p) != pattern[j])
2ffc9c70:	6808      	ldr	r0, [r1, #0]
2ffc9c72:	f853 2b04 	ldr.w	r2, [r3], #4
2ffc9c76:	4290      	cmp	r0, r2
2ffc9c78:	d0f7      	beq.n	2ffc9c6a <DDR_Test_BitSpread+0xaa>
        printf("  test KO @ 0x%ln\n\r", p);
2ffc9c7a:	f64e 40bc 	movw	r0, #60604	@ 0xecbc
2ffc9c7e:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9c82:	f001 fe81 	bl	2ffcb988 <iprintf>
        if (ret != 0)
        {
          printf("  test_bitspread KO\n\r");
2ffc9c86:	f64e 5000 	movw	r0, #60672	@ 0xed00
2ffc9c8a:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9c8e:	f001 fe7b 	bl	2ffcb988 <iprintf>
          return 3;
2ffc9c92:	2003      	movs	r0, #3
      break;
    }
  }

  return 0;
}
2ffc9c94:	b00d      	add	sp, #52	@ 0x34
2ffc9c96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    *nb_loop = default_nb_loop;
2ffc9c9a:	2401      	movs	r4, #1
  if (addr_in != 0)
2ffc9c9c:	2d00      	cmp	r5, #0
2ffc9c9e:	d1a2      	bne.n	2ffc9be6 <DDR_Test_BitSpread+0x26>
2ffc9ca0:	f04f 4540 	mov.w	r5, #3221225472	@ 0xc0000000
2ffc9ca4:	e7a5      	b.n	2ffc9bf2 <DDR_Test_BitSpread+0x32>
  for (i = 0; i < bufsize; i += size * sizeof(uint32_t))
2ffc9ca6:	f10b 0b10 	add.w	fp, fp, #16
2ffc9caa:	455f      	cmp	r7, fp
2ffc9cac:	d8d9      	bhi.n	2ffc9c62 <DDR_Test_BitSpread+0xa2>
      for (j = 0; j < i; j++)
2ffc9cae:	f109 0901 	add.w	r9, r9, #1
2ffc9cb2:	45e1      	cmp	r9, ip
2ffc9cb4:	d1a9      	bne.n	2ffc9c0a <DDR_Test_BitSpread+0x4a>
    for (i = 1; i < 32; i++)
2ffc9cb6:	464c      	mov	r4, r9
2ffc9cb8:	f109 0c01 	add.w	ip, r9, #1
2ffc9cbc:	2c1f      	cmp	r4, #31
2ffc9cbe:	d1a0      	bne.n	2ffc9c02 <DDR_Test_BitSpread+0x42>
  (*loop)++;
2ffc9cc0:	f10a 0c01 	add.w	ip, sl, #1
  if (nb_loop && *loop >= nb_loop)
2ffc9cc4:	45f4      	cmp	ip, lr
2ffc9cc6:	d199      	bne.n	2ffc9bfc <DDR_Test_BitSpread+0x3c>
  return 0;
2ffc9cc8:	2000      	movs	r0, #0
2ffc9cca:	e7e3      	b.n	2ffc9c94 <DDR_Test_BitSpread+0xd4>
    return 1;
2ffc9ccc:	2001      	movs	r0, #1
}
2ffc9cce:	b00d      	add	sp, #52	@ 0x34
2ffc9cd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      printf("Warning: infinite loop requested\n\r");
2ffc9cd4:	f64e 20b8 	movw	r0, #60088	@ 0xeab8
2ffc9cd8:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9cdc:	f001 fe54 	bl	2ffcb988 <iprintf>
2ffc9ce0:	e77f      	b.n	2ffc9be2 <DDR_Test_BitSpread+0x22>
      printf("Unaligned address: 0x%lx\n\r", addr_in);
2ffc9ce2:	f64e 20f8 	movw	r0, #60152	@ 0xeaf8
2ffc9ce6:	4629      	mov	r1, r5
2ffc9ce8:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9cec:	f001 fe4c 	bl	2ffcb988 <iprintf>
    return 2;
2ffc9cf0:	2002      	movs	r0, #2
2ffc9cf2:	e7cf      	b.n	2ffc9c94 <DDR_Test_BitSpread+0xd4>
      printf("Address too low: 0x%lx\n\r", addr_in);
2ffc9cf4:	f64e 20dc 	movw	r0, #60124	@ 0xeadc
2ffc9cf8:	4629      	mov	r1, r5
2ffc9cfa:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9cfe:	f001 fe43 	bl	2ffcb988 <iprintf>
      return -1;
2ffc9d02:	e7f5      	b.n	2ffc9cf0 <DDR_Test_BitSpread+0x130>

2ffc9d04 <DDR_Test_BitFlip>:
*  Value different from 0: Test failed
*  None(0xFF): if the result is deduced by the user: waveform, event...
*/
uint32_t DDR_Test_BitFlip(uint32_t size, uint32_t loop_in,
                              uint32_t addr_in)
{
2ffc9d04:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
2ffc9d08:	b08a      	sub	sp, #40	@ 0x28
2ffc9d0a:	4614      	mov	r4, r2
2ffc9d0c:	460f      	mov	r7, r1
  uint32_t addr;
  uint32_t bitflip[4];
  int i;
  int ret;

  if (get_buf_size(size, &bufsize, 4 * 1024, 32) != 0)
2ffc9d0e:	2320      	movs	r3, #32
2ffc9d10:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
2ffc9d14:	a905      	add	r1, sp, #20
2ffc9d16:	f7ff f975 	bl	2ffc9004 <get_buf_size>
2ffc9d1a:	2800      	cmp	r0, #0
2ffc9d1c:	d165      	bne.n	2ffc9dea <DDR_Test_BitFlip+0xe6>
  if (loop_in != 0)
2ffc9d1e:	2f00      	cmp	r7, #0
2ffc9d20:	d050      	beq.n	2ffc9dc4 <DDR_Test_BitFlip+0xc0>
    if (loop_in == 0xFFFFFFFF)
2ffc9d22:	1c7a      	adds	r2, r7, #1
2ffc9d24:	d065      	beq.n	2ffc9df2 <DDR_Test_BitFlip+0xee>
  if (addr_in != 0)
2ffc9d26:	2c00      	cmp	r4, #0
2ffc9d28:	d04f      	beq.n	2ffc9dca <DDR_Test_BitFlip+0xc6>
    if (addr_in < DDR_BASE_ADDR)
2ffc9d2a:	f1b4 4f40 	cmp.w	r4, #3221225472	@ 0xc0000000
2ffc9d2e:	d370      	bcc.n	2ffc9e12 <DDR_Test_BitFlip+0x10e>
    if ((addr_in & 0x3) != 0)
2ffc9d30:	07a3      	lsls	r3, r4, #30
2ffc9d32:	d165      	bne.n	2ffc9e00 <DDR_Test_BitFlip+0xfc>
      bitflip[0] = 1 << i;
      bitflip[1] = bitflip[0];
      bitflip[2] = ~bitflip[0];
      bitflip[3] = bitflip[2];

      ret = test_loop_size(bitflip, 4, (uint32_t *)addr, bufsize);
2ffc9d34:	9d05      	ldr	r5, [sp, #20]
  uint32_t loop = 0;
2ffc9d36:	f04f 0900 	mov.w	r9, #0
      bitflip[0] = 1 << i;
2ffc9d3a:	f04f 0801 	mov.w	r8, #1
    for (i = 0; i < 32; i++)
2ffc9d3e:	2600      	movs	r6, #0
      bitflip[0] = 1 << i;
2ffc9d40:	fa08 f306 	lsl.w	r3, r8, r6
      bitflip[2] = ~bitflip[0];
2ffc9d44:	43da      	mvns	r2, r3
      bitflip[0] = 1 << i;
2ffc9d46:	e9cd 3300 	strd	r3, r3, [sp]
2ffc9d4a:	e9cd 2202 	strd	r2, r2, [sp, #8]
2ffc9d4e:	f96d 0adf 	vld1.64	{d16-d17}, [sp :64]
2ffc9d52:	edcd 0b06 	vstr	d16, [sp, #24]
2ffc9d56:	edcd 1b08 	vstr	d17, [sp, #32]
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9d5a:	2d00      	cmp	r5, #0
2ffc9d5c:	d03c      	beq.n	2ffc9dd8 <DDR_Test_BitFlip+0xd4>
2ffc9d5e:	f04f 0e00 	mov.w	lr, #0
      *p = pattern[j];
2ffc9d62:	eb04 0a0e 	add.w	sl, r4, lr
2ffc9d66:	f10d 0c18 	add.w	ip, sp, #24
2ffc9d6a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
2ffc9d6e:	f844 000e 	str.w	r0, [r4, lr]
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9d72:	f10e 0e10 	add.w	lr, lr, #16
2ffc9d76:	4575      	cmp	r5, lr
      *p = pattern[j];
2ffc9d78:	f8ca 1004 	str.w	r1, [sl, #4]
2ffc9d7c:	f8ca 2008 	str.w	r2, [sl, #8]
2ffc9d80:	f8ca 300c 	str.w	r3, [sl, #12]
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9d84:	d8ed      	bhi.n	2ffc9d62 <DDR_Test_BitFlip+0x5e>
  p = address;
2ffc9d86:	4621      	mov	r1, r4
2ffc9d88:	f04f 0e00 	mov.w	lr, #0
    for (j = 0; j < size; j++, p++)
2ffc9d8c:	ab06      	add	r3, sp, #24
2ffc9d8e:	f101 0c10 	add.w	ip, r1, #16
2ffc9d92:	e002      	b.n	2ffc9d9a <DDR_Test_BitFlip+0x96>
2ffc9d94:	3104      	adds	r1, #4
2ffc9d96:	4561      	cmp	r1, ip
2ffc9d98:	d01a      	beq.n	2ffc9dd0 <DDR_Test_BitFlip+0xcc>
      if (READ_REG(*(volatile uint32_t*)p) != pattern[j])
2ffc9d9a:	6808      	ldr	r0, [r1, #0]
2ffc9d9c:	f853 2b04 	ldr.w	r2, [r3], #4
2ffc9da0:	4290      	cmp	r0, r2
2ffc9da2:	d0f7      	beq.n	2ffc9d94 <DDR_Test_BitFlip+0x90>
        printf("  test KO @ 0x%ln\n\r", p);
2ffc9da4:	f64e 40bc 	movw	r0, #60604	@ 0xecbc
2ffc9da8:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9dac:	f001 fdec 	bl	2ffcb988 <iprintf>
      if (ret != 0)
      {
        printf("  test_bitflip KO\n\r");
2ffc9db0:	f64e 5018 	movw	r0, #60696	@ 0xed18
2ffc9db4:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9db8:	f001 fde6 	bl	2ffcb988 <iprintf>
        return 3;
2ffc9dbc:	2003      	movs	r0, #3
      break;
    }
  }

  return 0;
}
2ffc9dbe:	b00a      	add	sp, #40	@ 0x28
2ffc9dc0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    *nb_loop = default_nb_loop;
2ffc9dc4:	2701      	movs	r7, #1
  if (addr_in != 0)
2ffc9dc6:	2c00      	cmp	r4, #0
2ffc9dc8:	d1af      	bne.n	2ffc9d2a <DDR_Test_BitFlip+0x26>
2ffc9dca:	f04f 4440 	mov.w	r4, #3221225472	@ 0xc0000000
2ffc9dce:	e7b1      	b.n	2ffc9d34 <DDR_Test_BitFlip+0x30>
  for (i = 0; i < bufsize; i += size * sizeof(uint32_t))
2ffc9dd0:	f10e 0e10 	add.w	lr, lr, #16
2ffc9dd4:	4575      	cmp	r5, lr
2ffc9dd6:	d8d9      	bhi.n	2ffc9d8c <DDR_Test_BitFlip+0x88>
    for (i = 0; i < 32; i++)
2ffc9dd8:	3601      	adds	r6, #1
2ffc9dda:	2e20      	cmp	r6, #32
2ffc9ddc:	d1b0      	bne.n	2ffc9d40 <DDR_Test_BitFlip+0x3c>
  (*loop)++;
2ffc9dde:	f109 0901 	add.w	r9, r9, #1
  if (nb_loop && *loop >= nb_loop)
2ffc9de2:	45b9      	cmp	r9, r7
2ffc9de4:	d1ab      	bne.n	2ffc9d3e <DDR_Test_BitFlip+0x3a>
  return 0;
2ffc9de6:	2000      	movs	r0, #0
2ffc9de8:	e7e9      	b.n	2ffc9dbe <DDR_Test_BitFlip+0xba>
    return 1;
2ffc9dea:	2001      	movs	r0, #1
}
2ffc9dec:	b00a      	add	sp, #40	@ 0x28
2ffc9dee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      printf("Warning: infinite loop requested\n\r");
2ffc9df2:	f64e 20b8 	movw	r0, #60088	@ 0xeab8
2ffc9df6:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9dfa:	f001 fdc5 	bl	2ffcb988 <iprintf>
2ffc9dfe:	e792      	b.n	2ffc9d26 <DDR_Test_BitFlip+0x22>
      printf("Unaligned address: 0x%lx\n\r", addr_in);
2ffc9e00:	f64e 20f8 	movw	r0, #60152	@ 0xeaf8
2ffc9e04:	4621      	mov	r1, r4
2ffc9e06:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9e0a:	f001 fdbd 	bl	2ffcb988 <iprintf>
    return 2;
2ffc9e0e:	2002      	movs	r0, #2
2ffc9e10:	e7d5      	b.n	2ffc9dbe <DDR_Test_BitFlip+0xba>
      printf("Address too low: 0x%lx\n\r", addr_in);
2ffc9e12:	f64e 20dc 	movw	r0, #60124	@ 0xeadc
2ffc9e16:	4621      	mov	r1, r4
2ffc9e18:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9e1c:	f001 fdb4 	bl	2ffcb988 <iprintf>
      return -1;
2ffc9e20:	e7f5      	b.n	2ffc9e0e <DDR_Test_BitFlip+0x10a>
2ffc9e22:	bf00      	nop

2ffc9e24 <DDR_Test_WalkingZeroes>:
*  Value different from 0: Test failed
*  None(0xFF): if the result is deduced by the user: waveform, event...
*/
uint32_t DDR_Test_WalkingZeroes(uint32_t size, uint32_t loop_in,
                                    uint32_t addr_in)
{
2ffc9e24:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t addr;
  uint32_t value;
  int i;
  int ret;

  if (get_buf_size(size, &bufsize, 4 * 1024, 4) != 0)
2ffc9e26:	2304      	movs	r3, #4
{
2ffc9e28:	b083      	sub	sp, #12
2ffc9e2a:	4614      	mov	r4, r2
2ffc9e2c:	460d      	mov	r5, r1
  if (get_buf_size(size, &bufsize, 4 * 1024, 4) != 0)
2ffc9e2e:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
2ffc9e32:	eb0d 0103 	add.w	r1, sp, r3
2ffc9e36:	f7ff f8e5 	bl	2ffc9004 <get_buf_size>
2ffc9e3a:	2800      	cmp	r0, #0
2ffc9e3c:	d156      	bne.n	2ffc9eec <DDR_Test_WalkingZeroes+0xc8>
  if (loop_in != 0)
2ffc9e3e:	b3a5      	cbz	r5, 2ffc9eaa <DDR_Test_WalkingZeroes+0x86>
    if (loop_in == 0xFFFFFFFF)
2ffc9e40:	1c6a      	adds	r2, r5, #1
2ffc9e42:	d056      	beq.n	2ffc9ef2 <DDR_Test_WalkingZeroes+0xce>
  if (addr_in != 0)
2ffc9e44:	b3a4      	cbz	r4, 2ffc9eb0 <DDR_Test_WalkingZeroes+0x8c>
    if (addr_in < DDR_BASE_ADDR)
2ffc9e46:	f1b4 4f40 	cmp.w	r4, #3221225472	@ 0xc0000000
2ffc9e4a:	d359      	bcc.n	2ffc9f00 <DDR_Test_WalkingZeroes+0xdc>
    if ((addr_in & 0x3) != 0)
2ffc9e4c:	07a3      	lsls	r3, r4, #30
2ffc9e4e:	d160      	bne.n	2ffc9f12 <DDR_Test_WalkingZeroes+0xee>
      else
      {
        value = 1 << (63 - i);
      }

      ret = test_loop_size(&value, 1, (uint32_t *)addr, bufsize);
2ffc9e50:	4620      	mov	r0, r4
2ffc9e52:	9e01      	ldr	r6, [sp, #4]
  uint32_t loop = 0;
2ffc9e54:	2700      	movs	r7, #0
        value = 1 << i;
2ffc9e56:	f04f 0e01 	mov.w	lr, #1
    for (i = 0; i < 64; i++)
2ffc9e5a:	f04f 0c00 	mov.w	ip, #0
      if (i < 32)
2ffc9e5e:	f1bc 0f1f 	cmp.w	ip, #31
2ffc9e62:	dc32      	bgt.n	2ffc9eca <DDR_Test_WalkingZeroes+0xa6>
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9e64:	b33e      	cbz	r6, 2ffc9eb6 <DDR_Test_WalkingZeroes+0x92>
        value = 1 << i;
2ffc9e66:	fa0e f40c 	lsl.w	r4, lr, ip
2ffc9e6a:	1f02      	subs	r2, r0, #4
      *p = pattern[j];
2ffc9e6c:	4613      	mov	r3, r2
2ffc9e6e:	f842 4f04 	str.w	r4, [r2, #4]!
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9e72:	3308      	adds	r3, #8
2ffc9e74:	1a1b      	subs	r3, r3, r0
2ffc9e76:	429e      	cmp	r6, r3
2ffc9e78:	d8f8      	bhi.n	2ffc9e6c <DDR_Test_WalkingZeroes+0x48>
  for (i = 0; i < bufsize; i += size * sizeof(uint32_t))
2ffc9e7a:	2300      	movs	r3, #0
2ffc9e7c:	e001      	b.n	2ffc9e82 <DDR_Test_WalkingZeroes+0x5e>
2ffc9e7e:	429e      	cmp	r6, r3
2ffc9e80:	d92a      	bls.n	2ffc9ed8 <DDR_Test_WalkingZeroes+0xb4>
      if (READ_REG(*(volatile uint32_t*)p) != pattern[j])
2ffc9e82:	58c2      	ldr	r2, [r0, r3]
2ffc9e84:	18c1      	adds	r1, r0, r3
  for (i = 0; i < bufsize; i += size * sizeof(uint32_t))
2ffc9e86:	3304      	adds	r3, #4
      if (READ_REG(*(volatile uint32_t*)p) != pattern[j])
2ffc9e88:	42a2      	cmp	r2, r4
2ffc9e8a:	d0f8      	beq.n	2ffc9e7e <DDR_Test_WalkingZeroes+0x5a>
        printf("  test KO @ 0x%ln\n\r", p);
2ffc9e8c:	f64e 40bc 	movw	r0, #60604	@ 0xecbc
2ffc9e90:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9e94:	f001 fd78 	bl	2ffcb988 <iprintf>
      if (ret != 0)
      {
        printf("  test_walkbit0 KO\n\r");
2ffc9e98:	f64e 502c 	movw	r0, #60716	@ 0xed2c
2ffc9e9c:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9ea0:	f001 fd72 	bl	2ffcb988 <iprintf>
        return 3;
2ffc9ea4:	2003      	movs	r0, #3
      break;
    }
  }

  return 0;
}
2ffc9ea6:	b003      	add	sp, #12
2ffc9ea8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    *nb_loop = default_nb_loop;
2ffc9eaa:	2501      	movs	r5, #1
  if (addr_in != 0)
2ffc9eac:	2c00      	cmp	r4, #0
2ffc9eae:	d1ca      	bne.n	2ffc9e46 <DDR_Test_WalkingZeroes+0x22>
2ffc9eb0:	f04f 4040 	mov.w	r0, #3221225472	@ 0xc0000000
2ffc9eb4:	e7cd      	b.n	2ffc9e52 <DDR_Test_WalkingZeroes+0x2e>
    for (i = 0; i < 64; i++)
2ffc9eb6:	f10c 0c01 	add.w	ip, ip, #1
      if (i < 32)
2ffc9eba:	f1bc 0f20 	cmp.w	ip, #32
2ffc9ebe:	d1fa      	bne.n	2ffc9eb6 <DDR_Test_WalkingZeroes+0x92>
    for (i = 0; i < 64; i++)
2ffc9ec0:	f10c 0c01 	add.w	ip, ip, #1
2ffc9ec4:	f1bc 0f40 	cmp.w	ip, #64	@ 0x40
2ffc9ec8:	d00b      	beq.n	2ffc9ee2 <DDR_Test_WalkingZeroes+0xbe>
        value = 1 << (63 - i);
2ffc9eca:	f1cc 043f 	rsb	r4, ip, #63	@ 0x3f
2ffc9ece:	fa0e f404 	lsl.w	r4, lr, r4
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9ed2:	2e00      	cmp	r6, #0
2ffc9ed4:	d1c9      	bne.n	2ffc9e6a <DDR_Test_WalkingZeroes+0x46>
2ffc9ed6:	e7f3      	b.n	2ffc9ec0 <DDR_Test_WalkingZeroes+0x9c>
    for (i = 0; i < 64; i++)
2ffc9ed8:	f10c 0c01 	add.w	ip, ip, #1
2ffc9edc:	f1bc 0f40 	cmp.w	ip, #64	@ 0x40
2ffc9ee0:	d1bd      	bne.n	2ffc9e5e <DDR_Test_WalkingZeroes+0x3a>
  (*loop)++;
2ffc9ee2:	3701      	adds	r7, #1
  if (nb_loop && *loop >= nb_loop)
2ffc9ee4:	42af      	cmp	r7, r5
2ffc9ee6:	d1b8      	bne.n	2ffc9e5a <DDR_Test_WalkingZeroes+0x36>
  return 0;
2ffc9ee8:	2000      	movs	r0, #0
2ffc9eea:	e7dc      	b.n	2ffc9ea6 <DDR_Test_WalkingZeroes+0x82>
    return 1;
2ffc9eec:	2001      	movs	r0, #1
}
2ffc9eee:	b003      	add	sp, #12
2ffc9ef0:	bdf0      	pop	{r4, r5, r6, r7, pc}
      printf("Warning: infinite loop requested\n\r");
2ffc9ef2:	f64e 20b8 	movw	r0, #60088	@ 0xeab8
2ffc9ef6:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9efa:	f001 fd45 	bl	2ffcb988 <iprintf>
2ffc9efe:	e7a1      	b.n	2ffc9e44 <DDR_Test_WalkingZeroes+0x20>
      printf("Address too low: 0x%lx\n\r", addr_in);
2ffc9f00:	f64e 20dc 	movw	r0, #60124	@ 0xeadc
2ffc9f04:	4621      	mov	r1, r4
2ffc9f06:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9f0a:	f001 fd3d 	bl	2ffcb988 <iprintf>
    return 2;
2ffc9f0e:	2002      	movs	r0, #2
2ffc9f10:	e7c9      	b.n	2ffc9ea6 <DDR_Test_WalkingZeroes+0x82>
      printf("Unaligned address: 0x%lx\n\r", addr_in);
2ffc9f12:	f64e 20f8 	movw	r0, #60152	@ 0xeaf8
2ffc9f16:	4621      	mov	r1, r4
2ffc9f18:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9f1c:	f001 fd34 	bl	2ffcb988 <iprintf>
      return -1;
2ffc9f20:	e7f5      	b.n	2ffc9f0e <DDR_Test_WalkingZeroes+0xea>
2ffc9f22:	bf00      	nop

2ffc9f24 <DDR_Test_WalkingOnes>:
*  Value different from 0: Test failed
*  None(0xFF): if the result is deduced by the user: waveform, event...
*/
uint32_t DDR_Test_WalkingOnes(uint32_t size, uint32_t loop_in,
                                  uint32_t addr_in)
{
2ffc9f24:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t addr;
  uint32_t value;
  int i;
  int ret;

  if (get_buf_size(size, &bufsize, 4 * 1024, 4) != 0)
2ffc9f26:	2304      	movs	r3, #4
{
2ffc9f28:	b083      	sub	sp, #12
2ffc9f2a:	4614      	mov	r4, r2
2ffc9f2c:	460d      	mov	r5, r1
  if (get_buf_size(size, &bufsize, 4 * 1024, 4) != 0)
2ffc9f2e:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
2ffc9f32:	eb0d 0103 	add.w	r1, sp, r3
2ffc9f36:	f7ff f865 	bl	2ffc9004 <get_buf_size>
2ffc9f3a:	2800      	cmp	r0, #0
2ffc9f3c:	d150      	bne.n	2ffc9fe0 <DDR_Test_WalkingOnes+0xbc>
  if (loop_in != 0)
2ffc9f3e:	b3ad      	cbz	r5, 2ffc9fac <DDR_Test_WalkingOnes+0x88>
    if (loop_in == 0xFFFFFFFF)
2ffc9f40:	1c6a      	adds	r2, r5, #1
2ffc9f42:	d050      	beq.n	2ffc9fe6 <DDR_Test_WalkingOnes+0xc2>
  if (addr_in != 0)
2ffc9f44:	b3ac      	cbz	r4, 2ffc9fb2 <DDR_Test_WalkingOnes+0x8e>
    if (addr_in < DDR_BASE_ADDR)
2ffc9f46:	f1b4 4f40 	cmp.w	r4, #3221225472	@ 0xc0000000
2ffc9f4a:	d353      	bcc.n	2ffc9ff4 <DDR_Test_WalkingOnes+0xd0>
    if ((addr_in & 0x3) != 0)
2ffc9f4c:	07a3      	lsls	r3, r4, #30
2ffc9f4e:	d15a      	bne.n	2ffca006 <DDR_Test_WalkingOnes+0xe2>
      else
      {
        value = ~(1 << (63 - i));
      }

      ret = test_loop_size(&value, 1, (uint32_t *)addr, bufsize);
2ffc9f50:	4620      	mov	r0, r4
2ffc9f52:	9e01      	ldr	r6, [sp, #4]
  uint32_t loop = 0;
2ffc9f54:	2700      	movs	r7, #0
        value = ~(1 << (63 - i));
2ffc9f56:	f04f 0e01 	mov.w	lr, #1
    for (i = 0; i < 64; i++)
2ffc9f5a:	f04f 0c00 	mov.w	ip, #0
      if (i < 32)
2ffc9f5e:	f1bc 0f1f 	cmp.w	ip, #31
2ffc9f62:	dc29      	bgt.n	2ffc9fb8 <DDR_Test_WalkingOnes+0x94>
        value = ~(1 << i);
2ffc9f64:	fa0e f40c 	lsl.w	r4, lr, ip
2ffc9f68:	43e4      	mvns	r4, r4
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9f6a:	b3b6      	cbz	r6, 2ffc9fda <DDR_Test_WalkingOnes+0xb6>
2ffc9f6c:	1f02      	subs	r2, r0, #4
      *p = pattern[j];
2ffc9f6e:	4613      	mov	r3, r2
2ffc9f70:	f842 4f04 	str.w	r4, [r2, #4]!
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9f74:	3308      	adds	r3, #8
2ffc9f76:	1a1b      	subs	r3, r3, r0
2ffc9f78:	429e      	cmp	r6, r3
2ffc9f7a:	d8f8      	bhi.n	2ffc9f6e <DDR_Test_WalkingOnes+0x4a>
  for (i = 0; i < bufsize; i += size * sizeof(uint32_t))
2ffc9f7c:	2300      	movs	r3, #0
2ffc9f7e:	e001      	b.n	2ffc9f84 <DDR_Test_WalkingOnes+0x60>
2ffc9f80:	429e      	cmp	r6, r3
2ffc9f82:	d920      	bls.n	2ffc9fc6 <DDR_Test_WalkingOnes+0xa2>
      if (READ_REG(*(volatile uint32_t*)p) != pattern[j])
2ffc9f84:	58c2      	ldr	r2, [r0, r3]
2ffc9f86:	18c1      	adds	r1, r0, r3
  for (i = 0; i < bufsize; i += size * sizeof(uint32_t))
2ffc9f88:	3304      	adds	r3, #4
      if (READ_REG(*(volatile uint32_t*)p) != pattern[j])
2ffc9f8a:	42a2      	cmp	r2, r4
2ffc9f8c:	d0f8      	beq.n	2ffc9f80 <DDR_Test_WalkingOnes+0x5c>
        printf("  test KO @ 0x%ln\n\r", p);
2ffc9f8e:	f64e 40bc 	movw	r0, #60604	@ 0xecbc
2ffc9f92:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9f96:	f001 fcf7 	bl	2ffcb988 <iprintf>
      if (ret != 0)
      {
        printf("  test_walkbit1 KO\n\r");
2ffc9f9a:	f64e 5044 	movw	r0, #60740	@ 0xed44
2ffc9f9e:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9fa2:	f001 fcf1 	bl	2ffcb988 <iprintf>
        return 3;
2ffc9fa6:	2003      	movs	r0, #3
      break;
    }
  }

  return 0;
}
2ffc9fa8:	b003      	add	sp, #12
2ffc9faa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    *nb_loop = default_nb_loop;
2ffc9fac:	2501      	movs	r5, #1
  if (addr_in != 0)
2ffc9fae:	2c00      	cmp	r4, #0
2ffc9fb0:	d1c9      	bne.n	2ffc9f46 <DDR_Test_WalkingOnes+0x22>
2ffc9fb2:	f04f 4040 	mov.w	r0, #3221225472	@ 0xc0000000
2ffc9fb6:	e7cc      	b.n	2ffc9f52 <DDR_Test_WalkingOnes+0x2e>
        value = ~(1 << (63 - i));
2ffc9fb8:	f1cc 043f 	rsb	r4, ip, #63	@ 0x3f
2ffc9fbc:	fa0e f404 	lsl.w	r4, lr, r4
2ffc9fc0:	43e4      	mvns	r4, r4
  for (i = 0; i < bufsize; i += (size * sizeof(uint32_t)))
2ffc9fc2:	2e00      	cmp	r6, #0
2ffc9fc4:	d1d2      	bne.n	2ffc9f6c <DDR_Test_WalkingOnes+0x48>
    for (i = 0; i < 64; i++)
2ffc9fc6:	f10c 0c01 	add.w	ip, ip, #1
2ffc9fca:	f1bc 0f40 	cmp.w	ip, #64	@ 0x40
2ffc9fce:	d1c6      	bne.n	2ffc9f5e <DDR_Test_WalkingOnes+0x3a>
  (*loop)++;
2ffc9fd0:	3701      	adds	r7, #1
  if (nb_loop && *loop >= nb_loop)
2ffc9fd2:	42af      	cmp	r7, r5
2ffc9fd4:	d1c1      	bne.n	2ffc9f5a <DDR_Test_WalkingOnes+0x36>
  return 0;
2ffc9fd6:	2000      	movs	r0, #0
2ffc9fd8:	e7e6      	b.n	2ffc9fa8 <DDR_Test_WalkingOnes+0x84>
    for (i = 0; i < 64; i++)
2ffc9fda:	f10c 0c01 	add.w	ip, ip, #1
2ffc9fde:	e7be      	b.n	2ffc9f5e <DDR_Test_WalkingOnes+0x3a>
    return 1;
2ffc9fe0:	2001      	movs	r0, #1
}
2ffc9fe2:	b003      	add	sp, #12
2ffc9fe4:	bdf0      	pop	{r4, r5, r6, r7, pc}
      printf("Warning: infinite loop requested\n\r");
2ffc9fe6:	f64e 20b8 	movw	r0, #60088	@ 0xeab8
2ffc9fea:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9fee:	f001 fccb 	bl	2ffcb988 <iprintf>
2ffc9ff2:	e7a7      	b.n	2ffc9f44 <DDR_Test_WalkingOnes+0x20>
      printf("Address too low: 0x%lx\n\r", addr_in);
2ffc9ff4:	f64e 20dc 	movw	r0, #60124	@ 0xeadc
2ffc9ff8:	4621      	mov	r1, r4
2ffc9ffa:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffc9ffe:	f001 fcc3 	bl	2ffcb988 <iprintf>
    return 2;
2ffca002:	2002      	movs	r0, #2
2ffca004:	e7d0      	b.n	2ffc9fa8 <DDR_Test_WalkingOnes+0x84>
      printf("Unaligned address: 0x%lx\n\r", addr_in);
2ffca006:	f64e 20f8 	movw	r0, #60152	@ 0xeaf8
2ffca00a:	4621      	mov	r1, r4
2ffca00c:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca010:	f001 fcba 	bl	2ffcb988 <iprintf>
      return -1;
2ffca014:	e7f5      	b.n	2ffca002 <DDR_Test_WalkingOnes+0xde>
2ffca016:	bf00      	nop

2ffca018 <DDR_Test_All>:

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

static uint32_t DDR_Test_All(uint32_t loop, uint32_t size, uint32_t addr)
{
2ffca018:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
2ffca01c:	f64f 4b2c 	movw	fp, #64556	@ 0xfc2c
2ffca020:	f6c2 7bfc 	movt	fp, #12284	@ 0x2ffc
2ffca024:	b083      	sub	sp, #12
2ffca026:	4688      	mov	r8, r1
2ffca028:	4617      	mov	r7, r2
  int i;

#ifdef TEST_INFINITE_ENABLE
  for (i = 1; i < (int)test_nb - 2; i++)
#else
  for (i = 1; i < (int)test_nb; i++)
2ffca02a:	f8cd b004 	str.w	fp, [sp, #4]
      case 1:
        ret = test[i].fct(addr);
        break;
      case 2:
        if (   (test[i].fct == DDR_Test_DatabusWalk0)
            || (test[i].fct == DDR_Test_DatabusWalk1))
2ffca02e:	f249 12fd 	movw	r2, #37373	@ 0x91fd
2ffca032:	f6c2 72fc 	movt	r2, #12284	@ 0x2ffc
        {
          ret = test[i].fct(loop, addr);
        }
        else if (test[i].fct == DDR_Test_Noise)
2ffca036:	f249 5175 	movw	r1, #38261	@ 0x9575
2ffca03a:	f6c2 71fc 	movt	r1, #12284	@ 0x2ffc
        if (   (test[i].fct == DDR_Test_DatabusWalk0)
2ffca03e:	f249 1af1 	movw	sl, #37361	@ 0x91f1
2ffca042:	f6c2 7afc 	movt	sl, #12284	@ 0x2ffc
2ffca046:	465c      	mov	r4, fp
{
2ffca048:	4681      	mov	r9, r0
  for (i = 1; i < (int)test_nb; i++)
2ffca04a:	2501      	movs	r5, #1
2ffca04c:	4693      	mov	fp, r2
2ffca04e:	460e      	mov	r6, r1
2ffca050:	e00e      	b.n	2ffca070 <DDR_Test_All+0x58>
    switch (test[i].max_args)
2ffca052:	2b01      	cmp	r3, #1
2ffca054:	d040      	beq.n	2ffca0d8 <DDR_Test_All+0xc0>
    {
      printf("%s failed [%ld]\n\r", test[i].name, ret);
      return ret;
    }

    printf("result %d:%s = Passed\n\r", i, test[i].name);
2ffca056:	69a2      	ldr	r2, [r4, #24]
2ffca058:	f64e 6098 	movw	r0, #61080	@ 0xee98
2ffca05c:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca060:	4629      	mov	r1, r5
  for (i = 1; i < (int)test_nb; i++)
2ffca062:	3501      	adds	r5, #1
    printf("result %d:%s = Passed\n\r", i, test[i].name);
2ffca064:	f001 fc90 	bl	2ffcb988 <iprintf>
  for (i = 1; i < (int)test_nb; i++)
2ffca068:	2d11      	cmp	r5, #17
2ffca06a:	f104 0414 	add.w	r4, r4, #20
2ffca06e:	d040      	beq.n	2ffca0f2 <DDR_Test_All+0xda>
    switch (test[i].max_args)
2ffca070:	f894 3024 	ldrb.w	r3, [r4, #36]	@ 0x24
2ffca074:	2b02      	cmp	r3, #2
2ffca076:	d021      	beq.n	2ffca0bc <DDR_Test_All+0xa4>
2ffca078:	2b03      	cmp	r3, #3
2ffca07a:	d1ea      	bne.n	2ffca052 <DDR_Test_All+0x3a>
        if (test[i].fct == DDR_Test_NoiseBurst)
2ffca07c:	6963      	ldr	r3, [r4, #20]
2ffca07e:	f249 6259 	movw	r2, #38489	@ 0x9659
2ffca082:	f6c2 72fc 	movt	r2, #12284	@ 0x2ffc
2ffca086:	4293      	cmp	r3, r2
          ret = test[i].fct(size, 0, addr);
2ffca088:	463a      	mov	r2, r7
        if (test[i].fct == DDR_Test_NoiseBurst)
2ffca08a:	d037      	beq.n	2ffca0fc <DDR_Test_All+0xe4>
          ret = test[i].fct(size, loop, addr);
2ffca08c:	4649      	mov	r1, r9
2ffca08e:	4640      	mov	r0, r8
2ffca090:	4798      	blx	r3
    if (ret != 0)
2ffca092:	2800      	cmp	r0, #0
2ffca094:	d0df      	beq.n	2ffca056 <DDR_Test_All+0x3e>
      printf("%s failed [%ld]\n\r", test[i].name, ret);
2ffca096:	f8dd b004 	ldr.w	fp, [sp, #4]
2ffca09a:	2314      	movs	r3, #20
2ffca09c:	4606      	mov	r6, r0
2ffca09e:	f64e 6084 	movw	r0, #61060	@ 0xee84
2ffca0a2:	fb03 bb05 	mla	fp, r3, r5, fp
2ffca0a6:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca0aa:	4632      	mov	r2, r6
2ffca0ac:	f8db 1004 	ldr.w	r1, [fp, #4]
2ffca0b0:	f001 fc6a 	bl	2ffcb988 <iprintf>
  }

  return ret;
}
2ffca0b4:	4630      	mov	r0, r6
2ffca0b6:	b003      	add	sp, #12
2ffca0b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (   (test[i].fct == DDR_Test_DatabusWalk0)
2ffca0bc:	6963      	ldr	r3, [r4, #20]
          ret = test[i].fct(loop, addr);
2ffca0be:	4639      	mov	r1, r7
            || (test[i].fct == DDR_Test_DatabusWalk1))
2ffca0c0:	4553      	cmp	r3, sl
2ffca0c2:	bf18      	it	ne
2ffca0c4:	455b      	cmpne	r3, fp
2ffca0c6:	bf0c      	ite	eq
2ffca0c8:	2001      	moveq	r0, #1
2ffca0ca:	2000      	movne	r0, #0
2ffca0cc:	d10a      	bne.n	2ffca0e4 <DDR_Test_All+0xcc>
          ret = test[i].fct(loop, addr);
2ffca0ce:	4648      	mov	r0, r9
2ffca0d0:	4798      	blx	r3
    if (ret != 0)
2ffca0d2:	2800      	cmp	r0, #0
2ffca0d4:	d0bf      	beq.n	2ffca056 <DDR_Test_All+0x3e>
2ffca0d6:	e7de      	b.n	2ffca096 <DDR_Test_All+0x7e>
        ret = test[i].fct(addr);
2ffca0d8:	6963      	ldr	r3, [r4, #20]
2ffca0da:	4638      	mov	r0, r7
2ffca0dc:	4798      	blx	r3
    if (ret != 0)
2ffca0de:	2800      	cmp	r0, #0
2ffca0e0:	d0b9      	beq.n	2ffca056 <DDR_Test_All+0x3e>
2ffca0e2:	e7d8      	b.n	2ffca096 <DDR_Test_All+0x7e>
        else if (test[i].fct == DDR_Test_Noise)
2ffca0e4:	42b3      	cmp	r3, r6
2ffca0e6:	d010      	beq.n	2ffca10a <DDR_Test_All+0xf2>
          ret = test[i].fct(size, addr);
2ffca0e8:	4640      	mov	r0, r8
2ffca0ea:	4798      	blx	r3
    if (ret != 0)
2ffca0ec:	2800      	cmp	r0, #0
2ffca0ee:	d0b2      	beq.n	2ffca056 <DDR_Test_All+0x3e>
2ffca0f0:	e7d1      	b.n	2ffca096 <DDR_Test_All+0x7e>
  return ret;
2ffca0f2:	2600      	movs	r6, #0
}
2ffca0f4:	4630      	mov	r0, r6
2ffca0f6:	b003      	add	sp, #12
2ffca0f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          ret = test[i].fct(size, 0, addr);
2ffca0fc:	2100      	movs	r1, #0
2ffca0fe:	4640      	mov	r0, r8
2ffca100:	f7ff faaa 	bl	2ffc9658 <DDR_Test_NoiseBurst>
    if (ret != 0)
2ffca104:	2800      	cmp	r0, #0
2ffca106:	d0a6      	beq.n	2ffca056 <DDR_Test_All+0x3e>
2ffca108:	e7c5      	b.n	2ffca096 <DDR_Test_All+0x7e>
          ret = test[i].fct(0, addr);
2ffca10a:	f7ff fa33 	bl	2ffc9574 <DDR_Test_Noise>
    if (ret != 0)
2ffca10e:	2800      	cmp	r0, #0
2ffca110:	d0a1      	beq.n	2ffca056 <DDR_Test_All+0x3e>
2ffca112:	e7c0      	b.n	2ffca096 <DDR_Test_All+0x7e>

2ffca114 <print_subcmd_usage.constprop.0>:

static void print_subcmd_usage(const subcmd_desc *array, const int size)
{
  int i;

  printf("commands:\n\r\n\r");
2ffca114:	f64e 60b0 	movw	r0, #61104	@ 0xeeb0
static void print_subcmd_usage(const subcmd_desc *array, const int size)
2ffca118:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2ffca11a:	f64f 442c 	movw	r4, #64556	@ 0xfc2c
  printf("commands:\n\r\n\r");
2ffca11e:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
      printf("  %2d: %s %s\n\r", i, array[i].name, array[i].usage);
2ffca122:	f64e 67c0 	movw	r7, #61120	@ 0xeec0
2ffca126:	f6c2 74fc 	movt	r4, #12284	@ 0x2ffc
      printf("          %s\n\r", array[i].help);
2ffca12a:	f64e 66d0 	movw	r6, #61136	@ 0xeed0
      printf("  %2d: %s %s\n\r", i, array[i].name, array[i].usage);
2ffca12e:	f6c2 77fc 	movt	r7, #12284	@ 0x2ffc

  for (i = 0; i < size; i++)
2ffca132:	2500      	movs	r5, #0
      printf("          %s\n\r", array[i].help);
2ffca134:	f6c2 76fc 	movt	r6, #12284	@ 0x2ffc
  printf("commands:\n\r\n\r");
2ffca138:	f001 fc26 	bl	2ffcb988 <iprintf>
      printf("  %2d: %s %s\n\r", i, array[i].name, array[i].usage);
2ffca13c:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
2ffca140:	4629      	mov	r1, r5
2ffca142:	4638      	mov	r0, r7
  for (i = 0; i < size; i++)
2ffca144:	3501      	adds	r5, #1
      printf("  %2d: %s %s\n\r", i, array[i].name, array[i].usage);
2ffca146:	f001 fc1f 	bl	2ffcb988 <iprintf>
      printf("          %s\n\r", array[i].help);
2ffca14a:	68e1      	ldr	r1, [r4, #12]
2ffca14c:	4630      	mov	r0, r6
  for (i = 0; i < size; i++)
2ffca14e:	3414      	adds	r4, #20
      printf("          %s\n\r", array[i].help);
2ffca150:	f001 fc1a 	bl	2ffcb988 <iprintf>
  for (i = 0; i < size; i++)
2ffca154:	2d11      	cmp	r5, #17
2ffca156:	d1f1      	bne.n	2ffca13c <print_subcmd_usage.constprop.0+0x28>
  {
      print_single_subcmd_usage(array, i);
  }
}
2ffca158:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
2ffca15a:	bf00      	nop
2ffca15c:	0000      	movs	r0, r0
	...

2ffca160 <HAL_DDR_Interactive>:

    printf("Result: Pass [%s]\n\r", array[value].name);
}

bool HAL_DDR_Interactive(HAL_DDR_InteractStepTypeDef step)
{
2ffca160:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  char *argv[CMD_MAX_ARG + 1]; /* NULL terminated */
  int argc;
  int cmd;
  static int next_step = -1;

  if ((next_step < 0) && (step == STEP_DDR_RESET))
2ffca164:	f641 0380 	movw	r3, #6272	@ 0x1880
2ffca168:	f6c2 73fd 	movt	r3, #12285	@ 0x2ffd
{
2ffca16c:	f6ad 0d54 	subw	sp, sp, #2132	@ 0x854
2ffca170:	af02      	add	r7, sp, #8
  if ((next_step < 0) && (step == STEP_DDR_RESET))
2ffca172:	461a      	mov	r2, r3
2ffca174:	60bb      	str	r3, [r7, #8]
2ffca176:	fab0 f380 	clz	r3, r0
2ffca17a:	6812      	ldr	r2, [r2, #0]
2ffca17c:	095b      	lsrs	r3, r3, #5
2ffca17e:	ea13 73d2 	ands.w	r3, r3, r2, lsr #31
2ffca182:	6138      	str	r0, [r7, #16]
2ffca184:	f040 8176 	bne.w	2ffca474 <HAL_DDR_Interactive+0x314>
    next_step = STEP_DDR_RESET;
  }

//  printf("** step %d ** %s / %d\n\r", step, step_str[step], next_step);

  if (next_step < 0)
2ffca188:	2a00      	cmp	r2, #0
2ffca18a:	f2c0 80b1 	blt.w	2ffca2f0 <HAL_DDR_Interactive+0x190>
  {
    return false;
  }

  if (step < 0 || step > STEP_RUN)
2ffca18e:	693b      	ldr	r3, [r7, #16]
2ffca190:	2b04      	cmp	r3, #4
2ffca192:	f200 80a6 	bhi.w	2ffca2e2 <HAL_DDR_Interactive+0x182>
  {
    printf("** step %d ** INVALID\n\r", step);
    return false;
  }

  printf("%d:%s\n\r", step, step_str[step]);
2ffca196:	693d      	ldr	r5, [r7, #16]
2ffca198:	f24f 50bc 	movw	r0, #62908	@ 0xf5bc
2ffca19c:	68bc      	ldr	r4, [r7, #8]
2ffca19e:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca1a2:	4629      	mov	r1, r5
2ffca1a4:	eb04 0385 	add.w	r3, r4, r5, lsl #2
2ffca1a8:	689a      	ldr	r2, [r3, #8]
2ffca1aa:	f001 fbed 	bl	2ffcb988 <iprintf>

  if (next_step > step)
2ffca1ae:	f8d4 e000 	ldr.w	lr, [r4]
2ffca1b2:	4575      	cmp	r5, lr
2ffca1b4:	f2c0 809c 	blt.w	2ffca2f0 <HAL_DDR_Interactive+0x190>
  {
    return false;
  }

  while (next_step == step)
2ffca1b8:	f040 840c 	bne.w	2ffca9d4 <HAL_DDR_Interactive+0x874>
2ffca1bc:	f8c7 e014 	str.w	lr, [r7, #20]
2ffca1c0:	f64f 4c2c 	movw	ip, #64556	@ 0xfc2c
2ffca1c4:	f6c2 7cfc 	movt	ip, #12284	@ 0x2ffc
2ffca1c8:	f107 0848 	add.w	r8, r7, #72	@ 0x48
2ffca1cc:	f8c7 c00c 	str.w	ip, [r7, #12]
  Serial_Putchar(0xd);
2ffca1d0:	200d      	movs	r0, #13
  int i = 0;
2ffca1d2:	f04f 0900 	mov.w	r9, #0
  Serial_Putchar(0xd);
2ffca1d6:	f000 fe8d 	bl	2ffcaef4 <Serial_Putchar>
  Serial_Putchar('D');
2ffca1da:	2044      	movs	r0, #68	@ 0x44
2ffca1dc:	f000 fe8a 	bl	2ffcaef4 <Serial_Putchar>
  Serial_Putchar('D');
2ffca1e0:	2044      	movs	r0, #68	@ 0x44
2ffca1e2:	f000 fe87 	bl	2ffcaef4 <Serial_Putchar>
  Serial_Putchar('R');
2ffca1e6:	2052      	movs	r0, #82	@ 0x52
2ffca1e8:	f000 fe84 	bl	2ffcaef4 <Serial_Putchar>
  Serial_Putchar('>');
2ffca1ec:	203e      	movs	r0, #62	@ 0x3e
2ffca1ee:	f000 fe81 	bl	2ffcaef4 <Serial_Putchar>
  while(user_entry_valid == 0)
2ffca1f2:	e007      	b.n	2ffca204 <HAL_DDR_Interactive+0xa4>
    else if (user_entry_value == 0x18)
2ffca1f4:	2d18      	cmp	r5, #24
      entry[i++] = user_entry_value;
2ffca1f6:	bf16      	itet	ne
2ffca1f8:	f808 5009 	strbne.w	r5, [r8, r9]
      i--;
2ffca1fc:	f109 39ff 	addeq.w	r9, r9, #4294967295	@ 0xffffffff
      entry[i++] = user_entry_value;
2ffca200:	f109 0901 	addne.w	r9, r9, #1
    user_entry_value = Serial_Scanf(255);
2ffca204:	20ff      	movs	r0, #255	@ 0xff
2ffca206:	f000 fe4f 	bl	2ffcaea8 <Serial_Scanf>
2ffca20a:	b2c5      	uxtb	r5, r0
    Serial_Putchar(user_entry_value);
2ffca20c:	4628      	mov	r0, r5
2ffca20e:	f000 fe71 	bl	2ffcaef4 <Serial_Putchar>
    if (user_entry_value == 0xd)
2ffca212:	2d0d      	cmp	r5, #13
2ffca214:	d1ee      	bne.n	2ffca1f4 <HAL_DDR_Interactive+0x94>
      printf("\r\n");
2ffca216:	f64e 60bc 	movw	r0, #61116	@ 0xeebc
      entry[i] = '\0';
2ffca21a:	2600      	movs	r6, #0
      printf("\r\n");
2ffca21c:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
      entry[i] = '\0';
2ffca220:	f808 6009 	strb.w	r6, [r8, r9]
      printf("\r\n");
2ffca224:	f001 fc18 	bl	2ffcba58 <puts>
  {
    get_entry_string(buffer);

    argc = parse_entry_string(buffer, strlen(buffer), &cmd, argv);
2ffca228:	4640      	mov	r0, r8
2ffca22a:	f001 fdea 	bl	2ffcbe02 <strlen>
  for (i = 0; i < (int)size; i++)
2ffca22e:	2800      	cmp	r0, #0
2ffca230:	f000 8108 	beq.w	2ffca444 <HAL_DDR_Interactive+0x2e4>
2ffca234:	627e      	str	r6, [r7, #36]	@ 0x24
  ddr_arg arg = {0, 0};
2ffca236:	46b3      	mov	fp, r6
  for (i = 0; i < (int)size; i++)
2ffca238:	61bc      	str	r4, [r7, #24]
  ddr_arg cmd = {0, 0};
2ffca23a:	4631      	mov	r1, r6
  int n = 0;
2ffca23c:	46b1      	mov	r9, r6
  for (i = 0; i < (int)size; i++)
2ffca23e:	4635      	mov	r5, r6
2ffca240:	4682      	mov	sl, r0
    if (entry[i] == '\0')
2ffca242:	f818 2005 	ldrb.w	r2, [r8, r5]
2ffca246:	eb08 0305 	add.w	r3, r8, r5
2ffca24a:	b1d2      	cbz	r2, 2ffca282 <HAL_DDR_Interactive+0x122>
    if (entry[i] == ' ')
2ffca24c:	2a20      	cmp	r2, #32
      i++;
2ffca24e:	bf08      	it	eq
2ffca250:	3501      	addeq	r5, #1
    if (entry[i] == ' ')
2ffca252:	d014      	beq.n	2ffca27e <HAL_DDR_Interactive+0x11e>
    if (n == 0)
2ffca254:	f1b9 0f00 	cmp.w	r9, #0
      cmd.off = i;
2ffca258:	b2ee      	uxtb	r6, r5
    if (n == 0)
2ffca25a:	bf1c      	itt	ne
2ffca25c:	46b3      	movne	fp, r6
2ffca25e:	460e      	movne	r6, r1
    while ((entry[i] != ' ') && (entry[i] != '\0'))
2ffca260:	f813 4f01 	ldrb.w	r4, [r3, #1]!
      i++;
2ffca264:	3501      	adds	r5, #1
    while ((entry[i] != ' ') && (entry[i] != '\0'))
2ffca266:	f014 04df 	ands.w	r4, r4, #223	@ 0xdf
2ffca26a:	d1f9      	bne.n	2ffca260 <HAL_DDR_Interactive+0x100>
    if (n == 0)
2ffca26c:	f1b9 0f00 	cmp.w	r9, #0
2ffca270:	d144      	bne.n	2ffca2fc <HAL_DDR_Interactive+0x19c>
      cmd.len = i - cmd.off;
2ffca272:	1bab      	subs	r3, r5, r6
    n++;
2ffca274:	f04f 0901 	mov.w	r9, #1
      cmd.len = i - cmd.off;
2ffca278:	b2db      	uxtb	r3, r3
2ffca27a:	627b      	str	r3, [r7, #36]	@ 0x24
    n++;
2ffca27c:	4631      	mov	r1, r6
  for (i = 0; i < (int)size; i++)
2ffca27e:	45aa      	cmp	sl, r5
2ffca280:	dcdf      	bgt.n	2ffca242 <HAL_DDR_Interactive+0xe2>
  if ((n == 0) && (cmd.len == 0))
2ffca282:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
2ffca284:	464b      	mov	r3, r9
2ffca286:	f8c7 9020 	str.w	r9, [r7, #32]
2ffca28a:	2e00      	cmp	r6, #0
2ffca28c:	bf08      	it	eq
2ffca28e:	2b00      	cmpeq	r3, #0
    if (   !strncmp(&entry[cmd.off], ddr_cmd[i].str, cmd.len)
2ffca290:	bf14      	ite	ne
2ffca292:	eb08 0501 	addne.w	r5, r8, r1
  if ((n == 0) && (cmd.len == 0))
2ffca296:	f04f 0901 	moveq.w	r9, #1
2ffca29a:	69bc      	ldr	r4, [r7, #24]
2ffca29c:	bf1c      	itt	ne
2ffca29e:	f04f 0900 	movne.w	r9, #0
    if (   !strncmp(&entry[cmd.off], ddr_cmd[i].str, cmd.len)
2ffca2a2:	46ab      	movne	fp, r5
  if ((n == 0) && (cmd.len == 0))
2ffca2a4:	f000 80ce 	beq.w	2ffca444 <HAL_DDR_Interactive+0x2e4>
    if (   !strncmp(&entry[cmd.off], ddr_cmd[i].str, cmd.len)
2ffca2a8:	4bba      	ldr	r3, [pc, #744]	@ (2ffca594 <HAL_DDR_Interactive+0x434>)
2ffca2aa:	4632      	mov	r2, r6
2ffca2ac:	4658      	mov	r0, fp
2ffca2ae:	f853 1039 	ldr.w	r1, [r3, r9, lsl #3]
2ffca2b2:	468a      	mov	sl, r1
2ffca2b4:	f001 fcd8 	bl	2ffcbc68 <strncmp>
2ffca2b8:	4605      	mov	r5, r0
        && (cmd.len == strlen(ddr_cmd[i].str)))
2ffca2ba:	4650      	mov	r0, sl
    if (   !strncmp(&entry[cmd.off], ddr_cmd[i].str, cmd.len)
2ffca2bc:	b91d      	cbnz	r5, 2ffca2c6 <HAL_DDR_Interactive+0x166>
        && (cmd.len == strlen(ddr_cmd[i].str)))
2ffca2be:	f001 fda0 	bl	2ffcbe02 <strlen>
2ffca2c2:	42b0      	cmp	r0, r6
2ffca2c4:	d059      	beq.n	2ffca37a <HAL_DDR_Interactive+0x21a>
  for (i = 0; i < DDR_CMD_UNKNOWN; i++)
2ffca2c6:	f109 0901 	add.w	r9, r9, #1
2ffca2ca:	f1b9 0f0c 	cmp.w	r9, #12
2ffca2ce:	d1eb      	bne.n	2ffca2a8 <HAL_DDR_Interactive+0x148>
    printf("Unknown command\n\r");
2ffca2d0:	f24f 6084 	movw	r0, #63108	@ 0xf684
2ffca2d4:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca2d8:	f001 fb56 	bl	2ffcb988 <iprintf>
    return -2;
2ffca2dc:	f06f 0101 	mvn.w	r1, #1
2ffca2e0:	e037      	b.n	2ffca352 <HAL_DDR_Interactive+0x1f2>
    printf("** step %d ** INVALID\n\r", step);
2ffca2e2:	f64e 60e0 	movw	r0, #61152	@ 0xeee0
2ffca2e6:	4619      	mov	r1, r3
2ffca2e8:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca2ec:	f001 fb4c 	bl	2ffcb988 <iprintf>
    return false;
2ffca2f0:	2000      	movs	r0, #0

    free_args(argc, argv);
  }

  return next_step == STEP_DDR_RESET;
}
2ffca2f2:	f607 074c 	addw	r7, r7, #2124	@ 0x84c
2ffca2f6:	46bd      	mov	sp, r7
2ffca2f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      arg.len = i - arg.off;
2ffca2fc:	eba5 020b 	sub.w	r2, r5, fp
2ffca300:	b2d2      	uxtb	r2, r2
      argv[n - 1] = (char *)malloc(arg.len + 1);
2ffca302:	623a      	str	r2, [r7, #32]
2ffca304:	1c50      	adds	r0, r2, #1
2ffca306:	f001 f837 	bl	2ffcb378 <malloc>
      strncpy(argv[n - 1], &entry[arg.off], arg.len);
2ffca30a:	eb08 010b 	add.w	r1, r8, fp
      argv[n - 1] = (char *)malloc(arg.len + 1);
2ffca30e:	f109 4c80 	add.w	ip, r9, #1073741824	@ 0x40000000
2ffca312:	61f8      	str	r0, [r7, #28]
2ffca314:	f10c 3cff 	add.w	ip, ip, #4294967295	@ 0xffffffff
2ffca318:	f607 0248 	addw	r2, r7, #2120	@ 0x848
    n++;
2ffca31c:	f109 0901 	add.w	r9, r9, #1
      argv[n - 1] = (char *)malloc(arg.len + 1);
2ffca320:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
      strncpy(argv[n - 1], &entry[arg.off], arg.len);
2ffca324:	6a3a      	ldr	r2, [r7, #32]
      argv[n - 1] = (char *)malloc(arg.len + 1);
2ffca326:	f5ac 6c80 	sub.w	ip, ip, #1024	@ 0x400
2ffca32a:	f8cc 0000 	str.w	r0, [ip]
      strncpy(argv[n - 1], &entry[arg.off], arg.len);
2ffca32e:	f001 fcad 	bl	2ffcbc8c <strncpy>
      strncpy(argv[n - 1] + arg.len, "\0", 1);
2ffca332:	e9d7 3207 	ldrd	r3, r2, [r7, #28]
    if (n > CMD_MAX_ARG + 1)
2ffca336:	f5b9 7f80 	cmp.w	r9, #256	@ 0x100
      strncpy(argv[n - 1] + arg.len, "\0", 1);
2ffca33a:	549c      	strb	r4, [r3, r2]
    if (n > CMD_MAX_ARG + 1)
2ffca33c:	dd9e      	ble.n	2ffca27c <HAL_DDR_Interactive+0x11c>
      printf("Too many arguments (max=%d)\n\r", CMD_MAX_ARG);
2ffca33e:	69bc      	ldr	r4, [r7, #24]
2ffca340:	f64e 60f8 	movw	r0, #61176	@ 0xeef8
2ffca344:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca348:	21ff      	movs	r1, #255	@ 0xff
2ffca34a:	f001 fb1d 	bl	2ffcb988 <iprintf>
      return -1;
2ffca34e:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
      printf("Error [%d]\n\r", argc);
2ffca352:	f64e 7064 	movw	r0, #61284	@ 0xef64
2ffca356:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca35a:	f001 fb15 	bl	2ffcb988 <iprintf>
  while (next_step == step)
2ffca35e:	f8d4 b000 	ldr.w	fp, [r4]
2ffca362:	697b      	ldr	r3, [r7, #20]
2ffca364:	455b      	cmp	r3, fp
2ffca366:	f43f af33 	beq.w	2ffca1d0 <HAL_DDR_Interactive+0x70>
  return next_step == STEP_DDR_RESET;
2ffca36a:	fabb f08b 	clz	r0, fp
}
2ffca36e:	f607 074c 	addw	r7, r7, #2124	@ 0x84c
  return next_step == STEP_DDR_RESET;
2ffca372:	0940      	lsrs	r0, r0, #5
}
2ffca374:	46bd      	mov	sp, r7
2ffca376:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((n - 1) < ddr_cmd[*command].param_min)
2ffca37a:	68fb      	ldr	r3, [r7, #12]
2ffca37c:	46ab      	mov	fp, r5
2ffca37e:	6a39      	ldr	r1, [r7, #32]
2ffca380:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
2ffca384:	f893 2158 	ldrb.w	r2, [r3, #344]	@ 0x158
2ffca388:	428a      	cmp	r2, r1
2ffca38a:	f280 8428 	bge.w	2ffcabde <HAL_DDR_Interactive+0xa7e>
  } else if ((n - 1) > ddr_cmd[*command].param_max)
2ffca38e:	6a39      	ldr	r1, [r7, #32]
2ffca390:	f893 2159 	ldrb.w	r2, [r3, #345]	@ 0x159
2ffca394:	f101 3aff 	add.w	sl, r1, #4294967295	@ 0xffffffff
2ffca398:	4592      	cmp	sl, r2
2ffca39a:	f300 8414 	bgt.w	2ffcabc6 <HAL_DDR_Interactive+0xa66>
  if ((n >= 2) && (argv[0] != NULL))
2ffca39e:	6a3b      	ldr	r3, [r7, #32]
2ffca3a0:	2b01      	cmp	r3, #1
2ffca3a2:	d020      	beq.n	2ffca3e6 <HAL_DDR_Interactive+0x286>
2ffca3a4:	f8d7 6448 	ldr.w	r6, [r7, #1096]	@ 0x448
2ffca3a8:	f507 6589 	add.w	r5, r7, #1096	@ 0x448
2ffca3ac:	b146      	cbz	r6, 2ffca3c0 <HAL_DDR_Interactive+0x260>
    if (!strcmp(argv[0], "help"))
2ffca3ae:	f64e 715c 	movw	r1, #61276	@ 0xef5c
2ffca3b2:	4630      	mov	r0, r6
2ffca3b4:	f6c2 71fc 	movt	r1, #12284	@ 0x2ffc
2ffca3b8:	f001 ed00 	blx	2ffcbdbc <strcmp>
2ffca3bc:	2800      	cmp	r0, #0
2ffca3be:	d044      	beq.n	2ffca44a <HAL_DDR_Interactive+0x2ea>
    switch (cmd)
2ffca3c0:	f109 39ff 	add.w	r9, r9, #4294967295	@ 0xffffffff
2ffca3c4:	f1b9 0f0a 	cmp.w	r9, #10
2ffca3c8:	f200 8553 	bhi.w	2ffcae72 <HAL_DDR_Interactive+0xd12>
2ffca3cc:	e8df f019 	tbh	[pc, r9, lsl #1]
2ffca3d0:	00e4006f 	.word	0x00e4006f
2ffca3d4:	00ba013b 	.word	0x00ba013b
2ffca3d8:	01670099 	.word	0x01670099
2ffca3dc:	00670160 	.word	0x00670160
2ffca3e0:	014f015a 	.word	0x014f015a
2ffca3e4:	001e      	.short	0x001e
2ffca3e6:	f109 39ff 	add.w	r9, r9, #4294967295	@ 0xffffffff
2ffca3ea:	f1b9 0f0a 	cmp.w	r9, #10
2ffca3ee:	f200 854a 	bhi.w	2ffcae86 <HAL_DDR_Interactive+0xd26>
2ffca3f2:	e8df f019 	tbh	[pc, r9, lsl #1]
2ffca3f6:	026f      	.short	0x026f
2ffca3f8:	01ca01af 	.word	0x01ca01af
2ffca3fc:	01de01d2 	.word	0x01de01d2
2ffca400:	01e70266 	.word	0x01e70266
2ffca404:	020401ee 	.word	0x020401ee
2ffca408:	0043025b 	.word	0x0043025b
  if (step != expected)
2ffca40c:	693b      	ldr	r3, [r7, #16]
2ffca40e:	2b03      	cmp	r3, #3
2ffca410:	f000 814c 	beq.w	2ffca6ac <HAL_DDR_Interactive+0x54c>
    printf("invalid step %d:%s expecting %d:%s\n\r",
2ffca414:	6979      	ldr	r1, [r7, #20]
2ffca416:	f24f 5020 	movw	r0, #62752	@ 0xf520
2ffca41a:	6963      	ldr	r3, [r4, #20]
2ffca41c:	eb04 0281 	add.w	r2, r4, r1, lsl #2
2ffca420:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca424:	6892      	ldr	r2, [r2, #8]
2ffca426:	9300      	str	r3, [sp, #0]
2ffca428:	2303      	movs	r3, #3
2ffca42a:	f001 faad 	bl	2ffcb988 <iprintf>
  for (i = 1; i < argc; i++)
2ffca42e:	6a3b      	ldr	r3, [r7, #32]
2ffca430:	f207 4244 	addw	r2, r7, #1092	@ 0x444
2ffca434:	eb02 0683 	add.w	r6, r2, r3, lsl #2
    free(argv[i - 1]);
2ffca438:	f855 0b04 	ldr.w	r0, [r5], #4
2ffca43c:	f000 ffa4 	bl	2ffcb388 <free>
  for (i = 1; i < argc; i++)
2ffca440:	42b5      	cmp	r5, r6
2ffca442:	d1f9      	bne.n	2ffca438 <HAL_DDR_Interactive+0x2d8>
  while (next_step == step)
2ffca444:	f8d4 b000 	ldr.w	fp, [r4]
2ffca448:	e78b      	b.n	2ffca362 <HAL_DDR_Interactive+0x202>
      switch (*command)
2ffca44a:	f1b9 0f0b 	cmp.w	r9, #11
2ffca44e:	d021      	beq.n	2ffca494 <HAL_DDR_Interactive+0x334>
    switch (cmd)
2ffca450:	f109 39ff 	add.w	r9, r9, #4294967295	@ 0xffffffff
2ffca454:	f1b9 0f09 	cmp.w	r9, #9
2ffca458:	f200 8515 	bhi.w	2ffcae86 <HAL_DDR_Interactive+0xd26>
2ffca45c:	e8df f019 	tbh	[pc, r9, lsl #1]
2ffca460:	0178023a 	.word	0x0178023a
2ffca464:	019d0195 	.word	0x019d0195
2ffca468:	028201a9 	.word	0x028201a9
2ffca46c:	01b901b2 	.word	0x01b901b2
2ffca470:	022601cf 	.word	0x022601cf
    next_step = STEP_DDR_RESET;
2ffca474:	68ba      	ldr	r2, [r7, #8]
2ffca476:	2300      	movs	r3, #0
2ffca478:	6013      	str	r3, [r2, #0]
  if (next_step < 0)
2ffca47a:	e68c      	b.n	2ffca196 <HAL_DDR_Interactive+0x36>
  if (step != expected)
2ffca47c:	693b      	ldr	r3, [r7, #16]
2ffca47e:	2b03      	cmp	r3, #3
2ffca480:	f040 84dd 	bne.w	2ffcae3e <HAL_DDR_Interactive+0xcde>
    printf("Please enter a sub command number\n\r\n\r");
2ffca484:	f24f 50c4 	movw	r0, #62916	@ 0xf5c4
  char arg_zero[2] = "0\0";
2ffca488:	2330      	movs	r3, #48	@ 0x30
    printf("Please enter a sub command number\n\r\n\r");
2ffca48a:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
  char arg_zero[2] = "0\0";
2ffca48e:	85bb      	strh	r3, [r7, #44]	@ 0x2c
    printf("Please enter a sub command number\n\r\n\r");
2ffca490:	f001 fa7a 	bl	2ffcb988 <iprintf>
    print_subcmd_usage(array, size);
2ffca494:	f7ff fe3e 	bl	2ffca114 <print_subcmd_usage.constprop.0>
  while (next_step == step)
2ffca498:	f8d4 b000 	ldr.w	fp, [r4]
2ffca49c:	e761      	b.n	2ffca362 <HAL_DDR_Interactive+0x202>
  switch (argc)
2ffca49e:	6a3b      	ldr	r3, [r7, #32]
2ffca4a0:	2b02      	cmp	r3, #2
2ffca4a2:	f000 8266 	beq.w	2ffca972 <HAL_DDR_Interactive+0x812>
      next_step = do_step(step, argc, argv);
2ffca4a6:	697b      	ldr	r3, [r7, #20]
2ffca4a8:	6023      	str	r3, [r4, #0]
2ffca4aa:	469b      	mov	fp, r3
2ffca4ac:	e0d2      	b.n	2ffca654 <HAL_DDR_Interactive+0x4f4>
  if (argc < 3)
2ffca4ae:	6a3b      	ldr	r3, [r7, #32]
2ffca4b0:	2b02      	cmp	r3, #2
2ffca4b2:	f000 83b1 	beq.w	2ffcac18 <HAL_DDR_Interactive+0xab8>
  if (!strcmp(argv[0], "name"))
2ffca4b6:	f24f 4110 	movw	r1, #62480	@ 0xf410
2ffca4ba:	4630      	mov	r0, r6
2ffca4bc:	f6c2 71fc 	movt	r1, #12284	@ 0x2ffc
2ffca4c0:	f001 ec7c 	blx	2ffcbdbc <strcmp>
2ffca4c4:	2800      	cmp	r0, #0
2ffca4c6:	f000 81a2 	beq.w	2ffca80e <HAL_DDR_Interactive+0x6ae>
  if (!strcmp(argv[0], "size"))
2ffca4ca:	f24f 4138 	movw	r1, #62520	@ 0xf438
2ffca4ce:	4630      	mov	r0, r6
2ffca4d0:	f6c2 71fc 	movt	r1, #12284	@ 0x2ffc
2ffca4d4:	f001 ec72 	blx	2ffcbdbc <strcmp>
2ffca4d8:	2800      	cmp	r0, #0
2ffca4da:	f000 83c3 	beq.w	2ffcac64 <HAL_DDR_Interactive+0xb04>
  if (!strcmp(argv[0], "speed"))
2ffca4de:	f24f 4140 	movw	r1, #62528	@ 0xf440
2ffca4e2:	4630      	mov	r0, r6
2ffca4e4:	f6c2 71fc 	movt	r1, #12284	@ 0x2ffc
2ffca4e8:	f001 ec68 	blx	2ffcbdbc <strcmp>
2ffca4ec:	2800      	cmp	r0, #0
2ffca4ee:	f000 839c 	beq.w	2ffcac2a <HAL_DDR_Interactive+0xaca>
  printf("argument %s invalid\n\r", argv[0]);
2ffca4f2:	f24f 405c 	movw	r0, #62556	@ 0xf45c
2ffca4f6:	4631      	mov	r1, r6
2ffca4f8:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca4fc:	f001 fa44 	bl	2ffcb988 <iprintf>
2ffca500:	e044      	b.n	2ffca58c <HAL_DDR_Interactive+0x42c>
  char reg_name[(argc == 1)? 0 : strlen(argv[0])];
2ffca502:	4630      	mov	r0, r6
{
2ffca504:	46ea      	mov	sl, sp
  char reg_name[(argc == 1)? 0 : strlen(argv[0])];
2ffca506:	f001 fc7c 	bl	2ffcbe02 <strlen>
2ffca50a:	1dc3      	adds	r3, r0, #7
2ffca50c:	f023 0307 	bic.w	r3, r3, #7
2ffca510:	ebad 0d03 	sub.w	sp, sp, r3
  switch (argc)
2ffca514:	6a3b      	ldr	r3, [r7, #32]
  char reg_name[(argc == 1)? 0 : strlen(argv[0])];
2ffca516:	f10d 0908 	add.w	r9, sp, #8
  switch (argc)
2ffca51a:	2b02      	cmp	r3, #2
2ffca51c:	d110      	bne.n	2ffca540 <HAL_DDR_Interactive+0x3e0>
      HAL_DDR_Convert_Case(argv[0], reg_name, 1); /* convert to upper case */
2ffca51e:	4630      	mov	r0, r6
2ffca520:	4649      	mov	r1, r9
2ffca522:	2201      	movs	r2, #1
2ffca524:	f7f9 fa96 	bl	2ffc3a54 <HAL_DDR_Convert_Case>
      if (HAL_DDR_Dump_Reg(reg_name, false) != HAL_OK)
2ffca528:	2100      	movs	r1, #0
2ffca52a:	4648      	mov	r0, r9
2ffca52c:	f7f9 fab6 	bl	2ffc3a9c <HAL_DDR_Dump_Reg>
2ffca530:	b130      	cbz	r0, 2ffca540 <HAL_DDR_Interactive+0x3e0>
        printf("invalid argument %s\n\r", reg_name);
2ffca532:	f24f 4074 	movw	r0, #62580	@ 0xf474
2ffca536:	4649      	mov	r1, r9
2ffca538:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca53c:	f001 fa24 	bl	2ffcb988 <iprintf>
2ffca540:	46d5      	mov	sp, sl
}
2ffca542:	e023      	b.n	2ffca58c <HAL_DDR_Interactive+0x42c>
  char reg_name[(argc == 1)? 0 : strlen(argv[0])];
2ffca544:	4630      	mov	r0, r6
{
2ffca546:	46e9      	mov	r9, sp
  char reg_name[(argc == 1)? 0 : strlen(argv[0])];
2ffca548:	f001 fc5b 	bl	2ffcbe02 <strlen>
2ffca54c:	1dc3      	adds	r3, r0, #7
2ffca54e:	f023 0307 	bic.w	r3, r3, #7
2ffca552:	ebad 0d03 	sub.w	sp, sp, r3
  switch (argc)
2ffca556:	6a3b      	ldr	r3, [r7, #32]
  char reg_name[(argc == 1)? 0 : strlen(argv[0])];
2ffca558:	f10d 0a08 	add.w	sl, sp, #8
  switch (argc)
2ffca55c:	2b02      	cmp	r3, #2
2ffca55e:	f000 81df 	beq.w	2ffca920 <HAL_DDR_Interactive+0x7c0>
2ffca562:	6a3b      	ldr	r3, [r7, #32]
2ffca564:	2b03      	cmp	r3, #3
2ffca566:	d110      	bne.n	2ffca58a <HAL_DDR_Interactive+0x42a>
  if (step != expected)
2ffca568:	693b      	ldr	r3, [r7, #16]
2ffca56a:	2b00      	cmp	r3, #0
2ffca56c:	f040 8343 	bne.w	2ffcabf6 <HAL_DDR_Interactive+0xa96>
    HAL_DDR_Convert_Case(argv[0], reg_name, 1); /* convert to upper case */
2ffca570:	4630      	mov	r0, r6
2ffca572:	2201      	movs	r2, #1
2ffca574:	4651      	mov	r1, sl
2ffca576:	f7f9 fa6d 	bl	2ffc3a54 <HAL_DDR_Convert_Case>
    HAL_DDR_Edit_Param(&static_ddr_config, reg_name, argv[1]);
2ffca57a:	686a      	ldr	r2, [r5, #4]
2ffca57c:	f241 701c 	movw	r0, #5916	@ 0x171c
2ffca580:	f6c2 70fd 	movt	r0, #12285	@ 0x2ffd
2ffca584:	4651      	mov	r1, sl
2ffca586:	f7f9 fcf9 	bl	2ffc3f7c <HAL_DDR_Edit_Param>
    break;
2ffca58a:	46cd      	mov	sp, r9
  while (next_step == step)
2ffca58c:	f8d4 b000 	ldr.w	fp, [r4]
2ffca590:	e060      	b.n	2ffca654 <HAL_DDR_Interactive+0x4f4>
2ffca592:	bf00      	nop
2ffca594:	2ffcfd80 	.word	0x2ffcfd80
  if (argc == 2)
2ffca598:	6a3b      	ldr	r3, [r7, #32]
2ffca59a:	2b02      	cmp	r3, #2
2ffca59c:	f040 80da 	bne.w	2ffca754 <HAL_DDR_Interactive+0x5f4>
    value = strtoll(argv[0], &end_ptr, 0) * 1000;
2ffca5a0:	2200      	movs	r2, #0
2ffca5a2:	f107 0128 	add.w	r1, r7, #40	@ 0x28
2ffca5a6:	4630      	mov	r0, r6
2ffca5a8:	f001 f914 	bl	2ffcb7d4 <strtoll>
    if (end_ptr == argv[0])
2ffca5ac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    value = strtoll(argv[0], &end_ptr, 0) * 1000;
2ffca5ae:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
2ffca5b2:	fb02 f100 	mul.w	r1, r2, r0
    if (end_ptr == argv[0])
2ffca5b6:	429e      	cmp	r6, r3
2ffca5b8:	f000 83f7 	beq.w	2ffcadaa <HAL_DDR_Interactive+0xc4a>
2ffca5bc:	6279      	str	r1, [r7, #36]	@ 0x24
    HAL_RCC_GetPLL2ClockFreq(&PLL2);
2ffca5be:	f107 092c 	add.w	r9, r7, #44	@ 0x2c
2ffca5c2:	4648      	mov	r0, r9
2ffca5c4:	f7fb ff4c 	bl	2ffc6460 <HAL_RCC_GetPLL2ClockFreq>
    if (value == PLL2.PLL2_R_Frequency)
2ffca5c8:	f8d9 3008 	ldr.w	r3, [r9, #8]
2ffca5cc:	6a79      	ldr	r1, [r7, #36]	@ 0x24
2ffca5ce:	4299      	cmp	r1, r3
2ffca5d0:	f000 83e4 	beq.w	2ffcad9c <HAL_DDR_Interactive+0xc3c>
      HAL_DDR_ASS_Set_Clksrc(HAL_DDR_CLK_AXI_HSI);
2ffca5d4:	6279      	str	r1, [r7, #36]	@ 0x24
2ffca5d6:	2000      	movs	r0, #0
2ffca5d8:	f7f9 fa08 	bl	2ffc39ec <HAL_DDR_ASS_Set_Clksrc>
  switch (__HAL_RCC_GET_PLL12_SOURCE())
2ffca5dc:	6a79      	ldr	r1, [r7, #36]	@ 0x24
  PLL2.PLLM = ((READ_REG(RCC->PLL2CFGR1) & RCC_PLL2CFGR1_DIVM2) >>
2ffca5de:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffca5e2:	f8d3 0098 	ldr.w	r0, [r3, #152]	@ 0x98
  PLL2.PLLN = ((READ_REG(RCC->PLL2CFGR1) & RCC_PLL2CFGR1_DIVN) >>
2ffca5e6:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
  PLL2.PLLP = ((READ_REG(RCC->PLL2CFGR2) & RCC_PLL2CFGR2_DIVP) >>
2ffca5ea:	f8d3 209c 	ldr.w	r2, [r3, #156]	@ 0x9c
2ffca5ee:	61ba      	str	r2, [r7, #24]
  PLL2.PLLQ = ((READ_REG(RCC->PLL2CFGR2) & RCC_PLL2CFGR2_DIVQ) >>
2ffca5f0:	f8d3 209c 	ldr.w	r2, [r3, #156]	@ 0x9c
2ffca5f4:	607a      	str	r2, [r7, #4]
  PLL2.PLLR = ((READ_REG(RCC->PLL2CFGR2) & RCC_PLL2CFGR2_DIVR) >>
2ffca5f6:	f8d3 209c 	ldr.w	r2, [r3, #156]	@ 0x9c
  PLL2.PLLFRACV = (READ_REG(RCC->PLL2FRACR) & RCC_PLL2FRACR_FRACV) >>
2ffca5fa:	f8d3 60a0 	ldr.w	r6, [r3, #160]	@ 0xa0
  switch (__HAL_RCC_GET_PLL12_SOURCE())
2ffca5fe:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
2ffca600:	f013 0303 	ands.w	r3, r3, #3
2ffca604:	f000 82af 	beq.w	2ffcab66 <HAL_DDR_Interactive+0xa06>
2ffca608:	2b01      	cmp	r3, #1
2ffca60a:	f000 81e5 	beq.w	2ffca9d8 <HAL_DDR_Interactive+0x878>
      printf("PLL2 OSC clock source is not set properly\n\r");
2ffca60e:	f24f 40ac 	movw	r0, #62636	@ 0xf4ac
2ffca612:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca616:	f001 f9b7 	bl	2ffcb988 <iprintf>
      HAL_DDR_ASS_Set_Clksrc(HAL_DDR_CLK_AXI_PLL2);
2ffca61a:	2002      	movs	r0, #2
2ffca61c:	f7f9 f9e6 	bl	2ffc39ec <HAL_DDR_ASS_Set_Clksrc>
  HAL_RCC_GetPLL2ClockFreq(&PLL2);
2ffca620:	4648      	mov	r0, r9
2ffca622:	f7fb ff1d 	bl	2ffc6460 <HAL_RCC_GetPLL2ClockFreq>
  printf("DDRPHY = %ld kHz\n\r", PLL2.PLL2_R_Frequency / 1000);
2ffca626:	f8d9 1008 	ldr.w	r1, [r9, #8]
2ffca62a:	f644 53d3 	movw	r3, #19923	@ 0x4dd3
2ffca62e:	f24f 4048 	movw	r0, #62536	@ 0xf448
2ffca632:	f2c1 0362 	movt	r3, #4194	@ 0x1062
2ffca636:	fba3 3101 	umull	r3, r1, r3, r1
2ffca63a:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca63e:	0989      	lsrs	r1, r1, #6
2ffca640:	f001 f9a2 	bl	2ffcb988 <iprintf>
2ffca644:	e7a2      	b.n	2ffca58c <HAL_DDR_Interactive+0x42c>
  while (next_step == step)
2ffca646:	f8d4 b000 	ldr.w	fp, [r4]
      __HAL_RCC_SYS_RESET();
2ffca64a:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffca64e:	2201      	movs	r2, #1
2ffca650:	f8c3 2404 	str.w	r2, [r3, #1028]	@ 0x404
      next_step = do_step(step, argc, argv);
2ffca654:	f8d7 9020 	ldr.w	r9, [r7, #32]
2ffca658:	2600      	movs	r6, #0
    free(argv[i - 1]);
2ffca65a:	f855 0026 	ldr.w	r0, [r5, r6, lsl #2]
2ffca65e:	f000 fe93 	bl	2ffcb388 <free>
  for (i = 1; i < argc; i++)
2ffca662:	4633      	mov	r3, r6
2ffca664:	3601      	adds	r6, #1
2ffca666:	3302      	adds	r3, #2
2ffca668:	454b      	cmp	r3, r9
2ffca66a:	dbf6      	blt.n	2ffca65a <HAL_DDR_Interactive+0x4fa>
2ffca66c:	e679      	b.n	2ffca362 <HAL_DDR_Interactive+0x202>
      printf("### Exit DDR INTERACTIVE mode. Please RESET the BOARD ###\n\r");
2ffca66e:	f24f 5048 	movw	r0, #62792	@ 0xf548
      next_step = STEP_RUN;
2ffca672:	2304      	movs	r3, #4
      printf("### Exit DDR INTERACTIVE mode. Please RESET the BOARD ###\n\r");
2ffca674:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
      next_step = STEP_RUN;
2ffca678:	6023      	str	r3, [r4, #0]
      printf("### Exit DDR INTERACTIVE mode. Please RESET the BOARD ###\n\r");
2ffca67a:	f001 f985 	bl	2ffcb988 <iprintf>
  while (next_step == step)
2ffca67e:	f8d4 b000 	ldr.w	fp, [r4]
      break;
2ffca682:	e7e7      	b.n	2ffca654 <HAL_DDR_Interactive+0x4f4>
      next_step = step + 1;
2ffca684:	697b      	ldr	r3, [r7, #20]
2ffca686:	f103 0b01 	add.w	fp, r3, #1
2ffca68a:	f8c4 b000 	str.w	fp, [r4]
      break;
2ffca68e:	e7e1      	b.n	2ffca654 <HAL_DDR_Interactive+0x4f4>
      HAL_DDR_Dump_Reg(NULL, true);
2ffca690:	2101      	movs	r1, #1
2ffca692:	2000      	movs	r0, #0
2ffca694:	f7f9 fa02 	bl	2ffc3a9c <HAL_DDR_Dump_Reg>
  while (next_step == step)
2ffca698:	f8d4 b000 	ldr.w	fp, [r4]
      break;
2ffca69c:	e7da      	b.n	2ffca654 <HAL_DDR_Interactive+0x4f4>
      HAL_DDR_Edit_Reg(argv[0], argv[1]);
2ffca69e:	6869      	ldr	r1, [r5, #4]
2ffca6a0:	4630      	mov	r0, r6
2ffca6a2:	f7f9 faed 	bl	2ffc3c80 <HAL_DDR_Edit_Reg>
  while (next_step == step)
2ffca6a6:	f8d4 b000 	ldr.w	fp, [r4]
      break;
2ffca6aa:	e7d3      	b.n	2ffca654 <HAL_DDR_Interactive+0x4f4>
  char arg_zero[2] = "0\0";
2ffca6ac:	f107 092c 	add.w	r9, r7, #44	@ 0x2c
2ffca6b0:	2330      	movs	r3, #48	@ 0x30
  uint64_t val = strtoul(string, &end_ptr, 0);
2ffca6b2:	2200      	movs	r2, #0
2ffca6b4:	f107 0138 	add.w	r1, r7, #56	@ 0x38
  char arg_zero[2] = "0\0";
2ffca6b8:	f8a9 3000 	strh.w	r3, [r9]
  uint64_t val = strtoul(string, &end_ptr, 0);
2ffca6bc:	4630      	mov	r0, r6
2ffca6be:	f000 fff1 	bl	2ffcb6a4 <strtoul>
  if (end_ptr == string)
2ffca6c2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
  uint64_t val = strtoul(string, &end_ptr, 0);
2ffca6c4:	6278      	str	r0, [r7, #36]	@ 0x24
  if (end_ptr == string)
2ffca6c6:	429e      	cmp	r6, r3
2ffca6c8:	f000 817a 	beq.w	2ffca9c0 <HAL_DDR_Interactive+0x860>
  if ((value < 0) || (value >= size))
2ffca6cc:	2810      	cmp	r0, #16
2ffca6ce:	f200 8177 	bhi.w	2ffca9c0 <HAL_DDR_Interactive+0x860>
  if ((array == test) && (array[value].fct == DDR_Test_All))
2ffca6d2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2ffca6d4:	2214      	movs	r2, #20
2ffca6d6:	68f9      	ldr	r1, [r7, #12]
2ffca6d8:	fb03 f202 	mul.w	r2, r3, r2
2ffca6dc:	f24a 0319 	movw	r3, #40985	@ 0xa019
2ffca6e0:	5888      	ldr	r0, [r1, r2]
2ffca6e2:	f6c2 73fc 	movt	r3, #12284	@ 0x2ffc
2ffca6e6:	eb01 0b02 	add.w	fp, r1, r2
2ffca6ea:	4298      	cmp	r0, r3
  if ((uint8_t)(local_argc - 2) != array[value].max_args)
2ffca6ec:	f89b 1010 	ldrb.w	r1, [fp, #16]
2ffca6f0:	bf18      	it	ne
2ffca6f2:	6a38      	ldrne	r0, [r7, #32]
  if ((array == test) && (array[value].fct == DDR_Test_All))
2ffca6f4:	f000 812b 	beq.w	2ffca94e <HAL_DDR_Interactive+0x7ee>
  if ((uint8_t)(local_argc - 2) != array[value].max_args)
2ffca6f8:	1e83      	subs	r3, r0, #2
2ffca6fa:	b2db      	uxtb	r3, r3
2ffca6fc:	428b      	cmp	r3, r1
2ffca6fe:	f040 8248 	bne.w	2ffcab92 <HAL_DDR_Interactive+0xa32>
  for (i = 1; i <= (local_argc - 2); i++)
2ffca702:	2802      	cmp	r0, #2
2ffca704:	f100 3aff 	add.w	sl, r0, #4294967295	@ 0xffffffff
2ffca708:	d019      	beq.n	2ffca73e <HAL_DDR_Interactive+0x5de>
2ffca70a:	e9c7 4b06 	strd	r4, fp, [r7, #24]
2ffca70e:	46a9      	mov	r9, r5
2ffca710:	2601      	movs	r6, #1
2ffca712:	4614      	mov	r4, r2
    if (string_to_num(argv[i]) < 0)
2ffca714:	f859 bf04 	ldr.w	fp, [r9, #4]!
  uint64_t val = strtoul(string, &end_ptr, 0);
2ffca718:	2200      	movs	r2, #0
2ffca71a:	f107 0138 	add.w	r1, r7, #56	@ 0x38
2ffca71e:	4658      	mov	r0, fp
2ffca720:	f000 ffc0 	bl	2ffcb6a4 <strtoul>
  if (end_ptr == string)
2ffca724:	6bba      	ldr	r2, [r7, #56]	@ 0x38
2ffca726:	4593      	cmp	fp, r2
2ffca728:	f000 831e 	beq.w	2ffcad68 <HAL_DDR_Interactive+0xc08>
  for (i = 1; i <= (local_argc - 2); i++)
2ffca72c:	3601      	adds	r6, #1
2ffca72e:	45b2      	cmp	sl, r6
2ffca730:	d1f0      	bne.n	2ffca714 <HAL_DDR_Interactive+0x5b4>
2ffca732:	f8d7 b01c 	ldr.w	fp, [r7, #28]
2ffca736:	4622      	mov	r2, r4
2ffca738:	69bc      	ldr	r4, [r7, #24]
2ffca73a:	f89b 1010 	ldrb.w	r1, [fp, #16]
  switch (array[value].max_args)
2ffca73e:	2903      	cmp	r1, #3
2ffca740:	f200 8300 	bhi.w	2ffcad44 <HAL_DDR_Interactive+0xbe4>
2ffca744:	e8df f011 	tbh	[pc, r1, lsl #1]
2ffca748:	035c036d 	.word	0x035c036d
2ffca74c:	02c5033b 	.word	0x02c5033b
    switch (cmd)
2ffca750:	2301      	movs	r3, #1
2ffca752:	623b      	str	r3, [r7, #32]
  HAL_RCC_GetPLL2ClockFreq(&PLL2);
2ffca754:	f107 002c 	add.w	r0, r7, #44	@ 0x2c
2ffca758:	f7fb fe82 	bl	2ffc6460 <HAL_RCC_GetPLL2ClockFreq>
  printf("DDRPHY = %ld kHz\n\r", PLL2.PLL2_R_Frequency / 1000);
2ffca75c:	6b79      	ldr	r1, [r7, #52]	@ 0x34
2ffca75e:	f644 53d3 	movw	r3, #19923	@ 0x4dd3
2ffca762:	f2c1 0362 	movt	r3, #4194	@ 0x1062
2ffca766:	f24f 4048 	movw	r0, #62536	@ 0xf448
2ffca76a:	fba3 3101 	umull	r3, r1, r3, r1
2ffca76e:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca772:	0989      	lsrs	r1, r1, #6
2ffca774:	f001 f908 	bl	2ffcb988 <iprintf>
        next_step = STEP_DDR_RESET;
2ffca778:	2300      	movs	r3, #0
      next_step = do_step(step, argc, argv);
2ffca77a:	6023      	str	r3, [r4, #0]
  for (i = 1; i < argc; i++)
2ffca77c:	6a3b      	ldr	r3, [r7, #32]
2ffca77e:	2b01      	cmp	r3, #1
2ffca780:	f43f adef 	beq.w	2ffca362 <HAL_DDR_Interactive+0x202>
2ffca784:	f507 6589 	add.w	r5, r7, #1096	@ 0x448
2ffca788:	e764      	b.n	2ffca654 <HAL_DDR_Interactive+0x4f4>
  while (next_step == step)
2ffca78a:	f8d4 b000 	ldr.w	fp, [r4]
      __HAL_RCC_SYS_RESET();
2ffca78e:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffca792:	2201      	movs	r2, #1
2ffca794:	f8c3 2404 	str.w	r2, [r3, #1028]	@ 0x404
  for (i = 1; i < argc; i++)
2ffca798:	e5e3      	b.n	2ffca362 <HAL_DDR_Interactive+0x202>
    HAL_DDR_Dump_Param(&static_ddr_config, NULL);
2ffca79a:	f241 701c 	movw	r0, #5916	@ 0x171c
{
2ffca79e:	466d      	mov	r5, sp
    HAL_DDR_Dump_Param(&static_ddr_config, NULL);
2ffca7a0:	f6c2 70fd 	movt	r0, #12285	@ 0x2ffd
2ffca7a4:	2100      	movs	r1, #0
2ffca7a6:	f7f9 fad7 	bl	2ffc3d58 <HAL_DDR_Dump_Param>
  while (next_step == step)
2ffca7aa:	f8d4 b000 	ldr.w	fp, [r4]
2ffca7ae:	46ad      	mov	sp, r5
  for (i = 1; i < argc; i++)
2ffca7b0:	e5d7      	b.n	2ffca362 <HAL_DDR_Interactive+0x202>
      HAL_DDR_Dump_Reg(NULL, false);
2ffca7b2:	2100      	movs	r1, #0
{
2ffca7b4:	466d      	mov	r5, sp
      HAL_DDR_Dump_Reg(NULL, false);
2ffca7b6:	4608      	mov	r0, r1
2ffca7b8:	f7f9 f970 	bl	2ffc3a9c <HAL_DDR_Dump_Reg>
  while (next_step == step)
2ffca7bc:	f8d4 b000 	ldr.w	fp, [r4]
2ffca7c0:	46ad      	mov	sp, r5
  for (i = 1; i < argc; i++)
2ffca7c2:	e5ce      	b.n	2ffca362 <HAL_DDR_Interactive+0x202>
      HAL_DDR_Dump_Reg(NULL, true);
2ffca7c4:	2101      	movs	r1, #1
2ffca7c6:	2000      	movs	r0, #0
2ffca7c8:	f7f9 f968 	bl	2ffc3a9c <HAL_DDR_Dump_Reg>
  while (next_step == step)
2ffca7cc:	f8d4 b000 	ldr.w	fp, [r4]
  for (i = 1; i < argc; i++)
2ffca7d0:	e5c7      	b.n	2ffca362 <HAL_DDR_Interactive+0x202>
2ffca7d2:	4ecf      	ldr	r6, [pc, #828]	@ (2ffcab10 <HAL_DDR_Interactive+0x9b0>)
        printf("%d:%s\n\r", i, step_str[i]);
2ffca7d4:	f24f 55bc 	movw	r5, #62908	@ 0xf5bc
2ffca7d8:	f6c2 75fc 	movt	r5, #12284	@ 0x2ffc
2ffca7dc:	f856 2b04 	ldr.w	r2, [r6], #4
2ffca7e0:	4659      	mov	r1, fp
2ffca7e2:	4628      	mov	r0, r5
      for (i = 0; i <= STEP_RUN; i++)
2ffca7e4:	f10b 0b01 	add.w	fp, fp, #1
        printf("%d:%s\n\r", i, step_str[i]);
2ffca7e8:	f001 f8ce 	bl	2ffcb988 <iprintf>
      for (i = 0; i <= STEP_RUN; i++)
2ffca7ec:	f1bb 0f05 	cmp.w	fp, #5
2ffca7f0:	d1f4      	bne.n	2ffca7dc <HAL_DDR_Interactive+0x67c>
      break;
2ffca7f2:	f8d7 b014 	ldr.w	fp, [r7, #20]
2ffca7f6:	2201      	movs	r2, #1
2ffca7f8:	623a      	str	r2, [r7, #32]
2ffca7fa:	465b      	mov	r3, fp
2ffca7fc:	e7bd      	b.n	2ffca77a <HAL_DDR_Interactive+0x61a>
      next_step = step + 1;
2ffca7fe:	f8d7 e014 	ldr.w	lr, [r7, #20]
2ffca802:	68bb      	ldr	r3, [r7, #8]
2ffca804:	f10e 0b01 	add.w	fp, lr, #1
2ffca808:	f8c3 b000 	str.w	fp, [r3]
  while (next_step == step)
2ffca80c:	e5ad      	b.n	2ffca36a <HAL_DDR_Interactive+0x20a>
    uint32_t name_len = argc;
2ffca80e:	6a3e      	ldr	r6, [r7, #32]
    for (i = 1; i < (argc - 1); i++)
2ffca810:	f04f 0901 	mov.w	r9, #1
      name_len += strlen(argv[i]) + 1;
2ffca814:	f855 0029 	ldr.w	r0, [r5, r9, lsl #2]
    for (i = 1; i < (argc - 1); i++)
2ffca818:	f109 0901 	add.w	r9, r9, #1
      name_len += strlen(argv[i]) + 1;
2ffca81c:	f001 faf1 	bl	2ffcbe02 <strlen>
    for (i = 1; i < (argc - 1); i++)
2ffca820:	45d1      	cmp	r9, sl
      name_len += strlen(argv[i]) + 1;
2ffca822:	f100 0301 	add.w	r3, r0, #1
2ffca826:	441e      	add	r6, r3
    for (i = 1; i < (argc - 1); i++)
2ffca828:	d3f4      	bcc.n	2ffca814 <HAL_DDR_Interactive+0x6b4>
    if (ddr_name)
2ffca82a:	f642 1968 	movw	r9, #10600	@ 0x2968
2ffca82e:	f6c2 79fd 	movt	r9, #12285	@ 0x2ffd
2ffca832:	f8d9 0000 	ldr.w	r0, [r9]
2ffca836:	b108      	cbz	r0, 2ffca83c <HAL_DDR_Interactive+0x6dc>
      free(ddr_name);
2ffca838:	f000 fda6 	bl	2ffcb388 <free>
    ddr_name = malloc(name_len);
2ffca83c:	4630      	mov	r0, r6
2ffca83e:	f000 fd9b 	bl	2ffcb378 <malloc>
2ffca842:	f8c9 0000 	str.w	r0, [r9]
    static_ddr_config.info.name = ddr_name;
2ffca846:	f241 731c 	movw	r3, #5916	@ 0x171c
2ffca84a:	f6c2 73fd 	movt	r3, #12285	@ 0x2ffd
    ddr_name = malloc(name_len);
2ffca84e:	4683      	mov	fp, r0
    static_ddr_config.info.name = ddr_name;
2ffca850:	6018      	str	r0, [r3, #0]
    if (!ddr_name)
2ffca852:	2800      	cmp	r0, #0
2ffca854:	f000 82e9 	beq.w	2ffcae2a <HAL_DDR_Interactive+0xcca>
    strcpy(ddr_name, argv[1]);
2ffca858:	6869      	ldr	r1, [r5, #4]
2ffca85a:	f001 fabd 	bl	2ffcbdd8 <strcpy>
    for (i = 2; i < (argc - 1); i++)
2ffca85e:	f1ba 0f02 	cmp.w	sl, #2
2ffca862:	d019      	beq.n	2ffca898 <HAL_DDR_Interactive+0x738>
2ffca864:	f24f 4334 	movw	r3, #62516	@ 0xf434
2ffca868:	f507 6288 	add.w	r2, r7, #1088	@ 0x440
2ffca86c:	f6c2 73fc 	movt	r3, #12284	@ 0x2ffc
2ffca870:	f207 464c 	addw	r6, r7, #1100	@ 0x44c
      strcat(ddr_name, " ");
2ffca874:	f8b3 a000 	ldrh.w	sl, [r3]
2ffca878:	6a3b      	ldr	r3, [r7, #32]
2ffca87a:	eb02 0983 	add.w	r9, r2, r3, lsl #2
2ffca87e:	4658      	mov	r0, fp
2ffca880:	f001 fabf 	bl	2ffcbe02 <strlen>
2ffca884:	f82b a000 	strh.w	sl, [fp, r0]
2ffca888:	3001      	adds	r0, #1
      strcat(ddr_name, argv[i]);
2ffca88a:	f856 1f04 	ldr.w	r1, [r6, #4]!
2ffca88e:	4458      	add	r0, fp
2ffca890:	f001 faa2 	bl	2ffcbdd8 <strcpy>
    for (i = 2; i < (argc - 1); i++)
2ffca894:	454e      	cmp	r6, r9
2ffca896:	d1f2      	bne.n	2ffca87e <HAL_DDR_Interactive+0x71e>
    printf("name = %s\n\r", ddr_name);
2ffca898:	f24f 30c8 	movw	r0, #62408	@ 0xf3c8
2ffca89c:	4659      	mov	r1, fp
2ffca89e:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca8a2:	f001 f871 	bl	2ffcb988 <iprintf>
  while (next_step == step)
2ffca8a6:	f8d4 b000 	ldr.w	fp, [r4]
  for (i = 1; i < argc; i++)
2ffca8aa:	e6d3      	b.n	2ffca654 <HAL_DDR_Interactive+0x4f4>
      printf("### Exit DDR INTERACTIVE mode. Please RESET the BOARD ###\n\r");
2ffca8ac:	f24f 5048 	movw	r0, #62792	@ 0xf548
      next_step = STEP_RUN;
2ffca8b0:	2304      	movs	r3, #4
      printf("### Exit DDR INTERACTIVE mode. Please RESET the BOARD ###\n\r");
2ffca8b2:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
      next_step = STEP_RUN;
2ffca8b6:	6023      	str	r3, [r4, #0]
      printf("### Exit DDR INTERACTIVE mode. Please RESET the BOARD ###\n\r");
2ffca8b8:	f001 f866 	bl	2ffcb988 <iprintf>
  while (next_step == step)
2ffca8bc:	f8d4 b000 	ldr.w	fp, [r4]
  for (i = 1; i < argc; i++)
2ffca8c0:	e54f      	b.n	2ffca362 <HAL_DDR_Interactive+0x202>
      HAL_DDR_Edit_Reg(argv[0], argv[1]);
2ffca8c2:	f8d7 144c 	ldr.w	r1, [r7, #1100]	@ 0x44c
2ffca8c6:	f8d7 0448 	ldr.w	r0, [r7, #1096]	@ 0x448
2ffca8ca:	f7f9 f9d9 	bl	2ffc3c80 <HAL_DDR_Edit_Reg>
  while (next_step == step)
2ffca8ce:	f8d4 b000 	ldr.w	fp, [r4]
  for (i = 1; i < argc; i++)
2ffca8d2:	e546      	b.n	2ffca362 <HAL_DDR_Interactive+0x202>
    printf("step = %d : %s\n\r", step, step_str[step]);
2ffca8d4:	6979      	ldr	r1, [r7, #20]
2ffca8d6:	f24f 30b4 	movw	r0, #62388	@ 0xf3b4
2ffca8da:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
    printf("name = %s\n\r", static_ddr_config.info.name);
2ffca8de:	f241 751c 	movw	r5, #5916	@ 0x171c
    printf("step = %d : %s\n\r", step, step_str[step]);
2ffca8e2:	eb04 0381 	add.w	r3, r4, r1, lsl #2
    printf("name = %s\n\r", static_ddr_config.info.name);
2ffca8e6:	f6c2 75fd 	movt	r5, #12285	@ 0x2ffd
    printf("step = %d : %s\n\r", step, step_str[step]);
2ffca8ea:	689a      	ldr	r2, [r3, #8]
2ffca8ec:	f001 f84c 	bl	2ffcb988 <iprintf>
    printf("name = %s\n\r", static_ddr_config.info.name);
2ffca8f0:	6829      	ldr	r1, [r5, #0]
2ffca8f2:	f24f 30c8 	movw	r0, #62408	@ 0xf3c8
2ffca8f6:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca8fa:	f001 f845 	bl	2ffcb988 <iprintf>
    printf("size = 0x%lx\n\r", static_ddr_config.info.size);
2ffca8fe:	68a9      	ldr	r1, [r5, #8]
2ffca900:	f24f 30d4 	movw	r0, #62420	@ 0xf3d4
2ffca904:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca908:	f001 f83e 	bl	2ffcb988 <iprintf>
    printf("speed = %ld kHz\n\r", static_ddr_config.info.speed);
2ffca90c:	6869      	ldr	r1, [r5, #4]
2ffca90e:	f24f 30e4 	movw	r0, #62436	@ 0xf3e4
2ffca912:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca916:	f001 f837 	bl	2ffcb988 <iprintf>
  while (next_step == step)
2ffca91a:	f8d4 b000 	ldr.w	fp, [r4]
  for (i = 1; i < argc; i++)
2ffca91e:	e520      	b.n	2ffca362 <HAL_DDR_Interactive+0x202>
    HAL_DDR_Convert_Case(argv[0], reg_name, 1); /* convert to upper case */
2ffca920:	4630      	mov	r0, r6
2ffca922:	4651      	mov	r1, sl
2ffca924:	2201      	movs	r2, #1
2ffca926:	f7f9 f895 	bl	2ffc3a54 <HAL_DDR_Convert_Case>
    if (HAL_DDR_Dump_Param(&static_ddr_config, reg_name) != HAL_OK)
2ffca92a:	f241 701c 	movw	r0, #5916	@ 0x171c
2ffca92e:	4651      	mov	r1, sl
2ffca930:	f6c2 70fd 	movt	r0, #12285	@ 0x2ffd
2ffca934:	f7f9 fa10 	bl	2ffc3d58 <HAL_DDR_Dump_Param>
2ffca938:	2800      	cmp	r0, #0
2ffca93a:	f43f ae26 	beq.w	2ffca58a <HAL_DDR_Interactive+0x42a>
      printf("invalid argument %s\n\r", argv[0]);
2ffca93e:	f24f 4074 	movw	r0, #62580	@ 0xf474
2ffca942:	4631      	mov	r1, r6
2ffca944:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca948:	f001 f81e 	bl	2ffcb988 <iprintf>
2ffca94c:	e61d      	b.n	2ffca58a <HAL_DDR_Interactive+0x42a>
    switch (local_argc - 2)
2ffca94e:	6a3b      	ldr	r3, [r7, #32]
2ffca950:	3b02      	subs	r3, #2
2ffca952:	2b03      	cmp	r3, #3
2ffca954:	f200 811a 	bhi.w	2ffcab8c <HAL_DDR_Interactive+0xa2c>
2ffca958:	e8df f013 	tbh	[pc, r3, lsl #1]
2ffca95c:	01120110 	.word	0x01120110
2ffca960:	01160114 	.word	0x01160114
      HAL_DDR_Edit_Reg(argv[0], argv[1]);
2ffca964:	6869      	ldr	r1, [r5, #4]
2ffca966:	4630      	mov	r0, r6
2ffca968:	f7f9 f98a 	bl	2ffc3c80 <HAL_DDR_Edit_Reg>
  while (next_step == step)
2ffca96c:	f8d4 b000 	ldr.w	fp, [r4]
  for (i = 1; i < argc; i++)
2ffca970:	e4f7      	b.n	2ffca362 <HAL_DDR_Interactive+0x202>
      value = strtoll(argv[0], &end_ptr, 0);
2ffca972:	2200      	movs	r2, #0
2ffca974:	f107 0138 	add.w	r1, r7, #56	@ 0x38
2ffca978:	4630      	mov	r0, r6
2ffca97a:	f000 ff2b 	bl	2ffcb7d4 <strtoll>
      if ((end_ptr == argv[0]) || (value > STEP_RUN))
2ffca97e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
2ffca980:	2804      	cmp	r0, #4
2ffca982:	bf94      	ite	ls
2ffca984:	2300      	movls	r3, #0
2ffca986:	2301      	movhi	r3, #1
      value = strtoll(argv[0], &end_ptr, 0);
2ffca988:	4683      	mov	fp, r0
      if ((end_ptr == argv[0]) || (value > STEP_RUN))
2ffca98a:	42b2      	cmp	r2, r6
2ffca98c:	bf08      	it	eq
2ffca98e:	f043 0301 	orreq.w	r3, r3, #1
2ffca992:	2b00      	cmp	r3, #0
2ffca994:	f040 80ea 	bne.w	2ffcab6c <HAL_DDR_Interactive+0xa0c>
        printf("invalid target %d:%s, current step is %d:%s\n\r",
2ffca998:	eb04 0380 	add.w	r3, r4, r0, lsl #2
2ffca99c:	689a      	ldr	r2, [r3, #8]
      if ((value != STEP_DDR_RESET) && (value <= step))
2ffca99e:	b118      	cbz	r0, 2ffca9a8 <HAL_DDR_Interactive+0x848>
2ffca9a0:	693b      	ldr	r3, [r7, #16]
2ffca9a2:	4298      	cmp	r0, r3
2ffca9a4:	f240 8186 	bls.w	2ffcacb4 <HAL_DDR_Interactive+0xb54>
      printf("step to %d:%s\n\r", (int)value, step_str[value]);
2ffca9a8:	f24f 50b4 	movw	r0, #62900	@ 0xf5b4
2ffca9ac:	4659      	mov	r1, fp
2ffca9ae:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
      next_step = do_step(step, argc, argv);
2ffca9b2:	fa5f fb8b 	uxtb.w	fp, fp
      printf("step to %d:%s\n\r", (int)value, step_str[value]);
2ffca9b6:	f000 ffe7 	bl	2ffcb988 <iprintf>
      next_step = do_step(step, argc, argv);
2ffca9ba:	f8c4 b000 	str.w	fp, [r4]
  for (i = 1; i < argc; i++)
2ffca9be:	e649      	b.n	2ffca654 <HAL_DDR_Interactive+0x4f4>
    printf("Unknown sub command [%s]\n\r\n\r", argv[0]);
2ffca9c0:	f24f 50ec 	movw	r0, #62956	@ 0xf5ec
2ffca9c4:	4631      	mov	r1, r6
2ffca9c6:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffca9ca:	f000 ffdd 	bl	2ffcb988 <iprintf>
    print_subcmd_usage(array, size);
2ffca9ce:	f7ff fba1 	bl	2ffca114 <print_subcmd_usage.constprop.0>
    return;
2ffca9d2:	e5db      	b.n	2ffca58c <HAL_DDR_Interactive+0x42c>
  while (next_step == step)
2ffca9d4:	46f3      	mov	fp, lr
2ffca9d6:	e4c8      	b.n	2ffca36a <HAL_DDR_Interactive+0x20a>
  switch (__HAL_RCC_GET_PLL12_SOURCE())
2ffca9d8:	eddf 0b4b 	vldr	d16, [pc, #300]	@ 2ffcab08 <HAL_DDR_Interactive+0x9a8>
  PLL2.PLLR = ((READ_REG(RCC->PLL2CFGR2) & RCC_PLL2CFGR2_DIVR) >>
2ffca9dc:	f3c2 4306 	ubfx	r3, r2, #16, #7
  PLL2.PLLM = ((READ_REG(RCC->PLL2CFGR1) & RCC_PLL2CFGR1_DIVM2) >>
2ffca9e0:	f3c0 4a05 	ubfx	sl, r0, #16, #6
  div_res = lldiv(value, fck_ref);
2ffca9e4:	f107 0038 	add.w	r0, r7, #56	@ 0x38
               RCC_PLL2CFGR1_DIVM2_Pos) + 1U;
2ffca9e8:	f10a 0201 	add.w	r2, sl, #1
  div_res = lldiv(value, fck_ref);
2ffca9ec:	edcd 0b00 	vstr	d16, [sp]
  PLL2.PLLR = ((READ_REG(RCC->PLL2CFGR2) & RCC_PLL2CFGR2_DIVR) >>
2ffca9f0:	603b      	str	r3, [r7, #0]
               RCC_PLL2CFGR2_DIVR_Pos) + 1U;
2ffca9f2:	3301      	adds	r3, #1
  value = (pll2_clk_rate * PLL2.PLLR * PLL2.PLLM) << 13;
2ffca9f4:	fba3 3602 	umull	r3, r6, r3, r2
2ffca9f8:	fba3 2301 	umull	r2, r3, r3, r1
2ffca9fc:	fb01 3306 	mla	r3, r1, r6, r3
2ffcaa00:	035b      	lsls	r3, r3, #13
  div_res = lldiv(value, fck_ref);
2ffcaa02:	ea43 43d2 	orr.w	r3, r3, r2, lsr #19
2ffcaa06:	0352      	lsls	r2, r2, #13
2ffcaa08:	f000 feee 	bl	2ffcb7e8 <lldiv>
  value = div_res.quot;
2ffcaa0c:	e9d7 630e 	ldrd	r6, r3, [r7, #56]	@ 0x38
  PLL2.PLLN = value >> 13;
2ffcaa10:	0b71      	lsrs	r1, r6, #13
2ffcaa12:	ea41 41c3 	orr.w	r1, r1, r3, lsl #19
  if ((PLL2.PLLN < UTIL_PLL2_DIVN_MIN) || (PLL2.PLLN > UTIL_PLL2_DIVN_MAX))
2ffcaa16:	f1a1 0318 	sub.w	r3, r1, #24
2ffcaa1a:	2baf      	cmp	r3, #175	@ 0xaf
2ffcaa1c:	f200 81b0 	bhi.w	2ffcad80 <HAL_DDR_Interactive+0xc20>
2ffcaa20:	61f9      	str	r1, [r7, #28]
  __HAL_RCC_PLL2CLKOUT_DISABLE(RCC_PLL2_DIVP | RCC_PLL2_DIVQ | RCC_PLL2_DIVR);
2ffcaa22:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffcaa26:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
2ffcaa2a:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
2ffcaa2e:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
  __HAL_RCC_PLL2_DISABLE();
2ffcaa32:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
2ffcaa36:	f022 0201 	bic.w	r2, r2, #1
2ffcaa3a:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
  tickstart = HAL_GetTick();
2ffcaa3e:	f7f8 fd85 	bl	2ffc354c <HAL_GetTick>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != RESET)
2ffcaa42:	69f9      	ldr	r1, [r7, #28]
2ffcaa44:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffcaa48:	627d      	str	r5, [r7, #36]	@ 0x24
2ffcaa4a:	61fc      	str	r4, [r7, #28]
2ffcaa4c:	460d      	mov	r5, r1
2ffcaa4e:	4604      	mov	r4, r0
2ffcaa50:	e007      	b.n	2ffcaa62 <HAL_DDR_Interactive+0x902>
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffcaa52:	f7f8 fd7b 	bl	2ffc354c <HAL_GetTick>
2ffcaa56:	1b00      	subs	r0, r0, r4
2ffcaa58:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffcaa5c:	2864      	cmp	r0, #100	@ 0x64
2ffcaa5e:	f200 8120 	bhi.w	2ffcaca2 <HAL_DDR_Interactive+0xb42>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != RESET)
2ffcaa62:	f8d3 0094 	ldr.w	r0, [r3, #148]	@ 0x94
2ffcaa66:	0782      	lsls	r2, r0, #30
2ffcaa68:	d4f3      	bmi.n	2ffcaa52 <HAL_DDR_Interactive+0x8f2>
  __HAL_RCC_PLL2_CONFIG(
2ffcaa6a:	687a      	ldr	r2, [r7, #4]
2ffcaa6c:	4629      	mov	r1, r5
2ffcaa6e:	f8d3 e098 	ldr.w	lr, [r3, #152]	@ 0x98
2ffcaa72:	6a7d      	ldr	r5, [r7, #36]	@ 0x24
2ffcaa74:	f402 4cfe 	and.w	ip, r2, #32512	@ 0x7f00
  PLL2.PLLP = ((READ_REG(RCC->PLL2CFGR2) & RCC_PLL2CFGR2_DIVP) >>
2ffcaa78:	69ba      	ldr	r2, [r7, #24]
  PLL2.PLLFRACV = value - (PLL2.PLLN << 13);
2ffcaa7a:	eba6 3641 	sub.w	r6, r6, r1, lsl #13
  __HAL_RCC_PLL2_CONFIG(
2ffcaa7e:	3901      	subs	r1, #1
2ffcaa80:	69fc      	ldr	r4, [r7, #28]
  PLL2.PLLP = ((READ_REG(RCC->PLL2CFGR2) & RCC_PLL2CFGR2_DIVP) >>
2ffcaa82:	f002 007f 	and.w	r0, r2, #127	@ 0x7f
  __HAL_RCC_PLL2_CONFIG(
2ffcaa86:	f44f 427e 	mov.w	r2, #65024	@ 0xfe00
2ffcaa8a:	f6cf 72c0 	movt	r2, #65472	@ 0xffc0
2ffcaa8e:	ea0e 0202 	and.w	r2, lr, r2
2ffcaa92:	ea42 420a 	orr.w	r2, r2, sl, lsl #16
2ffcaa96:	430a      	orrs	r2, r1
2ffcaa98:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
2ffcaa9c:	f8d3 209c 	ldr.w	r2, [r3, #156]	@ 0x9c
2ffcaaa0:	6839      	ldr	r1, [r7, #0]
2ffcaaa2:	f022 127f 	bic.w	r2, r2, #8323199	@ 0x7f007f
2ffcaaa6:	f422 42fe 	bic.w	r2, r2, #32512	@ 0x7f00
2ffcaaaa:	ea42 020c 	orr.w	r2, r2, ip
2ffcaaae:	4302      	orrs	r2, r0
2ffcaab0:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
2ffcaab4:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
  __HAL_RCC_PLL2FRACV_DISABLE();
2ffcaab8:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
2ffcaabc:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
2ffcaac0:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
  __HAL_RCC_PLL2FRACV_CONFIG(PLL2.PLLFRACV);
2ffcaac4:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
2ffcaac8:	f422 427f 	bic.w	r2, r2, #65280	@ 0xff00
2ffcaacc:	f022 02f8 	bic.w	r2, r2, #248	@ 0xf8
2ffcaad0:	ea42 02c6 	orr.w	r2, r2, r6, lsl #3
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == RESET)
2ffcaad4:	f04f 46a0 	mov.w	r6, #1342177280	@ 0x50000000
  __HAL_RCC_PLL2FRACV_CONFIG(PLL2.PLLFRACV);
2ffcaad8:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
  __HAL_RCC_PLL2FRACV_ENABLE();
2ffcaadc:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
2ffcaae0:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
2ffcaae4:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
  __HAL_RCC_PLL2_SSMODE_DISABLE();
2ffcaae8:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
2ffcaaec:	f022 0204 	bic.w	r2, r2, #4
2ffcaaf0:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
  __HAL_RCC_PLL2_ENABLE();
2ffcaaf4:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
2ffcaaf8:	f042 0201 	orr.w	r2, r2, #1
2ffcaafc:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
  tickstart = HAL_GetTick();
2ffcab00:	f7f8 fd24 	bl	2ffc354c <HAL_GetTick>
2ffcab04:	4682      	mov	sl, r0
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == RESET)
2ffcab06:	e00c      	b.n	2ffcab22 <HAL_DDR_Interactive+0x9c2>
2ffcab08:	016e3600 	.word	0x016e3600
2ffcab0c:	00000000 	.word	0x00000000
2ffcab10:	2ffd1888 	.word	0x2ffd1888
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2ffcab14:	f7f8 fd1a 	bl	2ffc354c <HAL_GetTick>
2ffcab18:	eba0 030a 	sub.w	r3, r0, sl
2ffcab1c:	2b64      	cmp	r3, #100	@ 0x64
2ffcab1e:	f200 8136 	bhi.w	2ffcad8e <HAL_DDR_Interactive+0xc2e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == RESET)
2ffcab22:	f8d6 3094 	ldr.w	r3, [r6, #148]	@ 0x94
2ffcab26:	079b      	lsls	r3, r3, #30
2ffcab28:	d5f4      	bpl.n	2ffcab14 <HAL_DDR_Interactive+0x9b4>
  __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP | RCC_PLL2_DIVQ | RCC_PLL2_DIVR);
2ffcab2a:	f8d6 3094 	ldr.w	r3, [r6, #148]	@ 0x94
      HAL_DDR_ASS_Set_Clksrc(HAL_DDR_CLK_AXI_PLL2);
2ffcab2e:	2002      	movs	r0, #2
  __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP | RCC_PLL2_DIVQ | RCC_PLL2_DIVR);
2ffcab30:	f043 0370 	orr.w	r3, r3, #112	@ 0x70
2ffcab34:	f8c6 3094 	str.w	r3, [r6, #148]	@ 0x94
      HAL_DDR_ASS_Set_Clksrc(HAL_DDR_CLK_AXI_PLL2);
2ffcab38:	f7f8 ff58 	bl	2ffc39ec <HAL_DDR_ASS_Set_Clksrc>
  HAL_RCC_GetPLL2ClockFreq(&PLL2);
2ffcab3c:	4648      	mov	r0, r9
2ffcab3e:	f7fb fc8f 	bl	2ffc6460 <HAL_RCC_GetPLL2ClockFreq>
  printf("DDRPHY = %ld kHz\n\r", PLL2.PLL2_R_Frequency / 1000);
2ffcab42:	f8d9 1008 	ldr.w	r1, [r9, #8]
2ffcab46:	f644 53d3 	movw	r3, #19923	@ 0x4dd3
2ffcab4a:	f2c1 0362 	movt	r3, #4194	@ 0x1062
2ffcab4e:	f24f 4048 	movw	r0, #62536	@ 0xf448
2ffcab52:	fba3 3101 	umull	r3, r1, r3, r1
2ffcab56:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcab5a:	0989      	lsrs	r1, r1, #6
2ffcab5c:	f000 ff14 	bl	2ffcb988 <iprintf>
        next_step = STEP_DDR_RESET;
2ffcab60:	2300      	movs	r3, #0
2ffcab62:	6023      	str	r3, [r4, #0]
2ffcab64:	e576      	b.n	2ffca654 <HAL_DDR_Interactive+0x4f4>
  switch (__HAL_RCC_GET_PLL12_SOURCE())
2ffcab66:	eddf 0bce 	vldr	d16, [pc, #824]	@ 2ffcaea0 <HAL_DDR_Interactive+0xd40>
2ffcab6a:	e737      	b.n	2ffca9dc <HAL_DDR_Interactive+0x87c>
        printf("invalid argument %s\n\r", argv[1]);
2ffcab6c:	6869      	ldr	r1, [r5, #4]
2ffcab6e:	f24f 4074 	movw	r0, #62580	@ 0xf474
2ffcab72:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcab76:	f000 ff07 	bl	2ffcb988 <iprintf>
        goto end;
2ffcab7a:	e494      	b.n	2ffca4a6 <HAL_DDR_Interactive+0x346>
      argv[1] = arg_zero;
2ffcab7c:	f8c5 9004 	str.w	r9, [r5, #4]
      argv[2] = arg_zero;
2ffcab80:	f8c5 9008 	str.w	r9, [r5, #8]
      argv[3] = arg_zero;
2ffcab84:	f8c5 900c 	str.w	r9, [r5, #12]
      local_argc = array[value].max_args + 2;
2ffcab88:	1c88      	adds	r0, r1, #2
      break;
2ffcab8a:	e5b5      	b.n	2ffca6f8 <HAL_DDR_Interactive+0x598>
  if ((uint8_t)(local_argc - 2) != array[value].max_args)
2ffcab8c:	29fd      	cmp	r1, #253	@ 0xfd
2ffcab8e:	f000 80d9 	beq.w	2ffcad44 <HAL_DDR_Interactive+0xbe4>
    printf("Incorrect number of arguments\n\r\n\r");
2ffcab92:	f24f 600c 	movw	r0, #62988	@ 0xf60c
2ffcab96:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcab9a:	f000 fef5 	bl	2ffcb988 <iprintf>
      printf("  %2d: %s %s\n\r", i, array[i].name, array[i].usage);
2ffcab9e:	6a79      	ldr	r1, [r7, #36]	@ 0x24
2ffcaba0:	f64e 60c0 	movw	r0, #61120	@ 0xeec0
2ffcaba4:	f8db 3008 	ldr.w	r3, [fp, #8]
2ffcaba8:	f8db 2004 	ldr.w	r2, [fp, #4]
2ffcabac:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcabb0:	f000 feea 	bl	2ffcb988 <iprintf>
      printf("          %s\n\r", array[i].help);
2ffcabb4:	f8db 100c 	ldr.w	r1, [fp, #12]
2ffcabb8:	f64e 60d0 	movw	r0, #61136	@ 0xeed0
2ffcabbc:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcabc0:	f000 fee2 	bl	2ffcb988 <iprintf>
}
2ffcabc4:	e4e2      	b.n	2ffca58c <HAL_DDR_Interactive+0x42c>
    printf("%s: too many arguments (max=%d)\n\r", ddr_cmd[*command].str,
2ffcabc6:	f8d3 1154 	ldr.w	r1, [r3, #340]	@ 0x154
2ffcabca:	f64e 7038 	movw	r0, #61240	@ 0xef38
2ffcabce:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcabd2:	f000 fed9 	bl	2ffcb988 <iprintf>
    return -4;
2ffcabd6:	f06f 0103 	mvn.w	r1, #3
2ffcabda:	f7ff bbba 	b.w	2ffca352 <HAL_DDR_Interactive+0x1f2>
    printf("%s: argument missing (min=%d)\n\r", ddr_cmd[*command].str,
2ffcabde:	f8d3 1154 	ldr.w	r1, [r3, #340]	@ 0x154
2ffcabe2:	f64e 7018 	movw	r0, #61208	@ 0xef18
2ffcabe6:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcabea:	f000 fecd 	bl	2ffcb988 <iprintf>
    return -3;
2ffcabee:	f06f 0102 	mvn.w	r1, #2
2ffcabf2:	f7ff bbae 	b.w	2ffca352 <HAL_DDR_Interactive+0x1f2>
    printf("invalid step %d:%s expecting %d:%s\n\r",
2ffcabf6:	6979      	ldr	r1, [r7, #20]
2ffcabf8:	f24f 5020 	movw	r0, #62752	@ 0xf520
2ffcabfc:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcac00:	eb04 0381 	add.w	r3, r4, r1, lsl #2
2ffcac04:	689a      	ldr	r2, [r3, #8]
2ffcac06:	68a3      	ldr	r3, [r4, #8]
2ffcac08:	9300      	str	r3, [sp, #0]
2ffcac0a:	2300      	movs	r3, #0
2ffcac0c:	f000 febc 	bl	2ffcb988 <iprintf>
  while (next_step == step)
2ffcac10:	f8d4 b000 	ldr.w	fp, [r4]
      return;
2ffcac14:	46cd      	mov	sp, r9
  for (i = 1; i < argc; i++)
2ffcac16:	e51d      	b.n	2ffca654 <HAL_DDR_Interactive+0x4f4>
    printf("not enough parameters\n\r");
2ffcac18:	f24f 30f8 	movw	r0, #62456	@ 0xf3f8
2ffcac1c:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcac20:	f000 feb2 	bl	2ffcb988 <iprintf>
  while (next_step == step)
2ffcac24:	f8d4 b000 	ldr.w	fp, [r4]
2ffcac28:	e514      	b.n	2ffca654 <HAL_DDR_Interactive+0x4f4>
    value = strtoll(argv[1], &end_ptr, 10);
2ffcac2a:	686e      	ldr	r6, [r5, #4]
2ffcac2c:	220a      	movs	r2, #10
2ffcac2e:	f107 012c 	add.w	r1, r7, #44	@ 0x2c
2ffcac32:	4630      	mov	r0, r6
2ffcac34:	f000 fdce 	bl	2ffcb7d4 <strtoll>
    if (end_ptr == argv[1])
2ffcac38:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    value = strtoll(argv[1], &end_ptr, 10);
2ffcac3a:	4601      	mov	r1, r0
    if (end_ptr == argv[1])
2ffcac3c:	429e      	cmp	r6, r3
2ffcac3e:	f000 810f 	beq.w	2ffcae60 <HAL_DDR_Interactive+0xd00>
      static_ddr_config.info.speed = value;
2ffcac42:	f241 731c 	movw	r3, #5916	@ 0x171c
2ffcac46:	f6c2 73fd 	movt	r3, #12285	@ 0x2ffd
2ffcac4a:	6058      	str	r0, [r3, #4]
      printf("speed = %ld kHz\n\r", static_ddr_config.info.speed);
2ffcac4c:	f24f 30e4 	movw	r0, #62436	@ 0xf3e4
2ffcac50:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcac54:	f000 fe98 	bl	2ffcb988 <iprintf>
      HAL_RCC_GetPLL2ClockFreq(&PLL2);
2ffcac58:	f107 0038 	add.w	r0, r7, #56	@ 0x38
2ffcac5c:	f7fb fc00 	bl	2ffc6460 <HAL_RCC_GetPLL2ClockFreq>
      printf("DDRPHY = %ld kHz\n\r", value / 1000);
2ffcac60:	6c39      	ldr	r1, [r7, #64]	@ 0x40
2ffcac62:	e4e2      	b.n	2ffca62a <HAL_DDR_Interactive+0x4ca>
    value = strtoll(argv[1], &end_ptr, 16);
2ffcac64:	686e      	ldr	r6, [r5, #4]
2ffcac66:	2210      	movs	r2, #16
2ffcac68:	f107 012c 	add.w	r1, r7, #44	@ 0x2c
2ffcac6c:	4630      	mov	r0, r6
2ffcac6e:	f000 fdb1 	bl	2ffcb7d4 <strtoll>
    if (end_ptr == argv[1])
2ffcac72:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    value = strtoll(argv[1], &end_ptr, 16);
2ffcac74:	4601      	mov	r1, r0
    if (end_ptr == argv[1])
2ffcac76:	429e      	cmp	r6, r3
      static_ddr_config.info.size = value;
2ffcac78:	bf17      	itett	ne
2ffcac7a:	f241 731c 	movwne	r3, #5916	@ 0x171c
      printf("invalid value %s\n\r", argv[1]);
2ffcac7e:	f24e 1050 	movweq	r0, #57680	@ 0xe150
      static_ddr_config.info.size = value;
2ffcac82:	f6c2 73fd 	movtne	r3, #12285	@ 0x2ffd
      printf("size = 0x%lx\n\r", static_ddr_config.info.size);
2ffcac86:	f24f 30d4 	movwne	r0, #62420	@ 0xf3d4
      printf("invalid value %s\n\r", argv[1]);
2ffcac8a:	bf07      	ittee	eq
2ffcac8c:	f6c2 70fc 	movteq	r0, #12284	@ 0x2ffc
2ffcac90:	4631      	moveq	r1, r6
      printf("size = 0x%lx\n\r", static_ddr_config.info.size);
2ffcac92:	f6c2 70fc 	movtne	r0, #12284	@ 0x2ffc
      static_ddr_config.info.size = value;
2ffcac96:	6099      	strne	r1, [r3, #8]
      printf("size = 0x%lx\n\r", static_ddr_config.info.size);
2ffcac98:	f000 fe76 	bl	2ffcb988 <iprintf>
  while (next_step == step)
2ffcac9c:	f8d4 b000 	ldr.w	fp, [r4]
  for (i = 1; i < argc; i++)
2ffcaca0:	e4d8      	b.n	2ffca654 <HAL_DDR_Interactive+0x4f4>
      printf("PLL2 stop timeout\n\r");
2ffcaca2:	6a7d      	ldr	r5, [r7, #36]	@ 0x24
2ffcaca4:	f24f 40f4 	movw	r0, #62708	@ 0xf4f4
2ffcaca8:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcacac:	69fc      	ldr	r4, [r7, #28]
2ffcacae:	f000 fe6b 	bl	2ffcb988 <iprintf>
      return false;
2ffcacb2:	e4b2      	b.n	2ffca61a <HAL_DDR_Interactive+0x4ba>
        printf("invalid target %d:%s, current step is %d:%s\n\r",
2ffcacb4:	697e      	ldr	r6, [r7, #20]
2ffcacb6:	4601      	mov	r1, r0
2ffcacb8:	f24f 5084 	movw	r0, #62852	@ 0xf584
2ffcacbc:	eb04 0386 	add.w	r3, r4, r6, lsl #2
2ffcacc0:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcacc4:	689b      	ldr	r3, [r3, #8]
2ffcacc6:	9300      	str	r3, [sp, #0]
2ffcacc8:	4633      	mov	r3, r6
2ffcacca:	f000 fe5d 	bl	2ffcb988 <iprintf>
        goto end;
2ffcacce:	f7ff bbea 	b.w	2ffca4a6 <HAL_DDR_Interactive+0x346>
      retcode = array[value].fct((uint32_t)string_to_num(argv[1]),
2ffcacd2:	686e      	ldr	r6, [r5, #4]
  uint64_t val = strtoul(string, &end_ptr, 0);
2ffcacd4:	f107 0138 	add.w	r1, r7, #56	@ 0x38
      retcode = array[value].fct((uint32_t)string_to_num(argv[1]),
2ffcacd8:	68fb      	ldr	r3, [r7, #12]
  uint64_t val = strtoul(string, &end_ptr, 0);
2ffcacda:	4630      	mov	r0, r6
      retcode = array[value].fct((uint32_t)string_to_num(argv[1]),
2ffcacdc:	f853 a002 	ldr.w	sl, [r3, r2]
  uint64_t val = strtoul(string, &end_ptr, 0);
2ffcace0:	2200      	movs	r2, #0
2ffcace2:	f000 fcdf 	bl	2ffcb6a4 <strtoul>
  if (end_ptr == string)
2ffcace6:	6bba      	ldr	r2, [r7, #56]	@ 0x38
  uint64_t val = strtoul(string, &end_ptr, 0);
2ffcace8:	f107 0138 	add.w	r1, r7, #56	@ 0x38
                                (uint32_t)string_to_num(argv[2]),
2ffcacec:	68ab      	ldr	r3, [r5, #8]
  uint64_t val = strtoul(string, &end_ptr, 0);
2ffcacee:	4296      	cmp	r6, r2
2ffcacf0:	bf08      	it	eq
2ffcacf2:	f04f 30ff 	moveq.w	r0, #4294967295	@ 0xffffffff
2ffcacf6:	2200      	movs	r2, #0
2ffcacf8:	6278      	str	r0, [r7, #36]	@ 0x24
2ffcacfa:	4618      	mov	r0, r3
2ffcacfc:	61fb      	str	r3, [r7, #28]
2ffcacfe:	f000 fcd1 	bl	2ffcb6a4 <strtoul>
                                (uint32_t)string_to_num(argv[3]));
2ffcad02:	68ee      	ldr	r6, [r5, #12]
  uint64_t val = strtoul(string, &end_ptr, 0);
2ffcad04:	f107 0138 	add.w	r1, r7, #56	@ 0x38
  if (end_ptr == string)
2ffcad08:	6bba      	ldr	r2, [r7, #56]	@ 0x38
2ffcad0a:	69fb      	ldr	r3, [r7, #28]
2ffcad0c:	4293      	cmp	r3, r2
2ffcad0e:	bf14      	ite	ne
2ffcad10:	4681      	movne	r9, r0
2ffcad12:	f04f 39ff 	moveq.w	r9, #4294967295	@ 0xffffffff
  uint64_t val = strtoul(string, &end_ptr, 0);
2ffcad16:	2200      	movs	r2, #0
2ffcad18:	4630      	mov	r0, r6
2ffcad1a:	f000 fcc3 	bl	2ffcb6a4 <strtoul>
  if (end_ptr == string)
2ffcad1e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
      retcode = array[value].fct((uint32_t)string_to_num(argv[1]),
2ffcad20:	4649      	mov	r1, r9
2ffcad22:	4296      	cmp	r6, r2
2ffcad24:	bf14      	ite	ne
2ffcad26:	4602      	movne	r2, r0
2ffcad28:	f04f 32ff 	moveq.w	r2, #4294967295	@ 0xffffffff
2ffcad2c:	6a78      	ldr	r0, [r7, #36]	@ 0x24
2ffcad2e:	47d0      	blx	sl
    printf("Result: Pass [%s]\n\r", array[value].name);
2ffcad30:	f8db 1004 	ldr.w	r1, [fp, #4]
  if (retcode != 0)
2ffcad34:	b980      	cbnz	r0, 2ffcad58 <HAL_DDR_Interactive+0xbf8>
    printf("Result: Pass [%s]\n\r", array[value].name);
2ffcad36:	f24f 6070 	movw	r0, #63088	@ 0xf670
2ffcad3a:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcad3e:	f000 fe23 	bl	2ffcb988 <iprintf>
2ffcad42:	e423      	b.n	2ffca58c <HAL_DDR_Interactive+0x42c>
      printf("Number of arguments not supported\n\r");
2ffcad44:	f24f 604c 	movw	r0, #63052	@ 0xf64c
2ffcad48:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcad4c:	f000 fe1c 	bl	2ffcb988 <iprintf>
  if (retcode != 0)
2ffcad50:	f8db 1004 	ldr.w	r1, [fp, #4]
      retcode = 0XFFFFFFFF;
2ffcad54:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    printf("%s failed [%ld]\n\r", array[value].name, retcode);
2ffcad58:	4602      	mov	r2, r0
2ffcad5a:	f64e 6084 	movw	r0, #61060	@ 0xee84
2ffcad5e:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcad62:	f000 fe11 	bl	2ffcb988 <iprintf>
    return;
2ffcad66:	e411      	b.n	2ffca58c <HAL_DDR_Interactive+0x42c>
      printf("Invalid argument #%d %s\n\r\n\r", i, argv[i]);
2ffcad68:	465b      	mov	r3, fp
2ffcad6a:	f24f 6030 	movw	r0, #63024	@ 0xf630
2ffcad6e:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcad72:	461a      	mov	r2, r3
2ffcad74:	4631      	mov	r1, r6
2ffcad76:	e9d7 4b06 	ldrd	r4, fp, [r7, #24]
2ffcad7a:	f000 fe05 	bl	2ffcb988 <iprintf>
2ffcad7e:	e70e      	b.n	2ffcab9e <HAL_DDR_Interactive+0xa3e>
    printf("PLL2.PLLN invalid = %d\n\r", (int)PLL2.PLLN);
2ffcad80:	f24f 40d8 	movw	r0, #62680	@ 0xf4d8
2ffcad84:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcad88:	f000 fdfe 	bl	2ffcb988 <iprintf>
    return false;
2ffcad8c:	e445      	b.n	2ffca61a <HAL_DDR_Interactive+0x4ba>
      printf("PLL2 start timeout\n\r");
2ffcad8e:	f24f 5008 	movw	r0, #62728	@ 0xf508
2ffcad92:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcad96:	f000 fdf7 	bl	2ffcb988 <iprintf>
      return false;
2ffcad9a:	e43e      	b.n	2ffca61a <HAL_DDR_Interactive+0x4ba>
      printf("Same frequency, no change.\n\r");
2ffcad9c:	f24f 408c 	movw	r0, #62604	@ 0xf48c
2ffcada0:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcada4:	f000 fdf0 	bl	2ffcb988 <iprintf>
  for (i = 1; i < argc; i++)
2ffcada8:	e6da      	b.n	2ffcab60 <HAL_DDR_Interactive+0xa00>
      printf("invalid argument %s\n\r", argv[0]);
2ffcadaa:	f24f 4074 	movw	r0, #62580	@ 0xf474
2ffcadae:	4631      	mov	r1, r6
2ffcadb0:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcadb4:	f000 fde8 	bl	2ffcb988 <iprintf>
  while (next_step == step)
2ffcadb8:	f8d4 b000 	ldr.w	fp, [r4]
2ffcadbc:	e44a      	b.n	2ffca654 <HAL_DDR_Interactive+0x4f4>
      retcode = array[value].fct((uint32_t)string_to_num(argv[1]),
2ffcadbe:	68fb      	ldr	r3, [r7, #12]
  uint64_t val = strtoul(string, &end_ptr, 0);
2ffcadc0:	f107 0138 	add.w	r1, r7, #56	@ 0x38
      retcode = array[value].fct((uint32_t)string_to_num(argv[1]),
2ffcadc4:	f8d5 9004 	ldr.w	r9, [r5, #4]
2ffcadc8:	f853 a002 	ldr.w	sl, [r3, r2]
  uint64_t val = strtoul(string, &end_ptr, 0);
2ffcadcc:	2200      	movs	r2, #0
2ffcadce:	4648      	mov	r0, r9
2ffcadd0:	f000 fc68 	bl	2ffcb6a4 <strtoul>
  if (end_ptr == string)
2ffcadd4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
  uint64_t val = strtoul(string, &end_ptr, 0);
2ffcadd6:	f107 0138 	add.w	r1, r7, #56	@ 0x38
                                (uint32_t)string_to_num(argv[2]));
2ffcadda:	68ae      	ldr	r6, [r5, #8]
  uint64_t val = strtoul(string, &end_ptr, 0);
2ffcaddc:	2200      	movs	r2, #0
2ffcadde:	4599      	cmp	r9, r3
2ffcade0:	bf08      	it	eq
2ffcade2:	f04f 30ff 	moveq.w	r0, #4294967295	@ 0xffffffff
2ffcade6:	6278      	str	r0, [r7, #36]	@ 0x24
2ffcade8:	4630      	mov	r0, r6
2ffcadea:	f000 fc5b 	bl	2ffcb6a4 <strtoul>
  if (end_ptr == string)
2ffcadee:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
      retcode = array[value].fct((uint32_t)string_to_num(argv[1]),
2ffcadf0:	429e      	cmp	r6, r3
2ffcadf2:	bf14      	ite	ne
2ffcadf4:	4601      	movne	r1, r0
2ffcadf6:	f04f 31ff 	moveq.w	r1, #4294967295	@ 0xffffffff
2ffcadfa:	6a78      	ldr	r0, [r7, #36]	@ 0x24
2ffcadfc:	47d0      	blx	sl
      break;
2ffcadfe:	e797      	b.n	2ffcad30 <HAL_DDR_Interactive+0xbd0>
      retcode = array[value].fct((uint32_t)string_to_num(argv[1]));
2ffcae00:	68fb      	ldr	r3, [r7, #12]
  uint64_t val = strtoul(string, &end_ptr, 0);
2ffcae02:	f107 0138 	add.w	r1, r7, #56	@ 0x38
      retcode = array[value].fct((uint32_t)string_to_num(argv[1]));
2ffcae06:	686e      	ldr	r6, [r5, #4]
2ffcae08:	f853 9002 	ldr.w	r9, [r3, r2]
  uint64_t val = strtoul(string, &end_ptr, 0);
2ffcae0c:	2200      	movs	r2, #0
2ffcae0e:	4630      	mov	r0, r6
2ffcae10:	f000 fc48 	bl	2ffcb6a4 <strtoul>
  if (end_ptr == string)
2ffcae14:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
      retcode = array[value].fct((uint32_t)string_to_num(argv[1]));
2ffcae16:	429e      	cmp	r6, r3
2ffcae18:	bf08      	it	eq
2ffcae1a:	f04f 30ff 	moveq.w	r0, #4294967295	@ 0xffffffff
2ffcae1e:	47c8      	blx	r9
      break;
2ffcae20:	e786      	b.n	2ffcad30 <HAL_DDR_Interactive+0xbd0>
      retcode = array[value].fct();
2ffcae22:	68fb      	ldr	r3, [r7, #12]
2ffcae24:	589b      	ldr	r3, [r3, r2]
2ffcae26:	4798      	blx	r3
      break;
2ffcae28:	e782      	b.n	2ffcad30 <HAL_DDR_Interactive+0xbd0>
      printf("alloc error, length %ld\n\r", name_len);
2ffcae2a:	f24f 4018 	movw	r0, #62488	@ 0xf418
2ffcae2e:	4631      	mov	r1, r6
2ffcae30:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcae34:	f000 fda8 	bl	2ffcb988 <iprintf>
  while (next_step == step)
2ffcae38:	f8d4 b000 	ldr.w	fp, [r4]
  for (i = 1; i < argc; i++)
2ffcae3c:	e40a      	b.n	2ffca654 <HAL_DDR_Interactive+0x4f4>
    printf("invalid step %d:%s expecting %d:%s\n\r",
2ffcae3e:	6979      	ldr	r1, [r7, #20]
2ffcae40:	f24f 5020 	movw	r0, #62752	@ 0xf520
2ffcae44:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcae48:	eb04 0381 	add.w	r3, r4, r1, lsl #2
2ffcae4c:	689a      	ldr	r2, [r3, #8]
2ffcae4e:	6963      	ldr	r3, [r4, #20]
2ffcae50:	9300      	str	r3, [sp, #0]
2ffcae52:	2303      	movs	r3, #3
2ffcae54:	f000 fd98 	bl	2ffcb988 <iprintf>
  while (next_step == step)
2ffcae58:	f8d4 b000 	ldr.w	fp, [r4]
2ffcae5c:	f7ff ba81 	b.w	2ffca362 <HAL_DDR_Interactive+0x202>
      printf("invalid value %s\n\r", argv[1]);
2ffcae60:	f24e 1050 	movw	r0, #57680	@ 0xe150
2ffcae64:	4631      	mov	r1, r6
2ffcae66:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcae6a:	f000 fd8d 	bl	2ffcb988 <iprintf>
2ffcae6e:	f7ff bb8d 	b.w	2ffca58c <HAL_DDR_Interactive+0x42c>
  printf(usage);
2ffcae72:	f64e 7074 	movw	r0, #61300	@ 0xef74
2ffcae76:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcae7a:	f000 fd85 	bl	2ffcb988 <iprintf>
  while (next_step == step)
2ffcae7e:	f8d4 b000 	ldr.w	fp, [r4]
}
2ffcae82:	f7ff bbe7 	b.w	2ffca654 <HAL_DDR_Interactive+0x4f4>
  printf(usage);
2ffcae86:	f64e 7074 	movw	r0, #61300	@ 0xef74
2ffcae8a:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcae8e:	f000 fd7b 	bl	2ffcb988 <iprintf>
  while (next_step == step)
2ffcae92:	f8d4 b000 	ldr.w	fp, [r4]
  for (i = 1; i < argc; i++)
2ffcae96:	f7ff ba64 	b.w	2ffca362 <HAL_DDR_Interactive+0x202>
2ffcae9a:	bf00      	nop
2ffcae9c:	f3af 8000 	nop.w
2ffcaea0:	03d09000 	.word	0x03d09000
2ffcaea4:	00000000 	.word	0x00000000

2ffcaea8 <Serial_Scanf>:
uint32_t Serial_Scanf(uint32_t value)
{
  uint16_t tmp = 0;

#ifndef __TERMINAL_IO__
  __HAL_UART_CLEAR_OREFLAG(&huart);
2ffcaea8:	f642 1c6c 	movw	ip, #10604	@ 0x296c
2ffcaeac:	2108      	movs	r1, #8
2ffcaeae:	f6c2 7cfd 	movt	ip, #12285	@ 0x2ffd
  uint16_t tmp = 0;
2ffcaeb2:	2300      	movs	r3, #0
{
2ffcaeb4:	b510      	push	{r4, lr}
2ffcaeb6:	b082      	sub	sp, #8
  __HAL_UART_CLEAR_OREFLAG(&huart);
2ffcaeb8:	f8dc 2000 	ldr.w	r2, [ip]
{
2ffcaebc:	4604      	mov	r4, r0
  uint16_t tmp = 0;
2ffcaebe:	f8ad 3006 	strh.w	r3, [sp, #6]
  /* e.g. read a character from the EVAL_COM1 and Loop until RXNE = 1 */
  HAL_UART_Receive(&huart, (uint8_t *)&tmp, 1, HAL_TIMEOUT_VALUE);
2ffcaec2:	4660      	mov	r0, ip
  __HAL_UART_CLEAR_OREFLAG(&huart);
2ffcaec4:	6211      	str	r1, [r2, #32]
  HAL_UART_Receive(&huart, (uint8_t *)&tmp, 1, HAL_TIMEOUT_VALUE);
2ffcaec6:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
2ffcaeca:	2201      	movs	r2, #1
2ffcaecc:	f10d 0106 	add.w	r1, sp, #6
2ffcaed0:	f7fd ff0c 	bl	2ffc8cec <HAL_UART_Receive>
#else
  tmp = getchar();
#endif
  if (tmp > value)
2ffcaed4:	f8bd 0006 	ldrh.w	r0, [sp, #6]
2ffcaed8:	42a0      	cmp	r0, r4
2ffcaeda:	d801      	bhi.n	2ffcaee0 <Serial_Scanf+0x38>
  {
    printf("\n\r  !!! Please enter valid number between 0 and %lu \n", value);
    return 0xFF;
  }
  return tmp;
}
2ffcaedc:	b002      	add	sp, #8
2ffcaede:	bd10      	pop	{r4, pc}
    printf("\n\r  !!! Please enter valid number between 0 and %lu \n", value);
2ffcaee0:	f64f 50f4 	movw	r0, #65012	@ 0xfdf4
2ffcaee4:	4621      	mov	r1, r4
2ffcaee6:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcaeea:	f000 fd4d 	bl	2ffcb988 <iprintf>
    return 0xFF;
2ffcaeee:	20ff      	movs	r0, #255	@ 0xff
}
2ffcaef0:	b002      	add	sp, #8
2ffcaef2:	bd10      	pop	{r4, pc}

2ffcaef4 <Serial_Putchar>:
  * @brief  Gets numeric values from the Hyperterminal.
  * @param  Maximun value allowed (value)
  * @retval The character received
  */
void Serial_Putchar(char value)
{
2ffcaef4:	b500      	push	{lr}
2ffcaef6:	b083      	sub	sp, #12
2ffcaef8:	4602      	mov	r2, r0
#ifndef __TERMINAL_IO__
  /* e.g. read a character from the EVAL_COM1 and Loop until RXNE = 1 */
  HAL_UART_Transmit(&huart, (uint8_t *)&value, 1, HAL_TIMEOUT_VALUE);
2ffcaefa:	f642 106c 	movw	r0, #10604	@ 0x296c
{
2ffcaefe:	f88d 2007 	strb.w	r2, [sp, #7]
  HAL_UART_Transmit(&huart, (uint8_t *)&value, 1, HAL_TIMEOUT_VALUE);
2ffcaf02:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
2ffcaf06:	f6c2 70fd 	movt	r0, #12285	@ 0x2ffd
2ffcaf0a:	2201      	movs	r2, #1
2ffcaf0c:	f10d 0107 	add.w	r1, sp, #7
2ffcaf10:	f7fd fe7c 	bl	2ffc8c0c <HAL_UART_Transmit>
#endif
}
2ffcaf14:	b003      	add	sp, #12
2ffcaf16:	f85d fb04 	ldr.w	pc, [sp], #4
2ffcaf1a:	bf00      	nop

2ffcaf1c <Error_Handler>:

  /* User may add here some code to deal with this error */
  while(1)
  {
    HAL_Delay(5000);
   log_err("\n\r Error Handler \n\r");
2ffcaf1c:	f644 55d3 	movw	r5, #19923	@ 0x4dd3
2ffcaf20:	f64f 662c 	movw	r6, #65068	@ 0xfe2c
2ffcaf24:	f2c1 0562 	movt	r5, #4194	@ 0x1062
  BSP_LED_Off(LED5);
2ffcaf28:	2001      	movs	r0, #1
{
2ffcaf2a:	b508      	push	{r3, lr}
   log_err("\n\r Error Handler \n\r");
2ffcaf2c:	f6c2 76fc 	movt	r6, #12284	@ 0x2ffc
  BSP_LED_Off(LED5);
2ffcaf30:	f7f7 fc08 	bl	2ffc2744 <BSP_LED_Off>
    HAL_Delay(5000);
2ffcaf34:	f241 3088 	movw	r0, #5000	@ 0x1388
2ffcaf38:	f7f8 fb22 	bl	2ffc3580 <HAL_Delay>
   log_err("\n\r Error Handler \n\r");
2ffcaf3c:	f7f8 fb06 	bl	2ffc354c <HAL_GetTick>
2ffcaf40:	4604      	mov	r4, r0
2ffcaf42:	f7f8 fb03 	bl	2ffc354c <HAL_GetTick>
2ffcaf46:	fba5 3104 	umull	r3, r1, r5, r4
2ffcaf4a:	4603      	mov	r3, r0
2ffcaf4c:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
2ffcaf50:	fba5 0403 	umull	r0, r4, r5, r3
2ffcaf54:	0989      	lsrs	r1, r1, #6
2ffcaf56:	4630      	mov	r0, r6
2ffcaf58:	09a4      	lsrs	r4, r4, #6
2ffcaf5a:	fb02 3214 	mls	r2, r2, r4, r3
2ffcaf5e:	f000 fd13 	bl	2ffcb988 <iprintf>
  while(1)
2ffcaf62:	e7e7      	b.n	2ffcaf34 <Error_Handler+0x18>
2ffcaf64:	0000      	movs	r0, r0
	...

2ffcaf68 <UART_Config>:
{
2ffcaf68:	b510      	push	{r4, lr}
  huart.Instance        = USARTx;
2ffcaf6a:	f642 146c 	movw	r4, #10604	@ 0x296c
2ffcaf6e:	f6c2 74fd 	movt	r4, #12285	@ 0x2ffd
2ffcaf72:	2200      	movs	r2, #0
  huart.Init.BaudRate   = UTIL_UART_BAUDRATE;
2ffcaf74:	eddf 2b24 	vldr	d18, [pc, #144]	@ 2ffcb008 <UART_Config+0xa0>
2ffcaf78:	eddf 3b25 	vldr	d19, [pc, #148]	@ 2ffcb010 <UART_Config+0xa8>
  huart.Init.Mode       = UTIL_UART_MODE;
2ffcaf7c:	eddf 0b26 	vldr	d16, [pc, #152]	@ 2ffcb018 <UART_Config+0xb0>
  huart.Instance        = USARTx;
2ffcaf80:	f2c4 0201 	movt	r2, #16385	@ 0x4001
2ffcaf84:	4623      	mov	r3, r4
  huart.Init.Mode       = UTIL_UART_MODE;
2ffcaf86:	f104 0114 	add.w	r1, r4, #20
  if(HAL_UART_DeInit(&huart) != HAL_OK)
2ffcaf8a:	4620      	mov	r0, r4
  huart.Instance        = USARTx;
2ffcaf8c:	f843 2b04 	str.w	r2, [r3], #4
  huart.Init.OverSampling = UTIL_UART_OVERSAMPLING;
2ffcaf90:	2200      	movs	r2, #0
  huart.Init.BaudRate   = UTIL_UART_BAUDRATE;
2ffcaf92:	f943 2a8f 	vst1.32	{d18-d19}, [r3]
  huart.Init.Mode       = UTIL_UART_MODE;
2ffcaf96:	f941 078f 	vst1.32	{d16}, [r1]
  huart.Init.OverSampling = UTIL_UART_OVERSAMPLING;
2ffcaf9a:	61e2      	str	r2, [r4, #28]
  if(HAL_UART_DeInit(&huart) != HAL_OK)
2ffcaf9c:	f7fd fb12 	bl	2ffc85c4 <HAL_UART_DeInit>
2ffcafa0:	bb68      	cbnz	r0, 2ffcaffe <UART_Config+0x96>
  if(HAL_UART_Init(&huart) != HAL_OK)
2ffcafa2:	4620      	mov	r0, r4
2ffcafa4:	f7fd ff58 	bl	2ffc8e58 <HAL_UART_Init>
2ffcafa8:	bb48      	cbnz	r0, 2ffcaffe <UART_Config+0x96>
  if(HAL_UARTEx_EnableFifoMode(&huart) != HAL_OK)
2ffcafaa:	4620      	mov	r0, r4
2ffcafac:	f7fd ffc6 	bl	2ffc8f3c <HAL_UARTEx_EnableFifoMode>
2ffcafb0:	4601      	mov	r1, r0
2ffcafb2:	bb20      	cbnz	r0, 2ffcaffe <UART_Config+0x96>
  if (HAL_UARTEx_SetTxFifoThreshold(&huart, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
2ffcafb4:	4620      	mov	r0, r4
2ffcafb6:	f7fd ffe1 	bl	2ffc8f7c <HAL_UARTEx_SetTxFifoThreshold>
2ffcafba:	4601      	mov	r1, r0
2ffcafbc:	b9f8      	cbnz	r0, 2ffcaffe <UART_Config+0x96>
  if (HAL_UARTEx_SetRxFifoThreshold(&huart, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
2ffcafbe:	4620      	mov	r0, r4
2ffcafc0:	f7fd fffe 	bl	2ffc8fc0 <HAL_UARTEx_SetRxFifoThreshold>
2ffcafc4:	b9d8      	cbnz	r0, 2ffcaffe <UART_Config+0x96>
  printf("\n\r=============== UTILITIES-DDR Tool ===============\r");
2ffcafc6:	f64f 6054 	movw	r0, #65108	@ 0xfe54
2ffcafca:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcafce:	f000 fcdb 	bl	2ffcb988 <iprintf>
  printf("\n\rModel: %s \r", UTIL_MODEL);
2ffcafd2:	f64f 618c 	movw	r1, #65164	@ 0xfe8c
2ffcafd6:	f64f 6098 	movw	r0, #65176	@ 0xfe98
2ffcafda:	f6c2 71fc 	movt	r1, #12284	@ 0x2ffc
2ffcafde:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcafe2:	f000 fcd1 	bl	2ffcb988 <iprintf>
  printf("\n\rRAM: %s \n\r", DDR_MEM_NAME);
2ffcafe6:	f24e 1198 	movw	r1, #57752	@ 0xe198
2ffcafea:	f64f 60a8 	movw	r0, #65192	@ 0xfea8
}
2ffcafee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  printf("\n\rRAM: %s \n\r", DDR_MEM_NAME);
2ffcaff2:	f6c2 71fc 	movt	r1, #12284	@ 0x2ffc
2ffcaff6:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcaffa:	f000 bcc5 	b.w	2ffcb988 <iprintf>
    Error_Handler();
2ffcaffe:	f7ff ff8d 	bl	2ffcaf1c <Error_Handler>
2ffcb002:	bf00      	nop
2ffcb004:	f3af 8000 	nop.w
2ffcb008:	0001c200 	.word	0x0001c200
	...
2ffcb018:	0000000c 	.word	0x0000000c
2ffcb01c:	00000000 	.word	0x00000000

2ffcb020 <SystemClock_Config>:
CSI                    |N.A.     |    4.000000 MHz |   ON   | Mandatory for IO compensation
ck_per                 |N.A.     |    0.000000 MHz |   OFF  |
ETH                    |N.A.     |    0.000000 MHz |   OFF  | ETH clocked by RGMII PHY on EVAL
-----------------------|---------|-----------------|--------|-----------------------------------*/
void SystemClock_Config(void)
{
2ffcb020:	b500      	push	{lr}
2ffcb022:	b0d3      	sub	sp, #332	@ 0x14c
  RCC_ClkInitTypeDef RCC_ClkInitStructure;
  RCC_OscInitTypeDef RCC_OscInitStructure;

  /* Reset clocks to a known state */
  HAL_RCC_DeInit();
2ffcb024:	f7fa fdd0 	bl	2ffc5bc8 <HAL_RCC_DeInit>
  RCC_OscInitStructure.PLL.PLLM = 2;
  RCC_OscInitStructure.PLL.PLLN = 54;
  RCC_OscInitStructure.PLL.PLLP = 1;
  RCC_OscInitStructure.PLL.PLLQ = 1;
  RCC_OscInitStructure.PLL.PLLR = 1;
  RCC_OscInitStructure.PLL.PLLFRACV = 0;
2ffcb028:	efc0 0010 	vmov.i32	d16, #0	@ 0x00000000
  RCC_OscInitStructure.OscillatorType = (RCC_OSCILLATORTYPE_HSI
2ffcb02c:	eddf ab38 	vldr	d26, [pc, #224]	@ 2ffcb110 <SystemClock_Config+0xf0>
2ffcb030:	eddf bb39 	vldr	d27, [pc, #228]	@ 2ffcb118 <SystemClock_Config+0xf8>
2ffcb034:	eddf 8b3a 	vldr	d24, [pc, #232]	@ 2ffcb120 <SystemClock_Config+0x100>
2ffcb038:	eddf 9b3b 	vldr	d25, [pc, #236]	@ 2ffcb128 <SystemClock_Config+0x108>
2ffcb03c:	eddf 6b3c 	vldr	d22, [pc, #240]	@ 2ffcb130 <SystemClock_Config+0x110>
2ffcb040:	eddf 7b3d 	vldr	d23, [pc, #244]	@ 2ffcb138 <SystemClock_Config+0x118>
2ffcb044:	eddf 4b3e 	vldr	d20, [pc, #248]	@ 2ffcb140 <SystemClock_Config+0x120>
2ffcb048:	eddf 5b3f 	vldr	d21, [pc, #252]	@ 2ffcb148 <SystemClock_Config+0x128>
  RCC_OscInitStructure.PLL.PLLMODE = RCC_PLL_INTEGER;

  RCC_OscInitStructure.PLL2.PLLState = RCC_PLL_ON;
2ffcb04c:	eddf 2b40 	vldr	d18, [pc, #256]	@ 2ffcb150 <SystemClock_Config+0x130>
2ffcb050:	eddf 3b41 	vldr	d19, [pc, #260]	@ 2ffcb158 <SystemClock_Config+0x138>
  RCC_OscInitStructure.PLL2.PLLSource = RCC_PLL12SOURCE_HSE;
  RCC_OscInitStructure.PLL2.PLLM = UTIL_PLL2_M;
  RCC_OscInitStructure.PLL2.PLLN = UTIL_PLL2_N;
  RCC_OscInitStructure.PLL2.PLLP = UTIL_PLL2_P;
2ffcb054:	eddf 1b42 	vldr	d17, [pc, #264]	@ 2ffcb160 <SystemClock_Config+0x140>
  RCC_OscInitStructure.PLL.PLLFRACV = 0;
2ffcb058:	ab1d      	add	r3, sp, #116	@ 0x74
  RCC_OscInitStructure.PLL2.PLLQ = UTIL_PLL2_Q;
  RCC_OscInitStructure.PLL2.PLLR = UTIL_PLL2_R;
  RCC_OscInitStructure.PLL2.PLLFRACV = UTIL_PLL2_FRACV;
  RCC_OscInitStructure.PLL2.PLLMODE = UTIL_PLL2_MODE;

  RCC_OscInitStructure.PLL3.PLLState = RCC_PLL_NONE;
2ffcb05a:	2200      	movs	r2, #0
  RCC_OscInitStructure.PLL2.PLLFRACV = UTIL_PLL2_FRACV;
2ffcb05c:	edcd 0b2c 	vstr	d16, [sp, #176]	@ 0xb0
  RCC_OscInitStructure.PLL.PLLFRACV = 0;
2ffcb060:	f943 078f 	vst1.32	{d16}, [r3]
  RCC_OscInitStructure.OscillatorType = (RCC_OSCILLATORTYPE_HSI
2ffcb064:	edcd ab0c 	vstr	d26, [sp, #48]	@ 0x30
2ffcb068:	edcd bb0e 	vstr	d27, [sp, #56]	@ 0x38
2ffcb06c:	edcd 8b10 	vstr	d24, [sp, #64]	@ 0x40
2ffcb070:	edcd 9b12 	vstr	d25, [sp, #72]	@ 0x48
2ffcb074:	edcd 6b14 	vstr	d22, [sp, #80]	@ 0x50
2ffcb078:	edcd 7b16 	vstr	d23, [sp, #88]	@ 0x58
2ffcb07c:	edcd 4b18 	vstr	d20, [sp, #96]	@ 0x60
2ffcb080:	edcd 5b1a 	vstr	d21, [sp, #104]	@ 0x68
  RCC_OscInitStructure.PLL2.PLLState = RCC_PLL_ON;
2ffcb084:	edcd 2b24 	vstr	d18, [sp, #144]	@ 0x90
2ffcb088:	edcd 3b26 	vstr	d19, [sp, #152]	@ 0x98
  RCC_OscInitStructure.PLL2.PLLP = UTIL_PLL2_P;
2ffcb08c:	edcd 1b28 	vstr	d17, [sp, #160]	@ 0xa0
  RCC_OscInitStructure.PLL3.PLLState = RCC_PLL_NONE;
2ffcb090:	9233      	str	r2, [sp, #204]	@ 0xcc
  RCC_OscInitStructure.PLL4.PLLState = RCC_PLL_NONE;

  /* Enable access to RTC and backup registers */
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
2ffcb092:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
2ffcb096:	f2c5 0300 	movt	r3, #20480	@ 0x5000
  RCC_OscInitStructure.PLL2.PLLR = UTIL_PLL2_R;
2ffcb09a:	2101      	movs	r1, #1
2ffcb09c:	912a      	str	r1, [sp, #168]	@ 0xa8
  /* Configure LSEDRIVE value */
  __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_MEDIUMHIGH);
2ffcb09e:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
  RCC_OscInitStructure.PLL4.PLLState = RCC_PLL_NONE;
2ffcb0a2:	9242      	str	r2, [sp, #264]	@ 0x108

  if (HAL_RCC_OscConfig(&RCC_OscInitStructure) != HAL_OK) {
2ffcb0a4:	a80c      	add	r0, sp, #48	@ 0x30
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
2ffcb0a6:	681a      	ldr	r2, [r3, #0]
2ffcb0a8:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
2ffcb0ac:	601a      	str	r2, [r3, #0]
  __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_MEDIUMHIGH);
2ffcb0ae:	f8d1 3140 	ldr.w	r3, [r1, #320]	@ 0x140
2ffcb0b2:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
2ffcb0b6:	f043 0320 	orr.w	r3, r3, #32
2ffcb0ba:	f8c1 3140 	str.w	r3, [r1, #320]	@ 0x140
  if (HAL_RCC_OscConfig(&RCC_OscInitStructure) != HAL_OK) {
2ffcb0be:	f7fb fc5b 	bl	2ffc6978 <HAL_RCC_OscConfig>
2ffcb0c2:	b9e0      	cbnz	r0, 2ffcb0fe <SystemClock_Config+0xde>
    /* HAL RCC configuration error */
    Error_Handler();
  }

  /* Select PLLx as MPU, AXI and MCU clock sources */
  RCC_ClkInitStructure.ClockType = (RCC_CLOCKTYPE_MPU | RCC_CLOCKTYPE_ACLK |
2ffcb0c4:	eddf 4b28 	vldr	d20, [pc, #160]	@ 2ffcb168 <SystemClock_Config+0x148>
2ffcb0c8:	eddf 5b29 	vldr	d21, [pc, #164]	@ 2ffcb170 <SystemClock_Config+0x150>
2ffcb0cc:	eddf 2b2a 	vldr	d18, [pc, #168]	@ 2ffcb178 <SystemClock_Config+0x158>
2ffcb0d0:	eddf 3b2b 	vldr	d19, [pc, #172]	@ 2ffcb180 <SystemClock_Config+0x160>
2ffcb0d4:	eddf 0b2c 	vldr	d16, [pc, #176]	@ 2ffcb188 <SystemClock_Config+0x168>
2ffcb0d8:	eddf 1b2d 	vldr	d17, [pc, #180]	@ 2ffcb190 <SystemClock_Config+0x170>
  RCC_ClkInitStructure.MCUInit.MCU_Div = RCC_MCU_DIV1;
  RCC_ClkInitStructure.APB1_Div = RCC_APB1_DIV2;
  RCC_ClkInitStructure.APB2_Div = RCC_APB2_DIV2;
  RCC_ClkInitStructure.APB3_Div = RCC_APB3_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStructure) != HAL_OK) {
2ffcb0dc:	4668      	mov	r0, sp
  RCC_ClkInitStructure.ClockType = (RCC_CLOCKTYPE_MPU | RCC_CLOCKTYPE_ACLK |
2ffcb0de:	f94d 4adf 	vst1.64	{d20-d21}, [sp :64]
2ffcb0e2:	edcd 2b04 	vstr	d18, [sp, #16]
2ffcb0e6:	edcd 3b06 	vstr	d19, [sp, #24]
2ffcb0ea:	edcd 0b08 	vstr	d16, [sp, #32]
2ffcb0ee:	edcd 1b0a 	vstr	d17, [sp, #40]	@ 0x28
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStructure) != HAL_OK) {
2ffcb0f2:	f7fb fec1 	bl	2ffc6e78 <HAL_RCC_ClockConfig>
2ffcb0f6:	b928      	cbnz	r0, 2ffcb104 <SystemClock_Config+0xe4>

   __HAL_RCC_SYSCFG_CLK_ENABLE() ;

   HAL_EnableCompensationCell();
   */
}
2ffcb0f8:	b053      	add	sp, #332	@ 0x14c
2ffcb0fa:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
2ffcb0fe:	f7ff ff0d 	bl	2ffcaf1c <Error_Handler>
2ffcb102:	e7df      	b.n	2ffcb0c4 <SystemClock_Config+0xa4>
    Error_Handler();
2ffcb104:	f7ff ff0a 	bl	2ffcaf1c <Error_Handler>
}
2ffcb108:	e7f6      	b.n	2ffcb0f8 <SystemClock_Config+0xd8>
2ffcb10a:	bf00      	nop
2ffcb10c:	f3af 8000 	nop.w
2ffcb110:	0000001f 	.word	0x0000001f
2ffcb114:	00000100 	.word	0x00000100
2ffcb118:	00000001 	.word	0x00000001
2ffcb11c:	00000001 	.word	0x00000001
	...
2ffcb128:	00000001 	.word	0x00000001
2ffcb12c:	00000010 	.word	0x00000010
2ffcb130:	00000010 	.word	0x00000010
2ffcb134:	00000002 	.word	0x00000002
2ffcb138:	00000001 	.word	0x00000001
2ffcb13c:	00000002 	.word	0x00000002
2ffcb140:	00000036 	.word	0x00000036
2ffcb144:	00000001 	.word	0x00000001
2ffcb148:	00000001 	.word	0x00000001
2ffcb14c:	00000001 	.word	0x00000001
2ffcb150:	00000002 	.word	0x00000002
2ffcb154:	00000001 	.word	0x00000001
2ffcb158:	00000002 	.word	0x00000002
2ffcb15c:	0000002c 	.word	0x0000002c
2ffcb160:	00000002 	.word	0x00000002
2ffcb164:	00000001 	.word	0x00000001
2ffcb168:	000000ff 	.word	0x000000ff
2ffcb16c:	00000002 	.word	0x00000002
2ffcb170:	00000001 	.word	0x00000001
2ffcb174:	00000002 	.word	0x00000002
	...
2ffcb184:	00000001 	.word	0x00000001
2ffcb188:	00000002 	.word	0x00000002
2ffcb18c:	00000001 	.word	0x00000001
2ffcb190:	00000001 	.word	0x00000001
2ffcb194:	00000001 	.word	0x00000001

2ffcb198 <main>:
{
2ffcb198:	b510      	push	{r4, lr}
2ffcb19a:	b084      	sub	sp, #16
  /*Enable TZC clock*/
  __HAL_RCC_TZC1_CLK_ENABLE();
  __HAL_RCC_TZC2_CLK_ENABLE();

  /* Configure TZC to allow  DDR Region0 R/W  non secure for all IDs */
  TZC->GATE_KEEPER =0;
2ffcb19c:	2400      	movs	r4, #0
  HAL_Init();
2ffcb19e:	f7f8 f9b3 	bl	2ffc3508 <HAL_Init>
  SystemClock_Config();
2ffcb1a2:	f7ff ff3d 	bl	2ffcb020 <SystemClock_Config>
  UART_Config();
2ffcb1a6:	f7ff fedf 	bl	2ffcaf68 <UART_Config>
  SystemPower_Config();
2ffcb1aa:	f7f7 fd1d 	bl	2ffc2be8 <SystemPower_Config>
  BSP_LED_Init(LED_GREEN);
2ffcb1ae:	2001      	movs	r0, #1
2ffcb1b0:	f7f7 fae2 	bl	2ffc2778 <BSP_LED_Init>
  __HAL_RCC_TZC1_CLK_ENABLE();
2ffcb1b4:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
2ffcb1b8:	f44f 6000 	mov.w	r0, #2048	@ 0x800
  TZC->GATE_KEEPER =0;
2ffcb1bc:	f44f 43c0 	mov.w	r3, #24576	@ 0x6000
  TZC->REG_ID_ACCESSO=0xFFFFFFFF;  //Allow DDR Region0 R/W  non secure for all IDs
  TZC->REG_ATTRIBUTESO = 0xC0000003;
2ffcb1c0:	2103      	movs	r1, #3
  __HAL_RCC_TZC1_CLK_ENABLE();
2ffcb1c2:	f8c2 0208 	str.w	r0, [r2, #520]	@ 0x208
  __HAL_RCC_TZC2_CLK_ENABLE();
2ffcb1c6:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
  TZC->GATE_KEEPER =0;
2ffcb1ca:	f6c5 4300 	movt	r3, #23552	@ 0x5c00
  __HAL_RCC_TZC2_CLK_ENABLE();
2ffcb1ce:	f8c2 0208 	str.w	r0, [r2, #520]	@ 0x208
  TZC->REG_ID_ACCESSO=0xFFFFFFFF;  //Allow DDR Region0 R/W  non secure for all IDs
2ffcb1d2:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  TZC->REG_ATTRIBUTESO = 0xC0000003;
2ffcb1d6:	f2cc 0100 	movt	r1, #49152	@ 0xc000
  TZC->GATE_KEEPER =0;
2ffcb1da:	609c      	str	r4, [r3, #8]
  TZC->REG_ID_ACCESSO=0xFFFFFFFF;  //Allow DDR Region0 R/W  non secure for all IDs
2ffcb1dc:	f8c3 0114 	str.w	r0, [r3, #276]	@ 0x114
  TZC->GATE_KEEPER |=3;  //Enable the access in secure Mode  // filter 0 request close

  /* Enable TZPC & backup ram for security tests */
  __HAL_RCC_TZPC_CLK_ENABLE();
2ffcb1e0:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
  TZC->REG_ATTRIBUTESO = 0xC0000003;
2ffcb1e4:	f8c3 1110 	str.w	r1, [r3, #272]	@ 0x110
  TZC->GATE_KEEPER |=3;  //Enable the access in secure Mode  // filter 0 request close
2ffcb1e8:	6899      	ldr	r1, [r3, #8]
2ffcb1ea:	f041 0103 	orr.w	r1, r1, #3
2ffcb1ee:	6099      	str	r1, [r3, #8]
  __HAL_RCC_BKPSRAM_CLK_ENABLE();

  /* Disable both read and write access speculations */
  TZC->SPECULATION_CTRL = 3;
2ffcb1f0:	2103      	movs	r1, #3
  __HAL_RCC_TZPC_CLK_ENABLE();
2ffcb1f2:	f8c2 0208 	str.w	r0, [r2, #520]	@ 0x208
  __HAL_RCC_BKPSRAM_CLK_ENABLE();
2ffcb1f6:	f44f 7080 	mov.w	r0, #256	@ 0x100
2ffcb1fa:	f8c2 0210 	str.w	r0, [r2, #528]	@ 0x210
  HAL_Delay(1000);
2ffcb1fe:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
  TZC->SPECULATION_CTRL = 3;
2ffcb202:	60d9      	str	r1, [r3, #12]
  HAL_Delay(1000);
2ffcb204:	f7f8 f9bc 	bl	2ffc3580 <HAL_Delay>
  iddr.wakeup_from_standby = false;
2ffcb208:	f8ad 4004 	strh.w	r4, [sp, #4]
  if (HAL_DDR_Init(&iddr) != HAL_OK)
2ffcb20c:	a801      	add	r0, sp, #4
  iddr.zdata = 0;
2ffcb20e:	9402      	str	r4, [sp, #8]
  iddr.clear_bkp = false;
2ffcb210:	f88d 400c 	strb.w	r4, [sp, #12]
  if (HAL_DDR_Init(&iddr) != HAL_OK)
2ffcb214:	f7f9 f87a 	bl	2ffc430c <HAL_DDR_Init>
2ffcb218:	b950      	cbnz	r0, 2ffcb230 <main+0x98>
  BSP_LED_Toggle(LED_GREEN);
2ffcb21a:	2001      	movs	r0, #1
2ffcb21c:	f7f7 fae0 	bl	2ffc27e0 <BSP_LED_Toggle>
  HAL_Delay(1000);
2ffcb220:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
2ffcb224:	f7f8 f9ac 	bl	2ffc3580 <HAL_Delay>
  BSP_LED_Toggle(LED_GREEN);
2ffcb228:	2001      	movs	r0, #1
2ffcb22a:	f7f7 fad9 	bl	2ffc27e0 <BSP_LED_Toggle>
  while (1)
2ffcb22e:	e7f4      	b.n	2ffcb21a <main+0x82>
    printf("DDR Initialization KO\n\r");
2ffcb230:	f64f 60b8 	movw	r0, #65208	@ 0xfeb8
2ffcb234:	f6c2 70fc 	movt	r0, #12284	@ 0x2ffc
2ffcb238:	f000 fba6 	bl	2ffcb988 <iprintf>
}
2ffcb23c:	2001      	movs	r0, #1
2ffcb23e:	b004      	add	sp, #16
2ffcb240:	bd10      	pop	{r4, pc}
2ffcb242:	bf00      	nop

2ffcb244 <__io_putchar>:
#define PUTCHAR_PROTOTYPE int __attribute__(( weak )) fputc(int ch, FILE *f)
#endif /* __GNUC__ */

#if defined (__LOG_UART_IO_) || defined (__LOG_TRACE_IO_)
PUTCHAR_PROTOTYPE
{
2ffcb244:	b500      	push	{lr}
2ffcb246:	b083      	sub	sp, #12
  /* Place your implementation of fputc here */
  /* e.g. write a character to the USART1 and Loop until the end of transmission */
#if defined (__LOG_UART_IO_)
extern UART_HandleTypeDef huart;
  HAL_UART_Transmit(&huart, (uint8_t *)&ch, 1, HAL_MAX_DELAY);
2ffcb248:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
2ffcb24c:	2201      	movs	r2, #1
{
2ffcb24e:	9001      	str	r0, [sp, #4]
  HAL_UART_Transmit(&huart, (uint8_t *)&ch, 1, HAL_MAX_DELAY);
2ffcb250:	f642 106c 	movw	r0, #10604	@ 0x296c
2ffcb254:	f6c2 70fd 	movt	r0, #12285	@ 0x2ffd
2ffcb258:	a901      	add	r1, sp, #4
2ffcb25a:	f7fd fcd7 	bl	2ffc8c0c <HAL_UART_Transmit>
#endif
#if defined (__LOG_TRACE_IO_)
	log_buff(ch);
#endif
	return ch;
}
2ffcb25e:	9801      	ldr	r0, [sp, #4]
2ffcb260:	b003      	add	sp, #12
2ffcb262:	f85d fb04 	ldr.w	pc, [sp], #4
2ffcb266:	bf00      	nop

2ffcb268 <HAL_MspInit>:
 * @param  None
 * @retval None
 */
void HAL_MspInit(void)
{
}
2ffcb268:	4770      	bx	lr
2ffcb26a:	bf00      	nop
2ffcb26c:	0000      	movs	r0, r0
	...

2ffcb270 <HAL_UART_MspInit>:
 *           - Peripheral's GPIO Configuration
 * @param huart: UART handle pointer
 * @retval None
 */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
2ffcb270:	b510      	push	{r4, lr}

  RCC_PeriphCLKInitTypeDef RCC_PeriphClkInit;

  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO TX/RX clock */
  USARTx_TX_GPIO_CLK_ENABLE();
2ffcb272:	f04f 44a0 	mov.w	r4, #1342177280	@ 0x50000000
{
2ffcb276:	b0dc      	sub	sp, #368	@ 0x170
  USARTx_RX_GPIO_CLK_ENABLE();
2ffcb278:	2302      	movs	r3, #2
  USARTx_TX_GPIO_CLK_ENABLE();
2ffcb27a:	2240      	movs	r2, #64	@ 0x40

  /* Select SysClk as source of UART4 clocks */
#if (UTIL_UART_INSTANCE == UTIL_UART4)
  RCC_PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_UART24;
2ffcb27c:	2100      	movs	r1, #0
  USARTx_TX_GPIO_CLK_ENABLE();
2ffcb27e:	f8c4 2a28 	str.w	r2, [r4, #2600]	@ 0xa28
  RCC_PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_UART24;
2ffcb282:	2002      	movs	r0, #2
  USARTx_RX_GPIO_CLK_ENABLE();
2ffcb284:	f8c4 3a28 	str.w	r3, [r4, #2600]	@ 0xa28
  RCC_PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_UART24;
2ffcb288:	e9cd 0106 	strd	r0, r1, [sp, #24]
  RCC_PeriphClkInit.Uart24ClockSelection = RCC_UART24CLKSOURCE_HSI;
2ffcb28c:	9341      	str	r3, [sp, #260]	@ 0x104
  RCC_PeriphClkInit.Uart78ClockSelection = RCC_UART78CLKSOURCE_HSI;
#elif (UTIL_UART_INSTANCE == UTIL_UART8)
  RCC_PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_UART78;
  RCC_PeriphClkInit.Uart78ClockSelection = RCC_UART78CLKSOURCE_HSI;
#endif
  HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphClkInit);
2ffcb28e:	a806      	add	r0, sp, #24
2ffcb290:	f7fc f9cc 	bl	2ffc762c <HAL_RCCEx_PeriphCLKConfig>
  /* Enable USARTx clock */
  USARTx_CLK_ENABLE();

  /*##-2- Configure peripheral GPIO ##########################################*/
  /* UART TX GPIO pin configuration  */
  GPIO_InitStruct.Pin = USARTx_TX_PIN;
2ffcb294:	eddf 0b10 	vldr	d16, [pc, #64]	@ 2ffcb2d8 <HAL_UART_MspInit+0x68>
2ffcb298:	eddf 1b11 	vldr	d17, [pc, #68]	@ 2ffcb2e0 <HAL_UART_MspInit+0x70>
  USARTx_CLK_ENABLE();
2ffcb29c:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = USARTx_TX_AF;

  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);
2ffcb2a0:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
  USARTx_CLK_ENABLE();
2ffcb2a4:	f8c4 3a00 	str.w	r3, [r4, #2560]	@ 0xa00
  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);
2ffcb2a8:	4669      	mov	r1, sp
2ffcb2aa:	f2c5 0000 	movt	r0, #20480	@ 0x5000
  GPIO_InitStruct.Alternate = USARTx_TX_AF;
2ffcb2ae:	2306      	movs	r3, #6
  GPIO_InitStruct.Pin = USARTx_TX_PIN;
2ffcb2b0:	f94d 0adf 	vst1.64	{d16-d17}, [sp :64]
  GPIO_InitStruct.Alternate = USARTx_TX_AF;
2ffcb2b4:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);
2ffcb2b6:	f7f9 fd27 	bl	2ffc4d08 <HAL_GPIO_Init>

  /* UART RX GPIO pin configuration  */
  GPIO_InitStruct.Pin = USARTx_RX_PIN;
  GPIO_InitStruct.Alternate = USARTx_RX_AF;

  HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct);
2ffcb2ba:	f44f 5040 	mov.w	r0, #12288	@ 0x3000
  GPIO_InitStruct.Pin = USARTx_RX_PIN;
2ffcb2be:	2204      	movs	r2, #4
  HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct);
2ffcb2c0:	f2c5 0000 	movt	r0, #20480	@ 0x5000
  GPIO_InitStruct.Alternate = USARTx_RX_AF;
2ffcb2c4:	2308      	movs	r3, #8
  GPIO_InitStruct.Pin = USARTx_RX_PIN;
2ffcb2c6:	9200      	str	r2, [sp, #0]
  HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct);
2ffcb2c8:	4669      	mov	r1, sp
  GPIO_InitStruct.Alternate = USARTx_RX_AF;
2ffcb2ca:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct);
2ffcb2cc:	f7f9 fd1c 	bl	2ffc4d08 <HAL_GPIO_Init>
}
2ffcb2d0:	b05c      	add	sp, #368	@ 0x170
2ffcb2d2:	bd10      	pop	{r4, pc}
2ffcb2d4:	f3af 8000 	nop.w
2ffcb2d8:	00000800 	.word	0x00000800
2ffcb2dc:	00000002 	.word	0x00000002
2ffcb2e0:	00000001 	.word	0x00000001
2ffcb2e4:	00000003 	.word	0x00000003

2ffcb2e8 <HAL_UART_MspDeInit>:
 *          - Revert GPIO and NVIC configuration to their default state
 * @param huart: UART handle pointer
 * @retval None
 */
void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
{
2ffcb2e8:	b508      	push	{r3, lr}
  /*##-1- Reset peripherals ##################################################*/
  USARTx_FORCE_RESET();
2ffcb2ea:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
2ffcb2ee:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
  USARTx_RELEASE_RESET();

  /*##-2- Disable peripherals and GPIO Clocks ################################*/
  /* Configure UART Tx as alternate function  */
  HAL_GPIO_DeInit(USARTx_TX_GPIO_PORT, USARTx_TX_PIN);
2ffcb2f2:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
  USARTx_FORCE_RESET();
2ffcb2f6:	f8c3 2980 	str.w	r2, [r3, #2432]	@ 0x980
  HAL_GPIO_DeInit(USARTx_TX_GPIO_PORT, USARTx_TX_PIN);
2ffcb2fa:	f44f 6100 	mov.w	r1, #2048	@ 0x800
2ffcb2fe:	f2c5 0000 	movt	r0, #20480	@ 0x5000
  USARTx_RELEASE_RESET();
2ffcb302:	f8c3 2984 	str.w	r2, [r3, #2436]	@ 0x984
  HAL_GPIO_DeInit(USARTx_TX_GPIO_PORT, USARTx_TX_PIN);
2ffcb306:	f7f9 fe61 	bl	2ffc4fcc <HAL_GPIO_DeInit>
  /* Configure UART Rx as alternate function  */
  HAL_GPIO_DeInit(USARTx_RX_GPIO_PORT, USARTx_RX_PIN);
2ffcb30a:	f44f 5040 	mov.w	r0, #12288	@ 0x3000
2ffcb30e:	2104      	movs	r1, #4
}
2ffcb310:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_GPIO_DeInit(USARTx_RX_GPIO_PORT, USARTx_RX_PIN);
2ffcb314:	f2c5 0000 	movt	r0, #20480	@ 0x5000
2ffcb318:	f7f9 be58 	b.w	2ffc4fcc <HAL_GPIO_DeInit>

2ffcb31c <HAL_DDR_MspInit>:
 * @retval
 *  0: Test passed
 *  Value different from 0: Test failed
 */
int HAL_DDR_MspInit(ddr_type type)
{
2ffcb31c:	b508      	push	{r3, lr}
    /*
     * Set LDO3 to 1.8V
     * Set LDO3 to bypass mode if BUCK3 = 1.8V
     * Set LDO3 to normal mode if BUCK3 != 1.8V
     */
    read_val = STPMU1_Register_Read(BUCK3_CONTROL_REG);
2ffcb31e:	2022      	movs	r0, #34	@ 0x22
2ffcb320:	f7f7 fb40 	bl	2ffc29a4 <STPMU1_Register_Read>
    if ((read_val & STPMIC1_BUCK3_1V8) == STPMIC1_BUCK3_1V8)
    {
      buck3_at_1v8 = true;
    }

    read_val = STPMU1_Register_Read(LDO3_CONTROL_REG);
2ffcb324:	2027      	movs	r0, #39	@ 0x27
2ffcb326:	f7f7 fb3d 	bl	2ffc29a4 <STPMU1_Register_Read>

    read_val &= ~STPMIC1_LDO3_MODE;
    read_val &= ~STPMIC1_LDO12356_OUTPUT_MASK;
2ffcb32a:	f000 0103 	and.w	r1, r0, #3
    if (buck3_at_1v8)
    {
      read_val |= STPMIC1_LDO3_MODE;
    }

    STPMU1_Register_Write(LDO3_CONTROL_REG, read_val);
2ffcb32e:	2027      	movs	r0, #39	@ 0x27
2ffcb330:	f041 0180 	orr.w	r1, r1, #128	@ 0x80
2ffcb334:	f7f7 fb4a 	bl	2ffc29cc <STPMU1_Register_Write>

    STPMU1_Regulator_Voltage_Set(STPMU1_LDO3, ldo3_mv);
2ffcb338:	f44f 61e1 	mov.w	r1, #1800	@ 0x708
2ffcb33c:	2007      	movs	r0, #7
2ffcb33e:	f7f7 fb9b 	bl	2ffc2a78 <STPMU1_Regulator_Voltage_Set>
    case STM32MP_LPDDR3_16:
      buck2_mv = 1200;
      break;
    }

    STPMU1_Regulator_Voltage_Set(STPMU1_BUCK2, buck2_mv);
2ffcb342:	f240 41e2 	movw	r1, #1250	@ 0x4e2
2ffcb346:	2002      	movs	r0, #2
2ffcb348:	f7f7 fb96 	bl	2ffc2a78 <STPMU1_Regulator_Voltage_Set>

    STPMU1_Regulator_Enable(STPMU1_LDO3);
2ffcb34c:	2007      	movs	r0, #7
2ffcb34e:	f7f7 fb67 	bl	2ffc2a20 <STPMU1_Regulator_Enable>

    HAL_Delay(STPMIC1_DEFAULT_START_UP_DELAY_MS);
2ffcb352:	2001      	movs	r0, #1
2ffcb354:	f7f8 f914 	bl	2ffc3580 <HAL_Delay>

    STPMU1_Regulator_Enable(STPMU1_BUCK2);
2ffcb358:	2002      	movs	r0, #2
2ffcb35a:	f7f7 fb61 	bl	2ffc2a20 <STPMU1_Regulator_Enable>

    HAL_Delay(STPMIC1_DEFAULT_START_UP_DELAY_MS);
2ffcb35e:	2001      	movs	r0, #1
2ffcb360:	f7f8 f90e 	bl	2ffc3580 <HAL_Delay>

    STPMU1_Regulator_Enable(STPMU1_VREFDDR);
2ffcb364:	200b      	movs	r0, #11
2ffcb366:	f7f7 fb5b 	bl	2ffc2a20 <STPMU1_Regulator_Enable>

    HAL_Delay(STPMIC1_DEFAULT_START_UP_DELAY_MS);
2ffcb36a:	2001      	movs	r0, #1
2ffcb36c:	f7f8 f908 	bl	2ffc3580 <HAL_Delay>
    break;
  };
#endif /* UTIL_USE_PMIC */

  return 0;
}
2ffcb370:	2000      	movs	r0, #0
2ffcb372:	bd08      	pop	{r3, pc}

2ffcb374 <SVC_Handler>:
/**
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
2ffcb374:	4770      	bx	lr
2ffcb376:	bf00      	nop

2ffcb378 <malloc>:
2ffcb378:	4b02      	ldr	r3, [pc, #8]	@ (2ffcb384 <malloc+0xc>)
2ffcb37a:	4601      	mov	r1, r0
2ffcb37c:	6818      	ldr	r0, [r3, #0]
2ffcb37e:	f000 b82d 	b.w	2ffcb3dc <_malloc_r>
2ffcb382:	bf00      	nop
2ffcb384:	2ffd18a8 	.word	0x2ffd18a8

2ffcb388 <free>:
2ffcb388:	4b02      	ldr	r3, [pc, #8]	@ (2ffcb394 <free+0xc>)
2ffcb38a:	4601      	mov	r1, r0
2ffcb38c:	6818      	ldr	r0, [r3, #0]
2ffcb38e:	f000 bd5f 	b.w	2ffcbe50 <_free_r>
2ffcb392:	bf00      	nop
2ffcb394:	2ffd18a8 	.word	0x2ffd18a8

2ffcb398 <sbrk_aligned>:
2ffcb398:	b570      	push	{r4, r5, r6, lr}
2ffcb39a:	460c      	mov	r4, r1
2ffcb39c:	4e0e      	ldr	r6, [pc, #56]	@ (2ffcb3d8 <sbrk_aligned+0x40>)
2ffcb39e:	4605      	mov	r5, r0
2ffcb3a0:	6831      	ldr	r1, [r6, #0]
2ffcb3a2:	b911      	cbnz	r1, 2ffcb3aa <sbrk_aligned+0x12>
2ffcb3a4:	f000 fcba 	bl	2ffcbd1c <_sbrk_r>
2ffcb3a8:	6030      	str	r0, [r6, #0]
2ffcb3aa:	4621      	mov	r1, r4
2ffcb3ac:	4628      	mov	r0, r5
2ffcb3ae:	f000 fcb5 	bl	2ffcbd1c <_sbrk_r>
2ffcb3b2:	1c43      	adds	r3, r0, #1
2ffcb3b4:	d103      	bne.n	2ffcb3be <sbrk_aligned+0x26>
2ffcb3b6:	f04f 34ff 	mov.w	r4, #4294967295	@ 0xffffffff
2ffcb3ba:	4620      	mov	r0, r4
2ffcb3bc:	bd70      	pop	{r4, r5, r6, pc}
2ffcb3be:	1cc4      	adds	r4, r0, #3
2ffcb3c0:	f024 0403 	bic.w	r4, r4, #3
2ffcb3c4:	42a0      	cmp	r0, r4
2ffcb3c6:	d0f8      	beq.n	2ffcb3ba <sbrk_aligned+0x22>
2ffcb3c8:	1a21      	subs	r1, r4, r0
2ffcb3ca:	4628      	mov	r0, r5
2ffcb3cc:	f000 fca6 	bl	2ffcbd1c <_sbrk_r>
2ffcb3d0:	3001      	adds	r0, #1
2ffcb3d2:	d1f2      	bne.n	2ffcb3ba <sbrk_aligned+0x22>
2ffcb3d4:	e7ef      	b.n	2ffcb3b6 <sbrk_aligned+0x1e>
2ffcb3d6:	bf00      	nop
2ffcb3d8:	2ffd29f8 	.word	0x2ffd29f8

2ffcb3dc <_malloc_r>:
2ffcb3dc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
2ffcb3e0:	1ccd      	adds	r5, r1, #3
2ffcb3e2:	f025 0503 	bic.w	r5, r5, #3
2ffcb3e6:	3508      	adds	r5, #8
2ffcb3e8:	4606      	mov	r6, r0
2ffcb3ea:	2d0c      	cmp	r5, #12
2ffcb3ec:	bf38      	it	cc
2ffcb3ee:	250c      	movcc	r5, #12
2ffcb3f0:	2d00      	cmp	r5, #0
2ffcb3f2:	db01      	blt.n	2ffcb3f8 <_malloc_r+0x1c>
2ffcb3f4:	42a9      	cmp	r1, r5
2ffcb3f6:	d904      	bls.n	2ffcb402 <_malloc_r+0x26>
2ffcb3f8:	230c      	movs	r3, #12
2ffcb3fa:	6033      	str	r3, [r6, #0]
2ffcb3fc:	2000      	movs	r0, #0
2ffcb3fe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
2ffcb402:	f8df 80d0 	ldr.w	r8, [pc, #208]	@ 2ffcb4d4 <_malloc_r+0xf8>
2ffcb406:	f000 f867 	bl	2ffcb4d8 <__malloc_lock>
2ffcb40a:	f8d8 3000 	ldr.w	r3, [r8]
2ffcb40e:	461c      	mov	r4, r3
2ffcb410:	bb44      	cbnz	r4, 2ffcb464 <_malloc_r+0x88>
2ffcb412:	4629      	mov	r1, r5
2ffcb414:	4630      	mov	r0, r6
2ffcb416:	f7ff ffbf 	bl	2ffcb398 <sbrk_aligned>
2ffcb41a:	4604      	mov	r4, r0
2ffcb41c:	1c43      	adds	r3, r0, #1
2ffcb41e:	d157      	bne.n	2ffcb4d0 <_malloc_r+0xf4>
2ffcb420:	f8d8 4000 	ldr.w	r4, [r8]
2ffcb424:	4627      	mov	r7, r4
2ffcb426:	2f00      	cmp	r7, #0
2ffcb428:	d142      	bne.n	2ffcb4b0 <_malloc_r+0xd4>
2ffcb42a:	2c00      	cmp	r4, #0
2ffcb42c:	d04a      	beq.n	2ffcb4c4 <_malloc_r+0xe8>
2ffcb42e:	6823      	ldr	r3, [r4, #0]
2ffcb430:	4639      	mov	r1, r7
2ffcb432:	4630      	mov	r0, r6
2ffcb434:	eb04 0903 	add.w	r9, r4, r3
2ffcb438:	f000 fc70 	bl	2ffcbd1c <_sbrk_r>
2ffcb43c:	4581      	cmp	r9, r0
2ffcb43e:	d141      	bne.n	2ffcb4c4 <_malloc_r+0xe8>
2ffcb440:	6821      	ldr	r1, [r4, #0]
2ffcb442:	4630      	mov	r0, r6
2ffcb444:	1a6d      	subs	r5, r5, r1
2ffcb446:	4629      	mov	r1, r5
2ffcb448:	f7ff ffa6 	bl	2ffcb398 <sbrk_aligned>
2ffcb44c:	3001      	adds	r0, #1
2ffcb44e:	d039      	beq.n	2ffcb4c4 <_malloc_r+0xe8>
2ffcb450:	6823      	ldr	r3, [r4, #0]
2ffcb452:	442b      	add	r3, r5
2ffcb454:	6023      	str	r3, [r4, #0]
2ffcb456:	f8d8 3000 	ldr.w	r3, [r8]
2ffcb45a:	685a      	ldr	r2, [r3, #4]
2ffcb45c:	bb5a      	cbnz	r2, 2ffcb4b6 <_malloc_r+0xda>
2ffcb45e:	f8c8 7000 	str.w	r7, [r8]
2ffcb462:	e00e      	b.n	2ffcb482 <_malloc_r+0xa6>
2ffcb464:	6822      	ldr	r2, [r4, #0]
2ffcb466:	1b52      	subs	r2, r2, r5
2ffcb468:	d41f      	bmi.n	2ffcb4aa <_malloc_r+0xce>
2ffcb46a:	2a0b      	cmp	r2, #11
2ffcb46c:	d916      	bls.n	2ffcb49c <_malloc_r+0xc0>
2ffcb46e:	6025      	str	r5, [r4, #0]
2ffcb470:	1961      	adds	r1, r4, r5
2ffcb472:	42a3      	cmp	r3, r4
2ffcb474:	bf14      	ite	ne
2ffcb476:	6059      	strne	r1, [r3, #4]
2ffcb478:	f8c8 1000 	streq.w	r1, [r8]
2ffcb47c:	6863      	ldr	r3, [r4, #4]
2ffcb47e:	5162      	str	r2, [r4, r5]
2ffcb480:	604b      	str	r3, [r1, #4]
2ffcb482:	4630      	mov	r0, r6
2ffcb484:	f000 f82e 	bl	2ffcb4e4 <__malloc_unlock>
2ffcb488:	f104 000b 	add.w	r0, r4, #11
2ffcb48c:	1d23      	adds	r3, r4, #4
2ffcb48e:	f020 0007 	bic.w	r0, r0, #7
2ffcb492:	1ac2      	subs	r2, r0, r3
2ffcb494:	bf1c      	itt	ne
2ffcb496:	1a1b      	subne	r3, r3, r0
2ffcb498:	50a3      	strne	r3, [r4, r2]
2ffcb49a:	e7b0      	b.n	2ffcb3fe <_malloc_r+0x22>
2ffcb49c:	6862      	ldr	r2, [r4, #4]
2ffcb49e:	42a3      	cmp	r3, r4
2ffcb4a0:	bf0c      	ite	eq
2ffcb4a2:	f8c8 2000 	streq.w	r2, [r8]
2ffcb4a6:	605a      	strne	r2, [r3, #4]
2ffcb4a8:	e7eb      	b.n	2ffcb482 <_malloc_r+0xa6>
2ffcb4aa:	4623      	mov	r3, r4
2ffcb4ac:	6864      	ldr	r4, [r4, #4]
2ffcb4ae:	e7af      	b.n	2ffcb410 <_malloc_r+0x34>
2ffcb4b0:	463c      	mov	r4, r7
2ffcb4b2:	687f      	ldr	r7, [r7, #4]
2ffcb4b4:	e7b7      	b.n	2ffcb426 <_malloc_r+0x4a>
2ffcb4b6:	461a      	mov	r2, r3
2ffcb4b8:	685b      	ldr	r3, [r3, #4]
2ffcb4ba:	42a3      	cmp	r3, r4
2ffcb4bc:	d1fb      	bne.n	2ffcb4b6 <_malloc_r+0xda>
2ffcb4be:	2300      	movs	r3, #0
2ffcb4c0:	6053      	str	r3, [r2, #4]
2ffcb4c2:	e7de      	b.n	2ffcb482 <_malloc_r+0xa6>
2ffcb4c4:	230c      	movs	r3, #12
2ffcb4c6:	4630      	mov	r0, r6
2ffcb4c8:	6033      	str	r3, [r6, #0]
2ffcb4ca:	f000 f80b 	bl	2ffcb4e4 <__malloc_unlock>
2ffcb4ce:	e795      	b.n	2ffcb3fc <_malloc_r+0x20>
2ffcb4d0:	6005      	str	r5, [r0, #0]
2ffcb4d2:	e7d6      	b.n	2ffcb482 <_malloc_r+0xa6>
2ffcb4d4:	2ffd29fc 	.word	0x2ffd29fc

2ffcb4d8 <__malloc_lock>:
2ffcb4d8:	4801      	ldr	r0, [pc, #4]	@ (2ffcb4e0 <__malloc_lock+0x8>)
2ffcb4da:	f000 bc6c 	b.w	2ffcbdb6 <__retarget_lock_acquire_recursive>
2ffcb4de:	bf00      	nop
2ffcb4e0:	2ffd2b40 	.word	0x2ffd2b40

2ffcb4e4 <__malloc_unlock>:
2ffcb4e4:	4801      	ldr	r0, [pc, #4]	@ (2ffcb4ec <__malloc_unlock+0x8>)
2ffcb4e6:	f000 bc67 	b.w	2ffcbdb8 <__retarget_lock_release_recursive>
2ffcb4ea:	bf00      	nop
2ffcb4ec:	2ffd2b40 	.word	0x2ffd2b40

2ffcb4f0 <srand>:
2ffcb4f0:	b538      	push	{r3, r4, r5, lr}
2ffcb4f2:	4604      	mov	r4, r0
2ffcb4f4:	4b0f      	ldr	r3, [pc, #60]	@ (2ffcb534 <srand+0x44>)
2ffcb4f6:	681d      	ldr	r5, [r3, #0]
2ffcb4f8:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
2ffcb4fa:	b9b3      	cbnz	r3, 2ffcb52a <srand+0x3a>
2ffcb4fc:	2018      	movs	r0, #24
2ffcb4fe:	f7ff ff3b 	bl	2ffcb378 <malloc>
2ffcb502:	4602      	mov	r2, r0
2ffcb504:	6328      	str	r0, [r5, #48]	@ 0x30
2ffcb506:	b920      	cbnz	r0, 2ffcb512 <srand+0x22>
2ffcb508:	4b0b      	ldr	r3, [pc, #44]	@ (2ffcb538 <srand+0x48>)
2ffcb50a:	2146      	movs	r1, #70	@ 0x46
2ffcb50c:	480b      	ldr	r0, [pc, #44]	@ (2ffcb53c <srand+0x4c>)
2ffcb50e:	f000 fc81 	bl	2ffcbe14 <__assert_func>
2ffcb512:	490b      	ldr	r1, [pc, #44]	@ (2ffcb540 <srand+0x50>)
2ffcb514:	4b0b      	ldr	r3, [pc, #44]	@ (2ffcb544 <srand+0x54>)
2ffcb516:	e9c0 1300 	strd	r1, r3, [r0]
2ffcb51a:	2100      	movs	r1, #0
2ffcb51c:	4b0a      	ldr	r3, [pc, #40]	@ (2ffcb548 <srand+0x58>)
2ffcb51e:	6083      	str	r3, [r0, #8]
2ffcb520:	230b      	movs	r3, #11
2ffcb522:	8183      	strh	r3, [r0, #12]
2ffcb524:	2001      	movs	r0, #1
2ffcb526:	e9c2 0104 	strd	r0, r1, [r2, #16]
2ffcb52a:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
2ffcb52c:	2200      	movs	r2, #0
2ffcb52e:	611c      	str	r4, [r3, #16]
2ffcb530:	615a      	str	r2, [r3, #20]
2ffcb532:	bd38      	pop	{r3, r4, r5, pc}
2ffcb534:	2ffd18a8 	.word	0x2ffd18a8
2ffcb538:	2ffcfed0 	.word	0x2ffcfed0
2ffcb53c:	2ffcfee7 	.word	0x2ffcfee7
2ffcb540:	abcd330e 	.word	0xabcd330e
2ffcb544:	e66d1234 	.word	0xe66d1234
2ffcb548:	0005deec 	.word	0x0005deec

2ffcb54c <rand>:
2ffcb54c:	4b16      	ldr	r3, [pc, #88]	@ (2ffcb5a8 <rand+0x5c>)
2ffcb54e:	b510      	push	{r4, lr}
2ffcb550:	681c      	ldr	r4, [r3, #0]
2ffcb552:	6b23      	ldr	r3, [r4, #48]	@ 0x30
2ffcb554:	b9b3      	cbnz	r3, 2ffcb584 <rand+0x38>
2ffcb556:	2018      	movs	r0, #24
2ffcb558:	f7ff ff0e 	bl	2ffcb378 <malloc>
2ffcb55c:	4602      	mov	r2, r0
2ffcb55e:	6320      	str	r0, [r4, #48]	@ 0x30
2ffcb560:	b920      	cbnz	r0, 2ffcb56c <rand+0x20>
2ffcb562:	4b12      	ldr	r3, [pc, #72]	@ (2ffcb5ac <rand+0x60>)
2ffcb564:	2152      	movs	r1, #82	@ 0x52
2ffcb566:	4812      	ldr	r0, [pc, #72]	@ (2ffcb5b0 <rand+0x64>)
2ffcb568:	f000 fc54 	bl	2ffcbe14 <__assert_func>
2ffcb56c:	4911      	ldr	r1, [pc, #68]	@ (2ffcb5b4 <rand+0x68>)
2ffcb56e:	4b12      	ldr	r3, [pc, #72]	@ (2ffcb5b8 <rand+0x6c>)
2ffcb570:	e9c0 1300 	strd	r1, r3, [r0]
2ffcb574:	2100      	movs	r1, #0
2ffcb576:	4b11      	ldr	r3, [pc, #68]	@ (2ffcb5bc <rand+0x70>)
2ffcb578:	6083      	str	r3, [r0, #8]
2ffcb57a:	230b      	movs	r3, #11
2ffcb57c:	8183      	strh	r3, [r0, #12]
2ffcb57e:	2001      	movs	r0, #1
2ffcb580:	e9c2 0104 	strd	r0, r1, [r2, #16]
2ffcb584:	6b21      	ldr	r1, [r4, #48]	@ 0x30
2ffcb586:	480e      	ldr	r0, [pc, #56]	@ (2ffcb5c0 <rand+0x74>)
2ffcb588:	4a0e      	ldr	r2, [pc, #56]	@ (2ffcb5c4 <rand+0x78>)
2ffcb58a:	690b      	ldr	r3, [r1, #16]
2ffcb58c:	694c      	ldr	r4, [r1, #20]
2ffcb58e:	4358      	muls	r0, r3
2ffcb590:	fb02 0004 	mla	r0, r2, r4, r0
2ffcb594:	fba3 3202 	umull	r3, r2, r3, r2
2ffcb598:	3301      	adds	r3, #1
2ffcb59a:	eb40 0002 	adc.w	r0, r0, r2
2ffcb59e:	e9c1 3004 	strd	r3, r0, [r1, #16]
2ffcb5a2:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
2ffcb5a6:	bd10      	pop	{r4, pc}
2ffcb5a8:	2ffd18a8 	.word	0x2ffd18a8
2ffcb5ac:	2ffcfed0 	.word	0x2ffcfed0
2ffcb5b0:	2ffcfee7 	.word	0x2ffcfee7
2ffcb5b4:	abcd330e 	.word	0xabcd330e
2ffcb5b8:	e66d1234 	.word	0xe66d1234
2ffcb5bc:	0005deec 	.word	0x0005deec
2ffcb5c0:	5851f42d 	.word	0x5851f42d
2ffcb5c4:	4c957f2d 	.word	0x4c957f2d

2ffcb5c8 <_strtoul_l.constprop.0>:
2ffcb5c8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
2ffcb5cc:	4686      	mov	lr, r0
2ffcb5ce:	4e34      	ldr	r6, [pc, #208]	@ (2ffcb6a0 <_strtoul_l.constprop.0+0xd8>)
2ffcb5d0:	460d      	mov	r5, r1
2ffcb5d2:	4628      	mov	r0, r5
2ffcb5d4:	f815 4b01 	ldrb.w	r4, [r5], #1
2ffcb5d8:	5d37      	ldrb	r7, [r6, r4]
2ffcb5da:	f017 0708 	ands.w	r7, r7, #8
2ffcb5de:	d1f8      	bne.n	2ffcb5d2 <_strtoul_l.constprop.0+0xa>
2ffcb5e0:	2c2d      	cmp	r4, #45	@ 0x2d
2ffcb5e2:	d12f      	bne.n	2ffcb644 <_strtoul_l.constprop.0+0x7c>
2ffcb5e4:	782c      	ldrb	r4, [r5, #0]
2ffcb5e6:	2701      	movs	r7, #1
2ffcb5e8:	1c85      	adds	r5, r0, #2
2ffcb5ea:	f033 0010 	bics.w	r0, r3, #16
2ffcb5ee:	d109      	bne.n	2ffcb604 <_strtoul_l.constprop.0+0x3c>
2ffcb5f0:	2c30      	cmp	r4, #48	@ 0x30
2ffcb5f2:	d12c      	bne.n	2ffcb64e <_strtoul_l.constprop.0+0x86>
2ffcb5f4:	7828      	ldrb	r0, [r5, #0]
2ffcb5f6:	f000 00df 	and.w	r0, r0, #223	@ 0xdf
2ffcb5fa:	2858      	cmp	r0, #88	@ 0x58
2ffcb5fc:	d127      	bne.n	2ffcb64e <_strtoul_l.constprop.0+0x86>
2ffcb5fe:	786c      	ldrb	r4, [r5, #1]
2ffcb600:	2310      	movs	r3, #16
2ffcb602:	3502      	adds	r5, #2
2ffcb604:	f04f 38ff 	mov.w	r8, #4294967295	@ 0xffffffff
2ffcb608:	2600      	movs	r6, #0
2ffcb60a:	4630      	mov	r0, r6
2ffcb60c:	fbb8 f8f3 	udiv	r8, r8, r3
2ffcb610:	fb03 f908 	mul.w	r9, r3, r8
2ffcb614:	ea6f 0909 	mvn.w	r9, r9
2ffcb618:	f1a4 0c30 	sub.w	ip, r4, #48	@ 0x30
2ffcb61c:	f1bc 0f09 	cmp.w	ip, #9
2ffcb620:	d81c      	bhi.n	2ffcb65c <_strtoul_l.constprop.0+0x94>
2ffcb622:	4664      	mov	r4, ip
2ffcb624:	42a3      	cmp	r3, r4
2ffcb626:	dd2a      	ble.n	2ffcb67e <_strtoul_l.constprop.0+0xb6>
2ffcb628:	f1b6 3fff 	cmp.w	r6, #4294967295	@ 0xffffffff
2ffcb62c:	d007      	beq.n	2ffcb63e <_strtoul_l.constprop.0+0x76>
2ffcb62e:	4580      	cmp	r8, r0
2ffcb630:	d322      	bcc.n	2ffcb678 <_strtoul_l.constprop.0+0xb0>
2ffcb632:	d101      	bne.n	2ffcb638 <_strtoul_l.constprop.0+0x70>
2ffcb634:	45a1      	cmp	r9, r4
2ffcb636:	db1f      	blt.n	2ffcb678 <_strtoul_l.constprop.0+0xb0>
2ffcb638:	fb00 4003 	mla	r0, r0, r3, r4
2ffcb63c:	2601      	movs	r6, #1
2ffcb63e:	f815 4b01 	ldrb.w	r4, [r5], #1
2ffcb642:	e7e9      	b.n	2ffcb618 <_strtoul_l.constprop.0+0x50>
2ffcb644:	2c2b      	cmp	r4, #43	@ 0x2b
2ffcb646:	bf04      	itt	eq
2ffcb648:	782c      	ldrbeq	r4, [r5, #0]
2ffcb64a:	1c85      	addeq	r5, r0, #2
2ffcb64c:	e7cd      	b.n	2ffcb5ea <_strtoul_l.constprop.0+0x22>
2ffcb64e:	2b00      	cmp	r3, #0
2ffcb650:	d1d8      	bne.n	2ffcb604 <_strtoul_l.constprop.0+0x3c>
2ffcb652:	2c30      	cmp	r4, #48	@ 0x30
2ffcb654:	bf0c      	ite	eq
2ffcb656:	2308      	moveq	r3, #8
2ffcb658:	230a      	movne	r3, #10
2ffcb65a:	e7d3      	b.n	2ffcb604 <_strtoul_l.constprop.0+0x3c>
2ffcb65c:	f1a4 0c41 	sub.w	ip, r4, #65	@ 0x41
2ffcb660:	f1bc 0f19 	cmp.w	ip, #25
2ffcb664:	d801      	bhi.n	2ffcb66a <_strtoul_l.constprop.0+0xa2>
2ffcb666:	3c37      	subs	r4, #55	@ 0x37
2ffcb668:	e7dc      	b.n	2ffcb624 <_strtoul_l.constprop.0+0x5c>
2ffcb66a:	f1a4 0c61 	sub.w	ip, r4, #97	@ 0x61
2ffcb66e:	f1bc 0f19 	cmp.w	ip, #25
2ffcb672:	d804      	bhi.n	2ffcb67e <_strtoul_l.constprop.0+0xb6>
2ffcb674:	3c57      	subs	r4, #87	@ 0x57
2ffcb676:	e7d5      	b.n	2ffcb624 <_strtoul_l.constprop.0+0x5c>
2ffcb678:	f04f 36ff 	mov.w	r6, #4294967295	@ 0xffffffff
2ffcb67c:	e7df      	b.n	2ffcb63e <_strtoul_l.constprop.0+0x76>
2ffcb67e:	1c73      	adds	r3, r6, #1
2ffcb680:	d106      	bne.n	2ffcb690 <_strtoul_l.constprop.0+0xc8>
2ffcb682:	2322      	movs	r3, #34	@ 0x22
2ffcb684:	4630      	mov	r0, r6
2ffcb686:	f8ce 3000 	str.w	r3, [lr]
2ffcb68a:	b932      	cbnz	r2, 2ffcb69a <_strtoul_l.constprop.0+0xd2>
2ffcb68c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
2ffcb690:	b107      	cbz	r7, 2ffcb694 <_strtoul_l.constprop.0+0xcc>
2ffcb692:	4240      	negs	r0, r0
2ffcb694:	2a00      	cmp	r2, #0
2ffcb696:	d0f9      	beq.n	2ffcb68c <_strtoul_l.constprop.0+0xc4>
2ffcb698:	b106      	cbz	r6, 2ffcb69c <_strtoul_l.constprop.0+0xd4>
2ffcb69a:	1e69      	subs	r1, r5, #1
2ffcb69c:	6011      	str	r1, [r2, #0]
2ffcb69e:	e7f5      	b.n	2ffcb68c <_strtoul_l.constprop.0+0xc4>
2ffcb6a0:	2ffcff40 	.word	0x2ffcff40

2ffcb6a4 <strtoul>:
2ffcb6a4:	4613      	mov	r3, r2
2ffcb6a6:	460a      	mov	r2, r1
2ffcb6a8:	4601      	mov	r1, r0
2ffcb6aa:	4802      	ldr	r0, [pc, #8]	@ (2ffcb6b4 <strtoul+0x10>)
2ffcb6ac:	6800      	ldr	r0, [r0, #0]
2ffcb6ae:	f7ff bf8b 	b.w	2ffcb5c8 <_strtoul_l.constprop.0>
2ffcb6b2:	bf00      	nop
2ffcb6b4:	2ffd18a8 	.word	0x2ffd18a8

2ffcb6b8 <_strtoll_l.constprop.0>:
2ffcb6b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
2ffcb6bc:	4690      	mov	r8, r2
2ffcb6be:	4a44      	ldr	r2, [pc, #272]	@ (2ffcb7d0 <_strtoll_l.constprop.0+0x118>)
2ffcb6c0:	b085      	sub	sp, #20
2ffcb6c2:	4689      	mov	r9, r1
2ffcb6c4:	461e      	mov	r6, r3
2ffcb6c6:	460d      	mov	r5, r1
2ffcb6c8:	9002      	str	r0, [sp, #8]
2ffcb6ca:	462b      	mov	r3, r5
2ffcb6cc:	f815 4b01 	ldrb.w	r4, [r5], #1
2ffcb6d0:	5d17      	ldrb	r7, [r2, r4]
2ffcb6d2:	f017 0708 	ands.w	r7, r7, #8
2ffcb6d6:	d1f8      	bne.n	2ffcb6ca <_strtoll_l.constprop.0+0x12>
2ffcb6d8:	2c2d      	cmp	r4, #45	@ 0x2d
2ffcb6da:	d149      	bne.n	2ffcb770 <_strtoll_l.constprop.0+0xb8>
2ffcb6dc:	782c      	ldrb	r4, [r5, #0]
2ffcb6de:	2701      	movs	r7, #1
2ffcb6e0:	1c9d      	adds	r5, r3, #2
2ffcb6e2:	f036 0310 	bics.w	r3, r6, #16
2ffcb6e6:	d109      	bne.n	2ffcb6fc <_strtoll_l.constprop.0+0x44>
2ffcb6e8:	2c30      	cmp	r4, #48	@ 0x30
2ffcb6ea:	d146      	bne.n	2ffcb77a <_strtoll_l.constprop.0+0xc2>
2ffcb6ec:	782b      	ldrb	r3, [r5, #0]
2ffcb6ee:	f003 03df 	and.w	r3, r3, #223	@ 0xdf
2ffcb6f2:	2b58      	cmp	r3, #88	@ 0x58
2ffcb6f4:	d141      	bne.n	2ffcb77a <_strtoll_l.constprop.0+0xc2>
2ffcb6f6:	786c      	ldrb	r4, [r5, #1]
2ffcb6f8:	2610      	movs	r6, #16
2ffcb6fa:	3502      	adds	r5, #2
2ffcb6fc:	f107 4a00 	add.w	sl, r7, #2147483648	@ 0x80000000
2ffcb700:	f107 3bff 	add.w	fp, r7, #4294967295	@ 0xffffffff
2ffcb704:	f10a 3aff 	add.w	sl, sl, #4294967295	@ 0xffffffff
2ffcb708:	17f3      	asrs	r3, r6, #31
2ffcb70a:	4632      	mov	r2, r6
2ffcb70c:	4658      	mov	r0, fp
2ffcb70e:	4651      	mov	r1, sl
2ffcb710:	9303      	str	r3, [sp, #12]
2ffcb712:	f001 fabb 	bl	2ffccc8c <__aeabi_uldivmod>
2ffcb716:	9201      	str	r2, [sp, #4]
2ffcb718:	2200      	movs	r2, #0
2ffcb71a:	468e      	mov	lr, r1
2ffcb71c:	4684      	mov	ip, r0
2ffcb71e:	4611      	mov	r1, r2
2ffcb720:	4610      	mov	r0, r2
2ffcb722:	f1a4 0330 	sub.w	r3, r4, #48	@ 0x30
2ffcb726:	2b09      	cmp	r3, #9
2ffcb728:	d905      	bls.n	2ffcb736 <_strtoll_l.constprop.0+0x7e>
2ffcb72a:	f1a4 0341 	sub.w	r3, r4, #65	@ 0x41
2ffcb72e:	2b19      	cmp	r3, #25
2ffcb730:	d82a      	bhi.n	2ffcb788 <_strtoll_l.constprop.0+0xd0>
2ffcb732:	f1a4 0337 	sub.w	r3, r4, #55	@ 0x37
2ffcb736:	429e      	cmp	r6, r3
2ffcb738:	dd30      	ble.n	2ffcb79c <_strtoll_l.constprop.0+0xe4>
2ffcb73a:	1c54      	adds	r4, r2, #1
2ffcb73c:	d015      	beq.n	2ffcb76a <_strtoll_l.constprop.0+0xb2>
2ffcb73e:	4584      	cmp	ip, r0
2ffcb740:	eb7e 0201 	sbcs.w	r2, lr, r1
2ffcb744:	d327      	bcc.n	2ffcb796 <_strtoll_l.constprop.0+0xde>
2ffcb746:	458e      	cmp	lr, r1
2ffcb748:	bf08      	it	eq
2ffcb74a:	4584      	cmpeq	ip, r0
2ffcb74c:	d102      	bne.n	2ffcb754 <_strtoll_l.constprop.0+0x9c>
2ffcb74e:	9a01      	ldr	r2, [sp, #4]
2ffcb750:	429a      	cmp	r2, r3
2ffcb752:	db20      	blt.n	2ffcb796 <_strtoll_l.constprop.0+0xde>
2ffcb754:	9a03      	ldr	r2, [sp, #12]
2ffcb756:	4371      	muls	r1, r6
2ffcb758:	fb00 1102 	mla	r1, r0, r2, r1
2ffcb75c:	fba6 0200 	umull	r0, r2, r6, r0
2ffcb760:	440a      	add	r2, r1
2ffcb762:	1818      	adds	r0, r3, r0
2ffcb764:	eb42 71e3 	adc.w	r1, r2, r3, asr #31
2ffcb768:	2201      	movs	r2, #1
2ffcb76a:	f815 4b01 	ldrb.w	r4, [r5], #1
2ffcb76e:	e7d8      	b.n	2ffcb722 <_strtoll_l.constprop.0+0x6a>
2ffcb770:	2c2b      	cmp	r4, #43	@ 0x2b
2ffcb772:	bf04      	itt	eq
2ffcb774:	782c      	ldrbeq	r4, [r5, #0]
2ffcb776:	1c9d      	addeq	r5, r3, #2
2ffcb778:	e7b3      	b.n	2ffcb6e2 <_strtoll_l.constprop.0+0x2a>
2ffcb77a:	2e00      	cmp	r6, #0
2ffcb77c:	d1be      	bne.n	2ffcb6fc <_strtoll_l.constprop.0+0x44>
2ffcb77e:	2c30      	cmp	r4, #48	@ 0x30
2ffcb780:	bf0c      	ite	eq
2ffcb782:	2608      	moveq	r6, #8
2ffcb784:	260a      	movne	r6, #10
2ffcb786:	e7b9      	b.n	2ffcb6fc <_strtoll_l.constprop.0+0x44>
2ffcb788:	f1a4 0361 	sub.w	r3, r4, #97	@ 0x61
2ffcb78c:	2b19      	cmp	r3, #25
2ffcb78e:	d805      	bhi.n	2ffcb79c <_strtoll_l.constprop.0+0xe4>
2ffcb790:	f1a4 0357 	sub.w	r3, r4, #87	@ 0x57
2ffcb794:	e7cf      	b.n	2ffcb736 <_strtoll_l.constprop.0+0x7e>
2ffcb796:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
2ffcb79a:	e7e6      	b.n	2ffcb76a <_strtoll_l.constprop.0+0xb2>
2ffcb79c:	1c53      	adds	r3, r2, #1
2ffcb79e:	d10a      	bne.n	2ffcb7b6 <_strtoll_l.constprop.0+0xfe>
2ffcb7a0:	9a02      	ldr	r2, [sp, #8]
2ffcb7a2:	2322      	movs	r3, #34	@ 0x22
2ffcb7a4:	4658      	mov	r0, fp
2ffcb7a6:	4651      	mov	r1, sl
2ffcb7a8:	6013      	str	r3, [r2, #0]
2ffcb7aa:	f1b8 0f00 	cmp.w	r8, #0
2ffcb7ae:	d10a      	bne.n	2ffcb7c6 <_strtoll_l.constprop.0+0x10e>
2ffcb7b0:	b005      	add	sp, #20
2ffcb7b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
2ffcb7b6:	b117      	cbz	r7, 2ffcb7be <_strtoll_l.constprop.0+0x106>
2ffcb7b8:	4240      	negs	r0, r0
2ffcb7ba:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
2ffcb7be:	f1b8 0f00 	cmp.w	r8, #0
2ffcb7c2:	d0f5      	beq.n	2ffcb7b0 <_strtoll_l.constprop.0+0xf8>
2ffcb7c4:	b10a      	cbz	r2, 2ffcb7ca <_strtoll_l.constprop.0+0x112>
2ffcb7c6:	f105 39ff 	add.w	r9, r5, #4294967295	@ 0xffffffff
2ffcb7ca:	f8c8 9000 	str.w	r9, [r8]
2ffcb7ce:	e7ef      	b.n	2ffcb7b0 <_strtoll_l.constprop.0+0xf8>
2ffcb7d0:	2ffcff40 	.word	0x2ffcff40

2ffcb7d4 <strtoll>:
2ffcb7d4:	4613      	mov	r3, r2
2ffcb7d6:	460a      	mov	r2, r1
2ffcb7d8:	4601      	mov	r1, r0
2ffcb7da:	4802      	ldr	r0, [pc, #8]	@ (2ffcb7e4 <strtoll+0x10>)
2ffcb7dc:	6800      	ldr	r0, [r0, #0]
2ffcb7de:	f7ff bf6b 	b.w	2ffcb6b8 <_strtoll_l.constprop.0>
2ffcb7e2:	bf00      	nop
2ffcb7e4:	2ffd18a8 	.word	0x2ffd18a8

2ffcb7e8 <lldiv>:
2ffcb7e8:	b510      	push	{r4, lr}
2ffcb7ea:	4604      	mov	r4, r0
2ffcb7ec:	4619      	mov	r1, r3
2ffcb7ee:	4610      	mov	r0, r2
2ffcb7f0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
2ffcb7f4:	f001 f9fa 	bl	2ffccbec <__aeabi_ldivmod>
2ffcb7f8:	e9c4 0100 	strd	r0, r1, [r4]
2ffcb7fc:	4620      	mov	r0, r4
2ffcb7fe:	e9c4 2302 	strd	r2, r3, [r4, #8]
2ffcb802:	bd10      	pop	{r4, pc}

2ffcb804 <std>:
2ffcb804:	b510      	push	{r4, lr}
2ffcb806:	2300      	movs	r3, #0
2ffcb808:	4604      	mov	r4, r0
2ffcb80a:	e9c0 3300 	strd	r3, r3, [r0]
2ffcb80e:	6083      	str	r3, [r0, #8]
2ffcb810:	8181      	strh	r1, [r0, #12]
2ffcb812:	4619      	mov	r1, r3
2ffcb814:	6643      	str	r3, [r0, #100]	@ 0x64
2ffcb816:	81c2      	strh	r2, [r0, #14]
2ffcb818:	2208      	movs	r2, #8
2ffcb81a:	e9c0 3304 	strd	r3, r3, [r0, #16]
2ffcb81e:	305c      	adds	r0, #92	@ 0x5c
2ffcb820:	f840 3c44 	str.w	r3, [r0, #-68]
2ffcb824:	f000 fa18 	bl	2ffcbc58 <memset>
2ffcb828:	4b0c      	ldr	r3, [pc, #48]	@ (2ffcb85c <std+0x58>)
2ffcb82a:	6263      	str	r3, [r4, #36]	@ 0x24
2ffcb82c:	4b0c      	ldr	r3, [pc, #48]	@ (2ffcb860 <std+0x5c>)
2ffcb82e:	62a3      	str	r3, [r4, #40]	@ 0x28
2ffcb830:	4b0c      	ldr	r3, [pc, #48]	@ (2ffcb864 <std+0x60>)
2ffcb832:	62e3      	str	r3, [r4, #44]	@ 0x2c
2ffcb834:	4b0c      	ldr	r3, [pc, #48]	@ (2ffcb868 <std+0x64>)
2ffcb836:	6323      	str	r3, [r4, #48]	@ 0x30
2ffcb838:	4b0c      	ldr	r3, [pc, #48]	@ (2ffcb86c <std+0x68>)
2ffcb83a:	6224      	str	r4, [r4, #32]
2ffcb83c:	429c      	cmp	r4, r3
2ffcb83e:	d006      	beq.n	2ffcb84e <std+0x4a>
2ffcb840:	f103 0268 	add.w	r2, r3, #104	@ 0x68
2ffcb844:	4294      	cmp	r4, r2
2ffcb846:	d002      	beq.n	2ffcb84e <std+0x4a>
2ffcb848:	33d0      	adds	r3, #208	@ 0xd0
2ffcb84a:	429c      	cmp	r4, r3
2ffcb84c:	d105      	bne.n	2ffcb85a <std+0x56>
2ffcb84e:	f104 0058 	add.w	r0, r4, #88	@ 0x58
2ffcb852:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
2ffcb856:	f000 baad 	b.w	2ffcbdb4 <__retarget_lock_init_recursive>
2ffcb85a:	bd10      	pop	{r4, pc}
2ffcb85c:	2ffcbaa9 	.word	0x2ffcbaa9
2ffcb860:	2ffcbacb 	.word	0x2ffcbacb
2ffcb864:	2ffcbb03 	.word	0x2ffcbb03
2ffcb868:	2ffcbb27 	.word	0x2ffcbb27
2ffcb86c:	2ffd2a00 	.word	0x2ffd2a00

2ffcb870 <stdio_exit_handler>:
2ffcb870:	4a02      	ldr	r2, [pc, #8]	@ (2ffcb87c <stdio_exit_handler+0xc>)
2ffcb872:	4903      	ldr	r1, [pc, #12]	@ (2ffcb880 <stdio_exit_handler+0x10>)
2ffcb874:	4803      	ldr	r0, [pc, #12]	@ (2ffcb884 <stdio_exit_handler+0x14>)
2ffcb876:	f000 b869 	b.w	2ffcb94c <_fwalk_sglue>
2ffcb87a:	bf00      	nop
2ffcb87c:	2ffd189c 	.word	0x2ffd189c
2ffcb880:	2ffcc845 	.word	0x2ffcc845
2ffcb884:	2ffd18ac 	.word	0x2ffd18ac

2ffcb888 <cleanup_stdio>:
2ffcb888:	6841      	ldr	r1, [r0, #4]
2ffcb88a:	4b0c      	ldr	r3, [pc, #48]	@ (2ffcb8bc <cleanup_stdio+0x34>)
2ffcb88c:	b510      	push	{r4, lr}
2ffcb88e:	4604      	mov	r4, r0
2ffcb890:	4299      	cmp	r1, r3
2ffcb892:	d001      	beq.n	2ffcb898 <cleanup_stdio+0x10>
2ffcb894:	f000 ffd6 	bl	2ffcc844 <_fflush_r>
2ffcb898:	68a1      	ldr	r1, [r4, #8]
2ffcb89a:	4b09      	ldr	r3, [pc, #36]	@ (2ffcb8c0 <cleanup_stdio+0x38>)
2ffcb89c:	4299      	cmp	r1, r3
2ffcb89e:	d002      	beq.n	2ffcb8a6 <cleanup_stdio+0x1e>
2ffcb8a0:	4620      	mov	r0, r4
2ffcb8a2:	f000 ffcf 	bl	2ffcc844 <_fflush_r>
2ffcb8a6:	68e1      	ldr	r1, [r4, #12]
2ffcb8a8:	4b06      	ldr	r3, [pc, #24]	@ (2ffcb8c4 <cleanup_stdio+0x3c>)
2ffcb8aa:	4299      	cmp	r1, r3
2ffcb8ac:	d004      	beq.n	2ffcb8b8 <cleanup_stdio+0x30>
2ffcb8ae:	4620      	mov	r0, r4
2ffcb8b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
2ffcb8b4:	f000 bfc6 	b.w	2ffcc844 <_fflush_r>
2ffcb8b8:	bd10      	pop	{r4, pc}
2ffcb8ba:	bf00      	nop
2ffcb8bc:	2ffd2a00 	.word	0x2ffd2a00
2ffcb8c0:	2ffd2a68 	.word	0x2ffd2a68
2ffcb8c4:	2ffd2ad0 	.word	0x2ffd2ad0

2ffcb8c8 <global_stdio_init.part.0>:
2ffcb8c8:	4b0b      	ldr	r3, [pc, #44]	@ (2ffcb8f8 <global_stdio_init.part.0+0x30>)
2ffcb8ca:	2104      	movs	r1, #4
2ffcb8cc:	b510      	push	{r4, lr}
2ffcb8ce:	4c0b      	ldr	r4, [pc, #44]	@ (2ffcb8fc <global_stdio_init.part.0+0x34>)
2ffcb8d0:	4a0b      	ldr	r2, [pc, #44]	@ (2ffcb900 <global_stdio_init.part.0+0x38>)
2ffcb8d2:	4620      	mov	r0, r4
2ffcb8d4:	601a      	str	r2, [r3, #0]
2ffcb8d6:	2200      	movs	r2, #0
2ffcb8d8:	f7ff ff94 	bl	2ffcb804 <std>
2ffcb8dc:	f104 0068 	add.w	r0, r4, #104	@ 0x68
2ffcb8e0:	2201      	movs	r2, #1
2ffcb8e2:	2109      	movs	r1, #9
2ffcb8e4:	f7ff ff8e 	bl	2ffcb804 <std>
2ffcb8e8:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
2ffcb8ec:	2202      	movs	r2, #2
2ffcb8ee:	2112      	movs	r1, #18
2ffcb8f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
2ffcb8f4:	f7ff bf86 	b.w	2ffcb804 <std>
2ffcb8f8:	2ffd2b38 	.word	0x2ffd2b38
2ffcb8fc:	2ffd2a00 	.word	0x2ffd2a00
2ffcb900:	2ffcb871 	.word	0x2ffcb871

2ffcb904 <__sfp_lock_acquire>:
2ffcb904:	4801      	ldr	r0, [pc, #4]	@ (2ffcb90c <__sfp_lock_acquire+0x8>)
2ffcb906:	f000 ba56 	b.w	2ffcbdb6 <__retarget_lock_acquire_recursive>
2ffcb90a:	bf00      	nop
2ffcb90c:	2ffd2b41 	.word	0x2ffd2b41

2ffcb910 <__sfp_lock_release>:
2ffcb910:	4801      	ldr	r0, [pc, #4]	@ (2ffcb918 <__sfp_lock_release+0x8>)
2ffcb912:	f000 ba51 	b.w	2ffcbdb8 <__retarget_lock_release_recursive>
2ffcb916:	bf00      	nop
2ffcb918:	2ffd2b41 	.word	0x2ffd2b41

2ffcb91c <__sinit>:
2ffcb91c:	b510      	push	{r4, lr}
2ffcb91e:	4604      	mov	r4, r0
2ffcb920:	f7ff fff0 	bl	2ffcb904 <__sfp_lock_acquire>
2ffcb924:	6a23      	ldr	r3, [r4, #32]
2ffcb926:	b11b      	cbz	r3, 2ffcb930 <__sinit+0x14>
2ffcb928:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
2ffcb92c:	f7ff bff0 	b.w	2ffcb910 <__sfp_lock_release>
2ffcb930:	4b04      	ldr	r3, [pc, #16]	@ (2ffcb944 <__sinit+0x28>)
2ffcb932:	6223      	str	r3, [r4, #32]
2ffcb934:	4b04      	ldr	r3, [pc, #16]	@ (2ffcb948 <__sinit+0x2c>)
2ffcb936:	681b      	ldr	r3, [r3, #0]
2ffcb938:	2b00      	cmp	r3, #0
2ffcb93a:	d1f5      	bne.n	2ffcb928 <__sinit+0xc>
2ffcb93c:	f7ff ffc4 	bl	2ffcb8c8 <global_stdio_init.part.0>
2ffcb940:	e7f2      	b.n	2ffcb928 <__sinit+0xc>
2ffcb942:	bf00      	nop
2ffcb944:	2ffcb889 	.word	0x2ffcb889
2ffcb948:	2ffd2b38 	.word	0x2ffd2b38

2ffcb94c <_fwalk_sglue>:
2ffcb94c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
2ffcb950:	4607      	mov	r7, r0
2ffcb952:	4688      	mov	r8, r1
2ffcb954:	4614      	mov	r4, r2
2ffcb956:	2600      	movs	r6, #0
2ffcb958:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
2ffcb95c:	f1b9 0901 	subs.w	r9, r9, #1
2ffcb960:	d505      	bpl.n	2ffcb96e <_fwalk_sglue+0x22>
2ffcb962:	6824      	ldr	r4, [r4, #0]
2ffcb964:	2c00      	cmp	r4, #0
2ffcb966:	d1f7      	bne.n	2ffcb958 <_fwalk_sglue+0xc>
2ffcb968:	4630      	mov	r0, r6
2ffcb96a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
2ffcb96e:	89ab      	ldrh	r3, [r5, #12]
2ffcb970:	2b01      	cmp	r3, #1
2ffcb972:	d907      	bls.n	2ffcb984 <_fwalk_sglue+0x38>
2ffcb974:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
2ffcb978:	3301      	adds	r3, #1
2ffcb97a:	d003      	beq.n	2ffcb984 <_fwalk_sglue+0x38>
2ffcb97c:	4629      	mov	r1, r5
2ffcb97e:	4638      	mov	r0, r7
2ffcb980:	47c0      	blx	r8
2ffcb982:	4306      	orrs	r6, r0
2ffcb984:	3568      	adds	r5, #104	@ 0x68
2ffcb986:	e7e9      	b.n	2ffcb95c <_fwalk_sglue+0x10>

2ffcb988 <iprintf>:
2ffcb988:	b40f      	push	{r0, r1, r2, r3}
2ffcb98a:	b507      	push	{r0, r1, r2, lr}
2ffcb98c:	4906      	ldr	r1, [pc, #24]	@ (2ffcb9a8 <iprintf+0x20>)
2ffcb98e:	ab04      	add	r3, sp, #16
2ffcb990:	6808      	ldr	r0, [r1, #0]
2ffcb992:	f853 2b04 	ldr.w	r2, [r3], #4
2ffcb996:	9301      	str	r3, [sp, #4]
2ffcb998:	6881      	ldr	r1, [r0, #8]
2ffcb99a:	f000 fc25 	bl	2ffcc1e8 <_vfiprintf_r>
2ffcb99e:	b003      	add	sp, #12
2ffcb9a0:	f85d eb04 	ldr.w	lr, [sp], #4
2ffcb9a4:	b004      	add	sp, #16
2ffcb9a6:	4770      	bx	lr
2ffcb9a8:	2ffd18a8 	.word	0x2ffd18a8

2ffcb9ac <_puts_r>:
2ffcb9ac:	6a03      	ldr	r3, [r0, #32]
2ffcb9ae:	b570      	push	{r4, r5, r6, lr}
2ffcb9b0:	4605      	mov	r5, r0
2ffcb9b2:	6884      	ldr	r4, [r0, #8]
2ffcb9b4:	460e      	mov	r6, r1
2ffcb9b6:	b90b      	cbnz	r3, 2ffcb9bc <_puts_r+0x10>
2ffcb9b8:	f7ff ffb0 	bl	2ffcb91c <__sinit>
2ffcb9bc:	6e63      	ldr	r3, [r4, #100]	@ 0x64
2ffcb9be:	07db      	lsls	r3, r3, #31
2ffcb9c0:	d405      	bmi.n	2ffcb9ce <_puts_r+0x22>
2ffcb9c2:	89a3      	ldrh	r3, [r4, #12]
2ffcb9c4:	0598      	lsls	r0, r3, #22
2ffcb9c6:	d402      	bmi.n	2ffcb9ce <_puts_r+0x22>
2ffcb9c8:	6da0      	ldr	r0, [r4, #88]	@ 0x58
2ffcb9ca:	f000 f9f4 	bl	2ffcbdb6 <__retarget_lock_acquire_recursive>
2ffcb9ce:	89a3      	ldrh	r3, [r4, #12]
2ffcb9d0:	0719      	lsls	r1, r3, #28
2ffcb9d2:	d502      	bpl.n	2ffcb9da <_puts_r+0x2e>
2ffcb9d4:	6923      	ldr	r3, [r4, #16]
2ffcb9d6:	2b00      	cmp	r3, #0
2ffcb9d8:	d135      	bne.n	2ffcba46 <_puts_r+0x9a>
2ffcb9da:	4621      	mov	r1, r4
2ffcb9dc:	4628      	mov	r0, r5
2ffcb9de:	f000 f8e5 	bl	2ffcbbac <__swsetup_r>
2ffcb9e2:	b380      	cbz	r0, 2ffcba46 <_puts_r+0x9a>
2ffcb9e4:	f04f 35ff 	mov.w	r5, #4294967295	@ 0xffffffff
2ffcb9e8:	6e63      	ldr	r3, [r4, #100]	@ 0x64
2ffcb9ea:	07da      	lsls	r2, r3, #31
2ffcb9ec:	d405      	bmi.n	2ffcb9fa <_puts_r+0x4e>
2ffcb9ee:	89a3      	ldrh	r3, [r4, #12]
2ffcb9f0:	059b      	lsls	r3, r3, #22
2ffcb9f2:	d402      	bmi.n	2ffcb9fa <_puts_r+0x4e>
2ffcb9f4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
2ffcb9f6:	f000 f9df 	bl	2ffcbdb8 <__retarget_lock_release_recursive>
2ffcb9fa:	4628      	mov	r0, r5
2ffcb9fc:	bd70      	pop	{r4, r5, r6, pc}
2ffcb9fe:	2b00      	cmp	r3, #0
2ffcba00:	da04      	bge.n	2ffcba0c <_puts_r+0x60>
2ffcba02:	69a2      	ldr	r2, [r4, #24]
2ffcba04:	429a      	cmp	r2, r3
2ffcba06:	dc17      	bgt.n	2ffcba38 <_puts_r+0x8c>
2ffcba08:	290a      	cmp	r1, #10
2ffcba0a:	d015      	beq.n	2ffcba38 <_puts_r+0x8c>
2ffcba0c:	6823      	ldr	r3, [r4, #0]
2ffcba0e:	1c5a      	adds	r2, r3, #1
2ffcba10:	6022      	str	r2, [r4, #0]
2ffcba12:	7019      	strb	r1, [r3, #0]
2ffcba14:	f816 1f01 	ldrb.w	r1, [r6, #1]!
2ffcba18:	68a3      	ldr	r3, [r4, #8]
2ffcba1a:	3b01      	subs	r3, #1
2ffcba1c:	60a3      	str	r3, [r4, #8]
2ffcba1e:	2900      	cmp	r1, #0
2ffcba20:	d1ed      	bne.n	2ffcb9fe <_puts_r+0x52>
2ffcba22:	2b00      	cmp	r3, #0
2ffcba24:	da11      	bge.n	2ffcba4a <_puts_r+0x9e>
2ffcba26:	4622      	mov	r2, r4
2ffcba28:	210a      	movs	r1, #10
2ffcba2a:	4628      	mov	r0, r5
2ffcba2c:	f000 f87f 	bl	2ffcbb2e <__swbuf_r>
2ffcba30:	3001      	adds	r0, #1
2ffcba32:	d0d7      	beq.n	2ffcb9e4 <_puts_r+0x38>
2ffcba34:	250a      	movs	r5, #10
2ffcba36:	e7d7      	b.n	2ffcb9e8 <_puts_r+0x3c>
2ffcba38:	4622      	mov	r2, r4
2ffcba3a:	4628      	mov	r0, r5
2ffcba3c:	f000 f877 	bl	2ffcbb2e <__swbuf_r>
2ffcba40:	3001      	adds	r0, #1
2ffcba42:	d1e7      	bne.n	2ffcba14 <_puts_r+0x68>
2ffcba44:	e7ce      	b.n	2ffcb9e4 <_puts_r+0x38>
2ffcba46:	3e01      	subs	r6, #1
2ffcba48:	e7e4      	b.n	2ffcba14 <_puts_r+0x68>
2ffcba4a:	6823      	ldr	r3, [r4, #0]
2ffcba4c:	1c5a      	adds	r2, r3, #1
2ffcba4e:	6022      	str	r2, [r4, #0]
2ffcba50:	220a      	movs	r2, #10
2ffcba52:	701a      	strb	r2, [r3, #0]
2ffcba54:	e7ee      	b.n	2ffcba34 <_puts_r+0x88>
	...

2ffcba58 <puts>:
2ffcba58:	4b02      	ldr	r3, [pc, #8]	@ (2ffcba64 <puts+0xc>)
2ffcba5a:	4601      	mov	r1, r0
2ffcba5c:	6818      	ldr	r0, [r3, #0]
2ffcba5e:	f7ff bfa5 	b.w	2ffcb9ac <_puts_r>
2ffcba62:	bf00      	nop
2ffcba64:	2ffd18a8 	.word	0x2ffd18a8

2ffcba68 <siprintf>:
2ffcba68:	b40e      	push	{r1, r2, r3}
2ffcba6a:	f06f 4100 	mvn.w	r1, #2147483648	@ 0x80000000
2ffcba6e:	b500      	push	{lr}
2ffcba70:	b09c      	sub	sp, #112	@ 0x70
2ffcba72:	ab1d      	add	r3, sp, #116	@ 0x74
2ffcba74:	9002      	str	r0, [sp, #8]
2ffcba76:	9006      	str	r0, [sp, #24]
2ffcba78:	4809      	ldr	r0, [pc, #36]	@ (2ffcbaa0 <siprintf+0x38>)
2ffcba7a:	9107      	str	r1, [sp, #28]
2ffcba7c:	9104      	str	r1, [sp, #16]
2ffcba7e:	4909      	ldr	r1, [pc, #36]	@ (2ffcbaa4 <siprintf+0x3c>)
2ffcba80:	f853 2b04 	ldr.w	r2, [r3], #4
2ffcba84:	9105      	str	r1, [sp, #20]
2ffcba86:	a902      	add	r1, sp, #8
2ffcba88:	6800      	ldr	r0, [r0, #0]
2ffcba8a:	9301      	str	r3, [sp, #4]
2ffcba8c:	f000 fa86 	bl	2ffcbf9c <_svfiprintf_r>
2ffcba90:	9b02      	ldr	r3, [sp, #8]
2ffcba92:	2200      	movs	r2, #0
2ffcba94:	701a      	strb	r2, [r3, #0]
2ffcba96:	b01c      	add	sp, #112	@ 0x70
2ffcba98:	f85d eb04 	ldr.w	lr, [sp], #4
2ffcba9c:	b003      	add	sp, #12
2ffcba9e:	4770      	bx	lr
2ffcbaa0:	2ffd18a8 	.word	0x2ffd18a8
2ffcbaa4:	ffff0208 	.word	0xffff0208

2ffcbaa8 <__sread>:
2ffcbaa8:	b510      	push	{r4, lr}
2ffcbaaa:	460c      	mov	r4, r1
2ffcbaac:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
2ffcbab0:	f000 f922 	bl	2ffcbcf8 <_read_r>
2ffcbab4:	2800      	cmp	r0, #0
2ffcbab6:	bfa9      	itett	ge
2ffcbab8:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
2ffcbaba:	89a3      	ldrhlt	r3, [r4, #12]
2ffcbabc:	181b      	addge	r3, r3, r0
2ffcbabe:	6563      	strge	r3, [r4, #84]	@ 0x54
2ffcbac0:	bfbc      	itt	lt
2ffcbac2:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
2ffcbac6:	81a3      	strhlt	r3, [r4, #12]
2ffcbac8:	bd10      	pop	{r4, pc}

2ffcbaca <__swrite>:
2ffcbaca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
2ffcbace:	461f      	mov	r7, r3
2ffcbad0:	898b      	ldrh	r3, [r1, #12]
2ffcbad2:	4605      	mov	r5, r0
2ffcbad4:	460c      	mov	r4, r1
2ffcbad6:	4616      	mov	r6, r2
2ffcbad8:	05db      	lsls	r3, r3, #23
2ffcbada:	d505      	bpl.n	2ffcbae8 <__swrite+0x1e>
2ffcbadc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
2ffcbae0:	2302      	movs	r3, #2
2ffcbae2:	2200      	movs	r2, #0
2ffcbae4:	f000 f8f6 	bl	2ffcbcd4 <_lseek_r>
2ffcbae8:	89a3      	ldrh	r3, [r4, #12]
2ffcbaea:	4632      	mov	r2, r6
2ffcbaec:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
2ffcbaf0:	4628      	mov	r0, r5
2ffcbaf2:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
2ffcbaf6:	81a3      	strh	r3, [r4, #12]
2ffcbaf8:	463b      	mov	r3, r7
2ffcbafa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
2ffcbafe:	f000 b91d 	b.w	2ffcbd3c <_write_r>

2ffcbb02 <__sseek>:
2ffcbb02:	b510      	push	{r4, lr}
2ffcbb04:	460c      	mov	r4, r1
2ffcbb06:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
2ffcbb0a:	f000 f8e3 	bl	2ffcbcd4 <_lseek_r>
2ffcbb0e:	1c43      	adds	r3, r0, #1
2ffcbb10:	89a3      	ldrh	r3, [r4, #12]
2ffcbb12:	bf15      	itete	ne
2ffcbb14:	6560      	strne	r0, [r4, #84]	@ 0x54
2ffcbb16:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
2ffcbb1a:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
2ffcbb1e:	81a3      	strheq	r3, [r4, #12]
2ffcbb20:	bf18      	it	ne
2ffcbb22:	81a3      	strhne	r3, [r4, #12]
2ffcbb24:	bd10      	pop	{r4, pc}

2ffcbb26 <__sclose>:
2ffcbb26:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
2ffcbb2a:	f000 b8c3 	b.w	2ffcbcb4 <_close_r>

2ffcbb2e <__swbuf_r>:
2ffcbb2e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2ffcbb30:	460e      	mov	r6, r1
2ffcbb32:	4614      	mov	r4, r2
2ffcbb34:	4605      	mov	r5, r0
2ffcbb36:	b118      	cbz	r0, 2ffcbb40 <__swbuf_r+0x12>
2ffcbb38:	6a03      	ldr	r3, [r0, #32]
2ffcbb3a:	b90b      	cbnz	r3, 2ffcbb40 <__swbuf_r+0x12>
2ffcbb3c:	f7ff feee 	bl	2ffcb91c <__sinit>
2ffcbb40:	69a3      	ldr	r3, [r4, #24]
2ffcbb42:	60a3      	str	r3, [r4, #8]
2ffcbb44:	89a3      	ldrh	r3, [r4, #12]
2ffcbb46:	071a      	lsls	r2, r3, #28
2ffcbb48:	d501      	bpl.n	2ffcbb4e <__swbuf_r+0x20>
2ffcbb4a:	6923      	ldr	r3, [r4, #16]
2ffcbb4c:	b943      	cbnz	r3, 2ffcbb60 <__swbuf_r+0x32>
2ffcbb4e:	4621      	mov	r1, r4
2ffcbb50:	4628      	mov	r0, r5
2ffcbb52:	f000 f82b 	bl	2ffcbbac <__swsetup_r>
2ffcbb56:	b118      	cbz	r0, 2ffcbb60 <__swbuf_r+0x32>
2ffcbb58:	f04f 37ff 	mov.w	r7, #4294967295	@ 0xffffffff
2ffcbb5c:	4638      	mov	r0, r7
2ffcbb5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
2ffcbb60:	6823      	ldr	r3, [r4, #0]
2ffcbb62:	b2f6      	uxtb	r6, r6
2ffcbb64:	6922      	ldr	r2, [r4, #16]
2ffcbb66:	4637      	mov	r7, r6
2ffcbb68:	1a98      	subs	r0, r3, r2
2ffcbb6a:	6963      	ldr	r3, [r4, #20]
2ffcbb6c:	4283      	cmp	r3, r0
2ffcbb6e:	dc05      	bgt.n	2ffcbb7c <__swbuf_r+0x4e>
2ffcbb70:	4621      	mov	r1, r4
2ffcbb72:	4628      	mov	r0, r5
2ffcbb74:	f000 fe66 	bl	2ffcc844 <_fflush_r>
2ffcbb78:	2800      	cmp	r0, #0
2ffcbb7a:	d1ed      	bne.n	2ffcbb58 <__swbuf_r+0x2a>
2ffcbb7c:	68a3      	ldr	r3, [r4, #8]
2ffcbb7e:	3b01      	subs	r3, #1
2ffcbb80:	60a3      	str	r3, [r4, #8]
2ffcbb82:	6823      	ldr	r3, [r4, #0]
2ffcbb84:	1c5a      	adds	r2, r3, #1
2ffcbb86:	6022      	str	r2, [r4, #0]
2ffcbb88:	701e      	strb	r6, [r3, #0]
2ffcbb8a:	1c43      	adds	r3, r0, #1
2ffcbb8c:	6962      	ldr	r2, [r4, #20]
2ffcbb8e:	429a      	cmp	r2, r3
2ffcbb90:	d004      	beq.n	2ffcbb9c <__swbuf_r+0x6e>
2ffcbb92:	89a3      	ldrh	r3, [r4, #12]
2ffcbb94:	07db      	lsls	r3, r3, #31
2ffcbb96:	d5e1      	bpl.n	2ffcbb5c <__swbuf_r+0x2e>
2ffcbb98:	2e0a      	cmp	r6, #10
2ffcbb9a:	d1df      	bne.n	2ffcbb5c <__swbuf_r+0x2e>
2ffcbb9c:	4621      	mov	r1, r4
2ffcbb9e:	4628      	mov	r0, r5
2ffcbba0:	f000 fe50 	bl	2ffcc844 <_fflush_r>
2ffcbba4:	2800      	cmp	r0, #0
2ffcbba6:	d0d9      	beq.n	2ffcbb5c <__swbuf_r+0x2e>
2ffcbba8:	e7d6      	b.n	2ffcbb58 <__swbuf_r+0x2a>
	...

2ffcbbac <__swsetup_r>:
2ffcbbac:	b538      	push	{r3, r4, r5, lr}
2ffcbbae:	4605      	mov	r5, r0
2ffcbbb0:	4b28      	ldr	r3, [pc, #160]	@ (2ffcbc54 <__swsetup_r+0xa8>)
2ffcbbb2:	460c      	mov	r4, r1
2ffcbbb4:	6818      	ldr	r0, [r3, #0]
2ffcbbb6:	b118      	cbz	r0, 2ffcbbc0 <__swsetup_r+0x14>
2ffcbbb8:	6a03      	ldr	r3, [r0, #32]
2ffcbbba:	b90b      	cbnz	r3, 2ffcbbc0 <__swsetup_r+0x14>
2ffcbbbc:	f7ff feae 	bl	2ffcb91c <__sinit>
2ffcbbc0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
2ffcbbc4:	0719      	lsls	r1, r3, #28
2ffcbbc6:	d422      	bmi.n	2ffcbc0e <__swsetup_r+0x62>
2ffcbbc8:	06da      	lsls	r2, r3, #27
2ffcbbca:	d407      	bmi.n	2ffcbbdc <__swsetup_r+0x30>
2ffcbbcc:	2209      	movs	r2, #9
2ffcbbce:	602a      	str	r2, [r5, #0]
2ffcbbd0:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
2ffcbbd4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
2ffcbbd8:	81a3      	strh	r3, [r4, #12]
2ffcbbda:	e033      	b.n	2ffcbc44 <__swsetup_r+0x98>
2ffcbbdc:	0758      	lsls	r0, r3, #29
2ffcbbde:	d512      	bpl.n	2ffcbc06 <__swsetup_r+0x5a>
2ffcbbe0:	6b61      	ldr	r1, [r4, #52]	@ 0x34
2ffcbbe2:	b141      	cbz	r1, 2ffcbbf6 <__swsetup_r+0x4a>
2ffcbbe4:	f104 0344 	add.w	r3, r4, #68	@ 0x44
2ffcbbe8:	4299      	cmp	r1, r3
2ffcbbea:	d002      	beq.n	2ffcbbf2 <__swsetup_r+0x46>
2ffcbbec:	4628      	mov	r0, r5
2ffcbbee:	f000 f92f 	bl	2ffcbe50 <_free_r>
2ffcbbf2:	2300      	movs	r3, #0
2ffcbbf4:	6363      	str	r3, [r4, #52]	@ 0x34
2ffcbbf6:	89a3      	ldrh	r3, [r4, #12]
2ffcbbf8:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
2ffcbbfc:	81a3      	strh	r3, [r4, #12]
2ffcbbfe:	2300      	movs	r3, #0
2ffcbc00:	6063      	str	r3, [r4, #4]
2ffcbc02:	6923      	ldr	r3, [r4, #16]
2ffcbc04:	6023      	str	r3, [r4, #0]
2ffcbc06:	89a3      	ldrh	r3, [r4, #12]
2ffcbc08:	f043 0308 	orr.w	r3, r3, #8
2ffcbc0c:	81a3      	strh	r3, [r4, #12]
2ffcbc0e:	6923      	ldr	r3, [r4, #16]
2ffcbc10:	b94b      	cbnz	r3, 2ffcbc26 <__swsetup_r+0x7a>
2ffcbc12:	89a3      	ldrh	r3, [r4, #12]
2ffcbc14:	f403 7320 	and.w	r3, r3, #640	@ 0x280
2ffcbc18:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
2ffcbc1c:	d003      	beq.n	2ffcbc26 <__swsetup_r+0x7a>
2ffcbc1e:	4621      	mov	r1, r4
2ffcbc20:	4628      	mov	r0, r5
2ffcbc22:	f000 fe6e 	bl	2ffcc902 <__smakebuf_r>
2ffcbc26:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
2ffcbc2a:	f013 0201 	ands.w	r2, r3, #1
2ffcbc2e:	d00a      	beq.n	2ffcbc46 <__swsetup_r+0x9a>
2ffcbc30:	2200      	movs	r2, #0
2ffcbc32:	60a2      	str	r2, [r4, #8]
2ffcbc34:	6962      	ldr	r2, [r4, #20]
2ffcbc36:	4252      	negs	r2, r2
2ffcbc38:	61a2      	str	r2, [r4, #24]
2ffcbc3a:	6922      	ldr	r2, [r4, #16]
2ffcbc3c:	b942      	cbnz	r2, 2ffcbc50 <__swsetup_r+0xa4>
2ffcbc3e:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
2ffcbc42:	d1c5      	bne.n	2ffcbbd0 <__swsetup_r+0x24>
2ffcbc44:	bd38      	pop	{r3, r4, r5, pc}
2ffcbc46:	0799      	lsls	r1, r3, #30
2ffcbc48:	bf58      	it	pl
2ffcbc4a:	6962      	ldrpl	r2, [r4, #20]
2ffcbc4c:	60a2      	str	r2, [r4, #8]
2ffcbc4e:	e7f4      	b.n	2ffcbc3a <__swsetup_r+0x8e>
2ffcbc50:	2000      	movs	r0, #0
2ffcbc52:	e7f7      	b.n	2ffcbc44 <__swsetup_r+0x98>
2ffcbc54:	2ffd18a8 	.word	0x2ffd18a8

2ffcbc58 <memset>:
2ffcbc58:	4402      	add	r2, r0
2ffcbc5a:	4603      	mov	r3, r0
2ffcbc5c:	4293      	cmp	r3, r2
2ffcbc5e:	d100      	bne.n	2ffcbc62 <memset+0xa>
2ffcbc60:	4770      	bx	lr
2ffcbc62:	f803 1b01 	strb.w	r1, [r3], #1
2ffcbc66:	e7f9      	b.n	2ffcbc5c <memset+0x4>

2ffcbc68 <strncmp>:
2ffcbc68:	b510      	push	{r4, lr}
2ffcbc6a:	b16a      	cbz	r2, 2ffcbc88 <strncmp+0x20>
2ffcbc6c:	3901      	subs	r1, #1
2ffcbc6e:	1884      	adds	r4, r0, r2
2ffcbc70:	f810 2b01 	ldrb.w	r2, [r0], #1
2ffcbc74:	f811 3f01 	ldrb.w	r3, [r1, #1]!
2ffcbc78:	429a      	cmp	r2, r3
2ffcbc7a:	d103      	bne.n	2ffcbc84 <strncmp+0x1c>
2ffcbc7c:	42a0      	cmp	r0, r4
2ffcbc7e:	d001      	beq.n	2ffcbc84 <strncmp+0x1c>
2ffcbc80:	2a00      	cmp	r2, #0
2ffcbc82:	d1f5      	bne.n	2ffcbc70 <strncmp+0x8>
2ffcbc84:	1ad0      	subs	r0, r2, r3
2ffcbc86:	bd10      	pop	{r4, pc}
2ffcbc88:	4610      	mov	r0, r2
2ffcbc8a:	e7fc      	b.n	2ffcbc86 <strncmp+0x1e>

2ffcbc8c <strncpy>:
2ffcbc8c:	3901      	subs	r1, #1
2ffcbc8e:	4603      	mov	r3, r0
2ffcbc90:	b510      	push	{r4, lr}
2ffcbc92:	b132      	cbz	r2, 2ffcbca2 <strncpy+0x16>
2ffcbc94:	f811 4f01 	ldrb.w	r4, [r1, #1]!
2ffcbc98:	3a01      	subs	r2, #1
2ffcbc9a:	f803 4b01 	strb.w	r4, [r3], #1
2ffcbc9e:	2c00      	cmp	r4, #0
2ffcbca0:	d1f7      	bne.n	2ffcbc92 <strncpy+0x6>
2ffcbca2:	441a      	add	r2, r3
2ffcbca4:	2100      	movs	r1, #0
2ffcbca6:	4293      	cmp	r3, r2
2ffcbca8:	d100      	bne.n	2ffcbcac <strncpy+0x20>
2ffcbcaa:	bd10      	pop	{r4, pc}
2ffcbcac:	f803 1b01 	strb.w	r1, [r3], #1
2ffcbcb0:	e7f9      	b.n	2ffcbca6 <strncpy+0x1a>
	...

2ffcbcb4 <_close_r>:
2ffcbcb4:	b538      	push	{r3, r4, r5, lr}
2ffcbcb6:	4604      	mov	r4, r0
2ffcbcb8:	4d05      	ldr	r5, [pc, #20]	@ (2ffcbcd0 <_close_r+0x1c>)
2ffcbcba:	4608      	mov	r0, r1
2ffcbcbc:	2300      	movs	r3, #0
2ffcbcbe:	602b      	str	r3, [r5, #0]
2ffcbcc0:	f7f6 fd32 	bl	2ffc2728 <_close>
2ffcbcc4:	1c43      	adds	r3, r0, #1
2ffcbcc6:	d102      	bne.n	2ffcbcce <_close_r+0x1a>
2ffcbcc8:	682b      	ldr	r3, [r5, #0]
2ffcbcca:	b103      	cbz	r3, 2ffcbcce <_close_r+0x1a>
2ffcbccc:	6023      	str	r3, [r4, #0]
2ffcbcce:	bd38      	pop	{r3, r4, r5, pc}
2ffcbcd0:	2ffd2b3c 	.word	0x2ffd2b3c

2ffcbcd4 <_lseek_r>:
2ffcbcd4:	b538      	push	{r3, r4, r5, lr}
2ffcbcd6:	4604      	mov	r4, r0
2ffcbcd8:	4d06      	ldr	r5, [pc, #24]	@ (2ffcbcf4 <_lseek_r+0x20>)
2ffcbcda:	4608      	mov	r0, r1
2ffcbcdc:	4611      	mov	r1, r2
2ffcbcde:	2200      	movs	r2, #0
2ffcbce0:	602a      	str	r2, [r5, #0]
2ffcbce2:	461a      	mov	r2, r3
2ffcbce4:	f7f6 fd2c 	bl	2ffc2740 <_lseek>
2ffcbce8:	1c43      	adds	r3, r0, #1
2ffcbcea:	d102      	bne.n	2ffcbcf2 <_lseek_r+0x1e>
2ffcbcec:	682b      	ldr	r3, [r5, #0]
2ffcbcee:	b103      	cbz	r3, 2ffcbcf2 <_lseek_r+0x1e>
2ffcbcf0:	6023      	str	r3, [r4, #0]
2ffcbcf2:	bd38      	pop	{r3, r4, r5, pc}
2ffcbcf4:	2ffd2b3c 	.word	0x2ffd2b3c

2ffcbcf8 <_read_r>:
2ffcbcf8:	b538      	push	{r3, r4, r5, lr}
2ffcbcfa:	4604      	mov	r4, r0
2ffcbcfc:	4d06      	ldr	r5, [pc, #24]	@ (2ffcbd18 <_read_r+0x20>)
2ffcbcfe:	4608      	mov	r0, r1
2ffcbd00:	4611      	mov	r1, r2
2ffcbd02:	2200      	movs	r2, #0
2ffcbd04:	602a      	str	r2, [r5, #0]
2ffcbd06:	461a      	mov	r2, r3
2ffcbd08:	f7f6 fcd4 	bl	2ffc26b4 <_read>
2ffcbd0c:	1c43      	adds	r3, r0, #1
2ffcbd0e:	d102      	bne.n	2ffcbd16 <_read_r+0x1e>
2ffcbd10:	682b      	ldr	r3, [r5, #0]
2ffcbd12:	b103      	cbz	r3, 2ffcbd16 <_read_r+0x1e>
2ffcbd14:	6023      	str	r3, [r4, #0]
2ffcbd16:	bd38      	pop	{r3, r4, r5, pc}
2ffcbd18:	2ffd2b3c 	.word	0x2ffd2b3c

2ffcbd1c <_sbrk_r>:
2ffcbd1c:	b538      	push	{r3, r4, r5, lr}
2ffcbd1e:	4604      	mov	r4, r0
2ffcbd20:	4d05      	ldr	r5, [pc, #20]	@ (2ffcbd38 <_sbrk_r+0x1c>)
2ffcbd22:	4608      	mov	r0, r1
2ffcbd24:	2300      	movs	r3, #0
2ffcbd26:	602b      	str	r3, [r5, #0]
2ffcbd28:	f7f6 fce0 	bl	2ffc26ec <_sbrk>
2ffcbd2c:	1c43      	adds	r3, r0, #1
2ffcbd2e:	d102      	bne.n	2ffcbd36 <_sbrk_r+0x1a>
2ffcbd30:	682b      	ldr	r3, [r5, #0]
2ffcbd32:	b103      	cbz	r3, 2ffcbd36 <_sbrk_r+0x1a>
2ffcbd34:	6023      	str	r3, [r4, #0]
2ffcbd36:	bd38      	pop	{r3, r4, r5, pc}
2ffcbd38:	2ffd2b3c 	.word	0x2ffd2b3c

2ffcbd3c <_write_r>:
2ffcbd3c:	b538      	push	{r3, r4, r5, lr}
2ffcbd3e:	4604      	mov	r4, r0
2ffcbd40:	4d06      	ldr	r5, [pc, #24]	@ (2ffcbd5c <_write_r+0x20>)
2ffcbd42:	4608      	mov	r0, r1
2ffcbd44:	4611      	mov	r1, r2
2ffcbd46:	2200      	movs	r2, #0
2ffcbd48:	602a      	str	r2, [r5, #0]
2ffcbd4a:	461a      	mov	r2, r3
2ffcbd4c:	f7f6 fcc0 	bl	2ffc26d0 <_write>
2ffcbd50:	1c43      	adds	r3, r0, #1
2ffcbd52:	d102      	bne.n	2ffcbd5a <_write_r+0x1e>
2ffcbd54:	682b      	ldr	r3, [r5, #0]
2ffcbd56:	b103      	cbz	r3, 2ffcbd5a <_write_r+0x1e>
2ffcbd58:	6023      	str	r3, [r4, #0]
2ffcbd5a:	bd38      	pop	{r3, r4, r5, pc}
2ffcbd5c:	2ffd2b3c 	.word	0x2ffd2b3c

2ffcbd60 <__errno>:
2ffcbd60:	4b01      	ldr	r3, [pc, #4]	@ (2ffcbd68 <__errno+0x8>)
2ffcbd62:	6818      	ldr	r0, [r3, #0]
2ffcbd64:	4770      	bx	lr
2ffcbd66:	bf00      	nop
2ffcbd68:	2ffd18a8 	.word	0x2ffd18a8

2ffcbd6c <__libc_init_array>:
2ffcbd6c:	b570      	push	{r4, r5, r6, lr}
2ffcbd6e:	2600      	movs	r6, #0
2ffcbd70:	4d0c      	ldr	r5, [pc, #48]	@ (2ffcbda4 <__libc_init_array+0x38>)
2ffcbd72:	4c0d      	ldr	r4, [pc, #52]	@ (2ffcbda8 <__libc_init_array+0x3c>)
2ffcbd74:	1b64      	subs	r4, r4, r5
2ffcbd76:	10a4      	asrs	r4, r4, #2
2ffcbd78:	42a6      	cmp	r6, r4
2ffcbd7a:	d109      	bne.n	2ffcbd90 <__libc_init_array+0x24>
2ffcbd7c:	4d0b      	ldr	r5, [pc, #44]	@ (2ffcbdac <__libc_init_array+0x40>)
2ffcbd7e:	2600      	movs	r6, #0
2ffcbd80:	4c0b      	ldr	r4, [pc, #44]	@ (2ffcbdb0 <__libc_init_array+0x44>)
2ffcbd82:	f001 f955 	bl	2ffcd030 <_init>
2ffcbd86:	1b64      	subs	r4, r4, r5
2ffcbd88:	10a4      	asrs	r4, r4, #2
2ffcbd8a:	42a6      	cmp	r6, r4
2ffcbd8c:	d105      	bne.n	2ffcbd9a <__libc_init_array+0x2e>
2ffcbd8e:	bd70      	pop	{r4, r5, r6, pc}
2ffcbd90:	f855 3b04 	ldr.w	r3, [r5], #4
2ffcbd94:	3601      	adds	r6, #1
2ffcbd96:	4798      	blx	r3
2ffcbd98:	e7ee      	b.n	2ffcbd78 <__libc_init_array+0xc>
2ffcbd9a:	f855 3b04 	ldr.w	r3, [r5], #4
2ffcbd9e:	3601      	adds	r6, #1
2ffcbda0:	4798      	blx	r3
2ffcbda2:	e7f2      	b.n	2ffcbd8a <__libc_init_array+0x1e>
2ffcbda4:	2ffd1008 	.word	0x2ffd1008
2ffcbda8:	2ffd1008 	.word	0x2ffd1008
2ffcbdac:	2ffd1008 	.word	0x2ffd1008
2ffcbdb0:	2ffd100c 	.word	0x2ffd100c

2ffcbdb4 <__retarget_lock_init_recursive>:
2ffcbdb4:	4770      	bx	lr

2ffcbdb6 <__retarget_lock_acquire_recursive>:
2ffcbdb6:	4770      	bx	lr

2ffcbdb8 <__retarget_lock_release_recursive>:
2ffcbdb8:	4770      	bx	lr
	...

2ffcbdbc <strcmp>:
2ffcbdbc:	e4d02001 	ldrb	r2, [r0], #1
2ffcbdc0:	e4d13001 	ldrb	r3, [r1], #1
2ffcbdc4:	e3520001 	cmp	r2, #1
2ffcbdc8:	21520003 	cmpcs	r2, r3
2ffcbdcc:	0afffffa 	beq	2ffcbdbc <strcmp>
2ffcbdd0:	e0520003 	subs	r0, r2, r3
2ffcbdd4:	e12fff1e 	bx	lr

2ffcbdd8 <strcpy>:
2ffcbdd8:	4603      	mov	r3, r0
2ffcbdda:	f811 2b01 	ldrb.w	r2, [r1], #1
2ffcbdde:	f803 2b01 	strb.w	r2, [r3], #1
2ffcbde2:	2a00      	cmp	r2, #0
2ffcbde4:	d1f9      	bne.n	2ffcbdda <strcpy+0x2>
2ffcbde6:	4770      	bx	lr

2ffcbde8 <memcpy>:
2ffcbde8:	440a      	add	r2, r1
2ffcbdea:	1e43      	subs	r3, r0, #1
2ffcbdec:	4291      	cmp	r1, r2
2ffcbdee:	d100      	bne.n	2ffcbdf2 <memcpy+0xa>
2ffcbdf0:	4770      	bx	lr
2ffcbdf2:	b510      	push	{r4, lr}
2ffcbdf4:	f811 4b01 	ldrb.w	r4, [r1], #1
2ffcbdf8:	f803 4f01 	strb.w	r4, [r3, #1]!
2ffcbdfc:	4291      	cmp	r1, r2
2ffcbdfe:	d1f9      	bne.n	2ffcbdf4 <memcpy+0xc>
2ffcbe00:	bd10      	pop	{r4, pc}

2ffcbe02 <strlen>:
2ffcbe02:	4603      	mov	r3, r0
2ffcbe04:	f813 2b01 	ldrb.w	r2, [r3], #1
2ffcbe08:	2a00      	cmp	r2, #0
2ffcbe0a:	d1fb      	bne.n	2ffcbe04 <strlen+0x2>
2ffcbe0c:	1a18      	subs	r0, r3, r0
2ffcbe0e:	3801      	subs	r0, #1
2ffcbe10:	4770      	bx	lr
	...

2ffcbe14 <__assert_func>:
2ffcbe14:	b51f      	push	{r0, r1, r2, r3, r4, lr}
2ffcbe16:	4614      	mov	r4, r2
2ffcbe18:	461a      	mov	r2, r3
2ffcbe1a:	4b09      	ldr	r3, [pc, #36]	@ (2ffcbe40 <__assert_func+0x2c>)
2ffcbe1c:	4605      	mov	r5, r0
2ffcbe1e:	681b      	ldr	r3, [r3, #0]
2ffcbe20:	68d8      	ldr	r0, [r3, #12]
2ffcbe22:	b954      	cbnz	r4, 2ffcbe3a <__assert_func+0x26>
2ffcbe24:	4b07      	ldr	r3, [pc, #28]	@ (2ffcbe44 <__assert_func+0x30>)
2ffcbe26:	461c      	mov	r4, r3
2ffcbe28:	e9cd 3401 	strd	r3, r4, [sp, #4]
2ffcbe2c:	462b      	mov	r3, r5
2ffcbe2e:	9100      	str	r1, [sp, #0]
2ffcbe30:	4905      	ldr	r1, [pc, #20]	@ (2ffcbe48 <__assert_func+0x34>)
2ffcbe32:	f000 fd2f 	bl	2ffcc894 <fiprintf>
2ffcbe36:	f000 fe57 	bl	2ffccae8 <abort>
2ffcbe3a:	4b04      	ldr	r3, [pc, #16]	@ (2ffcbe4c <__assert_func+0x38>)
2ffcbe3c:	e7f4      	b.n	2ffcbe28 <__assert_func+0x14>
2ffcbe3e:	bf00      	nop
2ffcbe40:	2ffd18a8 	.word	0x2ffd18a8
2ffcbe44:	2ffd007b 	.word	0x2ffd007b
2ffcbe48:	2ffd004d 	.word	0x2ffd004d
2ffcbe4c:	2ffd0040 	.word	0x2ffd0040

2ffcbe50 <_free_r>:
2ffcbe50:	b538      	push	{r3, r4, r5, lr}
2ffcbe52:	4605      	mov	r5, r0
2ffcbe54:	2900      	cmp	r1, #0
2ffcbe56:	d041      	beq.n	2ffcbedc <_free_r+0x8c>
2ffcbe58:	f851 3c04 	ldr.w	r3, [r1, #-4]
2ffcbe5c:	1f0c      	subs	r4, r1, #4
2ffcbe5e:	2b00      	cmp	r3, #0
2ffcbe60:	bfb8      	it	lt
2ffcbe62:	18e4      	addlt	r4, r4, r3
2ffcbe64:	f7ff fb38 	bl	2ffcb4d8 <__malloc_lock>
2ffcbe68:	4a1d      	ldr	r2, [pc, #116]	@ (2ffcbee0 <_free_r+0x90>)
2ffcbe6a:	6813      	ldr	r3, [r2, #0]
2ffcbe6c:	b933      	cbnz	r3, 2ffcbe7c <_free_r+0x2c>
2ffcbe6e:	6063      	str	r3, [r4, #4]
2ffcbe70:	6014      	str	r4, [r2, #0]
2ffcbe72:	4628      	mov	r0, r5
2ffcbe74:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
2ffcbe78:	f7ff bb34 	b.w	2ffcb4e4 <__malloc_unlock>
2ffcbe7c:	42a3      	cmp	r3, r4
2ffcbe7e:	d908      	bls.n	2ffcbe92 <_free_r+0x42>
2ffcbe80:	6820      	ldr	r0, [r4, #0]
2ffcbe82:	1821      	adds	r1, r4, r0
2ffcbe84:	428b      	cmp	r3, r1
2ffcbe86:	bf01      	itttt	eq
2ffcbe88:	6819      	ldreq	r1, [r3, #0]
2ffcbe8a:	685b      	ldreq	r3, [r3, #4]
2ffcbe8c:	1809      	addeq	r1, r1, r0
2ffcbe8e:	6021      	streq	r1, [r4, #0]
2ffcbe90:	e7ed      	b.n	2ffcbe6e <_free_r+0x1e>
2ffcbe92:	461a      	mov	r2, r3
2ffcbe94:	685b      	ldr	r3, [r3, #4]
2ffcbe96:	b10b      	cbz	r3, 2ffcbe9c <_free_r+0x4c>
2ffcbe98:	42a3      	cmp	r3, r4
2ffcbe9a:	d9fa      	bls.n	2ffcbe92 <_free_r+0x42>
2ffcbe9c:	6811      	ldr	r1, [r2, #0]
2ffcbe9e:	1850      	adds	r0, r2, r1
2ffcbea0:	42a0      	cmp	r0, r4
2ffcbea2:	d10b      	bne.n	2ffcbebc <_free_r+0x6c>
2ffcbea4:	6820      	ldr	r0, [r4, #0]
2ffcbea6:	4401      	add	r1, r0
2ffcbea8:	6011      	str	r1, [r2, #0]
2ffcbeaa:	1850      	adds	r0, r2, r1
2ffcbeac:	4283      	cmp	r3, r0
2ffcbeae:	d1e0      	bne.n	2ffcbe72 <_free_r+0x22>
2ffcbeb0:	6818      	ldr	r0, [r3, #0]
2ffcbeb2:	685b      	ldr	r3, [r3, #4]
2ffcbeb4:	4408      	add	r0, r1
2ffcbeb6:	6053      	str	r3, [r2, #4]
2ffcbeb8:	6010      	str	r0, [r2, #0]
2ffcbeba:	e7da      	b.n	2ffcbe72 <_free_r+0x22>
2ffcbebc:	d902      	bls.n	2ffcbec4 <_free_r+0x74>
2ffcbebe:	230c      	movs	r3, #12
2ffcbec0:	602b      	str	r3, [r5, #0]
2ffcbec2:	e7d6      	b.n	2ffcbe72 <_free_r+0x22>
2ffcbec4:	6820      	ldr	r0, [r4, #0]
2ffcbec6:	1821      	adds	r1, r4, r0
2ffcbec8:	428b      	cmp	r3, r1
2ffcbeca:	bf02      	ittt	eq
2ffcbecc:	6819      	ldreq	r1, [r3, #0]
2ffcbece:	685b      	ldreq	r3, [r3, #4]
2ffcbed0:	1809      	addeq	r1, r1, r0
2ffcbed2:	6063      	str	r3, [r4, #4]
2ffcbed4:	bf08      	it	eq
2ffcbed6:	6021      	streq	r1, [r4, #0]
2ffcbed8:	6054      	str	r4, [r2, #4]
2ffcbeda:	e7ca      	b.n	2ffcbe72 <_free_r+0x22>
2ffcbedc:	bd38      	pop	{r3, r4, r5, pc}
2ffcbede:	bf00      	nop
2ffcbee0:	2ffd29fc 	.word	0x2ffd29fc

2ffcbee4 <__ssputs_r>:
2ffcbee4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
2ffcbee8:	461f      	mov	r7, r3
2ffcbeea:	688e      	ldr	r6, [r1, #8]
2ffcbeec:	680b      	ldr	r3, [r1, #0]
2ffcbeee:	4682      	mov	sl, r0
2ffcbef0:	460c      	mov	r4, r1
2ffcbef2:	4690      	mov	r8, r2
2ffcbef4:	42be      	cmp	r6, r7
2ffcbef6:	d82d      	bhi.n	2ffcbf54 <__ssputs_r+0x70>
2ffcbef8:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
2ffcbefc:	f412 6f90 	tst.w	r2, #1152	@ 0x480
2ffcbf00:	d026      	beq.n	2ffcbf50 <__ssputs_r+0x6c>
2ffcbf02:	6965      	ldr	r5, [r4, #20]
2ffcbf04:	6909      	ldr	r1, [r1, #16]
2ffcbf06:	eb05 0545 	add.w	r5, r5, r5, lsl #1
2ffcbf0a:	eba3 0901 	sub.w	r9, r3, r1
2ffcbf0e:	1c7b      	adds	r3, r7, #1
2ffcbf10:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
2ffcbf14:	444b      	add	r3, r9
2ffcbf16:	106d      	asrs	r5, r5, #1
2ffcbf18:	429d      	cmp	r5, r3
2ffcbf1a:	bf38      	it	cc
2ffcbf1c:	461d      	movcc	r5, r3
2ffcbf1e:	0553      	lsls	r3, r2, #21
2ffcbf20:	d527      	bpl.n	2ffcbf72 <__ssputs_r+0x8e>
2ffcbf22:	4629      	mov	r1, r5
2ffcbf24:	f7ff fa5a 	bl	2ffcb3dc <_malloc_r>
2ffcbf28:	4606      	mov	r6, r0
2ffcbf2a:	b360      	cbz	r0, 2ffcbf86 <__ssputs_r+0xa2>
2ffcbf2c:	6921      	ldr	r1, [r4, #16]
2ffcbf2e:	464a      	mov	r2, r9
2ffcbf30:	f7ff ff5a 	bl	2ffcbde8 <memcpy>
2ffcbf34:	89a3      	ldrh	r3, [r4, #12]
2ffcbf36:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
2ffcbf3a:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
2ffcbf3e:	81a3      	strh	r3, [r4, #12]
2ffcbf40:	6126      	str	r6, [r4, #16]
2ffcbf42:	444e      	add	r6, r9
2ffcbf44:	6026      	str	r6, [r4, #0]
2ffcbf46:	463e      	mov	r6, r7
2ffcbf48:	6165      	str	r5, [r4, #20]
2ffcbf4a:	eba5 0509 	sub.w	r5, r5, r9
2ffcbf4e:	60a5      	str	r5, [r4, #8]
2ffcbf50:	42be      	cmp	r6, r7
2ffcbf52:	d900      	bls.n	2ffcbf56 <__ssputs_r+0x72>
2ffcbf54:	463e      	mov	r6, r7
2ffcbf56:	6820      	ldr	r0, [r4, #0]
2ffcbf58:	4632      	mov	r2, r6
2ffcbf5a:	4641      	mov	r1, r8
2ffcbf5c:	f000 fd0d 	bl	2ffcc97a <memmove>
2ffcbf60:	68a3      	ldr	r3, [r4, #8]
2ffcbf62:	2000      	movs	r0, #0
2ffcbf64:	1b9b      	subs	r3, r3, r6
2ffcbf66:	60a3      	str	r3, [r4, #8]
2ffcbf68:	6823      	ldr	r3, [r4, #0]
2ffcbf6a:	4433      	add	r3, r6
2ffcbf6c:	6023      	str	r3, [r4, #0]
2ffcbf6e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
2ffcbf72:	462a      	mov	r2, r5
2ffcbf74:	f000 fdbf 	bl	2ffccaf6 <_realloc_r>
2ffcbf78:	4606      	mov	r6, r0
2ffcbf7a:	2800      	cmp	r0, #0
2ffcbf7c:	d1e0      	bne.n	2ffcbf40 <__ssputs_r+0x5c>
2ffcbf7e:	6921      	ldr	r1, [r4, #16]
2ffcbf80:	4650      	mov	r0, sl
2ffcbf82:	f7ff ff65 	bl	2ffcbe50 <_free_r>
2ffcbf86:	230c      	movs	r3, #12
2ffcbf88:	f8ca 3000 	str.w	r3, [sl]
2ffcbf8c:	89a3      	ldrh	r3, [r4, #12]
2ffcbf8e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
2ffcbf92:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
2ffcbf96:	81a3      	strh	r3, [r4, #12]
2ffcbf98:	e7e9      	b.n	2ffcbf6e <__ssputs_r+0x8a>
	...

2ffcbf9c <_svfiprintf_r>:
2ffcbf9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
2ffcbfa0:	4698      	mov	r8, r3
2ffcbfa2:	898b      	ldrh	r3, [r1, #12]
2ffcbfa4:	b09d      	sub	sp, #116	@ 0x74
2ffcbfa6:	4607      	mov	r7, r0
2ffcbfa8:	460d      	mov	r5, r1
2ffcbfaa:	4614      	mov	r4, r2
2ffcbfac:	061b      	lsls	r3, r3, #24
2ffcbfae:	d510      	bpl.n	2ffcbfd2 <_svfiprintf_r+0x36>
2ffcbfb0:	690b      	ldr	r3, [r1, #16]
2ffcbfb2:	b973      	cbnz	r3, 2ffcbfd2 <_svfiprintf_r+0x36>
2ffcbfb4:	2140      	movs	r1, #64	@ 0x40
2ffcbfb6:	f7ff fa11 	bl	2ffcb3dc <_malloc_r>
2ffcbfba:	6028      	str	r0, [r5, #0]
2ffcbfbc:	6128      	str	r0, [r5, #16]
2ffcbfbe:	b930      	cbnz	r0, 2ffcbfce <_svfiprintf_r+0x32>
2ffcbfc0:	230c      	movs	r3, #12
2ffcbfc2:	603b      	str	r3, [r7, #0]
2ffcbfc4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
2ffcbfc8:	b01d      	add	sp, #116	@ 0x74
2ffcbfca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
2ffcbfce:	2340      	movs	r3, #64	@ 0x40
2ffcbfd0:	616b      	str	r3, [r5, #20]
2ffcbfd2:	f8cd 800c 	str.w	r8, [sp, #12]
2ffcbfd6:	f04f 0901 	mov.w	r9, #1
2ffcbfda:	f8df 81a4 	ldr.w	r8, [pc, #420]	@ 2ffcc180 <_svfiprintf_r+0x1e4>
2ffcbfde:	2300      	movs	r3, #0
2ffcbfe0:	9309      	str	r3, [sp, #36]	@ 0x24
2ffcbfe2:	2320      	movs	r3, #32
2ffcbfe4:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
2ffcbfe8:	2330      	movs	r3, #48	@ 0x30
2ffcbfea:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
2ffcbfee:	4623      	mov	r3, r4
2ffcbff0:	469a      	mov	sl, r3
2ffcbff2:	f813 2b01 	ldrb.w	r2, [r3], #1
2ffcbff6:	b10a      	cbz	r2, 2ffcbffc <_svfiprintf_r+0x60>
2ffcbff8:	2a25      	cmp	r2, #37	@ 0x25
2ffcbffa:	d1f9      	bne.n	2ffcbff0 <_svfiprintf_r+0x54>
2ffcbffc:	ebba 0b04 	subs.w	fp, sl, r4
2ffcc000:	d00b      	beq.n	2ffcc01a <_svfiprintf_r+0x7e>
2ffcc002:	465b      	mov	r3, fp
2ffcc004:	4622      	mov	r2, r4
2ffcc006:	4629      	mov	r1, r5
2ffcc008:	4638      	mov	r0, r7
2ffcc00a:	f7ff ff6b 	bl	2ffcbee4 <__ssputs_r>
2ffcc00e:	3001      	adds	r0, #1
2ffcc010:	f000 80a7 	beq.w	2ffcc162 <_svfiprintf_r+0x1c6>
2ffcc014:	9a09      	ldr	r2, [sp, #36]	@ 0x24
2ffcc016:	445a      	add	r2, fp
2ffcc018:	9209      	str	r2, [sp, #36]	@ 0x24
2ffcc01a:	f89a 3000 	ldrb.w	r3, [sl]
2ffcc01e:	2b00      	cmp	r3, #0
2ffcc020:	f000 809f 	beq.w	2ffcc162 <_svfiprintf_r+0x1c6>
2ffcc024:	f10a 0a01 	add.w	sl, sl, #1
2ffcc028:	2300      	movs	r3, #0
2ffcc02a:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
2ffcc02e:	9304      	str	r3, [sp, #16]
2ffcc030:	9307      	str	r3, [sp, #28]
2ffcc032:	e9cd 2305 	strd	r2, r3, [sp, #20]
2ffcc036:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
2ffcc03a:	931a      	str	r3, [sp, #104]	@ 0x68
2ffcc03c:	4654      	mov	r4, sl
2ffcc03e:	2205      	movs	r2, #5
2ffcc040:	484f      	ldr	r0, [pc, #316]	@ (2ffcc180 <_svfiprintf_r+0x1e4>)
2ffcc042:	f814 1b01 	ldrb.w	r1, [r4], #1
2ffcc046:	f000 fcdb 	bl	2ffcca00 <memchr>
2ffcc04a:	9a04      	ldr	r2, [sp, #16]
2ffcc04c:	b9d8      	cbnz	r0, 2ffcc086 <_svfiprintf_r+0xea>
2ffcc04e:	06d0      	lsls	r0, r2, #27
2ffcc050:	bf44      	itt	mi
2ffcc052:	2320      	movmi	r3, #32
2ffcc054:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
2ffcc058:	0711      	lsls	r1, r2, #28
2ffcc05a:	bf44      	itt	mi
2ffcc05c:	232b      	movmi	r3, #43	@ 0x2b
2ffcc05e:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
2ffcc062:	f89a 3000 	ldrb.w	r3, [sl]
2ffcc066:	2b2a      	cmp	r3, #42	@ 0x2a
2ffcc068:	d015      	beq.n	2ffcc096 <_svfiprintf_r+0xfa>
2ffcc06a:	9a07      	ldr	r2, [sp, #28]
2ffcc06c:	4654      	mov	r4, sl
2ffcc06e:	2000      	movs	r0, #0
2ffcc070:	f04f 0c0a 	mov.w	ip, #10
2ffcc074:	4621      	mov	r1, r4
2ffcc076:	f811 3b01 	ldrb.w	r3, [r1], #1
2ffcc07a:	3b30      	subs	r3, #48	@ 0x30
2ffcc07c:	2b09      	cmp	r3, #9
2ffcc07e:	d94b      	bls.n	2ffcc118 <_svfiprintf_r+0x17c>
2ffcc080:	b1b0      	cbz	r0, 2ffcc0b0 <_svfiprintf_r+0x114>
2ffcc082:	9207      	str	r2, [sp, #28]
2ffcc084:	e014      	b.n	2ffcc0b0 <_svfiprintf_r+0x114>
2ffcc086:	eba0 0308 	sub.w	r3, r0, r8
2ffcc08a:	46a2      	mov	sl, r4
2ffcc08c:	fa09 f303 	lsl.w	r3, r9, r3
2ffcc090:	4313      	orrs	r3, r2
2ffcc092:	9304      	str	r3, [sp, #16]
2ffcc094:	e7d2      	b.n	2ffcc03c <_svfiprintf_r+0xa0>
2ffcc096:	9b03      	ldr	r3, [sp, #12]
2ffcc098:	1d19      	adds	r1, r3, #4
2ffcc09a:	9103      	str	r1, [sp, #12]
2ffcc09c:	681b      	ldr	r3, [r3, #0]
2ffcc09e:	2b00      	cmp	r3, #0
2ffcc0a0:	bfaf      	iteee	ge
2ffcc0a2:	9307      	strge	r3, [sp, #28]
2ffcc0a4:	425b      	neglt	r3, r3
2ffcc0a6:	f042 0202 	orrlt.w	r2, r2, #2
2ffcc0aa:	9307      	strlt	r3, [sp, #28]
2ffcc0ac:	bfb8      	it	lt
2ffcc0ae:	9204      	strlt	r2, [sp, #16]
2ffcc0b0:	7823      	ldrb	r3, [r4, #0]
2ffcc0b2:	2b2e      	cmp	r3, #46	@ 0x2e
2ffcc0b4:	d10a      	bne.n	2ffcc0cc <_svfiprintf_r+0x130>
2ffcc0b6:	7863      	ldrb	r3, [r4, #1]
2ffcc0b8:	2b2a      	cmp	r3, #42	@ 0x2a
2ffcc0ba:	d132      	bne.n	2ffcc122 <_svfiprintf_r+0x186>
2ffcc0bc:	9b03      	ldr	r3, [sp, #12]
2ffcc0be:	3402      	adds	r4, #2
2ffcc0c0:	1d1a      	adds	r2, r3, #4
2ffcc0c2:	9203      	str	r2, [sp, #12]
2ffcc0c4:	681b      	ldr	r3, [r3, #0]
2ffcc0c6:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
2ffcc0ca:	9305      	str	r3, [sp, #20]
2ffcc0cc:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 2ffcc190 <_svfiprintf_r+0x1f4>
2ffcc0d0:	2203      	movs	r2, #3
2ffcc0d2:	7821      	ldrb	r1, [r4, #0]
2ffcc0d4:	4650      	mov	r0, sl
2ffcc0d6:	f000 fc93 	bl	2ffcca00 <memchr>
2ffcc0da:	b138      	cbz	r0, 2ffcc0ec <_svfiprintf_r+0x150>
2ffcc0dc:	eba0 000a 	sub.w	r0, r0, sl
2ffcc0e0:	2240      	movs	r2, #64	@ 0x40
2ffcc0e2:	9b04      	ldr	r3, [sp, #16]
2ffcc0e4:	3401      	adds	r4, #1
2ffcc0e6:	4082      	lsls	r2, r0
2ffcc0e8:	4313      	orrs	r3, r2
2ffcc0ea:	9304      	str	r3, [sp, #16]
2ffcc0ec:	f814 1b01 	ldrb.w	r1, [r4], #1
2ffcc0f0:	2206      	movs	r2, #6
2ffcc0f2:	4824      	ldr	r0, [pc, #144]	@ (2ffcc184 <_svfiprintf_r+0x1e8>)
2ffcc0f4:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
2ffcc0f8:	f000 fc82 	bl	2ffcca00 <memchr>
2ffcc0fc:	2800      	cmp	r0, #0
2ffcc0fe:	d036      	beq.n	2ffcc16e <_svfiprintf_r+0x1d2>
2ffcc100:	4b21      	ldr	r3, [pc, #132]	@ (2ffcc188 <_svfiprintf_r+0x1ec>)
2ffcc102:	bb1b      	cbnz	r3, 2ffcc14c <_svfiprintf_r+0x1b0>
2ffcc104:	9b03      	ldr	r3, [sp, #12]
2ffcc106:	3307      	adds	r3, #7
2ffcc108:	f023 0307 	bic.w	r3, r3, #7
2ffcc10c:	3308      	adds	r3, #8
2ffcc10e:	9303      	str	r3, [sp, #12]
2ffcc110:	9b09      	ldr	r3, [sp, #36]	@ 0x24
2ffcc112:	4433      	add	r3, r6
2ffcc114:	9309      	str	r3, [sp, #36]	@ 0x24
2ffcc116:	e76a      	b.n	2ffcbfee <_svfiprintf_r+0x52>
2ffcc118:	fb0c 3202 	mla	r2, ip, r2, r3
2ffcc11c:	460c      	mov	r4, r1
2ffcc11e:	2001      	movs	r0, #1
2ffcc120:	e7a8      	b.n	2ffcc074 <_svfiprintf_r+0xd8>
2ffcc122:	2300      	movs	r3, #0
2ffcc124:	3401      	adds	r4, #1
2ffcc126:	4619      	mov	r1, r3
2ffcc128:	f04f 0c0a 	mov.w	ip, #10
2ffcc12c:	9305      	str	r3, [sp, #20]
2ffcc12e:	4620      	mov	r0, r4
2ffcc130:	f810 2b01 	ldrb.w	r2, [r0], #1
2ffcc134:	3a30      	subs	r2, #48	@ 0x30
2ffcc136:	2a09      	cmp	r2, #9
2ffcc138:	d903      	bls.n	2ffcc142 <_svfiprintf_r+0x1a6>
2ffcc13a:	2b00      	cmp	r3, #0
2ffcc13c:	d0c6      	beq.n	2ffcc0cc <_svfiprintf_r+0x130>
2ffcc13e:	9105      	str	r1, [sp, #20]
2ffcc140:	e7c4      	b.n	2ffcc0cc <_svfiprintf_r+0x130>
2ffcc142:	fb0c 2101 	mla	r1, ip, r1, r2
2ffcc146:	4604      	mov	r4, r0
2ffcc148:	2301      	movs	r3, #1
2ffcc14a:	e7f0      	b.n	2ffcc12e <_svfiprintf_r+0x192>
2ffcc14c:	ab03      	add	r3, sp, #12
2ffcc14e:	462a      	mov	r2, r5
2ffcc150:	9300      	str	r3, [sp, #0]
2ffcc152:	a904      	add	r1, sp, #16
2ffcc154:	4b0d      	ldr	r3, [pc, #52]	@ (2ffcc18c <_svfiprintf_r+0x1f0>)
2ffcc156:	4638      	mov	r0, r7
2ffcc158:	f3af 8000 	nop.w
2ffcc15c:	4606      	mov	r6, r0
2ffcc15e:	1c42      	adds	r2, r0, #1
2ffcc160:	d1d6      	bne.n	2ffcc110 <_svfiprintf_r+0x174>
2ffcc162:	89ab      	ldrh	r3, [r5, #12]
2ffcc164:	065b      	lsls	r3, r3, #25
2ffcc166:	f53f af2d 	bmi.w	2ffcbfc4 <_svfiprintf_r+0x28>
2ffcc16a:	9809      	ldr	r0, [sp, #36]	@ 0x24
2ffcc16c:	e72c      	b.n	2ffcbfc8 <_svfiprintf_r+0x2c>
2ffcc16e:	ab03      	add	r3, sp, #12
2ffcc170:	462a      	mov	r2, r5
2ffcc172:	9300      	str	r3, [sp, #0]
2ffcc174:	a904      	add	r1, sp, #16
2ffcc176:	4b05      	ldr	r3, [pc, #20]	@ (2ffcc18c <_svfiprintf_r+0x1f0>)
2ffcc178:	4638      	mov	r0, r7
2ffcc17a:	f000 f9bf 	bl	2ffcc4fc <_printf_i>
2ffcc17e:	e7ed      	b.n	2ffcc15c <_svfiprintf_r+0x1c0>
2ffcc180:	2ffd007c 	.word	0x2ffd007c
2ffcc184:	2ffd0086 	.word	0x2ffd0086
2ffcc188:	00000000 	.word	0x00000000
2ffcc18c:	2ffcbee5 	.word	0x2ffcbee5
2ffcc190:	2ffd0082 	.word	0x2ffd0082

2ffcc194 <__sfputc_r>:
2ffcc194:	6893      	ldr	r3, [r2, #8]
2ffcc196:	b410      	push	{r4}
2ffcc198:	3b01      	subs	r3, #1
2ffcc19a:	2b00      	cmp	r3, #0
2ffcc19c:	6093      	str	r3, [r2, #8]
2ffcc19e:	da08      	bge.n	2ffcc1b2 <__sfputc_r+0x1e>
2ffcc1a0:	6994      	ldr	r4, [r2, #24]
2ffcc1a2:	42a3      	cmp	r3, r4
2ffcc1a4:	db01      	blt.n	2ffcc1aa <__sfputc_r+0x16>
2ffcc1a6:	290a      	cmp	r1, #10
2ffcc1a8:	d103      	bne.n	2ffcc1b2 <__sfputc_r+0x1e>
2ffcc1aa:	f85d 4b04 	ldr.w	r4, [sp], #4
2ffcc1ae:	f7ff bcbe 	b.w	2ffcbb2e <__swbuf_r>
2ffcc1b2:	6813      	ldr	r3, [r2, #0]
2ffcc1b4:	1c58      	adds	r0, r3, #1
2ffcc1b6:	6010      	str	r0, [r2, #0]
2ffcc1b8:	7019      	strb	r1, [r3, #0]
2ffcc1ba:	4608      	mov	r0, r1
2ffcc1bc:	f85d 4b04 	ldr.w	r4, [sp], #4
2ffcc1c0:	4770      	bx	lr

2ffcc1c2 <__sfputs_r>:
2ffcc1c2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2ffcc1c4:	4606      	mov	r6, r0
2ffcc1c6:	460f      	mov	r7, r1
2ffcc1c8:	4614      	mov	r4, r2
2ffcc1ca:	18d5      	adds	r5, r2, r3
2ffcc1cc:	42ac      	cmp	r4, r5
2ffcc1ce:	d101      	bne.n	2ffcc1d4 <__sfputs_r+0x12>
2ffcc1d0:	2000      	movs	r0, #0
2ffcc1d2:	e007      	b.n	2ffcc1e4 <__sfputs_r+0x22>
2ffcc1d4:	f814 1b01 	ldrb.w	r1, [r4], #1
2ffcc1d8:	463a      	mov	r2, r7
2ffcc1da:	4630      	mov	r0, r6
2ffcc1dc:	f7ff ffda 	bl	2ffcc194 <__sfputc_r>
2ffcc1e0:	1c43      	adds	r3, r0, #1
2ffcc1e2:	d1f3      	bne.n	2ffcc1cc <__sfputs_r+0xa>
2ffcc1e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

2ffcc1e8 <_vfiprintf_r>:
2ffcc1e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
2ffcc1ec:	460d      	mov	r5, r1
2ffcc1ee:	4614      	mov	r4, r2
2ffcc1f0:	b09d      	sub	sp, #116	@ 0x74
2ffcc1f2:	4698      	mov	r8, r3
2ffcc1f4:	4606      	mov	r6, r0
2ffcc1f6:	b118      	cbz	r0, 2ffcc200 <_vfiprintf_r+0x18>
2ffcc1f8:	6a03      	ldr	r3, [r0, #32]
2ffcc1fa:	b90b      	cbnz	r3, 2ffcc200 <_vfiprintf_r+0x18>
2ffcc1fc:	f7ff fb8e 	bl	2ffcb91c <__sinit>
2ffcc200:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
2ffcc202:	07d9      	lsls	r1, r3, #31
2ffcc204:	d405      	bmi.n	2ffcc212 <_vfiprintf_r+0x2a>
2ffcc206:	89ab      	ldrh	r3, [r5, #12]
2ffcc208:	059a      	lsls	r2, r3, #22
2ffcc20a:	d402      	bmi.n	2ffcc212 <_vfiprintf_r+0x2a>
2ffcc20c:	6da8      	ldr	r0, [r5, #88]	@ 0x58
2ffcc20e:	f7ff fdd2 	bl	2ffcbdb6 <__retarget_lock_acquire_recursive>
2ffcc212:	89ab      	ldrh	r3, [r5, #12]
2ffcc214:	071b      	lsls	r3, r3, #28
2ffcc216:	d501      	bpl.n	2ffcc21c <_vfiprintf_r+0x34>
2ffcc218:	692b      	ldr	r3, [r5, #16]
2ffcc21a:	b99b      	cbnz	r3, 2ffcc244 <_vfiprintf_r+0x5c>
2ffcc21c:	4629      	mov	r1, r5
2ffcc21e:	4630      	mov	r0, r6
2ffcc220:	f7ff fcc4 	bl	2ffcbbac <__swsetup_r>
2ffcc224:	b170      	cbz	r0, 2ffcc244 <_vfiprintf_r+0x5c>
2ffcc226:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
2ffcc228:	07dc      	lsls	r4, r3, #31
2ffcc22a:	d504      	bpl.n	2ffcc236 <_vfiprintf_r+0x4e>
2ffcc22c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
2ffcc230:	b01d      	add	sp, #116	@ 0x74
2ffcc232:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
2ffcc236:	89ab      	ldrh	r3, [r5, #12]
2ffcc238:	0598      	lsls	r0, r3, #22
2ffcc23a:	d4f7      	bmi.n	2ffcc22c <_vfiprintf_r+0x44>
2ffcc23c:	6da8      	ldr	r0, [r5, #88]	@ 0x58
2ffcc23e:	f7ff fdbb 	bl	2ffcbdb8 <__retarget_lock_release_recursive>
2ffcc242:	e7f3      	b.n	2ffcc22c <_vfiprintf_r+0x44>
2ffcc244:	f8cd 800c 	str.w	r8, [sp, #12]
2ffcc248:	f04f 0901 	mov.w	r9, #1
2ffcc24c:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 2ffcc404 <_vfiprintf_r+0x21c>
2ffcc250:	2300      	movs	r3, #0
2ffcc252:	9309      	str	r3, [sp, #36]	@ 0x24
2ffcc254:	2320      	movs	r3, #32
2ffcc256:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
2ffcc25a:	2330      	movs	r3, #48	@ 0x30
2ffcc25c:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
2ffcc260:	4623      	mov	r3, r4
2ffcc262:	469a      	mov	sl, r3
2ffcc264:	f813 2b01 	ldrb.w	r2, [r3], #1
2ffcc268:	b10a      	cbz	r2, 2ffcc26e <_vfiprintf_r+0x86>
2ffcc26a:	2a25      	cmp	r2, #37	@ 0x25
2ffcc26c:	d1f9      	bne.n	2ffcc262 <_vfiprintf_r+0x7a>
2ffcc26e:	ebba 0b04 	subs.w	fp, sl, r4
2ffcc272:	d00b      	beq.n	2ffcc28c <_vfiprintf_r+0xa4>
2ffcc274:	465b      	mov	r3, fp
2ffcc276:	4622      	mov	r2, r4
2ffcc278:	4629      	mov	r1, r5
2ffcc27a:	4630      	mov	r0, r6
2ffcc27c:	f7ff ffa1 	bl	2ffcc1c2 <__sfputs_r>
2ffcc280:	3001      	adds	r0, #1
2ffcc282:	f000 80a7 	beq.w	2ffcc3d4 <_vfiprintf_r+0x1ec>
2ffcc286:	9a09      	ldr	r2, [sp, #36]	@ 0x24
2ffcc288:	445a      	add	r2, fp
2ffcc28a:	9209      	str	r2, [sp, #36]	@ 0x24
2ffcc28c:	f89a 3000 	ldrb.w	r3, [sl]
2ffcc290:	2b00      	cmp	r3, #0
2ffcc292:	f000 809f 	beq.w	2ffcc3d4 <_vfiprintf_r+0x1ec>
2ffcc296:	f10a 0a01 	add.w	sl, sl, #1
2ffcc29a:	2300      	movs	r3, #0
2ffcc29c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
2ffcc2a0:	9304      	str	r3, [sp, #16]
2ffcc2a2:	9307      	str	r3, [sp, #28]
2ffcc2a4:	e9cd 2305 	strd	r2, r3, [sp, #20]
2ffcc2a8:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
2ffcc2ac:	931a      	str	r3, [sp, #104]	@ 0x68
2ffcc2ae:	4654      	mov	r4, sl
2ffcc2b0:	2205      	movs	r2, #5
2ffcc2b2:	4854      	ldr	r0, [pc, #336]	@ (2ffcc404 <_vfiprintf_r+0x21c>)
2ffcc2b4:	f814 1b01 	ldrb.w	r1, [r4], #1
2ffcc2b8:	f000 fba2 	bl	2ffcca00 <memchr>
2ffcc2bc:	9a04      	ldr	r2, [sp, #16]
2ffcc2be:	b9d8      	cbnz	r0, 2ffcc2f8 <_vfiprintf_r+0x110>
2ffcc2c0:	06d1      	lsls	r1, r2, #27
2ffcc2c2:	bf44      	itt	mi
2ffcc2c4:	2320      	movmi	r3, #32
2ffcc2c6:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
2ffcc2ca:	0713      	lsls	r3, r2, #28
2ffcc2cc:	bf44      	itt	mi
2ffcc2ce:	232b      	movmi	r3, #43	@ 0x2b
2ffcc2d0:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
2ffcc2d4:	f89a 3000 	ldrb.w	r3, [sl]
2ffcc2d8:	2b2a      	cmp	r3, #42	@ 0x2a
2ffcc2da:	d015      	beq.n	2ffcc308 <_vfiprintf_r+0x120>
2ffcc2dc:	9a07      	ldr	r2, [sp, #28]
2ffcc2de:	4654      	mov	r4, sl
2ffcc2e0:	2000      	movs	r0, #0
2ffcc2e2:	f04f 0c0a 	mov.w	ip, #10
2ffcc2e6:	4621      	mov	r1, r4
2ffcc2e8:	f811 3b01 	ldrb.w	r3, [r1], #1
2ffcc2ec:	3b30      	subs	r3, #48	@ 0x30
2ffcc2ee:	2b09      	cmp	r3, #9
2ffcc2f0:	d94b      	bls.n	2ffcc38a <_vfiprintf_r+0x1a2>
2ffcc2f2:	b1b0      	cbz	r0, 2ffcc322 <_vfiprintf_r+0x13a>
2ffcc2f4:	9207      	str	r2, [sp, #28]
2ffcc2f6:	e014      	b.n	2ffcc322 <_vfiprintf_r+0x13a>
2ffcc2f8:	eba0 0308 	sub.w	r3, r0, r8
2ffcc2fc:	46a2      	mov	sl, r4
2ffcc2fe:	fa09 f303 	lsl.w	r3, r9, r3
2ffcc302:	4313      	orrs	r3, r2
2ffcc304:	9304      	str	r3, [sp, #16]
2ffcc306:	e7d2      	b.n	2ffcc2ae <_vfiprintf_r+0xc6>
2ffcc308:	9b03      	ldr	r3, [sp, #12]
2ffcc30a:	1d19      	adds	r1, r3, #4
2ffcc30c:	9103      	str	r1, [sp, #12]
2ffcc30e:	681b      	ldr	r3, [r3, #0]
2ffcc310:	2b00      	cmp	r3, #0
2ffcc312:	bfaf      	iteee	ge
2ffcc314:	9307      	strge	r3, [sp, #28]
2ffcc316:	425b      	neglt	r3, r3
2ffcc318:	f042 0202 	orrlt.w	r2, r2, #2
2ffcc31c:	9307      	strlt	r3, [sp, #28]
2ffcc31e:	bfb8      	it	lt
2ffcc320:	9204      	strlt	r2, [sp, #16]
2ffcc322:	7823      	ldrb	r3, [r4, #0]
2ffcc324:	2b2e      	cmp	r3, #46	@ 0x2e
2ffcc326:	d10a      	bne.n	2ffcc33e <_vfiprintf_r+0x156>
2ffcc328:	7863      	ldrb	r3, [r4, #1]
2ffcc32a:	2b2a      	cmp	r3, #42	@ 0x2a
2ffcc32c:	d132      	bne.n	2ffcc394 <_vfiprintf_r+0x1ac>
2ffcc32e:	9b03      	ldr	r3, [sp, #12]
2ffcc330:	3402      	adds	r4, #2
2ffcc332:	1d1a      	adds	r2, r3, #4
2ffcc334:	9203      	str	r2, [sp, #12]
2ffcc336:	681b      	ldr	r3, [r3, #0]
2ffcc338:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
2ffcc33c:	9305      	str	r3, [sp, #20]
2ffcc33e:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 2ffcc414 <_vfiprintf_r+0x22c>
2ffcc342:	2203      	movs	r2, #3
2ffcc344:	7821      	ldrb	r1, [r4, #0]
2ffcc346:	4650      	mov	r0, sl
2ffcc348:	f000 fb5a 	bl	2ffcca00 <memchr>
2ffcc34c:	b138      	cbz	r0, 2ffcc35e <_vfiprintf_r+0x176>
2ffcc34e:	eba0 000a 	sub.w	r0, r0, sl
2ffcc352:	2240      	movs	r2, #64	@ 0x40
2ffcc354:	9b04      	ldr	r3, [sp, #16]
2ffcc356:	3401      	adds	r4, #1
2ffcc358:	4082      	lsls	r2, r0
2ffcc35a:	4313      	orrs	r3, r2
2ffcc35c:	9304      	str	r3, [sp, #16]
2ffcc35e:	f814 1b01 	ldrb.w	r1, [r4], #1
2ffcc362:	2206      	movs	r2, #6
2ffcc364:	4828      	ldr	r0, [pc, #160]	@ (2ffcc408 <_vfiprintf_r+0x220>)
2ffcc366:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
2ffcc36a:	f000 fb49 	bl	2ffcca00 <memchr>
2ffcc36e:	2800      	cmp	r0, #0
2ffcc370:	d03f      	beq.n	2ffcc3f2 <_vfiprintf_r+0x20a>
2ffcc372:	4b26      	ldr	r3, [pc, #152]	@ (2ffcc40c <_vfiprintf_r+0x224>)
2ffcc374:	bb1b      	cbnz	r3, 2ffcc3be <_vfiprintf_r+0x1d6>
2ffcc376:	9b03      	ldr	r3, [sp, #12]
2ffcc378:	3307      	adds	r3, #7
2ffcc37a:	f023 0307 	bic.w	r3, r3, #7
2ffcc37e:	3308      	adds	r3, #8
2ffcc380:	9303      	str	r3, [sp, #12]
2ffcc382:	9b09      	ldr	r3, [sp, #36]	@ 0x24
2ffcc384:	443b      	add	r3, r7
2ffcc386:	9309      	str	r3, [sp, #36]	@ 0x24
2ffcc388:	e76a      	b.n	2ffcc260 <_vfiprintf_r+0x78>
2ffcc38a:	fb0c 3202 	mla	r2, ip, r2, r3
2ffcc38e:	460c      	mov	r4, r1
2ffcc390:	2001      	movs	r0, #1
2ffcc392:	e7a8      	b.n	2ffcc2e6 <_vfiprintf_r+0xfe>
2ffcc394:	2300      	movs	r3, #0
2ffcc396:	3401      	adds	r4, #1
2ffcc398:	4619      	mov	r1, r3
2ffcc39a:	f04f 0c0a 	mov.w	ip, #10
2ffcc39e:	9305      	str	r3, [sp, #20]
2ffcc3a0:	4620      	mov	r0, r4
2ffcc3a2:	f810 2b01 	ldrb.w	r2, [r0], #1
2ffcc3a6:	3a30      	subs	r2, #48	@ 0x30
2ffcc3a8:	2a09      	cmp	r2, #9
2ffcc3aa:	d903      	bls.n	2ffcc3b4 <_vfiprintf_r+0x1cc>
2ffcc3ac:	2b00      	cmp	r3, #0
2ffcc3ae:	d0c6      	beq.n	2ffcc33e <_vfiprintf_r+0x156>
2ffcc3b0:	9105      	str	r1, [sp, #20]
2ffcc3b2:	e7c4      	b.n	2ffcc33e <_vfiprintf_r+0x156>
2ffcc3b4:	fb0c 2101 	mla	r1, ip, r1, r2
2ffcc3b8:	4604      	mov	r4, r0
2ffcc3ba:	2301      	movs	r3, #1
2ffcc3bc:	e7f0      	b.n	2ffcc3a0 <_vfiprintf_r+0x1b8>
2ffcc3be:	ab03      	add	r3, sp, #12
2ffcc3c0:	462a      	mov	r2, r5
2ffcc3c2:	9300      	str	r3, [sp, #0]
2ffcc3c4:	a904      	add	r1, sp, #16
2ffcc3c6:	4b12      	ldr	r3, [pc, #72]	@ (2ffcc410 <_vfiprintf_r+0x228>)
2ffcc3c8:	4630      	mov	r0, r6
2ffcc3ca:	f3af 8000 	nop.w
2ffcc3ce:	4607      	mov	r7, r0
2ffcc3d0:	1c78      	adds	r0, r7, #1
2ffcc3d2:	d1d6      	bne.n	2ffcc382 <_vfiprintf_r+0x19a>
2ffcc3d4:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
2ffcc3d6:	07d9      	lsls	r1, r3, #31
2ffcc3d8:	d405      	bmi.n	2ffcc3e6 <_vfiprintf_r+0x1fe>
2ffcc3da:	89ab      	ldrh	r3, [r5, #12]
2ffcc3dc:	059a      	lsls	r2, r3, #22
2ffcc3de:	d402      	bmi.n	2ffcc3e6 <_vfiprintf_r+0x1fe>
2ffcc3e0:	6da8      	ldr	r0, [r5, #88]	@ 0x58
2ffcc3e2:	f7ff fce9 	bl	2ffcbdb8 <__retarget_lock_release_recursive>
2ffcc3e6:	89ab      	ldrh	r3, [r5, #12]
2ffcc3e8:	065b      	lsls	r3, r3, #25
2ffcc3ea:	f53f af1f 	bmi.w	2ffcc22c <_vfiprintf_r+0x44>
2ffcc3ee:	9809      	ldr	r0, [sp, #36]	@ 0x24
2ffcc3f0:	e71e      	b.n	2ffcc230 <_vfiprintf_r+0x48>
2ffcc3f2:	ab03      	add	r3, sp, #12
2ffcc3f4:	462a      	mov	r2, r5
2ffcc3f6:	9300      	str	r3, [sp, #0]
2ffcc3f8:	a904      	add	r1, sp, #16
2ffcc3fa:	4b05      	ldr	r3, [pc, #20]	@ (2ffcc410 <_vfiprintf_r+0x228>)
2ffcc3fc:	4630      	mov	r0, r6
2ffcc3fe:	f000 f87d 	bl	2ffcc4fc <_printf_i>
2ffcc402:	e7e4      	b.n	2ffcc3ce <_vfiprintf_r+0x1e6>
2ffcc404:	2ffd007c 	.word	0x2ffd007c
2ffcc408:	2ffd0086 	.word	0x2ffd0086
2ffcc40c:	00000000 	.word	0x00000000
2ffcc410:	2ffcc1c3 	.word	0x2ffcc1c3
2ffcc414:	2ffd0082 	.word	0x2ffd0082

2ffcc418 <_printf_common>:
2ffcc418:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
2ffcc41c:	4616      	mov	r6, r2
2ffcc41e:	4698      	mov	r8, r3
2ffcc420:	688a      	ldr	r2, [r1, #8]
2ffcc422:	4607      	mov	r7, r0
2ffcc424:	690b      	ldr	r3, [r1, #16]
2ffcc426:	460c      	mov	r4, r1
2ffcc428:	f8dd 9020 	ldr.w	r9, [sp, #32]
2ffcc42c:	4293      	cmp	r3, r2
2ffcc42e:	bfb8      	it	lt
2ffcc430:	4613      	movlt	r3, r2
2ffcc432:	6033      	str	r3, [r6, #0]
2ffcc434:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
2ffcc438:	b10a      	cbz	r2, 2ffcc43e <_printf_common+0x26>
2ffcc43a:	3301      	adds	r3, #1
2ffcc43c:	6033      	str	r3, [r6, #0]
2ffcc43e:	6823      	ldr	r3, [r4, #0]
2ffcc440:	0699      	lsls	r1, r3, #26
2ffcc442:	bf42      	ittt	mi
2ffcc444:	6833      	ldrmi	r3, [r6, #0]
2ffcc446:	3302      	addmi	r3, #2
2ffcc448:	6033      	strmi	r3, [r6, #0]
2ffcc44a:	6825      	ldr	r5, [r4, #0]
2ffcc44c:	f015 0506 	ands.w	r5, r5, #6
2ffcc450:	d106      	bne.n	2ffcc460 <_printf_common+0x48>
2ffcc452:	f104 0a19 	add.w	sl, r4, #25
2ffcc456:	68e3      	ldr	r3, [r4, #12]
2ffcc458:	6832      	ldr	r2, [r6, #0]
2ffcc45a:	1a9b      	subs	r3, r3, r2
2ffcc45c:	42ab      	cmp	r3, r5
2ffcc45e:	dc2b      	bgt.n	2ffcc4b8 <_printf_common+0xa0>
2ffcc460:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
2ffcc464:	6822      	ldr	r2, [r4, #0]
2ffcc466:	3b00      	subs	r3, #0
2ffcc468:	bf18      	it	ne
2ffcc46a:	2301      	movne	r3, #1
2ffcc46c:	0692      	lsls	r2, r2, #26
2ffcc46e:	d430      	bmi.n	2ffcc4d2 <_printf_common+0xba>
2ffcc470:	f104 0243 	add.w	r2, r4, #67	@ 0x43
2ffcc474:	4641      	mov	r1, r8
2ffcc476:	4638      	mov	r0, r7
2ffcc478:	47c8      	blx	r9
2ffcc47a:	3001      	adds	r0, #1
2ffcc47c:	d023      	beq.n	2ffcc4c6 <_printf_common+0xae>
2ffcc47e:	6823      	ldr	r3, [r4, #0]
2ffcc480:	341a      	adds	r4, #26
2ffcc482:	f854 2c0a 	ldr.w	r2, [r4, #-10]
2ffcc486:	f003 0306 	and.w	r3, r3, #6
2ffcc48a:	2b04      	cmp	r3, #4
2ffcc48c:	bf12      	itee	ne
2ffcc48e:	2500      	movne	r5, #0
2ffcc490:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
2ffcc494:	6833      	ldreq	r3, [r6, #0]
2ffcc496:	f04f 0600 	mov.w	r6, #0
2ffcc49a:	bf08      	it	eq
2ffcc49c:	1aed      	subeq	r5, r5, r3
2ffcc49e:	f854 3c12 	ldr.w	r3, [r4, #-18]
2ffcc4a2:	bf08      	it	eq
2ffcc4a4:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
2ffcc4a8:	4293      	cmp	r3, r2
2ffcc4aa:	bfc4      	itt	gt
2ffcc4ac:	1a9b      	subgt	r3, r3, r2
2ffcc4ae:	18ed      	addgt	r5, r5, r3
2ffcc4b0:	42b5      	cmp	r5, r6
2ffcc4b2:	d11a      	bne.n	2ffcc4ea <_printf_common+0xd2>
2ffcc4b4:	2000      	movs	r0, #0
2ffcc4b6:	e008      	b.n	2ffcc4ca <_printf_common+0xb2>
2ffcc4b8:	2301      	movs	r3, #1
2ffcc4ba:	4652      	mov	r2, sl
2ffcc4bc:	4641      	mov	r1, r8
2ffcc4be:	4638      	mov	r0, r7
2ffcc4c0:	47c8      	blx	r9
2ffcc4c2:	3001      	adds	r0, #1
2ffcc4c4:	d103      	bne.n	2ffcc4ce <_printf_common+0xb6>
2ffcc4c6:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
2ffcc4ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
2ffcc4ce:	3501      	adds	r5, #1
2ffcc4d0:	e7c1      	b.n	2ffcc456 <_printf_common+0x3e>
2ffcc4d2:	18e1      	adds	r1, r4, r3
2ffcc4d4:	1c5a      	adds	r2, r3, #1
2ffcc4d6:	2030      	movs	r0, #48	@ 0x30
2ffcc4d8:	4422      	add	r2, r4
2ffcc4da:	3302      	adds	r3, #2
2ffcc4dc:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
2ffcc4e0:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
2ffcc4e4:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
2ffcc4e8:	e7c2      	b.n	2ffcc470 <_printf_common+0x58>
2ffcc4ea:	2301      	movs	r3, #1
2ffcc4ec:	4622      	mov	r2, r4
2ffcc4ee:	4641      	mov	r1, r8
2ffcc4f0:	4638      	mov	r0, r7
2ffcc4f2:	47c8      	blx	r9
2ffcc4f4:	3001      	adds	r0, #1
2ffcc4f6:	d0e6      	beq.n	2ffcc4c6 <_printf_common+0xae>
2ffcc4f8:	3601      	adds	r6, #1
2ffcc4fa:	e7d9      	b.n	2ffcc4b0 <_printf_common+0x98>

2ffcc4fc <_printf_i>:
2ffcc4fc:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
2ffcc500:	4691      	mov	r9, r2
2ffcc502:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
2ffcc504:	7e0f      	ldrb	r7, [r1, #24]
2ffcc506:	4680      	mov	r8, r0
2ffcc508:	460c      	mov	r4, r1
2ffcc50a:	469a      	mov	sl, r3
2ffcc50c:	f101 0243 	add.w	r2, r1, #67	@ 0x43
2ffcc510:	2f78      	cmp	r7, #120	@ 0x78
2ffcc512:	d807      	bhi.n	2ffcc524 <_printf_i+0x28>
2ffcc514:	2f62      	cmp	r7, #98	@ 0x62
2ffcc516:	d80a      	bhi.n	2ffcc52e <_printf_i+0x32>
2ffcc518:	2f00      	cmp	r7, #0
2ffcc51a:	f000 80d2 	beq.w	2ffcc6c2 <_printf_i+0x1c6>
2ffcc51e:	2f58      	cmp	r7, #88	@ 0x58
2ffcc520:	f000 80b9 	beq.w	2ffcc696 <_printf_i+0x19a>
2ffcc524:	f104 0642 	add.w	r6, r4, #66	@ 0x42
2ffcc528:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
2ffcc52c:	e03a      	b.n	2ffcc5a4 <_printf_i+0xa8>
2ffcc52e:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
2ffcc532:	2b15      	cmp	r3, #21
2ffcc534:	d8f6      	bhi.n	2ffcc524 <_printf_i+0x28>
2ffcc536:	a101      	add	r1, pc, #4	@ (adr r1, 2ffcc53c <_printf_i+0x40>)
2ffcc538:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
2ffcc53c:	2ffcc595 	.word	0x2ffcc595
2ffcc540:	2ffcc5a9 	.word	0x2ffcc5a9
2ffcc544:	2ffcc525 	.word	0x2ffcc525
2ffcc548:	2ffcc525 	.word	0x2ffcc525
2ffcc54c:	2ffcc525 	.word	0x2ffcc525
2ffcc550:	2ffcc525 	.word	0x2ffcc525
2ffcc554:	2ffcc5a9 	.word	0x2ffcc5a9
2ffcc558:	2ffcc525 	.word	0x2ffcc525
2ffcc55c:	2ffcc525 	.word	0x2ffcc525
2ffcc560:	2ffcc525 	.word	0x2ffcc525
2ffcc564:	2ffcc525 	.word	0x2ffcc525
2ffcc568:	2ffcc6a9 	.word	0x2ffcc6a9
2ffcc56c:	2ffcc5d3 	.word	0x2ffcc5d3
2ffcc570:	2ffcc663 	.word	0x2ffcc663
2ffcc574:	2ffcc525 	.word	0x2ffcc525
2ffcc578:	2ffcc525 	.word	0x2ffcc525
2ffcc57c:	2ffcc6cb 	.word	0x2ffcc6cb
2ffcc580:	2ffcc525 	.word	0x2ffcc525
2ffcc584:	2ffcc5d3 	.word	0x2ffcc5d3
2ffcc588:	2ffcc525 	.word	0x2ffcc525
2ffcc58c:	2ffcc525 	.word	0x2ffcc525
2ffcc590:	2ffcc66b 	.word	0x2ffcc66b
2ffcc594:	6833      	ldr	r3, [r6, #0]
2ffcc596:	1d1a      	adds	r2, r3, #4
2ffcc598:	6032      	str	r2, [r6, #0]
2ffcc59a:	681b      	ldr	r3, [r3, #0]
2ffcc59c:	f104 0642 	add.w	r6, r4, #66	@ 0x42
2ffcc5a0:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
2ffcc5a4:	2301      	movs	r3, #1
2ffcc5a6:	e09d      	b.n	2ffcc6e4 <_printf_i+0x1e8>
2ffcc5a8:	6820      	ldr	r0, [r4, #0]
2ffcc5aa:	6833      	ldr	r3, [r6, #0]
2ffcc5ac:	1d19      	adds	r1, r3, #4
2ffcc5ae:	6031      	str	r1, [r6, #0]
2ffcc5b0:	0606      	lsls	r6, r0, #24
2ffcc5b2:	d501      	bpl.n	2ffcc5b8 <_printf_i+0xbc>
2ffcc5b4:	681d      	ldr	r5, [r3, #0]
2ffcc5b6:	e003      	b.n	2ffcc5c0 <_printf_i+0xc4>
2ffcc5b8:	0645      	lsls	r5, r0, #25
2ffcc5ba:	d5fb      	bpl.n	2ffcc5b4 <_printf_i+0xb8>
2ffcc5bc:	f9b3 5000 	ldrsh.w	r5, [r3]
2ffcc5c0:	2d00      	cmp	r5, #0
2ffcc5c2:	da03      	bge.n	2ffcc5cc <_printf_i+0xd0>
2ffcc5c4:	426d      	negs	r5, r5
2ffcc5c6:	232d      	movs	r3, #45	@ 0x2d
2ffcc5c8:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
2ffcc5cc:	4859      	ldr	r0, [pc, #356]	@ (2ffcc734 <_printf_i+0x238>)
2ffcc5ce:	230a      	movs	r3, #10
2ffcc5d0:	e011      	b.n	2ffcc5f6 <_printf_i+0xfa>
2ffcc5d2:	6821      	ldr	r1, [r4, #0]
2ffcc5d4:	6833      	ldr	r3, [r6, #0]
2ffcc5d6:	0608      	lsls	r0, r1, #24
2ffcc5d8:	f853 5b04 	ldr.w	r5, [r3], #4
2ffcc5dc:	d402      	bmi.n	2ffcc5e4 <_printf_i+0xe8>
2ffcc5de:	0649      	lsls	r1, r1, #25
2ffcc5e0:	bf48      	it	mi
2ffcc5e2:	b2ad      	uxthmi	r5, r5
2ffcc5e4:	2f6f      	cmp	r7, #111	@ 0x6f
2ffcc5e6:	4853      	ldr	r0, [pc, #332]	@ (2ffcc734 <_printf_i+0x238>)
2ffcc5e8:	6033      	str	r3, [r6, #0]
2ffcc5ea:	bf14      	ite	ne
2ffcc5ec:	230a      	movne	r3, #10
2ffcc5ee:	2308      	moveq	r3, #8
2ffcc5f0:	2100      	movs	r1, #0
2ffcc5f2:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
2ffcc5f6:	6866      	ldr	r6, [r4, #4]
2ffcc5f8:	60a6      	str	r6, [r4, #8]
2ffcc5fa:	2e00      	cmp	r6, #0
2ffcc5fc:	bfa2      	ittt	ge
2ffcc5fe:	6821      	ldrge	r1, [r4, #0]
2ffcc600:	f021 0104 	bicge.w	r1, r1, #4
2ffcc604:	6021      	strge	r1, [r4, #0]
2ffcc606:	b90d      	cbnz	r5, 2ffcc60c <_printf_i+0x110>
2ffcc608:	2e00      	cmp	r6, #0
2ffcc60a:	d04b      	beq.n	2ffcc6a4 <_printf_i+0x1a8>
2ffcc60c:	4616      	mov	r6, r2
2ffcc60e:	fbb5 f1f3 	udiv	r1, r5, r3
2ffcc612:	fb03 5711 	mls	r7, r3, r1, r5
2ffcc616:	5dc7      	ldrb	r7, [r0, r7]
2ffcc618:	f806 7d01 	strb.w	r7, [r6, #-1]!
2ffcc61c:	462f      	mov	r7, r5
2ffcc61e:	42bb      	cmp	r3, r7
2ffcc620:	460d      	mov	r5, r1
2ffcc622:	d9f4      	bls.n	2ffcc60e <_printf_i+0x112>
2ffcc624:	2b08      	cmp	r3, #8
2ffcc626:	d10b      	bne.n	2ffcc640 <_printf_i+0x144>
2ffcc628:	6823      	ldr	r3, [r4, #0]
2ffcc62a:	07df      	lsls	r7, r3, #31
2ffcc62c:	d508      	bpl.n	2ffcc640 <_printf_i+0x144>
2ffcc62e:	6923      	ldr	r3, [r4, #16]
2ffcc630:	6861      	ldr	r1, [r4, #4]
2ffcc632:	4299      	cmp	r1, r3
2ffcc634:	bfde      	ittt	le
2ffcc636:	2330      	movle	r3, #48	@ 0x30
2ffcc638:	f806 3c01 	strble.w	r3, [r6, #-1]
2ffcc63c:	f106 36ff 	addle.w	r6, r6, #4294967295	@ 0xffffffff
2ffcc640:	1b92      	subs	r2, r2, r6
2ffcc642:	6122      	str	r2, [r4, #16]
2ffcc644:	464b      	mov	r3, r9
2ffcc646:	aa03      	add	r2, sp, #12
2ffcc648:	4621      	mov	r1, r4
2ffcc64a:	4640      	mov	r0, r8
2ffcc64c:	f8cd a000 	str.w	sl, [sp]
2ffcc650:	f7ff fee2 	bl	2ffcc418 <_printf_common>
2ffcc654:	3001      	adds	r0, #1
2ffcc656:	d14a      	bne.n	2ffcc6ee <_printf_i+0x1f2>
2ffcc658:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
2ffcc65c:	b004      	add	sp, #16
2ffcc65e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
2ffcc662:	6823      	ldr	r3, [r4, #0]
2ffcc664:	f043 0320 	orr.w	r3, r3, #32
2ffcc668:	6023      	str	r3, [r4, #0]
2ffcc66a:	4833      	ldr	r0, [pc, #204]	@ (2ffcc738 <_printf_i+0x23c>)
2ffcc66c:	2778      	movs	r7, #120	@ 0x78
2ffcc66e:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
2ffcc672:	6823      	ldr	r3, [r4, #0]
2ffcc674:	6831      	ldr	r1, [r6, #0]
2ffcc676:	061f      	lsls	r7, r3, #24
2ffcc678:	f851 5b04 	ldr.w	r5, [r1], #4
2ffcc67c:	d402      	bmi.n	2ffcc684 <_printf_i+0x188>
2ffcc67e:	065f      	lsls	r7, r3, #25
2ffcc680:	bf48      	it	mi
2ffcc682:	b2ad      	uxthmi	r5, r5
2ffcc684:	6031      	str	r1, [r6, #0]
2ffcc686:	07d9      	lsls	r1, r3, #31
2ffcc688:	bf44      	itt	mi
2ffcc68a:	f043 0320 	orrmi.w	r3, r3, #32
2ffcc68e:	6023      	strmi	r3, [r4, #0]
2ffcc690:	b11d      	cbz	r5, 2ffcc69a <_printf_i+0x19e>
2ffcc692:	2310      	movs	r3, #16
2ffcc694:	e7ac      	b.n	2ffcc5f0 <_printf_i+0xf4>
2ffcc696:	4827      	ldr	r0, [pc, #156]	@ (2ffcc734 <_printf_i+0x238>)
2ffcc698:	e7e9      	b.n	2ffcc66e <_printf_i+0x172>
2ffcc69a:	6823      	ldr	r3, [r4, #0]
2ffcc69c:	f023 0320 	bic.w	r3, r3, #32
2ffcc6a0:	6023      	str	r3, [r4, #0]
2ffcc6a2:	e7f6      	b.n	2ffcc692 <_printf_i+0x196>
2ffcc6a4:	4616      	mov	r6, r2
2ffcc6a6:	e7bd      	b.n	2ffcc624 <_printf_i+0x128>
2ffcc6a8:	6833      	ldr	r3, [r6, #0]
2ffcc6aa:	6825      	ldr	r5, [r4, #0]
2ffcc6ac:	1d18      	adds	r0, r3, #4
2ffcc6ae:	6961      	ldr	r1, [r4, #20]
2ffcc6b0:	6030      	str	r0, [r6, #0]
2ffcc6b2:	062e      	lsls	r6, r5, #24
2ffcc6b4:	681b      	ldr	r3, [r3, #0]
2ffcc6b6:	d501      	bpl.n	2ffcc6bc <_printf_i+0x1c0>
2ffcc6b8:	6019      	str	r1, [r3, #0]
2ffcc6ba:	e002      	b.n	2ffcc6c2 <_printf_i+0x1c6>
2ffcc6bc:	0668      	lsls	r0, r5, #25
2ffcc6be:	d5fb      	bpl.n	2ffcc6b8 <_printf_i+0x1bc>
2ffcc6c0:	8019      	strh	r1, [r3, #0]
2ffcc6c2:	2300      	movs	r3, #0
2ffcc6c4:	4616      	mov	r6, r2
2ffcc6c6:	6123      	str	r3, [r4, #16]
2ffcc6c8:	e7bc      	b.n	2ffcc644 <_printf_i+0x148>
2ffcc6ca:	6833      	ldr	r3, [r6, #0]
2ffcc6cc:	2100      	movs	r1, #0
2ffcc6ce:	1d1a      	adds	r2, r3, #4
2ffcc6d0:	6032      	str	r2, [r6, #0]
2ffcc6d2:	6862      	ldr	r2, [r4, #4]
2ffcc6d4:	681e      	ldr	r6, [r3, #0]
2ffcc6d6:	4630      	mov	r0, r6
2ffcc6d8:	f000 f992 	bl	2ffcca00 <memchr>
2ffcc6dc:	b108      	cbz	r0, 2ffcc6e2 <_printf_i+0x1e6>
2ffcc6de:	1b80      	subs	r0, r0, r6
2ffcc6e0:	6060      	str	r0, [r4, #4]
2ffcc6e2:	6863      	ldr	r3, [r4, #4]
2ffcc6e4:	6123      	str	r3, [r4, #16]
2ffcc6e6:	2300      	movs	r3, #0
2ffcc6e8:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
2ffcc6ec:	e7aa      	b.n	2ffcc644 <_printf_i+0x148>
2ffcc6ee:	6923      	ldr	r3, [r4, #16]
2ffcc6f0:	4632      	mov	r2, r6
2ffcc6f2:	4649      	mov	r1, r9
2ffcc6f4:	4640      	mov	r0, r8
2ffcc6f6:	47d0      	blx	sl
2ffcc6f8:	3001      	adds	r0, #1
2ffcc6fa:	d0ad      	beq.n	2ffcc658 <_printf_i+0x15c>
2ffcc6fc:	6823      	ldr	r3, [r4, #0]
2ffcc6fe:	079b      	lsls	r3, r3, #30
2ffcc700:	d413      	bmi.n	2ffcc72a <_printf_i+0x22e>
2ffcc702:	68e0      	ldr	r0, [r4, #12]
2ffcc704:	9b03      	ldr	r3, [sp, #12]
2ffcc706:	4298      	cmp	r0, r3
2ffcc708:	bfb8      	it	lt
2ffcc70a:	4618      	movlt	r0, r3
2ffcc70c:	e7a6      	b.n	2ffcc65c <_printf_i+0x160>
2ffcc70e:	2301      	movs	r3, #1
2ffcc710:	4632      	mov	r2, r6
2ffcc712:	4649      	mov	r1, r9
2ffcc714:	4640      	mov	r0, r8
2ffcc716:	47d0      	blx	sl
2ffcc718:	3001      	adds	r0, #1
2ffcc71a:	d09d      	beq.n	2ffcc658 <_printf_i+0x15c>
2ffcc71c:	3501      	adds	r5, #1
2ffcc71e:	68e3      	ldr	r3, [r4, #12]
2ffcc720:	9903      	ldr	r1, [sp, #12]
2ffcc722:	1a5b      	subs	r3, r3, r1
2ffcc724:	42ab      	cmp	r3, r5
2ffcc726:	dcf2      	bgt.n	2ffcc70e <_printf_i+0x212>
2ffcc728:	e7eb      	b.n	2ffcc702 <_printf_i+0x206>
2ffcc72a:	2500      	movs	r5, #0
2ffcc72c:	f104 0619 	add.w	r6, r4, #25
2ffcc730:	e7f5      	b.n	2ffcc71e <_printf_i+0x222>
2ffcc732:	bf00      	nop
2ffcc734:	2ffd008d 	.word	0x2ffd008d
2ffcc738:	2ffd009e 	.word	0x2ffd009e

2ffcc73c <__sflush_r>:
2ffcc73c:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
2ffcc740:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
2ffcc744:	4605      	mov	r5, r0
2ffcc746:	460c      	mov	r4, r1
2ffcc748:	0716      	lsls	r6, r2, #28
2ffcc74a:	d454      	bmi.n	2ffcc7f6 <__sflush_r+0xba>
2ffcc74c:	684b      	ldr	r3, [r1, #4]
2ffcc74e:	2b00      	cmp	r3, #0
2ffcc750:	dc02      	bgt.n	2ffcc758 <__sflush_r+0x1c>
2ffcc752:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
2ffcc754:	2b00      	cmp	r3, #0
2ffcc756:	dd48      	ble.n	2ffcc7ea <__sflush_r+0xae>
2ffcc758:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
2ffcc75a:	2e00      	cmp	r6, #0
2ffcc75c:	d045      	beq.n	2ffcc7ea <__sflush_r+0xae>
2ffcc75e:	682f      	ldr	r7, [r5, #0]
2ffcc760:	2300      	movs	r3, #0
2ffcc762:	6a21      	ldr	r1, [r4, #32]
2ffcc764:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
2ffcc768:	602b      	str	r3, [r5, #0]
2ffcc76a:	d030      	beq.n	2ffcc7ce <__sflush_r+0x92>
2ffcc76c:	6d62      	ldr	r2, [r4, #84]	@ 0x54
2ffcc76e:	89a3      	ldrh	r3, [r4, #12]
2ffcc770:	0759      	lsls	r1, r3, #29
2ffcc772:	d505      	bpl.n	2ffcc780 <__sflush_r+0x44>
2ffcc774:	6863      	ldr	r3, [r4, #4]
2ffcc776:	1ad2      	subs	r2, r2, r3
2ffcc778:	6b63      	ldr	r3, [r4, #52]	@ 0x34
2ffcc77a:	b10b      	cbz	r3, 2ffcc780 <__sflush_r+0x44>
2ffcc77c:	6c23      	ldr	r3, [r4, #64]	@ 0x40
2ffcc77e:	1ad2      	subs	r2, r2, r3
2ffcc780:	2300      	movs	r3, #0
2ffcc782:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
2ffcc784:	6a21      	ldr	r1, [r4, #32]
2ffcc786:	4628      	mov	r0, r5
2ffcc788:	47b0      	blx	r6
2ffcc78a:	1c43      	adds	r3, r0, #1
2ffcc78c:	89a3      	ldrh	r3, [r4, #12]
2ffcc78e:	d106      	bne.n	2ffcc79e <__sflush_r+0x62>
2ffcc790:	6829      	ldr	r1, [r5, #0]
2ffcc792:	291d      	cmp	r1, #29
2ffcc794:	d82b      	bhi.n	2ffcc7ee <__sflush_r+0xb2>
2ffcc796:	4a2a      	ldr	r2, [pc, #168]	@ (2ffcc840 <__sflush_r+0x104>)
2ffcc798:	410a      	asrs	r2, r1
2ffcc79a:	07d6      	lsls	r6, r2, #31
2ffcc79c:	d427      	bmi.n	2ffcc7ee <__sflush_r+0xb2>
2ffcc79e:	2200      	movs	r2, #0
2ffcc7a0:	6062      	str	r2, [r4, #4]
2ffcc7a2:	6922      	ldr	r2, [r4, #16]
2ffcc7a4:	04d9      	lsls	r1, r3, #19
2ffcc7a6:	6022      	str	r2, [r4, #0]
2ffcc7a8:	d504      	bpl.n	2ffcc7b4 <__sflush_r+0x78>
2ffcc7aa:	1c42      	adds	r2, r0, #1
2ffcc7ac:	d101      	bne.n	2ffcc7b2 <__sflush_r+0x76>
2ffcc7ae:	682b      	ldr	r3, [r5, #0]
2ffcc7b0:	b903      	cbnz	r3, 2ffcc7b4 <__sflush_r+0x78>
2ffcc7b2:	6560      	str	r0, [r4, #84]	@ 0x54
2ffcc7b4:	6b61      	ldr	r1, [r4, #52]	@ 0x34
2ffcc7b6:	602f      	str	r7, [r5, #0]
2ffcc7b8:	b1b9      	cbz	r1, 2ffcc7ea <__sflush_r+0xae>
2ffcc7ba:	f104 0344 	add.w	r3, r4, #68	@ 0x44
2ffcc7be:	4299      	cmp	r1, r3
2ffcc7c0:	d002      	beq.n	2ffcc7c8 <__sflush_r+0x8c>
2ffcc7c2:	4628      	mov	r0, r5
2ffcc7c4:	f7ff fb44 	bl	2ffcbe50 <_free_r>
2ffcc7c8:	2300      	movs	r3, #0
2ffcc7ca:	6363      	str	r3, [r4, #52]	@ 0x34
2ffcc7cc:	e00d      	b.n	2ffcc7ea <__sflush_r+0xae>
2ffcc7ce:	2301      	movs	r3, #1
2ffcc7d0:	4628      	mov	r0, r5
2ffcc7d2:	47b0      	blx	r6
2ffcc7d4:	4602      	mov	r2, r0
2ffcc7d6:	1c50      	adds	r0, r2, #1
2ffcc7d8:	d1c9      	bne.n	2ffcc76e <__sflush_r+0x32>
2ffcc7da:	682b      	ldr	r3, [r5, #0]
2ffcc7dc:	2b00      	cmp	r3, #0
2ffcc7de:	d0c6      	beq.n	2ffcc76e <__sflush_r+0x32>
2ffcc7e0:	2b1d      	cmp	r3, #29
2ffcc7e2:	d001      	beq.n	2ffcc7e8 <__sflush_r+0xac>
2ffcc7e4:	2b16      	cmp	r3, #22
2ffcc7e6:	d11e      	bne.n	2ffcc826 <__sflush_r+0xea>
2ffcc7e8:	602f      	str	r7, [r5, #0]
2ffcc7ea:	2000      	movs	r0, #0
2ffcc7ec:	e022      	b.n	2ffcc834 <__sflush_r+0xf8>
2ffcc7ee:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
2ffcc7f2:	b21b      	sxth	r3, r3
2ffcc7f4:	e01b      	b.n	2ffcc82e <__sflush_r+0xf2>
2ffcc7f6:	690f      	ldr	r7, [r1, #16]
2ffcc7f8:	2f00      	cmp	r7, #0
2ffcc7fa:	d0f6      	beq.n	2ffcc7ea <__sflush_r+0xae>
2ffcc7fc:	0793      	lsls	r3, r2, #30
2ffcc7fe:	680e      	ldr	r6, [r1, #0]
2ffcc800:	bf18      	it	ne
2ffcc802:	2300      	movne	r3, #0
2ffcc804:	600f      	str	r7, [r1, #0]
2ffcc806:	bf08      	it	eq
2ffcc808:	694b      	ldreq	r3, [r1, #20]
2ffcc80a:	eba6 0807 	sub.w	r8, r6, r7
2ffcc80e:	608b      	str	r3, [r1, #8]
2ffcc810:	f1b8 0f00 	cmp.w	r8, #0
2ffcc814:	dde9      	ble.n	2ffcc7ea <__sflush_r+0xae>
2ffcc816:	6a21      	ldr	r1, [r4, #32]
2ffcc818:	4643      	mov	r3, r8
2ffcc81a:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
2ffcc81c:	463a      	mov	r2, r7
2ffcc81e:	4628      	mov	r0, r5
2ffcc820:	47b0      	blx	r6
2ffcc822:	2800      	cmp	r0, #0
2ffcc824:	dc08      	bgt.n	2ffcc838 <__sflush_r+0xfc>
2ffcc826:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
2ffcc82a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
2ffcc82e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
2ffcc832:	81a3      	strh	r3, [r4, #12]
2ffcc834:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
2ffcc838:	4407      	add	r7, r0
2ffcc83a:	eba8 0800 	sub.w	r8, r8, r0
2ffcc83e:	e7e7      	b.n	2ffcc810 <__sflush_r+0xd4>
2ffcc840:	dfbffffe 	.word	0xdfbffffe

2ffcc844 <_fflush_r>:
2ffcc844:	b538      	push	{r3, r4, r5, lr}
2ffcc846:	4605      	mov	r5, r0
2ffcc848:	690b      	ldr	r3, [r1, #16]
2ffcc84a:	460c      	mov	r4, r1
2ffcc84c:	b913      	cbnz	r3, 2ffcc854 <_fflush_r+0x10>
2ffcc84e:	2500      	movs	r5, #0
2ffcc850:	4628      	mov	r0, r5
2ffcc852:	bd38      	pop	{r3, r4, r5, pc}
2ffcc854:	b118      	cbz	r0, 2ffcc85e <_fflush_r+0x1a>
2ffcc856:	6a03      	ldr	r3, [r0, #32]
2ffcc858:	b90b      	cbnz	r3, 2ffcc85e <_fflush_r+0x1a>
2ffcc85a:	f7ff f85f 	bl	2ffcb91c <__sinit>
2ffcc85e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
2ffcc862:	2b00      	cmp	r3, #0
2ffcc864:	d0f3      	beq.n	2ffcc84e <_fflush_r+0xa>
2ffcc866:	6e62      	ldr	r2, [r4, #100]	@ 0x64
2ffcc868:	07d0      	lsls	r0, r2, #31
2ffcc86a:	d404      	bmi.n	2ffcc876 <_fflush_r+0x32>
2ffcc86c:	0599      	lsls	r1, r3, #22
2ffcc86e:	d402      	bmi.n	2ffcc876 <_fflush_r+0x32>
2ffcc870:	6da0      	ldr	r0, [r4, #88]	@ 0x58
2ffcc872:	f7ff faa0 	bl	2ffcbdb6 <__retarget_lock_acquire_recursive>
2ffcc876:	4628      	mov	r0, r5
2ffcc878:	4621      	mov	r1, r4
2ffcc87a:	f7ff ff5f 	bl	2ffcc73c <__sflush_r>
2ffcc87e:	6e63      	ldr	r3, [r4, #100]	@ 0x64
2ffcc880:	4605      	mov	r5, r0
2ffcc882:	07da      	lsls	r2, r3, #31
2ffcc884:	d4e4      	bmi.n	2ffcc850 <_fflush_r+0xc>
2ffcc886:	89a3      	ldrh	r3, [r4, #12]
2ffcc888:	059b      	lsls	r3, r3, #22
2ffcc88a:	d4e1      	bmi.n	2ffcc850 <_fflush_r+0xc>
2ffcc88c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
2ffcc88e:	f7ff fa93 	bl	2ffcbdb8 <__retarget_lock_release_recursive>
2ffcc892:	e7dd      	b.n	2ffcc850 <_fflush_r+0xc>

2ffcc894 <fiprintf>:
2ffcc894:	b40e      	push	{r1, r2, r3}
2ffcc896:	b503      	push	{r0, r1, lr}
2ffcc898:	4601      	mov	r1, r0
2ffcc89a:	4806      	ldr	r0, [pc, #24]	@ (2ffcc8b4 <fiprintf+0x20>)
2ffcc89c:	ab03      	add	r3, sp, #12
2ffcc89e:	6800      	ldr	r0, [r0, #0]
2ffcc8a0:	f853 2b04 	ldr.w	r2, [r3], #4
2ffcc8a4:	9301      	str	r3, [sp, #4]
2ffcc8a6:	f7ff fc9f 	bl	2ffcc1e8 <_vfiprintf_r>
2ffcc8aa:	b002      	add	sp, #8
2ffcc8ac:	f85d eb04 	ldr.w	lr, [sp], #4
2ffcc8b0:	b003      	add	sp, #12
2ffcc8b2:	4770      	bx	lr
2ffcc8b4:	2ffd18a8 	.word	0x2ffd18a8

2ffcc8b8 <__swhatbuf_r>:
2ffcc8b8:	b570      	push	{r4, r5, r6, lr}
2ffcc8ba:	460c      	mov	r4, r1
2ffcc8bc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
2ffcc8c0:	b096      	sub	sp, #88	@ 0x58
2ffcc8c2:	4615      	mov	r5, r2
2ffcc8c4:	461e      	mov	r6, r3
2ffcc8c6:	2900      	cmp	r1, #0
2ffcc8c8:	da0c      	bge.n	2ffcc8e4 <__swhatbuf_r+0x2c>
2ffcc8ca:	89a3      	ldrh	r3, [r4, #12]
2ffcc8cc:	2100      	movs	r1, #0
2ffcc8ce:	f013 0f80 	tst.w	r3, #128	@ 0x80
2ffcc8d2:	bf14      	ite	ne
2ffcc8d4:	2340      	movne	r3, #64	@ 0x40
2ffcc8d6:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
2ffcc8da:	2000      	movs	r0, #0
2ffcc8dc:	6031      	str	r1, [r6, #0]
2ffcc8de:	602b      	str	r3, [r5, #0]
2ffcc8e0:	b016      	add	sp, #88	@ 0x58
2ffcc8e2:	bd70      	pop	{r4, r5, r6, pc}
2ffcc8e4:	466a      	mov	r2, sp
2ffcc8e6:	f000 f863 	bl	2ffcc9b0 <_fstat_r>
2ffcc8ea:	2800      	cmp	r0, #0
2ffcc8ec:	dbed      	blt.n	2ffcc8ca <__swhatbuf_r+0x12>
2ffcc8ee:	9901      	ldr	r1, [sp, #4]
2ffcc8f0:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
2ffcc8f4:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
2ffcc8f8:	4259      	negs	r1, r3
2ffcc8fa:	4159      	adcs	r1, r3
2ffcc8fc:	f44f 6380 	mov.w	r3, #1024	@ 0x400
2ffcc900:	e7eb      	b.n	2ffcc8da <__swhatbuf_r+0x22>

2ffcc902 <__smakebuf_r>:
2ffcc902:	898b      	ldrh	r3, [r1, #12]
2ffcc904:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
2ffcc906:	4606      	mov	r6, r0
2ffcc908:	460c      	mov	r4, r1
2ffcc90a:	079d      	lsls	r5, r3, #30
2ffcc90c:	d507      	bpl.n	2ffcc91e <__smakebuf_r+0x1c>
2ffcc90e:	f104 0347 	add.w	r3, r4, #71	@ 0x47
2ffcc912:	6023      	str	r3, [r4, #0]
2ffcc914:	6123      	str	r3, [r4, #16]
2ffcc916:	2301      	movs	r3, #1
2ffcc918:	6163      	str	r3, [r4, #20]
2ffcc91a:	b003      	add	sp, #12
2ffcc91c:	bdf0      	pop	{r4, r5, r6, r7, pc}
2ffcc91e:	ab01      	add	r3, sp, #4
2ffcc920:	466a      	mov	r2, sp
2ffcc922:	f7ff ffc9 	bl	2ffcc8b8 <__swhatbuf_r>
2ffcc926:	9f00      	ldr	r7, [sp, #0]
2ffcc928:	4605      	mov	r5, r0
2ffcc92a:	4630      	mov	r0, r6
2ffcc92c:	4639      	mov	r1, r7
2ffcc92e:	f7fe fd55 	bl	2ffcb3dc <_malloc_r>
2ffcc932:	b948      	cbnz	r0, 2ffcc948 <__smakebuf_r+0x46>
2ffcc934:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
2ffcc938:	059a      	lsls	r2, r3, #22
2ffcc93a:	d4ee      	bmi.n	2ffcc91a <__smakebuf_r+0x18>
2ffcc93c:	f023 0303 	bic.w	r3, r3, #3
2ffcc940:	f043 0302 	orr.w	r3, r3, #2
2ffcc944:	81a3      	strh	r3, [r4, #12]
2ffcc946:	e7e2      	b.n	2ffcc90e <__smakebuf_r+0xc>
2ffcc948:	89a3      	ldrh	r3, [r4, #12]
2ffcc94a:	6020      	str	r0, [r4, #0]
2ffcc94c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
2ffcc950:	81a3      	strh	r3, [r4, #12]
2ffcc952:	9b01      	ldr	r3, [sp, #4]
2ffcc954:	e9c4 0704 	strd	r0, r7, [r4, #16]
2ffcc958:	b15b      	cbz	r3, 2ffcc972 <__smakebuf_r+0x70>
2ffcc95a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
2ffcc95e:	4630      	mov	r0, r6
2ffcc960:	f000 f838 	bl	2ffcc9d4 <_isatty_r>
2ffcc964:	b128      	cbz	r0, 2ffcc972 <__smakebuf_r+0x70>
2ffcc966:	89a3      	ldrh	r3, [r4, #12]
2ffcc968:	f023 0303 	bic.w	r3, r3, #3
2ffcc96c:	f043 0301 	orr.w	r3, r3, #1
2ffcc970:	81a3      	strh	r3, [r4, #12]
2ffcc972:	89a3      	ldrh	r3, [r4, #12]
2ffcc974:	431d      	orrs	r5, r3
2ffcc976:	81a5      	strh	r5, [r4, #12]
2ffcc978:	e7cf      	b.n	2ffcc91a <__smakebuf_r+0x18>

2ffcc97a <memmove>:
2ffcc97a:	b510      	push	{r4, lr}
2ffcc97c:	4288      	cmp	r0, r1
2ffcc97e:	eb01 0402 	add.w	r4, r1, r2
2ffcc982:	d902      	bls.n	2ffcc98a <memmove+0x10>
2ffcc984:	4623      	mov	r3, r4
2ffcc986:	4284      	cmp	r4, r0
2ffcc988:	d807      	bhi.n	2ffcc99a <memmove+0x20>
2ffcc98a:	1e43      	subs	r3, r0, #1
2ffcc98c:	42a1      	cmp	r1, r4
2ffcc98e:	d008      	beq.n	2ffcc9a2 <memmove+0x28>
2ffcc990:	f811 2b01 	ldrb.w	r2, [r1], #1
2ffcc994:	f803 2f01 	strb.w	r2, [r3, #1]!
2ffcc998:	e7f8      	b.n	2ffcc98c <memmove+0x12>
2ffcc99a:	4402      	add	r2, r0
2ffcc99c:	4601      	mov	r1, r0
2ffcc99e:	428a      	cmp	r2, r1
2ffcc9a0:	d100      	bne.n	2ffcc9a4 <memmove+0x2a>
2ffcc9a2:	bd10      	pop	{r4, pc}
2ffcc9a4:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
2ffcc9a8:	f802 4d01 	strb.w	r4, [r2, #-1]!
2ffcc9ac:	e7f7      	b.n	2ffcc99e <memmove+0x24>
	...

2ffcc9b0 <_fstat_r>:
2ffcc9b0:	b538      	push	{r3, r4, r5, lr}
2ffcc9b2:	4604      	mov	r4, r0
2ffcc9b4:	4d06      	ldr	r5, [pc, #24]	@ (2ffcc9d0 <_fstat_r+0x20>)
2ffcc9b6:	4608      	mov	r0, r1
2ffcc9b8:	4611      	mov	r1, r2
2ffcc9ba:	2300      	movs	r3, #0
2ffcc9bc:	602b      	str	r3, [r5, #0]
2ffcc9be:	f7f5 feb7 	bl	2ffc2730 <_fstat>
2ffcc9c2:	1c43      	adds	r3, r0, #1
2ffcc9c4:	d102      	bne.n	2ffcc9cc <_fstat_r+0x1c>
2ffcc9c6:	682b      	ldr	r3, [r5, #0]
2ffcc9c8:	b103      	cbz	r3, 2ffcc9cc <_fstat_r+0x1c>
2ffcc9ca:	6023      	str	r3, [r4, #0]
2ffcc9cc:	bd38      	pop	{r3, r4, r5, pc}
2ffcc9ce:	bf00      	nop
2ffcc9d0:	2ffd2b3c 	.word	0x2ffd2b3c

2ffcc9d4 <_isatty_r>:
2ffcc9d4:	b538      	push	{r3, r4, r5, lr}
2ffcc9d6:	4604      	mov	r4, r0
2ffcc9d8:	4d05      	ldr	r5, [pc, #20]	@ (2ffcc9f0 <_isatty_r+0x1c>)
2ffcc9da:	4608      	mov	r0, r1
2ffcc9dc:	2300      	movs	r3, #0
2ffcc9de:	602b      	str	r3, [r5, #0]
2ffcc9e0:	f7f5 feac 	bl	2ffc273c <_isatty>
2ffcc9e4:	1c43      	adds	r3, r0, #1
2ffcc9e6:	d102      	bne.n	2ffcc9ee <_isatty_r+0x1a>
2ffcc9e8:	682b      	ldr	r3, [r5, #0]
2ffcc9ea:	b103      	cbz	r3, 2ffcc9ee <_isatty_r+0x1a>
2ffcc9ec:	6023      	str	r3, [r4, #0]
2ffcc9ee:	bd38      	pop	{r3, r4, r5, pc}
2ffcc9f0:	2ffd2b3c 	.word	0x2ffd2b3c
	...

2ffcca00 <memchr>:
2ffcca00:	2a07      	cmp	r2, #7
2ffcca02:	d80a      	bhi.n	2ffcca1a <memchr+0x1a>
2ffcca04:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
2ffcca08:	3a01      	subs	r2, #1
2ffcca0a:	d36a      	bcc.n	2ffccae2 <memchr+0xe2>
2ffcca0c:	f810 3b01 	ldrb.w	r3, [r0], #1
2ffcca10:	428b      	cmp	r3, r1
2ffcca12:	d1f9      	bne.n	2ffcca08 <memchr+0x8>
2ffcca14:	f1a0 0001 	sub.w	r0, r0, #1
2ffcca18:	4770      	bx	lr
2ffcca1a:	eee0 1b10 	vdup.8	q0, r1
2ffcca1e:	f240 2301 	movw	r3, #513	@ 0x201
2ffcca22:	f6c0 0304 	movt	r3, #2052	@ 0x804
2ffcca26:	ea4f 1c03 	mov.w	ip, r3, lsl #4
2ffcca2a:	ec4c 3b16 	vmov	d6, r3, ip
2ffcca2e:	ec4c 3b17 	vmov	d7, r3, ip
2ffcca32:	f020 011f 	bic.w	r1, r0, #31
2ffcca36:	f010 0c1f 	ands.w	ip, r0, #31
2ffcca3a:	d01c      	beq.n	2ffcca76 <memchr+0x76>
2ffcca3c:	f921 223d 	vld1.8	{d2-d5}, [r1 :256]!
2ffcca40:	f1ac 0320 	sub.w	r3, ip, #32
2ffcca44:	18d2      	adds	r2, r2, r3
2ffcca46:	ff02 2850 	vceq.i8	q1, q1, q0
2ffcca4a:	ff04 4850 	vceq.i8	q2, q2, q0
2ffcca4e:	ef02 2156 	vand	q1, q1, q3
2ffcca52:	ef04 4156 	vand	q2, q2, q3
2ffcca56:	ef02 2b13 	vpadd.i8	d2, d2, d3
2ffcca5a:	ef04 4b15 	vpadd.i8	d4, d4, d5
2ffcca5e:	ef02 2b14 	vpadd.i8	d2, d2, d4
2ffcca62:	ef02 2b12 	vpadd.i8	d2, d2, d2
2ffcca66:	ee12 0b10 	vmov.32	r0, d2[0]
2ffcca6a:	fa20 f00c 	lsr.w	r0, r0, ip
2ffcca6e:	fa00 f00c 	lsl.w	r0, r0, ip
2ffcca72:	d927      	bls.n	2ffccac4 <memchr+0xc4>
2ffcca74:	bb68      	cbnz	r0, 2ffccad2 <memchr+0xd2>
2ffcca76:	ed2d 8b04 	vpush	{d8-d9}
2ffcca7a:	bf00      	nop
2ffcca7c:	f3af 8000 	nop.w
2ffcca80:	f921 223d 	vld1.8	{d2-d5}, [r1 :256]!
2ffcca84:	3a20      	subs	r2, #32
2ffcca86:	ff02 2850 	vceq.i8	q1, q1, q0
2ffcca8a:	ff04 4850 	vceq.i8	q2, q2, q0
2ffcca8e:	d907      	bls.n	2ffccaa0 <memchr+0xa0>
2ffcca90:	ef22 8154 	vorr	q4, q1, q2
2ffcca94:	ef28 8119 	vorr	d8, d8, d9
2ffcca98:	ec53 0b18 	vmov	r0, r3, d8
2ffcca9c:	4318      	orrs	r0, r3
2ffcca9e:	d0ef      	beq.n	2ffcca80 <memchr+0x80>
2ffccaa0:	ecbd 8b04 	vpop	{d8-d9}
2ffccaa4:	ef02 2156 	vand	q1, q1, q3
2ffccaa8:	ef04 4156 	vand	q2, q2, q3
2ffccaac:	ef02 2b13 	vpadd.i8	d2, d2, d3
2ffccab0:	ef04 4b15 	vpadd.i8	d4, d4, d5
2ffccab4:	ef02 2b14 	vpadd.i8	d2, d2, d4
2ffccab8:	ef02 2b12 	vpadd.i8	d2, d2, d2
2ffccabc:	ee12 0b10 	vmov.32	r0, d2[0]
2ffccac0:	b178      	cbz	r0, 2ffccae2 <memchr+0xe2>
2ffccac2:	d806      	bhi.n	2ffccad2 <memchr+0xd2>
2ffccac4:	f1c2 0200 	rsb	r2, r2, #0
2ffccac8:	fa00 f002 	lsl.w	r0, r0, r2
2ffccacc:	40d0      	lsrs	r0, r2
2ffccace:	bf08      	it	eq
2ffccad0:	2100      	moveq	r1, #0
2ffccad2:	fa90 f0a0 	rbit	r0, r0
2ffccad6:	f1a1 0120 	sub.w	r1, r1, #32
2ffccada:	fab0 f080 	clz	r0, r0
2ffccade:	4408      	add	r0, r1
2ffccae0:	4770      	bx	lr
2ffccae2:	f04f 0000 	mov.w	r0, #0
2ffccae6:	4770      	bx	lr

2ffccae8 <abort>:
2ffccae8:	2006      	movs	r0, #6
2ffccaea:	b508      	push	{r3, lr}
2ffccaec:	f000 f85a 	bl	2ffccba4 <raise>
2ffccaf0:	2001      	movs	r0, #1
2ffccaf2:	f7f5 fdd9 	bl	2ffc26a8 <_exit>

2ffccaf6 <_realloc_r>:
2ffccaf6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
2ffccafa:	4680      	mov	r8, r0
2ffccafc:	4615      	mov	r5, r2
2ffccafe:	460c      	mov	r4, r1
2ffccb00:	b921      	cbnz	r1, 2ffccb0c <_realloc_r+0x16>
2ffccb02:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
2ffccb06:	4611      	mov	r1, r2
2ffccb08:	f7fe bc68 	b.w	2ffcb3dc <_malloc_r>
2ffccb0c:	b92a      	cbnz	r2, 2ffccb1a <_realloc_r+0x24>
2ffccb0e:	f7ff f99f 	bl	2ffcbe50 <_free_r>
2ffccb12:	2400      	movs	r4, #0
2ffccb14:	4620      	mov	r0, r4
2ffccb16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
2ffccb1a:	f000 f85f 	bl	2ffccbdc <_malloc_usable_size_r>
2ffccb1e:	4606      	mov	r6, r0
2ffccb20:	4285      	cmp	r5, r0
2ffccb22:	d802      	bhi.n	2ffccb2a <_realloc_r+0x34>
2ffccb24:	ebb5 0f50 	cmp.w	r5, r0, lsr #1
2ffccb28:	d8f4      	bhi.n	2ffccb14 <_realloc_r+0x1e>
2ffccb2a:	4629      	mov	r1, r5
2ffccb2c:	4640      	mov	r0, r8
2ffccb2e:	f7fe fc55 	bl	2ffcb3dc <_malloc_r>
2ffccb32:	4607      	mov	r7, r0
2ffccb34:	2800      	cmp	r0, #0
2ffccb36:	d0ec      	beq.n	2ffccb12 <_realloc_r+0x1c>
2ffccb38:	42b5      	cmp	r5, r6
2ffccb3a:	462a      	mov	r2, r5
2ffccb3c:	4621      	mov	r1, r4
2ffccb3e:	bf28      	it	cs
2ffccb40:	4632      	movcs	r2, r6
2ffccb42:	f7ff f951 	bl	2ffcbde8 <memcpy>
2ffccb46:	4621      	mov	r1, r4
2ffccb48:	4640      	mov	r0, r8
2ffccb4a:	463c      	mov	r4, r7
2ffccb4c:	f7ff f980 	bl	2ffcbe50 <_free_r>
2ffccb50:	e7e0      	b.n	2ffccb14 <_realloc_r+0x1e>

2ffccb52 <_raise_r>:
2ffccb52:	b538      	push	{r3, r4, r5, lr}
2ffccb54:	291f      	cmp	r1, #31
2ffccb56:	4605      	mov	r5, r0
2ffccb58:	460c      	mov	r4, r1
2ffccb5a:	d904      	bls.n	2ffccb66 <_raise_r+0x14>
2ffccb5c:	2316      	movs	r3, #22
2ffccb5e:	6003      	str	r3, [r0, #0]
2ffccb60:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
2ffccb64:	bd38      	pop	{r3, r4, r5, pc}
2ffccb66:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
2ffccb68:	b112      	cbz	r2, 2ffccb70 <_raise_r+0x1e>
2ffccb6a:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
2ffccb6e:	b94b      	cbnz	r3, 2ffccb84 <_raise_r+0x32>
2ffccb70:	4628      	mov	r0, r5
2ffccb72:	f000 f831 	bl	2ffccbd8 <_getpid_r>
2ffccb76:	4622      	mov	r2, r4
2ffccb78:	4601      	mov	r1, r0
2ffccb7a:	4628      	mov	r0, r5
2ffccb7c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
2ffccb80:	f000 b818 	b.w	2ffccbb4 <_kill_r>
2ffccb84:	2b01      	cmp	r3, #1
2ffccb86:	d00a      	beq.n	2ffccb9e <_raise_r+0x4c>
2ffccb88:	1c59      	adds	r1, r3, #1
2ffccb8a:	d103      	bne.n	2ffccb94 <_raise_r+0x42>
2ffccb8c:	2316      	movs	r3, #22
2ffccb8e:	6003      	str	r3, [r0, #0]
2ffccb90:	2001      	movs	r0, #1
2ffccb92:	e7e7      	b.n	2ffccb64 <_raise_r+0x12>
2ffccb94:	2100      	movs	r1, #0
2ffccb96:	4620      	mov	r0, r4
2ffccb98:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
2ffccb9c:	4798      	blx	r3
2ffccb9e:	2000      	movs	r0, #0
2ffccba0:	e7e0      	b.n	2ffccb64 <_raise_r+0x12>
	...

2ffccba4 <raise>:
2ffccba4:	4b02      	ldr	r3, [pc, #8]	@ (2ffccbb0 <raise+0xc>)
2ffccba6:	4601      	mov	r1, r0
2ffccba8:	6818      	ldr	r0, [r3, #0]
2ffccbaa:	f7ff bfd2 	b.w	2ffccb52 <_raise_r>
2ffccbae:	bf00      	nop
2ffccbb0:	2ffd18a8 	.word	0x2ffd18a8

2ffccbb4 <_kill_r>:
2ffccbb4:	b538      	push	{r3, r4, r5, lr}
2ffccbb6:	4604      	mov	r4, r0
2ffccbb8:	4d06      	ldr	r5, [pc, #24]	@ (2ffccbd4 <_kill_r+0x20>)
2ffccbba:	4608      	mov	r0, r1
2ffccbbc:	4611      	mov	r1, r2
2ffccbbe:	2300      	movs	r3, #0
2ffccbc0:	602b      	str	r3, [r5, #0]
2ffccbc2:	f7f5 fd67 	bl	2ffc2694 <_kill>
2ffccbc6:	1c43      	adds	r3, r0, #1
2ffccbc8:	d102      	bne.n	2ffccbd0 <_kill_r+0x1c>
2ffccbca:	682b      	ldr	r3, [r5, #0]
2ffccbcc:	b103      	cbz	r3, 2ffccbd0 <_kill_r+0x1c>
2ffccbce:	6023      	str	r3, [r4, #0]
2ffccbd0:	bd38      	pop	{r3, r4, r5, pc}
2ffccbd2:	bf00      	nop
2ffccbd4:	2ffd2b3c 	.word	0x2ffd2b3c

2ffccbd8 <_getpid_r>:
2ffccbd8:	f7f5 bd5a 	b.w	2ffc2690 <_getpid>

2ffccbdc <_malloc_usable_size_r>:
2ffccbdc:	f851 3c04 	ldr.w	r3, [r1, #-4]
2ffccbe0:	1f18      	subs	r0, r3, #4
2ffccbe2:	2b00      	cmp	r3, #0
2ffccbe4:	bfbc      	itt	lt
2ffccbe6:	580b      	ldrlt	r3, [r1, r0]
2ffccbe8:	18c0      	addlt	r0, r0, r3
2ffccbea:	4770      	bx	lr

2ffccbec <__aeabi_ldivmod>:
2ffccbec:	b97b      	cbnz	r3, 2ffccc0e <__aeabi_ldivmod+0x22>
2ffccbee:	b972      	cbnz	r2, 2ffccc0e <__aeabi_ldivmod+0x22>
2ffccbf0:	2900      	cmp	r1, #0
2ffccbf2:	bfbe      	ittt	lt
2ffccbf4:	2000      	movlt	r0, #0
2ffccbf6:	f04f 4100 	movlt.w	r1, #2147483648	@ 0x80000000
2ffccbfa:	e006      	blt.n	2ffccc0a <__aeabi_ldivmod+0x1e>
2ffccbfc:	bf08      	it	eq
2ffccbfe:	2800      	cmpeq	r0, #0
2ffccc00:	bf1c      	itt	ne
2ffccc02:	f06f 4100 	mvnne.w	r1, #2147483648	@ 0x80000000
2ffccc06:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
2ffccc0a:	f000 ba0f 	b.w	2ffcd02c <__aeabi_idiv0>
2ffccc0e:	f1ad 0c08 	sub.w	ip, sp, #8
2ffccc12:	e96d ce04 	strd	ip, lr, [sp, #-16]!
2ffccc16:	2900      	cmp	r1, #0
2ffccc18:	db09      	blt.n	2ffccc2e <__aeabi_ldivmod+0x42>
2ffccc1a:	2b00      	cmp	r3, #0
2ffccc1c:	db1a      	blt.n	2ffccc54 <__aeabi_ldivmod+0x68>
2ffccc1e:	f000 f84d 	bl	2ffcccbc <__udivmoddi4>
2ffccc22:	f8dd e004 	ldr.w	lr, [sp, #4]
2ffccc26:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
2ffccc2a:	b004      	add	sp, #16
2ffccc2c:	4770      	bx	lr
2ffccc2e:	4240      	negs	r0, r0
2ffccc30:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
2ffccc34:	2b00      	cmp	r3, #0
2ffccc36:	db1b      	blt.n	2ffccc70 <__aeabi_ldivmod+0x84>
2ffccc38:	f000 f840 	bl	2ffcccbc <__udivmoddi4>
2ffccc3c:	f8dd e004 	ldr.w	lr, [sp, #4]
2ffccc40:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
2ffccc44:	b004      	add	sp, #16
2ffccc46:	4240      	negs	r0, r0
2ffccc48:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
2ffccc4c:	4252      	negs	r2, r2
2ffccc4e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
2ffccc52:	4770      	bx	lr
2ffccc54:	4252      	negs	r2, r2
2ffccc56:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
2ffccc5a:	f000 f82f 	bl	2ffcccbc <__udivmoddi4>
2ffccc5e:	f8dd e004 	ldr.w	lr, [sp, #4]
2ffccc62:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
2ffccc66:	b004      	add	sp, #16
2ffccc68:	4240      	negs	r0, r0
2ffccc6a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
2ffccc6e:	4770      	bx	lr
2ffccc70:	4252      	negs	r2, r2
2ffccc72:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
2ffccc76:	f000 f821 	bl	2ffcccbc <__udivmoddi4>
2ffccc7a:	f8dd e004 	ldr.w	lr, [sp, #4]
2ffccc7e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
2ffccc82:	b004      	add	sp, #16
2ffccc84:	4252      	negs	r2, r2
2ffccc86:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
2ffccc8a:	4770      	bx	lr

2ffccc8c <__aeabi_uldivmod>:
2ffccc8c:	b953      	cbnz	r3, 2ffccca4 <__aeabi_uldivmod+0x18>
2ffccc8e:	b94a      	cbnz	r2, 2ffccca4 <__aeabi_uldivmod+0x18>
2ffccc90:	2900      	cmp	r1, #0
2ffccc92:	bf08      	it	eq
2ffccc94:	2800      	cmpeq	r0, #0
2ffccc96:	bf1c      	itt	ne
2ffccc98:	f04f 31ff 	movne.w	r1, #4294967295	@ 0xffffffff
2ffccc9c:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
2ffccca0:	f000 b9c4 	b.w	2ffcd02c <__aeabi_idiv0>
2ffccca4:	f1ad 0c08 	sub.w	ip, sp, #8
2ffccca8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
2ffcccac:	f000 f806 	bl	2ffcccbc <__udivmoddi4>
2ffcccb0:	f8dd e004 	ldr.w	lr, [sp, #4]
2ffcccb4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
2ffcccb8:	b004      	add	sp, #16
2ffcccba:	4770      	bx	lr

2ffcccbc <__udivmoddi4>:
2ffcccbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
2ffcccc0:	4680      	mov	r8, r0
2ffcccc2:	4689      	mov	r9, r1
2ffcccc4:	b083      	sub	sp, #12
2ffcccc6:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
2ffcccc8:	2b00      	cmp	r3, #0
2ffcccca:	d15c      	bne.n	2ffccd86 <__udivmoddi4+0xca>
2ffccccc:	4694      	mov	ip, r2
2ffcccce:	fab2 f282 	clz	r2, r2
2ffcccd2:	458c      	cmp	ip, r1
2ffcccd4:	d978      	bls.n	2ffccdc8 <__udivmoddi4+0x10c>
2ffcccd6:	468e      	mov	lr, r1
2ffcccd8:	b152      	cbz	r2, 2ffcccf0 <__udivmoddi4+0x34>
2ffcccda:	f1c2 0e20 	rsb	lr, r2, #32
2ffcccde:	fa01 f302 	lsl.w	r3, r1, r2
2ffccce2:	fa0c fc02 	lsl.w	ip, ip, r2
2ffccce6:	fa20 fe0e 	lsr.w	lr, r0, lr
2ffcccea:	ea4e 0e03 	orr.w	lr, lr, r3
2ffcccee:	4090      	lsls	r0, r2
2ffcccf0:	ea4f 471c 	mov.w	r7, ip, lsr #16
2ffcccf4:	fa1f f58c 	uxth.w	r5, ip
2ffcccf8:	0c03      	lsrs	r3, r0, #16
2ffcccfa:	fbbe f1f7 	udiv	r1, lr, r7
2ffcccfe:	fb07 ee11 	mls	lr, r7, r1, lr
2ffccd02:	fb01 f405 	mul.w	r4, r1, r5
2ffccd06:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
2ffccd0a:	429c      	cmp	r4, r3
2ffccd0c:	d913      	bls.n	2ffccd36 <__udivmoddi4+0x7a>
2ffccd0e:	eb1c 0303 	adds.w	r3, ip, r3
2ffccd12:	f101 38ff 	add.w	r8, r1, #4294967295	@ 0xffffffff
2ffccd16:	bf34      	ite	cc
2ffccd18:	f04f 0e01 	movcc.w	lr, #1
2ffccd1c:	f04f 0e00 	movcs.w	lr, #0
2ffccd20:	429c      	cmp	r4, r3
2ffccd22:	bf94      	ite	ls
2ffccd24:	f04f 0e00 	movls.w	lr, #0
2ffccd28:	f00e 0e01 	andhi.w	lr, lr, #1
2ffccd2c:	f1be 0f00 	cmp.w	lr, #0
2ffccd30:	f040 8170 	bne.w	2ffcd014 <__udivmoddi4+0x358>
2ffccd34:	4641      	mov	r1, r8
2ffccd36:	1b1b      	subs	r3, r3, r4
2ffccd38:	b280      	uxth	r0, r0
2ffccd3a:	fbb3 f4f7 	udiv	r4, r3, r7
2ffccd3e:	fb07 3314 	mls	r3, r7, r4, r3
2ffccd42:	fb04 f505 	mul.w	r5, r4, r5
2ffccd46:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
2ffccd4a:	4285      	cmp	r5, r0
2ffccd4c:	d90f      	bls.n	2ffccd6e <__udivmoddi4+0xb2>
2ffccd4e:	eb1c 0000 	adds.w	r0, ip, r0
2ffccd52:	f104 37ff 	add.w	r7, r4, #4294967295	@ 0xffffffff
2ffccd56:	bf34      	ite	cc
2ffccd58:	2301      	movcc	r3, #1
2ffccd5a:	2300      	movcs	r3, #0
2ffccd5c:	4285      	cmp	r5, r0
2ffccd5e:	bf94      	ite	ls
2ffccd60:	2300      	movls	r3, #0
2ffccd62:	f003 0301 	andhi.w	r3, r3, #1
2ffccd66:	2b00      	cmp	r3, #0
2ffccd68:	f040 8157 	bne.w	2ffcd01a <__udivmoddi4+0x35e>
2ffccd6c:	463c      	mov	r4, r7
2ffccd6e:	1b43      	subs	r3, r0, r5
2ffccd70:	ea44 4001 	orr.w	r0, r4, r1, lsl #16
2ffccd74:	2100      	movs	r1, #0
2ffccd76:	b11e      	cbz	r6, 2ffccd80 <__udivmoddi4+0xc4>
2ffccd78:	40d3      	lsrs	r3, r2
2ffccd7a:	2200      	movs	r2, #0
2ffccd7c:	e9c6 3200 	strd	r3, r2, [r6]
2ffccd80:	b003      	add	sp, #12
2ffccd82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
2ffccd86:	428b      	cmp	r3, r1
2ffccd88:	d905      	bls.n	2ffccd96 <__udivmoddi4+0xda>
2ffccd8a:	b10e      	cbz	r6, 2ffccd90 <__udivmoddi4+0xd4>
2ffccd8c:	e9c6 8900 	strd	r8, r9, [r6]
2ffccd90:	2100      	movs	r1, #0
2ffccd92:	4608      	mov	r0, r1
2ffccd94:	e7f4      	b.n	2ffccd80 <__udivmoddi4+0xc4>
2ffccd96:	fab3 f183 	clz	r1, r3
2ffccd9a:	2900      	cmp	r1, #0
2ffccd9c:	d15d      	bne.n	2ffcce5a <__udivmoddi4+0x19e>
2ffccd9e:	ec49 8b30 	vmov	d16, r8, r9
2ffccda2:	4608      	mov	r0, r1
2ffccda4:	454b      	cmp	r3, r9
2ffccda6:	bf28      	it	cs
2ffccda8:	4542      	cmpcs	r2, r8
2ffccdaa:	d808      	bhi.n	2ffccdbe <__udivmoddi4+0x102>
2ffccdac:	ebb8 0002 	subs.w	r0, r8, r2
2ffccdb0:	eb69 0203 	sbc.w	r2, r9, r3
2ffccdb4:	e9cd 0200 	strd	r0, r2, [sp]
2ffccdb8:	2001      	movs	r0, #1
2ffccdba:	eddd 0b00 	vldr	d16, [sp]
2ffccdbe:	2e00      	cmp	r6, #0
2ffccdc0:	d0de      	beq.n	2ffccd80 <__udivmoddi4+0xc4>
2ffccdc2:	edc6 0b00 	vstr	d16, [r6]
2ffccdc6:	e7db      	b.n	2ffccd80 <__udivmoddi4+0xc4>
2ffccdc8:	2a00      	cmp	r2, #0
2ffccdca:	f040 80bc 	bne.w	2ffccf46 <__udivmoddi4+0x28a>
2ffccdce:	eba1 030c 	sub.w	r3, r1, ip
2ffccdd2:	ea4f 471c 	mov.w	r7, ip, lsr #16
2ffccdd6:	fa1f fe8c 	uxth.w	lr, ip
2ffccdda:	2101      	movs	r1, #1
2ffccddc:	fbb3 f5f7 	udiv	r5, r3, r7
2ffccde0:	fb07 3415 	mls	r4, r7, r5, r3
2ffccde4:	0c03      	lsrs	r3, r0, #16
2ffccde6:	fb0e f805 	mul.w	r8, lr, r5
2ffccdea:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
2ffccdee:	4598      	cmp	r8, r3
2ffccdf0:	d911      	bls.n	2ffcce16 <__udivmoddi4+0x15a>
2ffccdf2:	eb1c 0303 	adds.w	r3, ip, r3
2ffccdf6:	f105 39ff 	add.w	r9, r5, #4294967295	@ 0xffffffff
2ffccdfa:	bf2c      	ite	cs
2ffccdfc:	2401      	movcs	r4, #1
2ffccdfe:	2400      	movcc	r4, #0
2ffcce00:	f084 0401 	eor.w	r4, r4, #1
2ffcce04:	4598      	cmp	r8, r3
2ffcce06:	bf94      	ite	ls
2ffcce08:	2400      	movls	r4, #0
2ffcce0a:	f004 0401 	andhi.w	r4, r4, #1
2ffcce0e:	2c00      	cmp	r4, #0
2ffcce10:	f040 8109 	bne.w	2ffcd026 <__udivmoddi4+0x36a>
2ffcce14:	464d      	mov	r5, r9
2ffcce16:	eba3 0308 	sub.w	r3, r3, r8
2ffcce1a:	b280      	uxth	r0, r0
2ffcce1c:	fbb3 f4f7 	udiv	r4, r3, r7
2ffcce20:	fb07 3314 	mls	r3, r7, r4, r3
2ffcce24:	fb0e fe04 	mul.w	lr, lr, r4
2ffcce28:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
2ffcce2c:	4586      	cmp	lr, r0
2ffcce2e:	d90f      	bls.n	2ffcce50 <__udivmoddi4+0x194>
2ffcce30:	eb1c 0000 	adds.w	r0, ip, r0
2ffcce34:	f104 37ff 	add.w	r7, r4, #4294967295	@ 0xffffffff
2ffcce38:	bf34      	ite	cc
2ffcce3a:	2301      	movcc	r3, #1
2ffcce3c:	2300      	movcs	r3, #0
2ffcce3e:	4586      	cmp	lr, r0
2ffcce40:	bf94      	ite	ls
2ffcce42:	2300      	movls	r3, #0
2ffcce44:	f003 0301 	andhi.w	r3, r3, #1
2ffcce48:	2b00      	cmp	r3, #0
2ffcce4a:	f040 80e9 	bne.w	2ffcd020 <__udivmoddi4+0x364>
2ffcce4e:	463c      	mov	r4, r7
2ffcce50:	eba0 030e 	sub.w	r3, r0, lr
2ffcce54:	ea44 4005 	orr.w	r0, r4, r5, lsl #16
2ffcce58:	e78d      	b.n	2ffccd76 <__udivmoddi4+0xba>
2ffcce5a:	f1c1 0720 	rsb	r7, r1, #32
2ffcce5e:	408b      	lsls	r3, r1
2ffcce60:	fa02 fc01 	lsl.w	ip, r2, r1
2ffcce64:	40fa      	lsrs	r2, r7
2ffcce66:	431a      	orrs	r2, r3
2ffcce68:	fa09 fe01 	lsl.w	lr, r9, r1
2ffcce6c:	fa29 f007 	lsr.w	r0, r9, r7
2ffcce70:	ea4f 4912 	mov.w	r9, r2, lsr #16
2ffcce74:	fa28 f507 	lsr.w	r5, r8, r7
2ffcce78:	fa08 f401 	lsl.w	r4, r8, r1
2ffcce7c:	ea4e 0305 	orr.w	r3, lr, r5
2ffcce80:	fa1f fe82 	uxth.w	lr, r2
2ffcce84:	fbb0 f8f9 	udiv	r8, r0, r9
2ffcce88:	0c1d      	lsrs	r5, r3, #16
2ffcce8a:	fb09 0018 	mls	r0, r9, r8, r0
2ffcce8e:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
2ffcce92:	fb08 f00e 	mul.w	r0, r8, lr
2ffcce96:	42a8      	cmp	r0, r5
2ffcce98:	d914      	bls.n	2ffccec4 <__udivmoddi4+0x208>
2ffcce9a:	1955      	adds	r5, r2, r5
2ffcce9c:	f108 3bff 	add.w	fp, r8, #4294967295	@ 0xffffffff
2ffccea0:	bf2c      	ite	cs
2ffccea2:	f04f 0a01 	movcs.w	sl, #1
2ffccea6:	f04f 0a00 	movcc.w	sl, #0
2ffcceaa:	f08a 0a01 	eor.w	sl, sl, #1
2ffcceae:	42a8      	cmp	r0, r5
2ffcceb0:	bf94      	ite	ls
2ffcceb2:	f04f 0a00 	movls.w	sl, #0
2ffcceb6:	f00a 0a01 	andhi.w	sl, sl, #1
2ffcceba:	f1ba 0f00 	cmp.w	sl, #0
2ffccebe:	f040 809f 	bne.w	2ffcd000 <__udivmoddi4+0x344>
2ffccec2:	46d8      	mov	r8, fp
2ffccec4:	1a2d      	subs	r5, r5, r0
2ffccec6:	b29b      	uxth	r3, r3
2ffccec8:	fbb5 f0f9 	udiv	r0, r5, r9
2ffccecc:	fb09 5510 	mls	r5, r9, r0, r5
2ffcced0:	fb00 fe0e 	mul.w	lr, r0, lr
2ffcced4:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
2ffcced8:	459e      	cmp	lr, r3
2ffcceda:	d90e      	bls.n	2ffccefa <__udivmoddi4+0x23e>
2ffccedc:	18d3      	adds	r3, r2, r3
2ffccede:	f100 39ff 	add.w	r9, r0, #4294967295	@ 0xffffffff
2ffccee2:	bf34      	ite	cc
2ffccee4:	2501      	movcc	r5, #1
2ffccee6:	2500      	movcs	r5, #0
2ffccee8:	459e      	cmp	lr, r3
2ffcceea:	bf94      	ite	ls
2ffcceec:	2500      	movls	r5, #0
2ffcceee:	f005 0501 	andhi.w	r5, r5, #1
2ffccef2:	2d00      	cmp	r5, #0
2ffccef4:	f040 808b 	bne.w	2ffcd00e <__udivmoddi4+0x352>
2ffccef8:	4648      	mov	r0, r9
2ffccefa:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
2ffccefe:	eba3 030e 	sub.w	r3, r3, lr
2ffccf02:	fba0 850c 	umull	r8, r5, r0, ip
2ffccf06:	46c6      	mov	lr, r8
2ffccf08:	46a9      	mov	r9, r5
2ffccf0a:	42ab      	cmp	r3, r5
2ffccf0c:	d36e      	bcc.n	2ffccfec <__udivmoddi4+0x330>
2ffccf0e:	bf0c      	ite	eq
2ffccf10:	f04f 0a01 	moveq.w	sl, #1
2ffccf14:	f04f 0a00 	movne.w	sl, #0
2ffccf18:	4544      	cmp	r4, r8
2ffccf1a:	bf2c      	ite	cs
2ffccf1c:	f04f 0a00 	movcs.w	sl, #0
2ffccf20:	f00a 0a01 	andcc.w	sl, sl, #1
2ffccf24:	f1ba 0f00 	cmp.w	sl, #0
2ffccf28:	d160      	bne.n	2ffccfec <__udivmoddi4+0x330>
2ffccf2a:	b156      	cbz	r6, 2ffccf42 <__udivmoddi4+0x286>
2ffccf2c:	ebb4 020e 	subs.w	r2, r4, lr
2ffccf30:	eb63 0309 	sbc.w	r3, r3, r9
2ffccf34:	fa03 f707 	lsl.w	r7, r3, r7
2ffccf38:	40ca      	lsrs	r2, r1
2ffccf3a:	4317      	orrs	r7, r2
2ffccf3c:	40cb      	lsrs	r3, r1
2ffccf3e:	e9c6 7300 	strd	r7, r3, [r6]
2ffccf42:	2100      	movs	r1, #0
2ffccf44:	e71c      	b.n	2ffccd80 <__udivmoddi4+0xc4>
2ffccf46:	fa0c fc02 	lsl.w	ip, ip, r2
2ffccf4a:	f1c2 0120 	rsb	r1, r2, #32
2ffccf4e:	fa09 f302 	lsl.w	r3, r9, r2
2ffccf52:	fa29 f501 	lsr.w	r5, r9, r1
2ffccf56:	ea4f 471c 	mov.w	r7, ip, lsr #16
2ffccf5a:	fa28 f101 	lsr.w	r1, r8, r1
2ffccf5e:	fa1f fe8c 	uxth.w	lr, ip
2ffccf62:	430b      	orrs	r3, r1
2ffccf64:	4090      	lsls	r0, r2
2ffccf66:	fbb5 f4f7 	udiv	r4, r5, r7
2ffccf6a:	0c19      	lsrs	r1, r3, #16
2ffccf6c:	fb07 5514 	mls	r5, r7, r4, r5
2ffccf70:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
2ffccf74:	fb04 f50e 	mul.w	r5, r4, lr
2ffccf78:	428d      	cmp	r5, r1
2ffccf7a:	d914      	bls.n	2ffccfa6 <__udivmoddi4+0x2ea>
2ffccf7c:	eb1c 0101 	adds.w	r1, ip, r1
2ffccf80:	f104 39ff 	add.w	r9, r4, #4294967295	@ 0xffffffff
2ffccf84:	bf2c      	ite	cs
2ffccf86:	f04f 0801 	movcs.w	r8, #1
2ffccf8a:	f04f 0800 	movcc.w	r8, #0
2ffccf8e:	f088 0801 	eor.w	r8, r8, #1
2ffccf92:	428d      	cmp	r5, r1
2ffccf94:	bf94      	ite	ls
2ffccf96:	f04f 0800 	movls.w	r8, #0
2ffccf9a:	f008 0801 	andhi.w	r8, r8, #1
2ffccf9e:	f1b8 0f00 	cmp.w	r8, #0
2ffccfa2:	d12a      	bne.n	2ffccffa <__udivmoddi4+0x33e>
2ffccfa4:	464c      	mov	r4, r9
2ffccfa6:	1b49      	subs	r1, r1, r5
2ffccfa8:	b29b      	uxth	r3, r3
2ffccfaa:	fbb1 f5f7 	udiv	r5, r1, r7
2ffccfae:	fb07 1115 	mls	r1, r7, r5, r1
2ffccfb2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
2ffccfb6:	fb05 f10e 	mul.w	r1, r5, lr
2ffccfba:	4299      	cmp	r1, r3
2ffccfbc:	d912      	bls.n	2ffccfe4 <__udivmoddi4+0x328>
2ffccfbe:	eb1c 0303 	adds.w	r3, ip, r3
2ffccfc2:	f105 39ff 	add.w	r9, r5, #4294967295	@ 0xffffffff
2ffccfc6:	bf34      	ite	cc
2ffccfc8:	f04f 0801 	movcc.w	r8, #1
2ffccfcc:	f04f 0800 	movcs.w	r8, #0
2ffccfd0:	4299      	cmp	r1, r3
2ffccfd2:	bf94      	ite	ls
2ffccfd4:	f04f 0800 	movls.w	r8, #0
2ffccfd8:	f008 0801 	andhi.w	r8, r8, #1
2ffccfdc:	f1b8 0f00 	cmp.w	r8, #0
2ffccfe0:	d112      	bne.n	2ffcd008 <__udivmoddi4+0x34c>
2ffccfe2:	464d      	mov	r5, r9
2ffccfe4:	1a5b      	subs	r3, r3, r1
2ffccfe6:	ea45 4104 	orr.w	r1, r5, r4, lsl #16
2ffccfea:	e6f7      	b.n	2ffccddc <__udivmoddi4+0x120>
2ffccfec:	ebb8 0e0c 	subs.w	lr, r8, ip
2ffccff0:	eb65 0202 	sbc.w	r2, r5, r2
2ffccff4:	3801      	subs	r0, #1
2ffccff6:	4691      	mov	r9, r2
2ffccff8:	e797      	b.n	2ffccf2a <__udivmoddi4+0x26e>
2ffccffa:	3c02      	subs	r4, #2
2ffccffc:	4461      	add	r1, ip
2ffccffe:	e7d2      	b.n	2ffccfa6 <__udivmoddi4+0x2ea>
2ffcd000:	f1a8 0802 	sub.w	r8, r8, #2
2ffcd004:	4415      	add	r5, r2
2ffcd006:	e75d      	b.n	2ffccec4 <__udivmoddi4+0x208>
2ffcd008:	3d02      	subs	r5, #2
2ffcd00a:	4463      	add	r3, ip
2ffcd00c:	e7ea      	b.n	2ffccfe4 <__udivmoddi4+0x328>
2ffcd00e:	3802      	subs	r0, #2
2ffcd010:	4413      	add	r3, r2
2ffcd012:	e772      	b.n	2ffccefa <__udivmoddi4+0x23e>
2ffcd014:	3902      	subs	r1, #2
2ffcd016:	4463      	add	r3, ip
2ffcd018:	e68d      	b.n	2ffccd36 <__udivmoddi4+0x7a>
2ffcd01a:	4460      	add	r0, ip
2ffcd01c:	3c02      	subs	r4, #2
2ffcd01e:	e6a6      	b.n	2ffccd6e <__udivmoddi4+0xb2>
2ffcd020:	4460      	add	r0, ip
2ffcd022:	3c02      	subs	r4, #2
2ffcd024:	e714      	b.n	2ffcce50 <__udivmoddi4+0x194>
2ffcd026:	3d02      	subs	r5, #2
2ffcd028:	4463      	add	r3, ip
2ffcd02a:	e6f4      	b.n	2ffcce16 <__udivmoddi4+0x15a>

2ffcd02c <__aeabi_idiv0>:
2ffcd02c:	4770      	bx	lr
2ffcd02e:	bf00      	nop

2ffcd030 <_init>:
2ffcd030:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2ffcd032:	bf00      	nop
2ffcd034:	bcf8      	pop	{r3, r4, r5, r6, r7}
2ffcd036:	bc08      	pop	{r3}
2ffcd038:	469e      	mov	lr, r3
2ffcd03a:	4770      	bx	lr

2ffcd03c <_fini>:
2ffcd03c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2ffcd03e:	bf00      	nop
2ffcd040:	bcf8      	pop	{r3, r4, r5, r6, r7}
2ffcd042:	bc08      	pop	{r3}
2ffcd044:	469e      	mov	lr, r3
2ffcd046:	4770      	bx	lr

2ffcd048 <__TEXT_END_UNALIGNED__>:
	...

2ffce000 <LED_PORT>:
2ffce000:	2000 5000 2000 5000 9000 5000 5000 5000     . .P. .P...P.P.P

2ffce010 <LED_PIN>:
2ffce010:	2000 0000 4000 0000 0080 0000 0800 0000     . ...@..........

2ffce020 <BUTTON_PIN>:
2ffce020:	0001 4000 2000 0000                         ...@. ..

2ffce028 <BUTTON_PORT>:
2ffce028:	2000 5000 2000 5000 2000 5000               . .P. .P. .P

2ffce034 <BUTTON_IRQn>:
2ffce034:	0026 0099 006d 0000 6423 6665 6e69 2065     &...m...#define 
2ffce044:	4444 5f52 7325 0000 7325 003d 7325 3020     DDR_%s..%s=.%s 0
2ffce054:	2578 3830 786c 0d0a 0000 0000 2f0a 202a     x%08lx......./* 
2ffce064:	4444 2052 4552 2047 4156 554c 5345 5420     DDR REG VALUES T
2ffce074:	204f 4542 5320 5641 4445 2a20 0a2f 000d     O BE SAVED */...
2ffce084:	6423 6665 6e69 2065 4444 5f52 454d 5f4d     #define DDR_MEM_
2ffce094:	414e 454d 2020 2522 2273 0d0a 0000 0000     NAME  "%s"......
2ffce0a4:	6423 6665 6e69 2065 4444 5f52 454d 5f4d     #define DDR_MEM_
2ffce0b4:	5053 4545 2044 6425 0d0a 0000 6423 6665     SPEED %d....#def
2ffce0c4:	6e69 2065 4444 5f52 454d 5f4d 4953 455a     ine DDR_MEM_SIZE
2ffce0d4:	2020 7830 3025 6c38 0a78 0d0a 0000 0000       0x%08lx.......
2ffce0e4:	2f0a 202a 212f 205c 6f4e 6e20 6565 2064     ./* /!\ No need 
2ffce0f4:	6f74 6320 706f 2079 4444 2052 7964 616e     to copy DDR dyna
2ffce104:	696d 2063 6572 6967 7473 7265 2073 6f74     mic registers to
2ffce114:	6320 6e6f 2066 6966 656c 2a20 0a2f 000d      conf file */...
2ffce124:	2f0a 202a 7325 252e 2073 2f2a 0d0a 0000     ./* %s.%s */....
2ffce134:	3d3d 7325 252e 3d73 0a3d 000d 7325 6e20     ==%s.%s==...%s n
2ffce144:	746f 6620 756f 646e 0d0a 0000 6e69 6176     ot found....inva
2ffce154:	696c 2064 6176 756c 2065 7325 0d0a 0000     lid value %s....
2ffce164:	7325 203d 7830 3025 6c38 0a78 000d 0000     %s= 0x%08lx.....
2ffce174:	3d3d 7325 252e 3d73 0a3d 0a0d 000d 0000     ==%s.%s==.......
2ffce184:	6f6e 7020 7261 6d61 7465 7265 2520 0a73     no parameter %s.
2ffce194:	000d 0000 504c 4444 3352 3320 6232 7469     ....LPDDR3 32bit
2ffce1a4:	2073 3335 3033 3030 486b 007a 7463 006c     s 533000kHz.ctl.
2ffce1b4:	6870 0079 7473 7461 6369 0000 6974 696d     phy.static..timi
2ffce1c4:	676e 0000 6570 6672 0000 0000 616d 0070     ng..perf....map.
2ffce1d4:	7964 006e 4950 0052 4750 5253 0000 0000     dyn.PIR.PGSR....
2ffce1e4:	515a 5330 3052 0000 515a 5330 3152 0000     ZQ0SR0..ZQ0SR1..
2ffce1f4:	5844 4730 5253 0030 5844 4730 5253 0031     DX0GSR0.DX0GSR1.
2ffce204:	5844 4430 4c4c 5243 0000 0000 5844 4430     DX0DLLCR....DX0D
2ffce214:	5451 0052 5844 4430 5351 5254 0000 0000     QTR.DX0DQSTR....
2ffce224:	5844 4731 5253 0030 5844 4731 5253 0031     DX1GSR0.DX1GSR1.
2ffce234:	5844 4431 4c4c 5243 0000 0000 5844 4431     DX1DLLCR....DX1D
2ffce244:	5451 0052 5844 4431 5351 5254 0000 0000     QTR.DX1DQSTR....
2ffce254:	5844 4732 5253 0030 5844 4732 5253 0031     DX2GSR0.DX2GSR1.
2ffce264:	5844 4432 4c4c 5243 0000 0000 5844 4432     DX2DLLCR....DX2D
2ffce274:	5451 0052 5844 4432 5351 5254 0000 0000     QTR.DX2DQSTR....
2ffce284:	5844 4733 5253 0030 5844 4733 5253 0031     DX3GSR0.DX3GSR1.
2ffce294:	5844 4433 4c4c 5243 0000 0000 5844 4433     DX3DLLCR....DX3D
2ffce2a4:	5451 0052 5844 4433 5351 5254 0000 0000     QTR.DX3DQSTR....
2ffce2b4:	5453 5441 0000 0000 4e49 5449 0030 0000     STAT....INIT0...
2ffce2c4:	4644 4d49 5349 0043 4644 5349 4154 0054     DFIMISC.DFISTAT.
2ffce2d4:	5753 5443 004c 0000 5753 5453 5441 0000     SWCTL...SWSTAT..
2ffce2e4:	4350 5254 5f4c 0030 4350 5254 5f4c 0031     PCTRL_0.PCTRL_1.
2ffce2f4:	5450 3052 0000 0000 5450 3152 0000 0000     PTR0....PTR1....
2ffce304:	5450 3252 0000 0000 5444 5250 0030 0000     PTR2....DTPR0...
2ffce314:	5444 5250 0031 0000 5444 5250 0032 0000     DTPR1...DTPR2...
2ffce324:	524d 0030 524d 0031 524d 0032 524d 0033     MR0.MR1.MR2.MR3.
2ffce334:	4750 5243 0000 0000 4341 4f49 5243 0000     PGCR....ACIOCR..
2ffce344:	5844 4343 0052 0000 5344 4347 0052 0000     DXCCR...DSGCR...
2ffce354:	4344 0052 444f 4354 0052 0000 515a 4330     DCR.ODTCR...ZQ0C
2ffce364:	3152 0000 5844 4730 5243 0000 5844 4731     R1..DX0GCR..DX1G
2ffce374:	5243 0000 5844 4732 5243 0000 5844 4733     CR..DX2GCR..DX3G
2ffce384:	5243 0000 4353 4548 0044 0000 4353 4548     CR..SCHED...SCHE
2ffce394:	3144 0000 4550 4652 5048 3152 0000 0000     D1..PERFHPR1....
2ffce3a4:	4550 4652 504c 3152 0000 0000 4550 4652     PERFLPR1....PERF
2ffce3b4:	5257 0031 4350 4746 5f52 0030 4350 4746     WR1.PCFGR_0.PCFG
2ffce3c4:	5f57 0030 4350 4746 4f51 3053 305f 0000     W_0.PCFGQOS0_0..
2ffce3d4:	4350 4746 4f51 3153 305f 0000 4350 4746     PCFGQOS1_0..PCFG
2ffce3e4:	5157 534f 5f30 0030 4350 4746 5157 534f     WQOS0_0.PCFGWQOS
2ffce3f4:	5f31 0030 4350 4746 5f52 0031 4350 4746     1_0.PCFGR_1.PCFG
2ffce404:	5f57 0031 4350 4746 4f51 3053 315f 0000     W_1.PCFGQOS0_1..
2ffce414:	4350 4746 4f51 3153 315f 0000 4350 4746     PCFGQOS1_1..PCFG
2ffce424:	5157 534f 5f30 0031 4350 4746 5157 534f     WQOS0_1.PCFGWQOS
2ffce434:	5f31 0031 4441 5244 414d 3150 0000 0000     1_1.ADDRMAP1....
2ffce444:	4441 5244 414d 3250 0000 0000 4441 5244     ADDRMAP2....ADDR
2ffce454:	414d 3350 0000 0000 4441 5244 414d 3450     MAP3....ADDRMAP4
2ffce464:	0000 0000 4441 5244 414d 3550 0000 0000     ....ADDRMAP5....
2ffce474:	4441 5244 414d 3650 0000 0000 4441 5244     ADDRMAP6....ADDR
2ffce484:	414d 3950 0000 0000 4441 5244 414d 3150     MAP9....ADDRMAP1
2ffce494:	0030 0000 4441 5244 414d 3150 0031 0000     0...ADDRMAP11...
2ffce4a4:	4652 4853 4d54 0047 5244 4d41 4d54 3047     RFSHTMG.DRAMTMG0
2ffce4b4:	0000 0000 5244 4d41 4d54 3147 0000 0000     ....DRAMTMG1....
2ffce4c4:	5244 4d41 4d54 3247 0000 0000 5244 4d41     DRAMTMG2....DRAM
2ffce4d4:	4d54 3347 0000 0000 5244 4d41 4d54 3447     TMG3....DRAMTMG4
2ffce4e4:	0000 0000 5244 4d41 4d54 3547 0000 0000     ....DRAMTMG5....
2ffce4f4:	5244 4d41 4d54 3647 0000 0000 5244 4d41     DRAMTMG6....DRAM
2ffce504:	4d54 3747 0000 0000 5244 4d41 4d54 3847     TMG7....DRAMTMG8
2ffce514:	0000 0000 5244 4d41 4d54 3147 0034 0000     ....DRAMTMG14...
2ffce524:	444f 4354 4746 0000 534d 5254 0000 0000     ODTCFG..MSTR....
2ffce534:	524d 5443 4c52 0030 524d 5443 4c52 0031     MRCTRL0.MRCTRL1.
2ffce544:	4544 4152 4554 4e45 0000 0000 4544 4152     DERATEEN....DERA
2ffce554:	4554 4e49 0054 0000 5750 4352 4c54 0000     TEINT...PWRCTL..
2ffce564:	5750 5452 474d 0000 5748 504c 5443 004c     PWRTMG..HWLPCTL.
2ffce574:	4652 4853 5443 304c 0000 0000 4652 4853     RFSHCTL0....RFSH
2ffce584:	5443 334c 0000 0000 5243 5043 5241 5443     CTL3....CRCPARCT
2ffce594:	304c 0000 515a 5443 304c 0000 4644 5449     L0..ZQCTL0..DFIT
2ffce5a4:	474d 0030 4644 5449 474d 0031 4644 4c49     MG0.DFITMG1.DFIL
2ffce5b4:	4350 4746 0030 0000 4644 5549 4450 0030     PCFG0...DFIUPD0.
2ffce5c4:	4644 5549 4450 0031 4644 5549 4450 0032     DFIUPD1.DFIUPD2.
2ffce5d4:	4644 5049 5948 534d 5254 0000 444f 4d54     DFIPHYMSTR..ODTM
2ffce5e4:	5041 0000 4244 3047 0000 0000 4244 3147     AP..DBG0....DBG1
2ffce5f4:	0000 0000 4244 4347 444d 0000 4f50 5349     ....DBGCMD..POIS
2ffce604:	4e4f 4643 0047 0000 4350 4643 0047 0000     ONCFG...PCCFG...

2ffce614 <ddr_registers>:
2ffce614:	e1b8 2ffc e674 2ffc 0019 0000 e1c0 2ffc     .../t../......./
2ffce624:	e73c 2ffc 000c 0000 e1c8 2ffc e7e4 2ffc     <../......./.../
2ffce634:	0011 0000 e1d0 2ffc e79c 2ffc 0009 0000     ......./.../....
2ffce644:	e1b8 2ffc e86c 2ffc 010b 0000 e1c0 2ffc     .../l../......./
2ffce654:	e8c4 2ffc 010a 0000 e1d4 2ffc e9e0 2ffc     .../......./.../
2ffce664:	0008 0000 e1d4 2ffc e920 2ffc 0118 0000     ......./ ../....

2ffce674 <ddr_reg_desc>:
2ffce674:	e52c 2ffc 0000 0000 e534 2ffc 0010 0004     ,../....4../....
2ffce684:	e53c 2ffc 0014 0008 e544 2ffc 0020 000c     <../....D../ ...
2ffce694:	e550 2ffc 0024 0010 e55c 2ffc 0030 0014     P../$...\../0...
2ffce6a4:	e564 2ffc 0034 0018 e56c 2ffc 0038 001c     d../4...l../8...
2ffce6b4:	e574 2ffc 0050 0020 e580 2ffc 0060 0024     t../P. ..../`.$.
2ffce6c4:	e58c 2ffc 00c0 0028 e598 2ffc 0180 002c     .../..(..../..,.
2ffce6d4:	e5a0 2ffc 0190 0030 e5a8 2ffc 0194 0034     .../..0..../..4.
2ffce6e4:	e5b0 2ffc 0198 0038 e5bc 2ffc 01a0 003c     .../..8..../..<.
2ffce6f4:	e5c4 2ffc 01a4 0040 e5cc 2ffc 01a8 0044     .../..@..../..D.
2ffce704:	e5d4 2ffc 01c4 0048 e5e0 2ffc 0244 004c     .../..H..../D.L.
2ffce714:	e5e8 2ffc 0300 0050 e5f0 2ffc 0304 0054     .../..P..../..T.
2ffce724:	e5f8 2ffc 030c 0058 e600 2ffc 036c 005c     .../..X..../l.\.
2ffce734:	e60c 2ffc 0400 0060                         .../..`.

2ffce73c <ddr_timing_desc>:
2ffce73c:	e4a4 2ffc 0064 0000 e4ac 2ffc 0100 0004     .../d....../....
2ffce74c:	e4b8 2ffc 0104 0008 e4c4 2ffc 0108 000c     .../......./....
2ffce75c:	e4d0 2ffc 010c 0010 e4dc 2ffc 0110 0014     .../......./....
2ffce76c:	e4e8 2ffc 0114 0018 e4f4 2ffc 0118 001c     .../......./....
2ffce77c:	e500 2ffc 011c 0020 e50c 2ffc 0120 0024     .../.. ..../ .$.
2ffce78c:	e518 2ffc 0138 0028 e524 2ffc 0240 002c     .../8.(.$../@.,.

2ffce79c <ddr_map_desc>:
2ffce79c:	e438 2ffc 0204 0000 e444 2ffc 0208 0004     8../....D../....
2ffce7ac:	e450 2ffc 020c 0008 e45c 2ffc 0210 000c     P../....\../....
2ffce7bc:	e468 2ffc 0214 0010 e474 2ffc 0218 0014     h../....t../....
2ffce7cc:	e480 2ffc 0224 0018 e48c 2ffc 0228 001c     .../$....../(...
2ffce7dc:	e498 2ffc 022c 0020                         .../,. .

2ffce7e4 <ddr_perf_desc>:
2ffce7e4:	e388 2ffc 0250 0000 e390 2ffc 0254 0004     .../P....../T...
2ffce7f4:	e398 2ffc 025c 0008 e3a4 2ffc 0264 000c     .../\....../d...
2ffce804:	e3b0 2ffc 026c 0010 e3b8 2ffc 0404 0014     .../l....../....
2ffce814:	e3c0 2ffc 0408 0018 e3c8 2ffc 0494 001c     .../......./....
2ffce824:	e3d4 2ffc 0498 0020 e3e0 2ffc 049c 0024     .../.. ..../..$.
2ffce834:	e3ec 2ffc 04a0 0028 e3f8 2ffc 04b4 002c     .../..(..../..,.
2ffce844:	e400 2ffc 04b8 0030 e408 2ffc 0544 0034     .../..0..../D.4.
2ffce854:	e414 2ffc 0548 0038 e420 2ffc 054c 003c     .../H.8. ../L.<.
2ffce864:	e42c 2ffc 0550 0040                         ,../P.@.

2ffce86c <ddrphy_reg_desc>:
2ffce86c:	e334 2ffc 0008 0000 e33c 2ffc 0024 0004     4../....<../$...
2ffce87c:	e344 2ffc 0028 0008 e34c 2ffc 002c 000c     D../(...L../,...
2ffce88c:	e354 2ffc 0030 0010 e358 2ffc 0050 0014     T../0...X../P...
2ffce89c:	e360 2ffc 0184 0018 e368 2ffc 01c0 001c     `../....h../....
2ffce8ac:	e370 2ffc 0200 0020 e378 2ffc 0240 0024     p../.. .x../@.$.
2ffce8bc:	e380 2ffc 0280 0028                         .../..(.

2ffce8c4 <ddrphy_timing_desc>:
2ffce8c4:	e2f4 2ffc 0018 0000 e2fc 2ffc 001c 0004     .../......./....
2ffce8d4:	e304 2ffc 0020 0008 e30c 2ffc 0034 000c     .../ ....../4...
2ffce8e4:	e314 2ffc 0038 0010 e31c 2ffc 003c 0014     .../8....../<...
2ffce8f4:	e324 2ffc 0040 0018 e328 2ffc 0044 001c     $../@...(../D...
2ffce904:	e32c 2ffc 0048 0020 e330 2ffc 004c 0024     ,../H. .0../L.$.

2ffce914 <CSWTCH.102>:
2ffce914:	0300 0303 0303 0303 0102 0000               ............

2ffce920 <ddrphy_dyn_desc>:
2ffce920:	e1d8 2ffc 0004 00ff e1dc 2ffc 000c 00ff     .../......./....
2ffce930:	e1e4 2ffc 0188 00ff e1ec 2ffc 018c 00ff     .../......./....
2ffce940:	e1f4 2ffc 01c4 00ff e1fc 2ffc 01c8 00ff     .../......./....
2ffce950:	e204 2ffc 01cc 00ff e210 2ffc 01d0 00ff     .../......./....
2ffce960:	e218 2ffc 01d4 00ff e224 2ffc 0204 00ff     .../....$../....
2ffce970:	e22c 2ffc 0208 00ff e234 2ffc 020c 00ff     ,../....4../....
2ffce980:	e240 2ffc 0210 00ff e248 2ffc 0214 00ff     @../....H../....
2ffce990:	e254 2ffc 0244 00ff e25c 2ffc 0248 00ff     T../D...\../H...
2ffce9a0:	e264 2ffc 024c 00ff e270 2ffc 0250 00ff     d../L...p../P...
2ffce9b0:	e278 2ffc 0254 00ff e284 2ffc 0284 00ff     x../T....../....
2ffce9c0:	e28c 2ffc 0288 00ff e294 2ffc 028c 00ff     .../......./....
2ffce9d0:	e2a0 2ffc 0290 00ff e2a8 2ffc 0294 00ff     .../......./....

2ffce9e0 <ddr_dyn_desc>:
2ffce9e0:	e2b4 2ffc 0004 00ff e2bc 2ffc 00d0 00ff     .../......./....
2ffce9f0:	e2c4 2ffc 01b0 00ff e2cc 2ffc 01bc 00ff     .../......./....
2ffcea00:	e2d4 2ffc 0320 00ff e2dc 2ffc 0324 00ff     .../ ....../$...
2ffcea10:	e2e4 2ffc 0490 00ff e2ec 2ffc 0540 00ff     .../......./@...

2ffcea20 <CSWTCH.253>:
2ffcea20:	0002 0000 0004 0000 0006 0000 0008 0000     ................
2ffcea30:	000a 0000 000c 0000 0010 0000 0020 0000     ............ ...
2ffcea40:	0040 0000 0080 0000 0100 0000 0408 0402     @...............
2ffcea50:	0108 0101 0000 0000 0101 0301 0107 0000     ................
2ffcea60:	6e49 6176 696c 2064 6973 657a 203a 7830     Invalid size: 0x
2ffcea70:	6c25 0a78 000d 0000 2020 7228 6e61 6567     %lx.....  (range
2ffcea80:	3d20 3020 2578 786c 2e2e 7830 7825 0a29      = 0x%lx..0x%x).
2ffcea90:	000d 0000 6e55 6c61 6769 656e 2064 6973     ....Unaligned si
2ffceaa0:	657a 203a 7830 6c25 2078 6d28 6e69 253d     ze: 0x%lx (min=%
2ffceab0:	646c 0a29 000d 0000 6157 6e72 6e69 3a67     ld).....Warning:
2ffceac0:	6920 666e 6e69 7469 2065 6f6c 706f 7220      infinite loop r
2ffcead0:	7165 6575 7473 6465 0d0a 0000 6441 7264     equested....Addr
2ffceae0:	7365 2073 6f74 206f 6f6c 3a77 3020 2578     ess too low: 0x%
2ffceaf0:	786c 0d0a 0000 0000 6e55 6c61 6769 656e     lx......Unaligne
2ffceb00:	2064 6461 7264 7365 3a73 3020 2578 786c     d address: 0x%lx
2ffceb10:	0d0a 0000 2020 6c25 3a78 6520 7272 726f     ....  %lx: error
2ffceb20:	2520 786c 6520 7078 6365 6574 2064 6c25      %lx expected %l
2ffceb30:	2078 3e3d 6520 7272 726f 253a 786c 0d0a     x => error:%lx..
2ffceb40:	0000 0000 2020 6574 7473 645f 7461 6261     ....  test_datab
2ffceb50:	7375 6177 6b6c 6425 4b20 0a4f 000d 0000     uswalk%d KO.....
2ffceb60:	2020 6574 7473 645f 7461 6261 7375 4b20       test_databus K
2ffceb70:	204f 2040 7830 6c25 2078 0d0a 0000 0000     O @ 0x%lx ......
2ffceb80:	6973 657a 3020 2578 786c 6920 2073 6f6e     size 0x%lx is no
2ffceb90:	2074 2061 6f70 6577 2072 666f 3220 0d0a     t a power of 2..
2ffceba0:	0000 0000 2020 6574 7473 615f 6464 6272     ....  test_addrb
2ffcebb0:	7375 4b20 204f 2040 7830 6c25 2078 0d0a     us KO @ 0x%lx ..
2ffcebc0:	0000 0000 2020 6574 7473 6d5f 6d65 6564     ....  test_memde
2ffcebd0:	6976 6563 4b20 204f 2040 7830 6c25 2078     vice KO @ 0x%lx 
2ffcebe0:	0d0a 0000 2020 6574 7473 735f 6f73 4b20     ....  test_sso K
2ffcebf0:	204f 2040 7830 6c25 2078 0d0a 0000 0000     O @ 0x%lx ......
2ffcec00:	2020 6574 7473 6e5f 696f 6573 4b20 204f       test_noise KO 
2ffcec10:	2040 7830 6c25 2078 0d0a 0000 2020 6574     @ 0x%lx ....  te
2ffcec20:	7473 6e5f 696f 6573 7562 7372 2074 4f4b     st_noiseburst KO
2ffcec30:	4020 3020 2578 786c 0d0a 0000 2020 6f6c      @ 0x%lx....  lo
2ffcec40:	706f 2520 646c 203a 7265 6f72 2072 2040     op %ld: error @ 
2ffcec50:	7830 6c25 3a78 3020 2578 786c 6520 7078     0x%lx: 0x%lx exp
2ffcec60:	6365 6574 2064 7830 6c25 0a78 000d 0000     ected 0x%lx.....
2ffcec70:	2020 6574 7473 725f 6e61 6f64 206d 4f4b       test_random KO
2ffcec80:	0d0a 0000 2020 6574 7473 665f 6572 7071     ....  test_freqp
2ffcec90:	7461 6574 6e72 4b20 204f 2040 7830 6c25     attern KO @ 0x%l
2ffceca0:	0a78 000d 2020 6574 7473 665f 6572 7071     x...  test_freqp
2ffcecb0:	7461 6574 6e72 4b20 0a4f 000d 2020 6574     attern KO...  te
2ffcecc0:	7473 4b20 204f 2040 7830 6c25 0a6e 000d     st KO @ 0x%ln...
2ffcecd0:	2020 6574 7473 625f 6f6c 6b63 6573 2071       test_blockseq 
2ffcece0:	4f4b 0d0a 0000 0000 2020 6574 7473 635f     KO......  test_c
2ffcecf0:	6568 6b63 6f62 7261 2064 4f4b 0d0a 0000     heckboard KO....
2ffced00:	2020 6574 7473 625f 7469 7073 6572 6461       test_bitspread
2ffced10:	4b20 0a4f 000d 0000 2020 6574 7473 625f      KO.....  test_b
2ffced20:	7469 6c66 7069 4b20 0a4f 000d 2020 6574     itflip KO...  te
2ffced30:	7473 775f 6c61 626b 7469 2030 4f4b 0d0a     st_walkbit0 KO..
2ffced40:	0000 0000 2020 6574 7473 775f 6c61 626b     ....  test_walkb
2ffced50:	7469 2031 4f4b 0d0a 0000 0000 ee64 2ffc     it1 KO......d../
2ffced60:	ee44 2ffc ee24 2ffc ede4 2ffc eda4 2ffc     D../$../.../.../
2ffced70:	ee44 2ffc ee24 2ffc ee04 2ffc edc4 2ffc     D../$../.../.../
2ffced80:	ed84 2ffc                                   .../

2ffced84 <pattern_mostly_one_x32>:
2ffced84:	ffff ffff ffff ffff ffff ffff 0000 0000     ................
2ffced94:	ffff ffff ffff ffff ffff ffff ffff ffff     ................

2ffceda4 <pattern_mostly_one_x16>:
2ffceda4:	ffff ffff ffff ffff ffff ffff ffff 0000     ................
2ffcedb4:	ffff ffff ffff ffff ffff ffff ffff ffff     ................

2ffcedc4 <pattern_mostly_zero_x32>:
	...
2ffcedd0:	ffff ffff 0000 0000 0000 0000 0000 0000     ................
2ffcede0:	0000 0000                                   ....

2ffcede4 <pattern_mostly_zero_x16>:
	...
2ffcedf0:	ffff 0000 0000 0000 0000 0000 0000 0000     ................
2ffcee00:	0000 0000                                   ....

2ffcee04 <pattern_div4_x32>:
2ffcee04:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
	...

2ffcee24 <pattern_div4_x16>:
2ffcee24:	ffff ffff ffff ffff 0000 0000 0000 0000     ................
2ffcee34:	ffff ffff ffff ffff 0000 0000 0000 0000     ................

2ffcee44 <pattern_div2_x16>:
2ffcee44:	ffff ffff 0000 0000 ffff ffff 0000 0000     ................
2ffcee54:	ffff ffff 0000 0000 ffff ffff 0000 0000     ................

2ffcee64 <pattern_div1_x16>:
2ffcee64:	ffff 0000 ffff 0000 ffff 0000 ffff 0000     ................
2ffcee74:	ffff 0000 ffff 0000 ffff 0000 ffff 0000     ................
2ffcee84:	7325 6620 6961 656c 2064 255b 646c 0a5d     %s failed [%ld].
2ffcee94:	000d 0000 6572 7573 746c 2520 3a64 7325     ....result %d:%s
2ffceea4:	3d20 5020 7361 6573 0a64 000d 6f63 6d6d      = Passed...comm
2ffceeb4:	6e61 7364 0a3a 0a0d 000d 0000 2020 3225     ands:.......  %2
2ffceec4:	3a64 2520 2073 7325 0d0a 0000 2020 2020     d: %s %s....    
2ffceed4:	2020 2020 2020 7325 0d0a 0000 2a2a 7320           %s....** s
2ffceee4:	6574 2070 6425 2a20 202a 4e49 4156 494c     tep %d ** INVALI
2ffceef4:	0a44 000d 6f54 206f 616d 796e 6120 6772     D...Too many arg
2ffcef04:	6d75 6e65 7374 2820 616d 3d78 6425 0a29     uments (max=%d).
2ffcef14:	000d 0000 7325 203a 7261 7567 656d 746e     ....%s: argument
2ffcef24:	6d20 7369 6973 676e 2820 696d 3d6e 6425      missing (min=%d
2ffcef34:	0a29 000d 7325 203a 6f74 206f 616d 796e     )...%s: too many
2ffcef44:	6120 6772 6d75 6e65 7374 2820 616d 3d78      arguments (max=
2ffcef54:	6425 0a29 000d 0000 6568 706c 0000 0000     %d).....help....
2ffcef64:	7245 6f72 2072 255b 5d64 0d0a 0000 0000     Error [%d]......
2ffcef74:	6f63 6d6d 6e61 7364 0a3a 0a0d 680d 6c65     commands:....hel
2ffcef84:	2070 2020 2020 2020 2020 2020 2020 2020     p               
2ffcef94:	2020 2020 2020 2020 6964 7073 616c 7379             displays
2ffcefa4:	6820 6c65 0a70 690d 666e 206f 2020 2020      help..info     
2ffcefb4:	2020 2020 2020 2020 2020 2020 2020 2020                     
2ffcefc4:	2020 6964 7073 616c 7379 4420 5244 6920       displays DDR i
2ffcefd4:	666e 726f 616d 6974 6e6f 0d0a 6e69 6f66     nformation..info
2ffcefe4:	2020 703c 7261 6d61 203e 763c 6c61 203e       <param> <val> 
2ffceff4:	2020 2020 2020 6320 6168 676e 7365 4420            changes D
2ffcf004:	5244 6920 666e 726f 616d 6974 6e6f 0d0a     DR information..
2ffcf014:	2020 2020 2020 6977 6874 3c20 6170 6172           with <para
2ffcf024:	3e6d 3d20 7320 6574 2c70 6e20 6d61 2c65     m> = step, name,
2ffcf034:	7320 7a69 2065 726f 7320 6570 6465 0d0a      size or speed..
2ffcf044:	7266 7165 2020 2020 2020 2020 2020 2020     freq            
2ffcf054:	2020 2020 2020 2020 2020 6420 7369 6c70                displ
2ffcf064:	7961 2073 6874 2065 4444 2052 4850 2059     ays the DDR PHY 
2ffcf074:	7266 7165 6575 636e 2079 6e69 6b20 7a48     frequency in kHz
2ffcf084:	0d0a 7266 7165 2020 663c 6572 3e71 2020     ..freq  <freq>  
2ffcf094:	2020 2020 2020 2020 2020 2020 6320 6168                  cha
2ffcf0a4:	676e 7365 7420 6568 4420 5244 5020 5948     nges the DDR PHY
2ffcf0b4:	6620 6572 7571 6e65 7963 0d0a 6170 6172      frequency..para
2ffcf0c4:	206d 745b 7079 7c65 6572 5d67 2020 2020     m [type|reg]    
2ffcf0d4:	2020 2020 2020 7020 6972 746e 2073 6e69            prints in
2ffcf0e4:	7570 2074 6170 6172 656d 6574 7372 0d0a     put parameters..
2ffcf0f4:	6170 6172 206d 723c 6765 203e 763c 6c61     param <reg> <val
2ffcf104:	203e 2020 2020 2020 2020 6520 6964 7374     >          edits
2ffcf114:	7020 7261 6d61 7465 7265 2073 6e69 7320      parameters in s
2ffcf124:	6574 2070 0a30 700d 6972 746e 5b20 7974     tep 0..print [ty
2ffcf134:	6570 727c 6765 205d 2020 2020 2020 2020     pe|reg]         
2ffcf144:	2020 7564 706d 2073 6572 6967 7473 7265       dumps register
2ffcf154:	0a73 650d 6964 2074 723c 6765 203e 763c     s..edit <reg> <v
2ffcf164:	6c61 203e 2020 2020 2020 2020 2020 6f6d     al>           mo
2ffcf174:	6964 6966 7365 6f20 656e 7220 6765 7369     difies one regis
2ffcf184:	6574 0a72 730d 7661 2065 2020 2020 2020     ter..save       
2ffcf194:	2020 2020 2020 2020 2020 2020 2020 2020                     
2ffcf1a4:	756f 7074 7475 6620 726f 616d 6574 2064     output formated 
2ffcf1b4:	4444 2052 6572 7367 7420 206f 6562 7320     DDR regs to be s
2ffcf1c4:	7661 6465 0d0a 7473 7065 2020 2020 2020     aved..step      
2ffcf1d4:	2020 2020 2020 2020 2020 2020 2020 2020                     
2ffcf1e4:	6c20 7369 7374 7420 6568 6120 6176 6c69      lists the avail
2ffcf1f4:	6261 656c 7320 6574 0a70 730d 6574 2070     able step..step 
2ffcf204:	6e3c 203e 2020 2020 2020 2020 2020 2020     <n>             
2ffcf214:	2020 2020 2020 6f67 7420 206f 6874 2065           go to the 
2ffcf224:	7473 7065 3c20 3e6e 0d0a 656e 7478 2020     step <n>..next  
2ffcf234:	2020 2020 2020 2020 2020 2020 2020 2020                     
2ffcf244:	2020 2020 6720 656f 2073 6f74 7420 6568          goes to the
2ffcf254:	6e20 7865 2074 7473 7065 0d0a 6f67 2020      next step..go  
2ffcf264:	2020 2020 2020 2020 2020 2020 2020 2020                     
2ffcf274:	2020 2020 2020 6320 6e6f 6974 756e 7365            continues
2ffcf284:	7420 6568 4420 5244 5420 4f4f 204c 7865      the DDR TOOL ex
2ffcf294:	6365 7475 6f69 0a6e 720d 7365 7465 2020     ecution..reset  
2ffcf2a4:	2020 2020 2020 2020 2020 2020 2020 2020                     
2ffcf2b4:	2020 2020 6572 6f62 746f 2073 616d 6863         reboots mach
2ffcf2c4:	6e69 0a65 740d 7365 2074 685b 6c65 5d70     ine..test [help]
2ffcf2d4:	7c20 3c20 3e6e 5b20 2e2e 5d2e 2020 2020      | <n> [...]    
2ffcf2e4:	696c 7473 2073 7728 7469 2068 6568 706c     lists (with help
2ffcf2f4:	2029 726f 6520 6578 7563 6574 2073 6574     ) or executes te
2ffcf304:	7473 3c20 3e6e 0d0a 0d0a 6977 6874 6620     st <n>....with f
2ffcf314:	726f 5b20 7974 6570 727c 6765 3a5d 0d0a     or [type|reg]:..
2ffcf324:	2020 6c61 206c 6572 6967 7473 7265 2073       all registers 
2ffcf334:	6669 6120 7362 6e65 0a74 200d 3c20 7974     if absent..  <ty
2ffcf344:	6570 203e 203d 7463 2c6c 7020 7968 0d0a     pe> = ctl, phy..
2ffcf354:	2020 2020 2020 2020 2020 6f20 2072 6e6f                or on
2ffcf364:	2065 6163 6574 6f67 7972 2820 7473 7461     e category (stat
2ffcf374:	6369 202c 6974 696d 676e 202c 616d 2c70     ic, timing, map,
2ffcf384:	7020 7265 2c66 6420 6e79 0a29 200d 3c20      perf, dyn)..  <
2ffcf394:	6572 3e67 3d20 6e20 6d61 2065 666f 7420     reg> = name of t
2ffcf3a4:	6568 7220 6765 7369 6574 0a72 000d 0000     he register.....
2ffcf3b4:	7473 7065 3d20 2520 2064 203a 7325 0d0a     step = %d : %s..
2ffcf3c4:	0000 0000 616e 656d 3d20 2520 0a73 000d     ....name = %s...
2ffcf3d4:	6973 657a 3d20 3020 2578 786c 0d0a 0000     size = 0x%lx....
2ffcf3e4:	7073 6565 2064 203d 6c25 2064 486b 0a7a     speed = %ld kHz.
2ffcf3f4:	000d 0000 6f6e 2074 6e65 756f 6867 7020     ....not enough p
2ffcf404:	7261 6d61 7465 7265 0a73 000d 616e 656d     arameters...name
2ffcf414:	0000 0000 6c61 6f6c 2063 7265 6f72 2c72     ....alloc error,
2ffcf424:	6c20 6e65 7467 2068 6c25 0a64 000d 0000      length %ld.....
2ffcf434:	0020 0000 6973 657a 0000 0000 7073 6565      ...size....spee
2ffcf444:	0064 0000 4444 5052 5948 3d20 2520 646c     d...DDRPHY = %ld
2ffcf454:	6b20 7a48 0d0a 0000 7261 7567 656d 746e      kHz....argument
2ffcf464:	2520 2073 6e69 6176 696c 0a64 000d 0000      %s invalid.....
2ffcf474:	6e69 6176 696c 2064 7261 7567 656d 746e     invalid argument
2ffcf484:	2520 0a73 000d 0000 6153 656d 6620 6572      %s.....Same fre
2ffcf494:	7571 6e65 7963 202c 6f6e 6320 6168 676e     quency, no chang
2ffcf4a4:	2e65 0d0a 0000 0000 4c50 324c 4f20 4353     e.......PLL2 OSC
2ffcf4b4:	6320 6f6c 6b63 7320 756f 6372 2065 7369      clock source is
2ffcf4c4:	6e20 746f 7320 7465 7020 6f72 6570 6c72      not set properl
2ffcf4d4:	0a79 000d 4c50 324c 502e 4c4c 204e 6e69     y...PLL2.PLLN in
2ffcf4e4:	6176 696c 2064 203d 6425 0d0a 0000 0000     valid = %d......
2ffcf4f4:	4c50 324c 7320 6f74 2070 6974 656d 756f     PLL2 stop timeou
2ffcf504:	0a74 000d 4c50 324c 7320 6174 7472 7420     t...PLL2 start t
2ffcf514:	6d69 6f65 7475 0d0a 0000 0000 6e69 6176     imeout......inva
2ffcf524:	696c 2064 7473 7065 2520 3a64 7325 6520     lid step %d:%s e
2ffcf534:	7078 6365 6974 676e 2520 3a64 7325 0d0a     xpecting %d:%s..
2ffcf544:	0000 0000 2323 2023 7845 7469 4420 5244     ....### Exit DDR
2ffcf554:	4920 544e 5245 4341 4954 4556 6d20 646f      INTERACTIVE mod
2ffcf564:	2e65 5020 656c 7361 2065 4552 4553 2054     e. Please RESET 
2ffcf574:	6874 2065 4f42 5241 2044 2323 0a23 000d     the BOARD ###...
2ffcf584:	6e69 6176 696c 2064 6174 6772 7465 2520     invalid target %
2ffcf594:	3a64 7325 202c 7563 7272 6e65 2074 7473     d:%s, current st
2ffcf5a4:	7065 6920 2073 6425 253a 0a73 000d 0000     ep is %d:%s.....
2ffcf5b4:	7473 7065 7420 206f 6425 253a 0a73 000d     step to %d:%s...
2ffcf5c4:	6c50 6165 6573 6520 746e 7265 6120 7320     Please enter a s
2ffcf5d4:	6275 6320 6d6f 616d 646e 6e20 6d75 6562     ub command numbe
2ffcf5e4:	0a72 0a0d 000d 0000 6e55 6e6b 776f 206e     r.......Unknown 
2ffcf5f4:	7573 2062 6f63 6d6d 6e61 2064 255b 5d73     sub command [%s]
2ffcf604:	0d0a 0d0a 0000 0000 6e49 6f63 7272 6365     ........Incorrec
2ffcf614:	2074 756e 626d 7265 6f20 2066 7261 7567     t number of argu
2ffcf624:	656d 746e 0a73 0a0d 000d 0000 6e49 6176     ments.......Inva
2ffcf634:	696c 2064 7261 7567 656d 746e 2320 6425     lid argument #%d
2ffcf644:	2520 0a73 0a0d 000d 754e 626d 7265 6f20      %s.....Number o
2ffcf654:	2066 7261 7567 656d 746e 2073 6f6e 2074     f arguments not 
2ffcf664:	7573 7070 726f 6574 0a64 000d 6552 7573     supported...Resu
2ffcf674:	746c 203a 6150 7373 5b20 7325 0a5d 000d     lt: Pass [%s]...
2ffcf684:	6e55 6e6b 776f 206e 6f63 6d6d 6e61 0a64     Unknown command.
2ffcf694:	000d 0000 6e69 6f66 0000 0000 7266 7165     ....info....freq
2ffcf6a4:	0000 0000 6572 6573 0074 0000 6170 6172     ....reset...para
2ffcf6b4:	006d 0000 7270 6e69 0074 0000 6465 7469     m...print...edit
2ffcf6c4:	0000 0000 6173 6576 0000 0000 7473 7065     ....save....step
2ffcf6d4:	0000 0000 656e 7478 0000 0000 6f67 0000     ....next....go..
2ffcf6e4:	6574 7473 0000 0000 6574 7473 6820 6c65     test....test hel
2ffcf6f4:	0070 0000 4444 5f52 4552 4553 0054 0000     p...DDR_RESET...
2ffcf704:	4444 5f52 5443 4c52 495f 494e 5f54 4f44     DDR_CTRL_INIT_DO
2ffcf714:	454e 0000 4444 5f52 4850 5f59 4e49 5449     NE..DDR_PHY_INIT
2ffcf724:	445f 4e4f 0045 0000 4444 5f52 4552 4441     _DONE...DDR_READ
2ffcf734:	0059 0000 5552 004e 6554 7473 4120 6c6c     Y...RUN.Test All
2ffcf744:	0000 0000 6e5b 6e6f 5d65 7c20 5b20 6f6c     ....[none] | [lo
2ffcf754:	706f 205d 207c 6c5b 6f6f 5d70 5b20 6973     op] | [loop] [si
2ffcf764:	657a 205d 207c 6c5b 6f6f 5d70 5b20 6973     ze] | [loop] [si
2ffcf774:	657a 205d 615b 6464 5d72 0000 7845 6365     ze] [addr]..Exec
2ffcf784:	7475 2065 6c61 206c 6574 7473 0073 0000     ute all tests...
2ffcf794:	6554 7473 5320 6d69 6c70 2065 6144 6174     Test Simple Data
2ffcf7a4:	7542 0073 6556 6972 6966 7365 6520 6361     Bus.Verifies eac
2ffcf7b4:	2068 6164 6174 6c20 6e69 2065 7962 7720     h data line by w
2ffcf7c4:	6c61 696b 676e 3120 6f20 206e 6966 6578     alking 1 on fixe
2ffcf7d4:	2064 6461 7264 7365 0073 0000 6554 7473     d address...Test
2ffcf7e4:	4420 7461 4261 7375 6157 6b6c 6e69 3067      DataBusWalking0
2ffcf7f4:	0000 0000 6c5b 6f6f 5d70 5b20 6461 7264     ....[loop] [addr
2ffcf804:	005d 0000 6556 6972 6966 7365 6520 6361     ]...Verifies eac
2ffcf814:	2068 6164 6174 6220 7375 7320 6769 616e     h data bus signa
2ffcf824:	206c 6163 206e 6562 6420 6972 6576 206e     l can be driven 
2ffcf834:	6f6c 2077 3328 2032 6f77 6472 6220 7275     low (32 word bur
2ffcf844:	7473 0029 6554 7473 4420 7461 4261 7375     st).Test DataBus
2ffcf854:	6157 6b6c 6e69 3167 0000 0000 6556 6972     Walking1....Veri
2ffcf864:	6966 7365 6520 6361 2068 6164 6174 6220     fies each data b
2ffcf874:	7375 7320 6769 616e 206c 6163 206e 6562     us signal can be
2ffcf884:	6420 6972 6576 206e 6968 6867 2820 3233      driven high (32
2ffcf894:	7720 726f 2064 7562 7372 2974 0000 0000      word burst)....
2ffcf8a4:	6554 7473 4120 6464 6572 7373 7542 0073     Test AddressBus.
2ffcf8b4:	735b 7a69 5d65 5b20 6461 7264 005d 0000     [size] [addr]...
2ffcf8c4:	6556 6972 6966 7365 6520 6361 2068 6572     Verifies each re
2ffcf8d4:	656c 6176 746e 6220 7469 2073 666f 7420     levant bits of t
2ffcf8e4:	6568 6120 6464 6572 7373 6120 646e 6320     he address and c
2ffcf8f4:	6568 6b63 6e69 2067 6f66 2072 6c61 6169     hecking for alia
2ffcf904:	6973 676e 0000 0000 6554 7473 4d20 6d65     sing....Test Mem
2ffcf914:	6544 6976 6563 0000 6554 7473 7420 6568     Device..Test the
2ffcf924:	6920 746e 6765 6972 7974 6f20 2066 2061      integrity of a 
2ffcf934:	6870 7379 6369 6c61 6d20 6d65 726f 0079     physical memory.
2ffcf944:	6554 7473 5320 6d69 6c75 6174 656e 756f     Test Simultaneou
2ffcf954:	5373 6977 6374 6968 676e 754f 7074 7475     sSwitchingOutput
2ffcf964:	0000 0000 735b 7a69 5d65 5b20 6461 7264     ....[size] [addr
2ffcf974:	205d 0000 7453 6572 7373 7420 6568 6420     ] ..Stress the d
2ffcf984:	7461 2061 7562 2073 766f 7265 6120 206e     ata bus over an 
2ffcf994:	6461 7264 7365 2073 6172 676e 0065 0000     address range...
2ffcf9a4:	6554 7473 4e20 696f 6573 0000 705b 7461     Test Noise..[pat
2ffcf9b4:	6574 6e72 205d 615b 6464 5d72 0000 0000     tern] [addr]....
2ffcf9c4:	6556 6972 6966 7365 7220 772f 7720 6968     Verifies r/w whi
2ffcf9d4:	656c 6620 726f 6963 676e 7320 6977 6374     le forcing switc
2ffcf9e4:	6968 676e 6f20 2066 6c61 206c 6164 6174     hing of all data
2ffcf9f4:	6220 7375 6c20 6e69 7365 002e 6554 7473      bus lines..Test
2ffcfa04:	4e20 696f 6573 7542 7372 0074 735b 7a69      NoiseBurst.[siz
2ffcfa14:	5d65 5b20 6170 7474 7265 5d6e 5b20 6461     e] [pattern] [ad
2ffcfa24:	7264 005d 7562 7372 2074 7274 6e61 6673     dr].burst transf
2ffcfa34:	7265 2073 6877 6c69 2065 6f66 6372 6e69     ers while forcin
2ffcfa44:	2067 7773 7469 6863 6e69 2067 666f 7420     g switching of t
2ffcfa54:	6568 6420 7461 2061 7562 2073 696c 656e     he data bus line
2ffcfa64:	0073 0000 6554 7473 5220 6e61 6f64 006d     s...Test Random.
2ffcfa74:	735b 7a69 5d65 5b20 6f6c 706f 205d 615b     [size] [loop] [a
2ffcfa84:	6464 5d72 0000 0000 6556 6972 6966 7365     ddr]....Verifies
2ffcfa94:	7220 772f 6120 646e 6d20 6d65 6f63 7970      r/w and memcopy
2ffcfaa4:	6228 7275 7473 6620 726f 7020 6573 6475     (burst for pseud
2ffcfab4:	206f 6172 646e 6d6f 7620 6c61 6575 0000     o random value..
2ffcfac4:	6554 7473 4620 6572 7571 6e65 7963 6553     Test FrequencySe
2ffcfad4:	656c 7463 7669 5065 7461 6574 6e72 0000     lectivePattern..
2ffcfae4:	7277 7469 2065 2026 6574 7473 7020 7461     write & test pat
2ffcfaf4:	6574 6e72 3a73 4d20 736f 6c74 2079 655a     terns: Mostly Ze
2ffcfb04:	6f72 202c 6f4d 7473 796c 4f20 656e 6120     ro, Mostly One a
2ffcfb14:	646e 4620 6e2f 0000 6554 7473 4220 6f6c     nd F/n..Test Blo
2ffcfb24:	6b63 6553 7571 6e65 6974 6c61 0000 0000     ckSequential....
2ffcfb34:	6574 7473 6920 636e 6572 656d 746e 6c61     test incremental
2ffcfb44:	7020 7461 6574 6e72 0000 0000 6554 7473      pattern....Test
2ffcfb54:	4320 6568 6b63 7265 6f62 7261 0064 0000      Checkerboard...
2ffcfb64:	6574 7473 6320 6568 6b63 7265 7020 7461     test checker pat
2ffcfb74:	6574 6e72 0000 0000 6554 7473 4220 7469     tern....Test Bit
2ffcfb84:	7053 6572 6461 0000 6574 7473 4220 7469     Spread..test Bit
2ffcfb94:	5320 7270 6165 2064 6170 7474 7265 006e      Spread pattern.
2ffcfba4:	6554 7473 4220 7469 6c46 7069 0000 0000     Test BitFlip....
2ffcfbb4:	6574 7473 4220 7469 4620 696c 2070 6170     test Bit Flip pa
2ffcfbc4:	7474 7265 006e 0000 6554 7473 5720 6c61     ttern...Test Wal
2ffcfbd4:	696b 676e 655a 6f72 7365 0000 6574 7473     kingZeroes..test
2ffcfbe4:	5720 6c61 696b 676e 4f20 656e 2073 6170      Walking Ones pa
2ffcfbf4:	7474 7265 006e 0000 6554 7473 5720 6c61     ttern...Test Wal
2ffcfc04:	696b 676e 6e4f 7365 0000 0000 6574 7473     kingOnes....test
2ffcfc14:	5720 6c61 696b 676e 5a20 7265 656f 2073      Walking Zeroes 
2ffcfc24:	6170 7474 7265 006e                         pattern.

2ffcfc2c <test>:
2ffcfc2c:	a019 2ffc f73c 2ffc f748 2ffc f780 2ffc     .../<../H../.../
2ffcfc3c:	0003 0000 9191 2ffc f794 2ffc f778 2ffc     ......./.../x../
2ffcfc4c:	f7a8 2ffc 0001 0000 91f1 2ffc f7e0 2ffc     .../......./.../
2ffcfc5c:	f7f8 2ffc f808 2ffc 0002 0000 91fd 2ffc     .../.../......./
2ffcfc6c:	f848 2ffc f7f8 2ffc f860 2ffc 0002 0000     H../.../`../....
2ffcfc7c:	9209 2ffc f8a4 2ffc f8b4 2ffc f8c4 2ffc     .../.../.../.../
2ffcfc8c:	0002 0000 93e5 2ffc f90c 2ffc f8b4 2ffc     ......./.../.../
2ffcfc9c:	f91c 2ffc 0002 0000 94b1 2ffc f944 2ffc     .../......./D../
2ffcfcac:	f968 2ffc f978 2ffc 0002 0000 9575 2ffc     h../x../....u../
2ffcfcbc:	f9a4 2ffc f9b0 2ffc f9c4 2ffc 0002 0000     .../.../.../....
2ffcfccc:	9659 2ffc fa00 2ffc fa10 2ffc fa28 2ffc     Y../.../.../(../
2ffcfcdc:	0003 0000 975d 2ffc fa68 2ffc fa74 2ffc     ....]../h../t../
2ffcfcec:	fa8c 2ffc 0003 0000 9885 2ffc fac4 2ffc     .../......./.../
2ffcfcfc:	f8b4 2ffc fae4 2ffc 0002 0000 99d9 2ffc     .../.../......./
2ffcfd0c:	fb1c 2ffc fa74 2ffc fb34 2ffc 0003 0000     .../t../4../....
2ffcfd1c:	9ad1 2ffc fb50 2ffc fa74 2ffc fb64 2ffc     .../P../t../d../
2ffcfd2c:	0003 0000 9bc1 2ffc fb7c 2ffc fa74 2ffc     ......./|../t../
2ffcfd3c:	fb8c 2ffc 0003 0000 9d05 2ffc fba4 2ffc     .../......./.../
2ffcfd4c:	fa74 2ffc fbb4 2ffc 0003 0000 9e25 2ffc     t../.../....%../
2ffcfd5c:	fbcc 2ffc fa74 2ffc fbe0 2ffc 0003 0000     .../t../.../....
2ffcfd6c:	9f25 2ffc fbfc 2ffc fa74 2ffc fc10 2ffc     %../.../t../.../
2ffcfd7c:	0003 0000                                   ....

2ffcfd80 <ddr_cmd>:
2ffcfd80:	ef5c 2ffc 0000 0000 f698 2ffc ff00 0000     \../......./....
2ffcfd90:	f6a0 2ffc 0100 0000 f6a8 2ffc 0000 0000     .../......./....
2ffcfda0:	f6b0 2ffc 0200 0000 f6b8 2ffc 0100 0000     .../......./....
2ffcfdb0:	f6c0 2ffc 0202 0000 f6c8 2ffc 0000 0000     .../......./....
2ffcfdc0:	f6d0 2ffc 0100 0000 f6d8 2ffc 0000 0000     .../......./....
2ffcfdd0:	f6e0 2ffc 0000 0000 f6e4 2ffc ff00 0000     .../......./....
	...
2ffcfde8:	f6ec 2ffc 0000 0000                         .../....

2ffcfdf0 <test_nb>:
2ffcfdf0:	0011 0000 0d0a 2020 2121 2021 6c50 6165     ......  !!! Plea
2ffcfe00:	6573 6520 746e 7265 7620 6c61 6469 6e20     se enter valid n
2ffcfe10:	6d75 6562 2072 6562 7774 6565 206e 2030     umber between 0 
2ffcfe20:	6e61 2064 6c25 2075 000a 0000 255b 3530     and %lu ....[%05
2ffcfe30:	646c 252e 3330 646c 5b5d 5245 2052 5d20     ld.%03ld][ERR  ]
2ffcfe40:	0d0a 4520 7272 726f 4820 6e61 6c64 7265     .. Error Handler
2ffcfe50:	0a20 000d 0d0a 3d3d 3d3d 3d3d 3d3d 3d3d      .....==========
2ffcfe60:	3d3d 3d3d 203d 5455 4c49 5449 4549 2d53     ===== UTILITIES-
2ffcfe70:	4444 2052 6f54 6c6f 3d20 3d3d 3d3d 3d3d     DDR Tool =======
2ffcfe80:	3d3d 3d3d 3d3d 3d3d 000d 0000 5453 334d     ========....STM3
2ffcfe90:	4d32 3150 5835 0058 0d0a 6f4d 6564 3a6c     2MP15XX...Model:
2ffcfea0:	2520 2073 000d 0000 0d0a 4152 3a4d 2520      %s ......RAM: %
2ffcfeb0:	2073 0d0a 0000 0000 4444 2052 6e49 7469     s ......DDR Init
2ffcfec0:	6169 696c 617a 6974 6e6f 4b20 0a4f 000d     ialization KO...
2ffcfed0:	4552 4e45 2054 616d 6c6c 636f 7320 6375     REENT malloc suc
2ffcfee0:	6563 6465 6465 2f00 7562 6c69 2f64 6e67     ceeded./build/gn
2ffcfef0:	2d75 6f74 6c6f 2d73 6f66 2d72 7473 336d     u-tools-for-stm3
2ffcff00:	5f32 3231 332e 722e 6c65 2e31 3032 3432     2_12.3.rel1.2024
2ffcff10:	3630 3231 312d 3133 2f35 7273 2f63 656e     0612-1315/src/ne
2ffcff20:	6c77 6269 6e2f 7765 696c 2f62 696c 6362     wlib/newlib/libc
2ffcff30:	732f 6474 696c 2f62 6172 646e 632e           /stdlib/rand.c.

2ffcff3f <_ctype_>:
2ffcff3f:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
2ffcff4f:	2020 2020 2020 2020 2020 2020 2020 2020                     
2ffcff5f:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
2ffcff6f:	0410 0404 0404 0404 0404 1004 1010 1010     ................
2ffcff7f:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
2ffcff8f:	0101 0101 0101 0101 0101 0101 1010 1010     ................
2ffcff9f:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
2ffcffaf:	0202 0202 0202 0202 0202 0202 1010 1010     ................
2ffcffbf:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...
2ffd003f:	2c00 6620 6e75 7463 6f69 3a6e 0020 7361     ., function: .as
2ffd004f:	6573 7472 6f69 206e 2522 2273 6620 6961     sertion "%s" fai
2ffd005f:	656c 3a64 6620 6c69 2065 2522 2273 202c     led: file "%s", 
2ffd006f:	696c 656e 2520 2564 2573 0a73 2300 302d     line %d%s%s..#-0
2ffd007f:	202b 6800 4c6c 6500 6766 4645 0047 3130     + .hlL.efgEFG.01
2ffd008f:	3332 3534 3736 3938 4241 4443 4645 3000     23456789ABCDEF.0
2ffd009f:	3231 3433 3635 3837 6139 6362 6564 0066     123456789abcdef.

2ffd00af <__RO_END_UNALIGNED__>:
	...
